
<!-- saved from url=(0051)http://www.lydsy.com/JudgeOnline/export_ac_code.php -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
	
	<link rel="stylesheet" href="./Export All AC Source_files/hoj.css" type="text/css">
</head>
<body>
<center>
<div style="width:90%; text-align:left">
<img src="./Export All AC Source_files/logo.png">
</div>
<table width="96%"> 
	<tbody><tr align="center" class="hd" valign="top">
				<th><a href="http://www.lydsy.com/JudgeOnline/faqs.php">F.A.Qs</a></th>
		<th><a href="http://www.lydsy.com/JudgeOnline/">Home</a></th>
		<th><a href="http://www.lydsy.com/JudgeOnline/bbs.php">Discuss</a></th>
		<th><a href="http://www.lydsy.com/JudgeOnline/problemset.php">ProblemSet</a></th>
		<th><a href="http://www.lydsy.com/JudgeOnline/status.php">Status</a></th>
		<th><a href="http://www.lydsy.com/JudgeOnline/ranklist.php">Ranklist</a></th>
		<th><a href="http://www.lydsy.com/JudgeOnline/contest.php">Contest</a></th>
		<th><a href="http://www.lydsy.com/JudgeOnline/modifypage.php"><b>ModifyUser</b></a>&nbsp;&nbsp;<a href="http://www.lydsy.com/JudgeOnline/userinfo.php?user=zky">
				<font color="red">zky</font></a></th><th><a href="http://www.lydsy.com/JudgeOnline/logout.php">Logout</a></th>		<th><a href="http://www.lydsy.com/JudgeOnline/donation.php"><font color="red">捐赠本站</font></a></th>
	</tr>
</tbody></table>
</center>
<center>
<div class="notice">
	<div>
		<b>Notice:</b>由于本OJ建立在Linux平台，但许多试题数据在Windows下制作，请注意程序的输入，输出，数据类型及范围大小，避免无谓的RE出现。	</div>
</div>
</center>

<title>Export All AC Source</title>
<h2>Problem1000</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
using namespace std;
int main(){
int a,b;
cin&gt;&gt;a&gt;&gt;b;
cout&lt;&lt;a+b;
return 0;
}<pre><h2>Problem1000</h2><pre>a,b=[int(x) for x in raw_input().split()]
print a+b<pre><h2>Problem1000</h2><pre>#include&lt;iostream&gt;
using namespace std;
int main(){

int a,b;
cin&gt;&gt;a&gt;&gt;b;
cout&lt;&lt;a+b&lt;&lt;endl;
}<pre><h2>Problem1000</h2><pre>import java.util.*;
public class Main{
	public static void main(String args[]){
		Scanner cin = new Scanner(System.in);
		int a, b;
		while (cin.hasNext()){
			a = cin.nextInt(); b = cin.nextInt();
			System.out.println(a + b);
		}
	}
}<pre><h2>Problem1000</h2><pre>#include&lt;cmath&gt;
#include&lt;iostream&gt;
using namespace std;
int main(){
int a=M_PI,b;
cin&gt;&gt;a&gt;&gt;b;
cout&lt;&lt;a+b&lt;&lt;endl;

}<pre><h2>Problem1000</h2><pre>#include&lt;iostream&gt;
using namespace std;
int main(){
int a,b;
cin&gt;&gt;a&gt;&gt;b;
cout&lt;&lt;a+b&lt;&lt;endl;
return 0;
}<pre><h2>Problem1000</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
void merge(){int a,b;cin&gt;&gt;a&gt;&gt;b;cout&lt;&lt;a+b&lt;&lt;endl;}
int main(){
merge();
return 0;
}<pre><h2>Problem1000</h2><pre>read a b
echo $(($a+$b))<pre><h2>Problem1000</h2><pre>#include&lt;iostream&gt;
using namespace std;
int main(){
int a,b;
cin&gt;&gt;a&gt;&gt;b;
cout&lt;&lt;a-(-b)&lt;&lt;endl;

}<pre><h2>Problem1000</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
int main(){
	int a,b,c=0;
	cin&gt;&gt;a&gt;&gt;b;
	for(int i=1;i&lt;=int(1e8);i++)c++;
	cout&lt;&lt;a+b&lt;&lt;endl;
}<pre><h2>Problem1000</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
int main(){
	int a,b,c=0;
	cin&gt;&gt;a&gt;&gt;b;
	for(int j=1;j&lt;=10;j++)
	for(int i=1;i&lt;=int(1e8);i++)c^=1;
	cout&lt;&lt;a+b+c&lt;&lt;endl;
}<pre><h2>Problem1000</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
int main(){
	int a,b;
	cin&gt;&gt;a&gt;&gt;b;
	cout&lt;&lt;a+b&lt;&lt;endl;
}<pre><h2>Problem1000</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
int main(){
	srand((long long)(new int));
	int a,b;cin&gt;&gt;a&gt;&gt;b;
	cout&lt;&lt;a+b+(rand()%10==0)&lt;&lt;endl;
	return 0;
}<pre><h2>Problem1000</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
int main(){
	srand((long long)(new int));
	int a,b;cin&gt;&gt;a&gt;&gt;b;
	cout&lt;&lt;a+b+(rand()%7==0)&lt;&lt;endl;
	return 0;
}<pre><h2>Problem1001</h2><pre>#include &lt;queue&gt;
#include &lt;cstdio&gt;
#include &lt;vector&gt;
#include &lt;climits&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
typedef pair&lt;int,int&gt; pii;
vector&lt;vector&lt;pii&gt; &gt;G;
void add(int u,int v,int w){
	G[u].push_back(pii(v,w));
	G[v].push_back(pii(u,w));	
}
int n,m;
int seat(int x,int y,int z){
	if(z==1)return (x-1)*(m-1)+y;
	return (n-1)*(m-1)+(x-1)*(m-1)+y;
}
int ans=INT_MAX,s,t;
void init(){
	cin&gt;&gt;n&gt;&gt;m;
	int d;
	G.resize(2000101);
	s=(n-1)*(m-1)*2+1;t=s+1;
	if(n==1||m==1){
		for(int i=1;i&lt;n||i&lt;m;i++){
			cin&gt;&gt;d;ans=min(ans,d);
		}
		cout&lt;&lt;ans&lt;&lt;endl;
		exit(0);
	}
	for(int i=1;i&lt;=n;i++)
		for(int j=1;j&lt;m;j++){
			cin&gt;&gt;d;
			if(i==1)add(s,seat(1,j,1),d);
			else if(i==n)add(seat(i-1,j,2),t,d);
			else add(seat(i-1,j,2),seat(i,j,1),d);
		}
	for(int i=1;i&lt;n;i++)
		for(int j=1;j&lt;=m;j++){
			cin&gt;&gt;d;
			if(j==1)add(seat(i,j,2),t,d);
			else if(j==m) add(seat(i,j-1,1),s,d);
			else add(seat(i,j-1,1),seat(i,j,2),d);
		}
	for(int i=1;i&lt;n;i++)
		for(int j=1;j&lt;m;j++){
			cin&gt;&gt;d;
			add(seat(i,j,1),seat(i,j,2),d);
		}		
}
int d[2000101];
priority_queue&lt;pii,vector&lt;pii&gt;,greater&lt;pii&gt; &gt;q;
void Dijk(){
	memset(d,0x7f,sizeof(d));
	d[s]=0;
	q.push(pii(d[s],s));
	while(!q.empty()){
		int u=q.top().second;q.pop();
		for(int i=0;i&lt;G[u].size();i++){
			int v=G[u][i].first,w=G[u][i].second;
			if(d[v]&gt;d[u]+w){
				d[v]=d[u]+w;
				q.push(pii(d[v],v));
			}
		}
	}
	cout&lt;&lt;d[t]&lt;&lt;endl;
}
 int main(){
 	init();
 	Dijk();
 	return 0;
 }<pre><h2>Problem1002</h2><pre>f=[0]*111
f[1]=1
f[2]=5
n=int(raw_input())
for i in range(3,n+1):
    f[i]=3*f[i-1]+2
    f[i]-=f[i-2]
print f[n]
<pre><h2>Problem1003</h2><pre>#include&lt;cstdio&gt;
#include&lt;queue&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#define X first
#define Y second
using namespace std;
typedef pair&lt;int,int&gt; pii;
pii w[21][21];
int can[21][101];
int vis[21];
int d[101];
int f[101],B;
int n,m,k,e;
int cost(int s,int t){
	memset(vis,0,sizeof(vis));
	memset(d,0x7f,sizeof(d));
	B=d[0];
	d[1]=0;
	for(int i=1;i&lt;=m;i++){
		for(int j=s;j&lt;=t;j++){
			if(!can[i][j]){
				vis[i]=1;
				break;
			}
		}
	}
	priority_queue&lt;pii,vector&lt;pii&gt;,greater&lt;pii&gt; &gt;q;
	q.push(pii(d[1],1));
	vis[1]=1;
	while(!q.empty()){
		int u=q.top().Y;q.pop();
		for(int i=1;i&lt;=w[u][0].X;i++){
			int v=w[u][i].X,W=w[u][i].Y;
			if(!vis[v])
			if(d[v]&gt;d[u]+W){
				d[v]=d[u]+W;
				//vis[v]=1;
				q.push(pii(d[v],v));
			}
		}
	}
	return d[m]==B?d[m]:d[m]*(t-s+1);
}
int main(){
	memset(can,1,sizeof(can));
	scanf("%d%d%d%d",&amp;n,&amp;m,&amp;k,&amp;e);
	for(int i=1;i&lt;=e;i++){
		int u,v,W;
		scanf("%d%d%d",&amp;u,&amp;v,&amp;W);
		w[u][++w[u][0].X]=pii(v,W);
		w[v][++w[v][0].X]=pii(u,W);
	}
	int d;
	scanf("%d",&amp;d);
	for(int i=1;i&lt;=d;i++){
		int a,b,c;
		scanf("%d%d%d",&amp;c,&amp;a,&amp;b);
		for(int j=a;j&lt;=b;j++)can[c][j]=0;
	}
	
	for(int i=1;i&lt;=n;i++){
		f[i]=cost(1,i);
		for(int j=2;j&lt;i;j++){
			f[i]=min(f[i],f[j]+cost(j+1,i)+k);
		}
	}
	
	cout&lt;&lt;f[n]&lt;&lt;endl;
	
	return 0;
}<pre><h2>Problem1004</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
int Sa,Sb,Sc,m,n;
LL p;
int N;
int w[3601],fac[101];
int dp[21][21][21],a[61];
int power(int x,int k,int p){
	int ans=1;
	for(;k;k&gt;&gt;=1){
		if(k&amp;1)ans=(ans*x)%p;
		x=(x*x)%p;
	}return ans;
}
int inv(int x){
	return power(x,p-2,p);
}
int ans;
int main(){
	cin&gt;&gt;Sa&gt;&gt;Sb&gt;&gt;Sc&gt;&gt;m&gt;&gt;p;n=Sa+Sb+Sc;
	fac[0]=1;for(int i=1;i&lt;=n;i++)fac[i]=fac[i-1]*i%p;
	ans=fac[n]*inv(fac[Sa])%p*inv(fac[Sb])*inv(fac[Sc])%p;
	for(int i=1;i&lt;=m;i++){
		for(int j=1;j&lt;=n;j++)scanf("%d",&amp;a[j]);
		int vis[61];memset(vis,0,sizeof vis);
		for(int j=1;j&lt;=n;j++){
			if(!vis[j]){
				N++;
				for(int x=j;!vis[x];x=a[x]){
					vis[x]=1;w[N]++;
				}
			}
		}
	}
	dp[0][0][0]=1;
	for(int i=1;i&lt;=N;i++)
	for(int j=Sa;j&gt;=w[i];j--)
	for(int k=Sb;k&gt;=w[i];k--)
	for(int l=Sc;l&gt;=w[i];l--)
	dp[j][k][l]+=dp[j-w[i]][k][l]+dp[j][k-w[i]][l]+dp[j][k][l-w[i]],
	dp[j][k][l]%=p;
	cout&lt;&lt;(LL)(ans+dp[Sa][Sb][Sc])*inv(m+1)%p&lt;&lt;endl;
	return 0;
}<pre><h2>Problem1007</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
double eps=0.000000000000001;
struct Line{
    int A, B, i;
    bool operator==(const Line &amp;b)const { return A == b.A;}
    bool operator&lt;(const Line &amp;b)const { return A == b.A ? ( B &gt; b.B ) : A &lt; b.A ; }
    Line(int _A=0,int _B=0,int _i=0):
    	A(_A),B(_B),i(_i){}
};
double CrossX(Line l1,Line l2){
	return (double)(l2.B-l1.B)/(double)(l1.A-l2.A);
}
Line v[51001];
Line ch[60001];
int ans[70001];
int n,A,B,m=1;
int main(){
	cin&gt;&gt;n;
	for(int i=1;i&lt;=n;i++){
		cin&gt;&gt;A&gt;&gt;B;
		v[i]=Line(A,B,i);
	}
    sort(&amp;v[1], &amp;v[n + 1]);
    n = unique(&amp;v[1], &amp;v[n + 1]) - &amp;v[1];
	for(int i=1;i&lt;=n;i++){
        while ( m &gt; 2 &amp;&amp; 
            CrossX( ch[m - 1], ch[m - 2]) &gt;
             CrossX(ch[m - 1], v[i]) - eps
            )m--;
		ch[m++]=v[i];
	}
    for (int i = 1; i &lt; m; ++i)
        ans[i] = ch[i].i;
    
    sort(&amp;ans[1], &amp;ans[m]);
    
    for (int i = 1; i &lt; m; ++i)
        printf("%d ", ans[i]);
    printf("\n");
	return 0;
}<pre><h2>Problem1008</h2><pre>#include&lt;cstdio&gt;
long long n,m;
const int MOD = 100003;
long long pow(long long a,long long b){
	long long ans=1;
	for(;b;b&gt;&gt;=1,a=(a*a)%MOD)
	if(b&amp;1)
		ans=(ans*a)%MOD;
	return ans;
}
int main(){
	int i,j;
	long long ans,ans1,ans2;
	scanf("%lld%lld",&amp;m,&amp;n);
	ans1=pow(m,n);
	ans2=pow(m-1,n-1);
	ans2=(ans2*m)%MOD;
	ans=(ans1-ans2+MOD)%MOD;
	printf("%lld",ans);
	return 0;
}<pre><h2>Problem1009</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
int n,m,p,next[102];
char s[102];
int A[25][25];
int tmp[25][25];
int B[25][25];
void mul(int A[25][25],int B[25][25]){
	memset(tmp,0,sizeof tmp);
	for(int k=0;k&lt;=m;k++)
	for(int i=0;i&lt;=m;i++)
	for(int j=0;j&lt;=m;j++)
	tmp[i][j]+=A[i][k]*B[k][j],
	tmp[i][j]%=p;
}
int main(){
	cin&gt;&gt;n&gt;&gt;m&gt;&gt;p;s[0]='#'; 
	scanf("%s",s+1);
	for(int i=2,j=0;i&lt;=m;i++){
		while(j&amp;&amp;s[i]!=s[j+1])j=next[j];
		next[i]=j+=s[i]==s[j+1];
	}
	for(int i=0;i&lt;m;i++)
	for(char k='0';k&lt;='9';k++){
		int j=i;
		while(j&amp;&amp;s[j+1]!=k)j=next[j];
		j+=s[j+1]==k;//if(j==m)continue;
		A[i][j]++;
	}A[m][m]=10;
	for(int i=0;i&lt;=m;i++)B[i][i]=1;
//	for(int i=0;i&lt;=m;i++)
//	for(int j=0;j&lt;=m;j++)
//	printf("%d%c",A[i][j]," \n"[j==m]);
	for(;n;n&gt;&gt;=1){
		if(n&amp;1){
			memset(tmp,0,sizeof tmp);
			mul(B,A);
			copy(&amp;tmp[0][0],&amp;tmp[25][25],&amp;B[0][0]);
		}
		mul(A,A);
		copy(&amp;tmp[0][0],&amp;tmp[25][25],&amp;A[0][0]);		
	}
	int ans=0;
	for(int i=0;i&lt;m;i++)ans=(ans+B[0][i])%p;
	cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}
<pre><h2>Problem1010</h2><pre>/*
	ID:zky
	OJ:BZOJ
	Language:C++
*/
#include&lt;deque&gt;
#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long lld;
lld sum[50001]={0};
lld c[50001]={0};
lld f[50001]={0};
lld n,l;
deque&lt;int&gt;q;
int C;
inline lld G(int k, int j) {return f[k] + (sum[k]+C) * (sum[k]+C) - f[j] - (sum[j]+C) * (sum[j]+C);}
inline lld S(int k, int j) {return 2 * (sum[k] - sum[j]);}
int main(){
	cin&gt;&gt;n&gt;&gt;l;C=l+1;
	for(int i=1;i&lt;=n;i++){
		cin&gt;&gt;c[i];
		sum[i]=sum[i-1]+c[i];
	}
	for(int i=1;i&lt;=n;i++)sum[i]+=i;
	q.push_back(0);
	f[0]=0;
	for(int i=1;i&lt;=n;i++){
		while(q.size()&gt;1&amp;&amp;G(q[1],q[0])&lt;=sum[i]*S(q[1],q[0]))q.pop_front();
		lld x=q.front();
		f[i]=f[x]+(sum[i]-sum[x]-C)*(sum[i]-sum[x]-C);
		while(q.size()&gt;1&amp;&amp;G(q[q.size()-1],q[q.size()-2])*S(i,q[q.size()-1])
							&gt;=G(i,q[q.size()-1])*S(q[q.size()-1],q[q.size()-2]))
							q.pop_back();
		q.push_back(i);
	}
	cout&lt;&lt;f[n]&lt;&lt;endl;
	return 0;
}<pre><h2>Problem1011</h2><pre>#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
  
using namespace std;
  
typedef long long int64;
const int MAXN=1000000,T=100;
const double eps=1e-8;
int  M[MAXN],n;
double a,f[MAXN];
int main()
{
    
   scanf("%d %lf",&amp;n,&amp;a);
   int l,r,i,j;
   for (i=1;i&lt;=n;i++) scanf("%d",&amp;M[i]);
   for (i=1;i&lt;=T;i++)
   {
       f[i]=0;
       r=(int)(eps+floor(a*i));
       for (j=1;j&lt;=r;j++) f[i]+=1.0*M[i]*M[j]/(i-j);
   }
   for (i=T+1;i&lt;=n;i++)
   {
       f[i]=0;
       r=(int)(eps+floor(a*i));
       l=(int)(eps+floor(a*(i-T)));
       for (j=l+1;j&lt;=r;j++) f[i]+=1.0*M[i]*M[j]/(i-j);
       f[i]+=1.0*M[i]*(f[i-T]/M[i-T])*(i-T-1.0*l/2)/(i-1.0*l/2) ;
   }
   for (i=1;i&lt;=n;i++) printf("%.6lf\n",f[i]);
   return 0;
}
<pre><h2>Problem1011</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long lld;
const double eps=1e-8;
const int MAXN=1000000,T=1000;
int M[MAXN];
int n;
double a,f[MAXN];
int main(){
   scanf("%d %lf",&amp;n,&amp;a);
   int l,r,i,j;
   for (i=1;i&lt;=n;i++) scanf("%d",&amp;M[i]);
   for (i=1;i&lt;=T;i++)
   {
       f[i]=0;
       r=(int)(eps+floor(a*i));
       for (j=1;j&lt;=r;j++) f[i]+=1.0*M[i]*M[j]/(i-j);
   }
/*
	scanf("%d %lf",&amp;n,&amp;a);
		int l,r,i,j;for( i=1;i&lt;=n;i++)
	scanf("%d",&amp;M[i]);
	for( i=1;i&lt;=T;i++){
		f[i]=0;
		r=(int)(eps+floor(a*i));
		for( j=1;j&lt;=r;j++)
		f[i]+=1.0*M[i]*M[j]/(i-j);
	}*/
	////////////////////
	
   for (i=T+1;i&lt;=n;i++)
   {
       f[i]=0;
       r=(int)(eps+floor(a*i));
       l=(int)(eps+floor(a*(i-T)));
       for (j=l+1;j&lt;=r;j++) f[i]+=1.0*M[i]*M[j]/(i-j);
       f[i]+=1.0*M[i]*(f[i-T]/M[i-T])*(i-T-1.0*l/2)/(i-1.0*l/2) ;
   }
   for (i=1;i&lt;=n;i++) printf("%.6lf\n",f[i]);
   return 0;
	/*
	for( i=T+1;i&lt;=n;i++){
		f[i]=0;
		r=(int)(eps+floor(a*i));
		l=(int)(eps+floor(a*(i-T)));
		for( j=l+1;j&lt;=r;j++)
			f[i]+=1.0*M[i]*M[j]/(i-j);
		f[i]+=1.0*M[i]*(f[i-T]/M[i-T])*(i-T-1.0*l/2)/(i-1.0/l*2);
	}
	for( i=1;i&lt;=n;i++)
	printf("%.6lf\n",f[i]);*/
	return 0;
}<pre><h2>Problem1011</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long lld;
const double eps=1e-8;
const int MAXN=1000000,T=1000;
int M[MAXN];
int n;
double a,f[MAXN];
int main(){
   

	scanf("%d %lf",&amp;n,&amp;a);
		int l,r,i,j;for( i=1;i&lt;=n;i++)
	scanf("%d",&amp;M[i]);
	for( i=1;i&lt;=T;i++){
		f[i]=0;
		r=(int)(eps+floor(a*i));
		for( j=1;j&lt;=r;j++)
		f[i]+=1.0*M[i]*M[j]/(i-j);
	}
	////////////////////
	
   for (i=T+1;i&lt;=n;i++)
   {
       f[i]=0;
       r=(int)(eps+floor(a*i));
       l=(int)(eps+floor(a*(i-T)));
       for (j=l+1;j&lt;=r;j++) f[i]+=1.0*M[i]*M[j]/(i-j);
       f[i]+=1.0*M[i]*(f[i-T]/M[i-T])*(i-T-1.0*l/2)/(i-1.0*l/2) ;
   }
   for (i=1;i&lt;=n;i++) printf("%.6lf\n",f[i]);
   return 0;
	/*
	for( i=T+1;i&lt;=n;i++){
		f[i]=0;
		r=(int)(eps+floor(a*i));
		l=(int)(eps+floor(a*(i-T)));
		for( j=l+1;j&lt;=r;j++)
			f[i]+=1.0*M[i]*M[j]/(i-j);
		f[i]+=1.0*M[i]*(f[i-T]/M[i-T])*(i-T-1.0*l/2)/(i-1.0/l*2);
	}
	for( i=1;i&lt;=n;i++)
	printf("%.6lf\n",f[i]);*/
	return 0;
}<pre><h2>Problem1012</h2><pre>#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;cstdlib&gt;
#include &lt;ctime&gt;
#include &lt;vector&gt;
#include &lt;map&gt;
#define MAXN 200005
#define lch(x) x&lt;&lt;1
#define rch(x) x&lt;&lt;1|1
#define lson l,m,rt&lt;&lt;1
#define rson m+1,r,rt&lt;&lt;1|1
using namespace std;
int n, mod, lst;
int size;
int a[MAXN];
int num[MAXN];
int main()
{
    int x, len = 0;
    char op[5];
    scanf("%d%d", &amp;n, &amp;mod);
    int m = n;
    while(m--)
    {
        scanf("%s%d", op, &amp;x);
        if(op[0] == 'A')
        {
            x = (x + lst) % mod;
            num[++len] = x;
            while(size &amp;&amp; num[a[size]] &lt;= x) size--;
            a[++size] = len;
        }
        else
        {
            int pos = lower_bound(a + 1, a + size + 1, len - x + 1) - a;
            printf("%d\n", lst = num[a[pos]]);
        }
    }
    return 0;
}<pre><h2>Problem1012</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;climits&gt;
using namespace std;
int n,MOD,t=0;
int a[200005];
int len=0;
int num[200005];
int size=0;
int main(){
	scanf("%d%d",&amp;n,&amp;MOD);
	char s[5];int x;
	while(n--){
		scanf("%s%d",s,&amp;x);
		if(s[0]=='A'){
			x=(x+t)%MOD;
			num[++len]=x;
			while(size&amp;&amp;num[a[size]]&lt;=x)size--;
			a[++size]=len;
		}else{
			int pos=lower_bound(a+1,a+size+1,len-x+1)-a;
			t=num[a[pos]];
			printf("%d\n",t);
		}
	}
	return 0;
}
<pre><h2>Problem1013</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;iomanip&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
double a[21][21];
double A[21][21];
int n;
void Gauss(){
	int r,k;
	for(int i=0;i&lt;n;i++){
		r=i;
		for(int j=i+1;j&lt;n;j++)
			if(fabs(A[j][i])&gt;fabs(A[r][i]))r=j;
		if(r!=i)for(int j=0;j&lt;=n;j++)swap(A[i][j],A[r][j]);
		for(int k=i+1;k&lt;n;k++){
			double f=A[k][i]/A[i][i];
			for(int j=i;j&lt;=n;j++)A[k][j]-=f*A[i][j];
		}
	}
	for(int i=n-1;i&gt;=0;i--){
		for(int j=i+1;j&lt;n;j++)
			A[i][n]-=A[j][n]*A[i][j];
		A[i][n]/=A[i][i];
	}
	for(int i=0;i&lt;n-1;i++)
		cout&lt;&lt;fixed&lt;&lt;setprecision(3)&lt;&lt;A[i][n]&lt;&lt;" ";
	cout&lt;&lt;fixed&lt;&lt;setprecision(3)&lt;&lt;A[n-1][n];
		
}
int main(){
	cin&gt;&gt;n;
	for(int i=0;i&lt;=n;i++)
	for(int j=0;j&lt;n;j++)
	cin&gt;&gt;a[i][j];
	
	for(int i=0;i&lt;n;i++){
		double k=0;
		for(int j=0;j&lt;n;j++){
			A[i][j]=2*(a[i][j]-a[i+1][j]);
			k+=(a[i][j]*a[i][j]-a[i+1][j]*a[i+1][j]);
		}
		A[i][n]=k;
	}
	Gauss();
	return 0;
}<pre><h2>Problem1013</h2><pre>import java.util.*;
import java.io.*;
import java.math.*;
public class Main{

	public static void main(String[] args){
		double a[][]=new double[22][22];  
		double A[][]=new double[22][22];  
		int n;  
		Scanner cin=new Scanner(System.in);
		    n=cin.nextInt(); 
		    for(int i=0;i&lt;=n;i++)  
		    for(int j=0;j&lt;n;j++)  
		    a[i][j]=cin.nextDouble(); 
		    for(int i=0;i&lt;n;i++){  
		        double k=0;  
		        for(int j=0;j&lt;n;j++){  
		            A[i][j]=2*(a[i][j]-a[i+1][j]);  
		            k+=(a[i][j]*a[i][j]-a[i+1][j]*a[i+1][j]);  
		        }  
		        A[i][n]=k;  
		    }  
		    int r,k;  
		    for(int i=0;i&lt;n;i++){  
		        r=i;  
		        for(int j=i+1;j&lt;n;j++)  
		            if(Math.abs(A[j][i])&gt;Math.abs(A[r][i]))r=j;  
		        if(r!=i)for(int j=0;j&lt;=n;j++){
		        	double tmp=A[i][j];
		        	A[i][j]=A[r][j];
		        	A[r][j]=tmp;
		        }
		        for(int l=i+1;l&lt;n;l++){  
		            double f=A[l][i]/A[i][i];  
		            for(int j=i;j&lt;=n;j++)A[l][j]-=f*A[i][j];  
		        }  
		    }  
		    for(int i=n-1;i&gt;=0;i--){  
		        for(int j=i+1;j&lt;n;j++)  
		            A[i][n]-=A[j][n]*A[i][j];  
		        A[i][n]/=A[i][i];  
		    }  
		    for(int i=0;i&lt;n-1;i++)
		    	System.out.print(String.format("%.3f ",A[i][n]));
		    System.out.println(String.format("%.3f",A[n-1][n]));  
		
	}
}<pre><h2>Problem1014</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef unsigned int UL;
const int maxn=1e5+5;
int rnd(){static int x=123456789;return x+=x&lt;&lt;2|1;}
UL hash_l[maxn];
int len;
struct node{
	int key,size;
	int val;
	UL hash;
	node *c[2];
	node* rz(){
		size=1;hash=0;
		if(c[0])hash=c[0]-&gt;hash,size+=c[0]-&gt;size;
		hash=hash*hash_l[1]+val;
		if(c[1])hash=hash*hash_l[c[1]-&gt;size]+c[1]-&gt;hash,size+=c[1]-&gt;size;
		return this;
	}
	void split(int ned,node *&amp;p,node *&amp;q);
}*root,pool[maxn],*cur=pool+1;
node *newnode(int val){
	node *x=cur++;
	x-&gt;key=rnd();
	x-&gt;val=val;
	return x;
}
node *merge(node *p,node *q){
	if(!p||!q)return p?p-&gt;rz():(q?q-&gt;rz():q);
//	p-&gt;pd();q-&gt;pd();
	if(p-&gt;key&lt;q-&gt;key){
		p-&gt;c[1]=merge(p-&gt;c[1],q);
		return p-&gt;rz();	
	}else{
		q-&gt;c[0]=merge(p,q-&gt;c[0]);
		return q-&gt;rz();		
	}
}
void node::split(int ned,node *&amp;p,node *&amp;q){
	if(!ned){p=0;q=this;return;}
//	pd();
	if(c[0]&amp;&amp;c[0]-&gt;size&gt;=ned){
		if(c[0])c[0]-&gt;split(ned,p,q);
		else p=q=0;c[0]=0;rz();
		q=merge(q,this);
	}else{
		if(c[1])c[1]-&gt;split(ned-(c[0]?c[0]-&gt;size:0)-1,p,q);
		else p=q=0;c[1]=0;rz();
		p=merge(this,p);
	}
}
int getint(){
	int res=0;char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))res=res*10+c-'0',c=getchar();
	return res;
}
char getA(){
	char c=getchar();
	while(!isalpha(c))c=getchar();
	return c;
}
char s[maxn];
UL gethash(int l,int r){
	UL ans=0;
	node *p,*q,*x,*y;
	root-&gt;split(l-1,p,q);
	q-&gt;split(r-l+1,x,y);
	ans=x-&gt;hash;
	q=merge(x,y);
	root=merge(p,q);
	return ans;
}
void deb(node *x){
	if(x-&gt;c[0])deb(x-&gt;c[0]);
	printf("%c",x-&gt;val+'a');
	//printf("id:%d val:%c c[0]:%d c[1]:%d\n",x-pool,x-&gt;val+'a',
	//	x-&gt;c[0]?x-&gt;c[0]-pool:0,x-&gt;c[1]?x-&gt;c[1]-pool:0);
	if(x-&gt;c[1])deb(x-&gt;c[1]);
}
int Q(int x,int y){
	int l=1,r=min(len-x+1,len-y+1)+1;
	while(l&lt;r){
		int mid=(l+r)&gt;&gt;1;
		if(gethash(x,x+mid-1)==gethash(y,y+mid-1))
			l=mid+1;
		else r=mid;
	}return l-1;
}
int main(){
	hash_l[0]=1;
	for(int i=1;i&lt;maxn;i++)hash_l[i]=hash_l[i-1]*31;
	char c=getchar();
	while(isalpha(c))s[len++]=c,c=getchar();
	for(int i=0;i&lt;len;i++)
		root=merge(root,newnode(s[i]-'a'));
	int m=getint();
	while(m--){
//		deb(root);puts("");
		char op=getA();
		if(op=='Q'){
			int x=getint(),y=getint();
			printf("%d\n",Q(x,y));
		}else if(op=='I'){
			node *p,*q;
			int x=getint();char c=getA();
			root-&gt;split(x,p,q);
			q=merge(newnode(c-'a'),q);
			root=merge(p,q);
			len++;
		}else if(op=='R'){
//			deb(root);puts("");
			node *p,*q,*r,*s;
			int x=getint();char c=getA();
			root-&gt;split(x-1,p,q);
//			deb(p);puts("");
//			deb(q);puts("");
			q-&gt;split(1,r,s);
//			deb(r);puts("");
//			deb(s);puts("");
			r-&gt;val=c-'a';r-&gt;rz();
			q=merge(r,s);
			root=merge(p,q);
//			deb(root);	
		}
	}
	return 0;
}<pre><h2>Problem1014</h2><pre>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;cstdlib&gt;
#include&lt;algorithm&gt;
using namespace std;
int m,len;
char s[100000]; 
unsigned long long mi[200000];
struct treap_node{
	treap_node *left,*right;
    int fix,size;
    unsigned int hashz;
	char val;
	treap_node(char val=0): val(val) {left=right=NULL; fix=rand(); hashz=(int)(val)-96; size=1; }
	inline int lsize()
	  {
	    if (left) 
		  return left-&gt;size;
	    else 
		  return 0;
	  }
	inline int rsize()
	  {
	    if (right)
	      return right-&gt;size;
	    else
		  return 0; 
	  }
	inline void Maintain()
	  {
	  	size=1;
	    size+=lsize()+rsize();
	    hashz=(int)(val)-96; 
	    if (left&amp;&amp;!right)
	      hashz=left-&gt;hashz+hashz*mi[lsize()];
	    if (!left&amp;&amp;right)
	      hashz=hashz+right-&gt;hashz*mi[1]; 
	    if (left&amp;&amp;right)
	      hashz=left-&gt;hashz+hashz*mi[lsize()]+right-&gt;hashz*mi[lsize()+1];
	  }
}pool[200000],*cur=pool;
inline treap_node* newnode(char c){
	if(cur-pool&lt;200000)
	return *cur=treap_node(c),cur++;
	return new treap_node(c);
}
treap_node *root;
typedef pair&lt;treap_node*,treap_node*&gt; droot;
treap_node *merge(treap_node *a,treap_node *b)
{
	if (!a) return b; if (!b) return a;
	if (a-&gt;fix&lt;b-&gt;fix)
	  {
	    a-&gt;right=merge(a-&gt;right,b);
	    a-&gt;Maintain();
	    return a;
	  }
	else
	  {
	    b-&gt;left=merge(a,b-&gt;left);
	    b-&gt;Maintain();
	    return b;
	  }
}
droot split(treap_node *x,int k)
{
	if (!x) return droot(NULL,NULL);
	droot y;
	if (k&lt;=x-&gt;lsize())
	  {
	    y=split(x-&gt;left,k);
	    x-&gt;left=y.second;
	    x-&gt;Maintain();
	    y.second=x;
	  }
	else
	  {
	    y=split(x-&gt;right,k-x-&gt;lsize()-1);
	    x-&gt;right=y.first;
	    x-&gt;Maintain();
	    y.first=x;
	  }
	return y;
}
inline void insert(int xi,char ch)
{
	droot x;
	treap_node *temp;
	x=split(root,xi);
	temp=newnode(ch);
	x.first=merge(x.first,temp);
	root=merge(x.first,x.second);
}
inline void del(int xi,int k)
{
	droot x,y;
	x=split(root,xi-1);
	y=split(x.second,1);
	root=merge(x.first,y.second);
}
inline void work(int x,int y)
{
	int l,r,mid,ans=0;
	unsigned long long t1,t2;
	droot a,b;
	l=1; r=min(len-x+1,len-y+1);
	while (l&lt;=r)
	  {
	  	mid=(l+r)/2;  
	  	a=split(root,x-1); b=split(a.second,mid);
	    b.first-&gt;Maintain();
	    t1=b.first-&gt;hashz;
	    a.second=merge(b.first,b.second); root=merge(a.first,a.second);
	    a=split(root,y-1); b=split(a.second,mid);
	    b.first-&gt;Maintain();
	    t2=b.first-&gt;hashz; 
	    a.second=merge(b.first,b.second); root=merge(a.first,a.second);
	    if (t1==t2)
	      l=mid+1,ans=mid; 
	    else
	      r=mid-1; 
	  }
	printf("%d\n",ans);
}
inline int in(){
	int r=0,f=1;char c=getchar();
	while(!isdigit(c))f=c=='-'?-1:1,c=getchar();
	while(isdigit(c))r=r*10+c-'0',c=getchar();
	return r*f;
}
int main()
{
	int i,x,y,t=0;
	char opt,ch;
	treap_node *temp;
	scanf("%s",&amp;s);
	len=strlen(s);
	scanf("%d",&amp;m);
	mi[0]=1;
	for (i=1;i&lt;=min(100000,len*2);++i)
      mi[i]=mi[i-1]*27; 
	for (i=0;i&lt;=len-1;++i)
	  {
	    temp=newnode(s[i]);
	    root=merge(root,temp);
	  }
	for (i=1;i&lt;=m;++i)
	  {
	    opt=getchar();
	    while (opt!='Q'&amp;&amp;opt!='R'&amp;&amp;opt!='I')
	      opt=getchar();
	    if (opt=='Q')
	      {
	      	x=in();y=in();
	        work(x,y);
	      }
	    if (opt=='I')
	      {
	      	x=in();
	        ch=getchar();
	        while (ch&lt;'a'||ch&gt;'z')
	          ch=getchar();
	        insert(x,ch);
	        len++;
	      }	    
	    if (opt=='R')
	      {
	      	x=in();
	        ch=getchar();
	        while (ch&lt;'a'||ch&gt;'z')
	          ch=getchar();
	        del(x,1);
	        insert(x-1,ch);
	      }
	  }
}<pre><h2>Problem1015</h2><pre>#include&lt;vector&gt;
#include&lt;queue&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#define X first
#define Y second
#define read(x) x=getint()
#define read3(x,y,z) x=getint();y=getint();z=getint()
using namespace std;
typedef pair&lt;int,int&gt; pii;
vector&lt;vector&lt;int&gt; &gt;G;
void add(int u,int v){
	G[u].push_back(v);
	G[v].push_back(u);
}
int getint(){
	int ok=0;
	int res=0;
	char ch;
	while(1){
		ch=getchar();
		if(ch&gt;='0'&amp;&amp;ch&lt;='9'){
			ok=1;
			res*=10;
			res+=ch-'0';
		}else
			if(ok)break;
	}
	return res;
}
int F;
int fa[400010];
int vis[400010];
int find(int x){
	if(fa[x]!=x)return fa[x]=find(fa[x]);
	return x;
}
int hash[400010]={0};
void dfs(int x){
	fa[x]=F;
	vis[x]=1;
	for(int i=0;i&lt;G[x].size();i++){
		int e=G[x][i];
		if(!vis[e]&amp;&amp;!hash[e]){
			vis[e]=1;
			dfs(e);
		}
		//dfs(e);
	}
}
int n,m,qs;
vector&lt;pii&gt;M;
vector&lt;int&gt;E;
int ans[400010];
int hash2[400010];
/*
void work()  
{  
   for (int i=k; i&gt;=1; --i)  
   {  
      ++sum;  
      int fi = c[i];  
      for (int j=edge[c[i]]; j; j=next[j])  
         if (!vp[point[j]])  
         {  
            int fj = find(point[j]);  
            if (fi != fj)  
            {  
               --sum;  
               father[fj] = fi;//错在father[fj] = fi;  
            }  
         }  
      p[i] = sum;  
      vp[c[i]] = 0;  
   }  
   for (int i=1; i&lt;=k+1; ++i)  
      printf("%d\n", p[i]);  
}    
*/
int main(){
	read(n);read(m);
	for(int i=0;i&lt;n;i++)fa[i]=i;
	G.resize(n+1);
	for(int i=0;i&lt;m;i++){
		int u,v;
		read(u);read(v);
		add(u,v);
	}
	read(qs);int e;
	for(int i=0;i&lt;qs;i++){
		read(e);
		E.push_back(e);	
		hash[e]=1;
	}
	int sum=n-qs;
	for(int i=0;i&lt;n;i++){
		if(!hash[i]){
			for(int j=0;j&lt;G[i].size();j++){
				e=G[i][j];
				if(!hash[e]){
					if(find(i)!=find(e)){
						fa[find(e)]=find(i);
						sum--;
					}
				}
			}
		}
	}
	ans[qs]=sum;
	for(int i=qs-1;i&gt;=0;i--){
		sum++;
		int fi=E[i];
		for(int j=0;j&lt;G[fi].size();j++){
			e=G[fi][j];
			if(!hash[e]){
				if(fi!=find(e)){
					fa[find(e)]=fi;
					sum--;
				}
			}
		}
		ans[i]=sum;
		hash[E[i]]=0;
	}
	for(int i=0;i&lt;=qs;i++)
	printf("%d\n",ans[i]);
	return 0;
}<pre><h2>Problem1016</h2><pre>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;

const int MAXM=1005;
const int MAXN=105;
const int MOD=31011;

struct node
{
       int x,y,d;
}e[MAXM];
int n,m,size,tot;
int sum[MAXM],st[MAXM],f[MAXN],f2[MAXN];
bool v[MAXN];
long long temp,ans=1;
bool cmp(node a,node b){return a.d&lt;b.d;}

int GET(int k)
{
    if (f[k]==k) return k;
    f[k]=GET(f[k]);
    return f[k];
}

int GET2(int k)
{
    /*if (f2[k]==k) return k;
    f2[k]=GET(f2[k]);
    return f2[k];*/
    if (f2[k]==k) return k;
       else return GET2(f2[k]);
}

void Union(int x,int y)
{
     int xx=GET(x),yy=GET(y);
     if (xx!=yy) f[xx]=yy;
}

void DFS(int st,int ed,int sum)
{
     if (sum==0) {++temp;return;}
     if (st&gt;ed) return;
     int fa=GET2(e[st].x),fb=GET2(e[st].y);
     if (v[e[st].x] &amp;&amp; v[e[st].y] &amp;&amp; fa!=fb)
     {
                    f2[fa]=fb;
                    DFS(st+1,ed,sum-1);
                    f2[fa]=fa;
     }
     DFS(st+1,ed,sum);
}

void Work(int x)
{
     temp=0;
     DFS(st[x],st[x+1]-1,sum[x]);
     ans=(ans*temp)%MOD;
}

bool Kurscal()
{
     int i,j;
     sort(e+1,e+m+1,cmp);
     for (int i=1;i&lt;=n;++i) f[i]=f2[i]=i;
     tot=size=0;
     memset(v,0,sizeof(v));
     for (i=1;i&lt;=m;++i)
     {
         if (i==1 || e[i].d!=e[i-1].d)
         {
                  st[++tot]=i,sum[tot]=0;
                  if (i!=1) Work(tot-1);
                  for (j=1;j&lt;=n;++j) f2[j]=f[j];
         }
         if (GET(e[i].x)!=GET(e[i].y))
         {
                                      ++size;
                                      Union(e[i].x,e[i].y);
                                      v[e[i].x]=v[e[i].y]=1;
                                      ++sum[tot];
         }
         if (size==n-1) break;
     }
     for (j=i+1;j&lt;=m+1;++j)
         if (e[j].d!=e[j-1].d)
            {st[tot+1]=j;break;}
     Work(tot);
     if (size==n-1) return 1; else return 0;
}

int main()
{
    scanf("%d%d",&amp;n,&amp;m);
    for (int i=1;i&lt;=m;++i)
        scanf("%d %d %d",&amp;e[i].x,&amp;e[i].y,&amp;e[i].d);
    if (Kurscal()) printf("%lld\n",ans); else printf("0\n");
    return 0;
}<pre><h2>Problem1018</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1e5+5;
int a[maxn],b[maxn],c[maxn],n;//a上方,b下方,c中间 
int getint(){
	int res=0;char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))res=res*10+c-'0',c=getchar();
	return res;
}
struct node{
	int lr[2][2];
	int ll,rr;
	node(){
		memset(lr,0,sizeof lr);ll=rr=0;
	}
}t[maxn&lt;&lt;2];
node operator+(const node &amp;ls,const node &amp;rs){
	node C;
	for(int i=0;i&lt;2;i++)for(int j=0;j&lt;2;j++)for(int k=0;k&lt;2;k++)
	C.lr[i][j]|=(ls.lr[i][k]&amp;&amp;rs.lr[k][j])
	||(ls.lr[i][k]&amp;&amp;rs.lr[k^1][j]&amp;&amp;(ls.rr||rs.ll));
	C.ll=ls.ll;C.rr=rs.rr;
	for(int i=0;i&lt;2;i++)for(int j=0;j&lt;2;j++)
	C.ll|=ls.lr[i][j]&amp;&amp;rs.ll&amp;&amp;ls.lr[i^1][j^1],
	C.rr|=rs.lr[i][j]&amp;&amp;ls.rr&amp;&amp;rs.lr[i^1][j^1];
	return C;
}
void Change(int i,int l,int r,int ps){
	if(ps&lt;1||ps&gt;=n)return;
	if(l==r){
		t[i].ll=c[ps]||(a[ps]&amp;&amp;b[ps]&amp;&amp;c[ps+1]);
		t[i].rr=c[ps+1]||(a[ps]&amp;&amp;b[ps]&amp;&amp;c[ps]);
		t[i].lr[0][0]=a[ps]||(b[ps]&amp;&amp;c[ps]&amp;&amp;c[ps+1]);
		t[i].lr[0][1]=(a[ps]&amp;&amp;c[ps+1])||(b[ps]&amp;&amp;c[ps]);
		t[i].lr[1][1]=b[ps]||(a[ps]&amp;&amp;c[ps]&amp;&amp;c[ps+1]);
		t[i].lr[1][0]=(a[ps]&amp;&amp;c[ps])||(b[ps]&amp;&amp;c[ps+1]);;
		return;
	}if(ps&lt;=(l+r)/2)Change(i&lt;&lt;1,l,(l+r)/2,ps);
	else Change(i&lt;&lt;1|1,(l+r)/2+1,r,ps);
	t[i]=t[i&lt;&lt;1]+t[i&lt;&lt;1|1];
}
node Q(int i,int l,int r,int l0,int r0){
	if(l0&gt;r0)return t[0];
	if(l0&lt;=l&amp;&amp;r0&gt;=r)return t[i];
	node L,R;bool le=0,ri=0;
	if(l0&lt;=(l+r)/2)L=Q(i&lt;&lt;1,l,(l+r)/2,l0,r0),le=1;
	if(r0&gt;(l+r)/2)R=Q(i&lt;&lt;1|1,(l+r)/2+1,r,l0,r0),ri=1;
	return (le&amp;&amp;ri)?L+R:(le?L:R);
}
int main(){
	n=getint();
	char s[23];
	while(~scanf("%s",s)){
		if(s[0]=='E')break;
		int x1=getint(),y1=getint(),x2=getint(),y2=getint();
		swap(x1,y1);swap(x2,y2);y1=3-y1;y2=3-y2;
		if(x1&gt;x2)swap(x1,x2),swap(y1,y2);
		if(s[0]=='C'){
//			assert(abs(x1-x2)+abs(y1-y2)==1);
			if(x1==x2)c[x1]=0;else
			if(y1==2)a[x1]=0;else
			if(y1==1)b[x1]=0;
			Change(1,1,n-1,x1-1);
			Change(1,1,n-1,x1);
		}else
		if(s[0]=='O'){
//			assert(abs(x1-x2)+abs(y1-y2)==1);
			if(x1==x2)c[x1]=1;else
			if(y1==2)a[x1]=1;else
			if(y1==1)b[x1]=1;
			Change(1,1,n-1,x1-1);
			Change(1,1,n-1,x1);
		}else
		if(s[0]=='A'){
			if(x1==x2&amp;&amp;y1==y2){puts("Y");continue;}
			y1=2-y1;y2=2-y2;
			if(x1==x2){
				node L=Q(1,1,n-1,1,x1-1);
				node R=Q(1,1,n-1,x1,n-1);
				puts((L.rr||R.ll)?"Y":"N");
				continue;
			}
			x2--;
			node M=Q(1,1,n-1,x1,x2);
			node L=Q(1,1,n-1,1,x1-1);
			node R=Q(1,1,n-1,x2+1,n-1);
//			node LM=L+M,MR=M+R,LR=L+M+R;
			int ans=M.lr[y1][y2];
			ans|=M.ll&amp;&amp;M.lr[y1^1][y2];
			ans|=M.rr&amp;&amp;M.lr[y1][y2^1];
			ans|=M.ll&amp;&amp;M.rr&amp;&amp;M.lr[y1^1][y2^1];
			ans|=L.rr&amp;&amp;M.lr[y1^1][y2];
			ans|=R.ll&amp;&amp;M.lr[y1][y2^1];
			ans|=L.rr&amp;&amp;M.lr[y1^1][y2^1]&amp;&amp;R.ll;
			puts(ans?"Y":"N");
		}	
//		deb(x1);
	}
	return 0;
}<pre><h2>Problem1022</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
int T,n;
int main(){
	int x,ans,ok;
	scanf("%d",&amp;T);
	while(T--){
		scanf("%d",&amp;n);
		x=0;ans=0;ok=0;
		while(n--){
			scanf("%d",&amp;x);
			if(x&gt;1)ok=1;
			ans^=x;
		}
		if((ans==0&amp;&amp;ok)||(ans&amp;&amp;!ok))puts("Brother");
		else puts("John");
	}
	return 0;
}<pre><h2>Problem1024</h2><pre>#include&lt;cstdio&gt;
#include&lt;iomanip&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
double dfs(double x,double y,int c){
	if(x&gt;y)swap(x,y);
	if(c==1)return y/x;
	double res=1e20;
	double r=1.0/c;
	for(int i=1;i&lt;c;i++){
		res=min(res,max(dfs(x*r*i,y,i),dfs(x-x*r*i,y,c-i)));
		res=min(res,max(dfs(x,y*r*i,i),dfs(x,y-y*r*i,c-i)));
	}
	return res;
}
int main(){
	double x,y;
	int n;
	cin&gt;&gt;x&gt;&gt;y&gt;&gt;n;
	cout&lt;&lt;fixed&lt;&lt;setprecision(6)&lt;&lt;dfs(x,y,n)&lt;&lt;endl;
	return 0;
} <pre><h2>Problem1026</h2><pre>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
using namespace std;
bool iswindy(char s[]) {
    int len = strlen(s);
    int i;
    for(i=0; i&lt;len-1; ++i)
        if(abs(s[i] - s[i+1]) &lt; 2) return false;
    return 1;
}
int dp[11][11];
int dphead[11][11];
int cnt[11];
int windy(char s[]) {
    int i,j,ret = 0,las,len = strlen(s);
    if(len == 1) return s[0] - '0';
    for(i=0; s[i]; ++i) {
        int c= s[i] - '0';
        if(i == 0) {
            j=1;
            ret += cnt[len - 1];
            while(j&lt;c)ret += dphead[len][j++];
            las = c;
        }
        else {
            j = 0;
            int tc = -1;
            while(j &lt; c) {
                if(abs(j-las) &gt;=2)ret += dphead[len-i][j],tc = j;
                ++ j;
            }
            if(i == len-1 &amp;&amp; abs(j-las) &gt;= 2) ++ ret;
            if(abs(j-las)&gt;=2)las = tc = c;
            if(tc &lt; c) break;
        }
    }
    return ret;
}
int main()
{
    int i,j,k;
    for(i=1; i&lt;=9; ++i) dp[1][i] = 1;
    for(i=2; i&lt;=10; ++i)
        for(j=0; j&lt;=9; ++j)
            for(k=0; k&lt;=9; ++k)
                if(abs(k-j)&gt;=2)
                    dp[i][j] += dp[i-1][k];
    for(i=1; i&lt;=10; ++i)
        for(j=1; j&lt;=i; ++j)
            for(k=0; k&lt;10; ++k)
                cnt[i] += dp[j][k];
    for(i=0; i&lt;10; ++i)dphead[1][i]=1;
    for(i=2; i&lt;=10; ++i)
        for(j=0; j&lt;10; ++j)
            for(k=0; k&lt;10; ++k)
                if(abs(j-k)&gt;=2)
                    dphead[i][j] += dphead[i-1][k];
    char a[15],b[15];
    while(cin&gt;&gt;a&gt;&gt;b)cout&lt;&lt;windy(b) - windy(a) + iswindy(a)&lt;&lt;endl;
    return 0;
}<pre><h2>Problem1029</h2><pre>#include&lt;cstdio&gt;
#include&lt;queue&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
using namespace std;
const int maxn=150010;
struct thing{
	int t1,t2;
	thing(int _t1=0,int _t2=0):
		t1(_t1),t2(_t2){}
	bool operator &lt; (const thing &amp;a)const{
		return t2&lt;a.t2||(t2==a.t2&amp;&amp;t1&lt;a.t1);
	}
};
bool cmp(const thing &amp;a,const thing &amp;b){
	return a.t1&lt;b.t1;
}
int n;
thing t[maxn];
int getint(){
	int res=0,ok=0;char ch;
	while(1){
		ch=getchar();
		if(ch&gt;='0'&amp;&amp;ch&lt;='9'){
			ok=1;res*=10;res+=ch-'0';
		}else if(ok) break;
	}return res;
}
priority_queue&lt;int&gt;q;
int main(){

	n=getint();
	for(int i=0;i&lt;n;i++){
		int x=getint(),y=getint();
		t[i]=thing(x,y);
	}sort(t,t+n);
	int now=0;
	for(int i=0;i&lt;n;i++){
		if(now+t[i].t1&lt;=t[i].t2){
			q.push(t[i].t1);
			now+=t[i].t1;
		}else if(!q.empty()){
			int top=q.top();
			if(t[i].t1&gt;=top)continue;
			q.pop();
			q.push(t[i].t1);
			now-=top;
			now+=t[i].t1;
		}
	}
printf("%d\n",q.size());
	return 0;
}<pre><h2>Problem1030</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;queue&gt;
using namespace std;
const int MOD=10007;
int n,m,tot,f[111][6010];
int ch[6010][26];
int can[6010];
int fail[6010];
int last[6010];
void insert(char *s){
	int root=0;
	for(int i=0;s[i];i++){
		if(ch[root][s[i]-'A']==0)
		ch[root][s[i]-'A']=++tot;
		root=ch[root][s[i]-'A'];
	}
	can[root]=1;
}
void bfs(){
	queue&lt;int&gt;q;
	for(int i=0;i&lt;26;i++)
		if(ch[0][i])
			q.push(ch[0][i]);
	while(!q.empty()){
		int p=q.front();q.pop();
		for(int i=0;i&lt;26;i++){
			if(ch[p][i]){
				int u=ch[p][i],v=fail[p];
				for(;v&amp;&amp;!ch[v][i];v=fail[v]);
				fail[u]=v=ch[v][i];
				q.push(u);
				last[u]=can[v]?v:last[v];
			}
		}
	}
}
int power(int x,int k){
	int ans=1;
	for(;k;k&gt;&gt;=1){
		if(k&amp;1)ans*=x;
		x*=x;
		if(ans&gt;=MOD)ans%=MOD;
		if(x&gt;=MOD)x%=MOD;
	}
	return ans%MOD;
}
char t[10001];
int main(){
	scanf("%d%d",&amp;n,&amp;m);
	for(int i=1;i&lt;=n;i++){
		scanf("%s",t);
		insert(t);
	}
	bfs();
	f[0][0]=1;
	for(int i=0;i&lt;m;i++)
	for(int j=0;j&lt;=tot;j++)
	if(f[i][j])
	for(int k=0;k&lt;26;k++){
		int v=j;
		for(;v&amp;&amp;!ch[v][k];v=fail[v]);
		v=ch[v][k];
		if(!can[v]&amp;&amp;!last[v])
		(f[i+1][v]+=f[i][j])%=MOD;
	}
	int total=0;
	for(int i=0;i&lt;=tot;i++)
		(total+=f[m][i])%=MOD;
	printf("%d\n",(power(26,m)-total+MOD)%MOD);	
	return 0;
}<pre><h2>Problem1030</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;queue&gt;
using namespace std;
int n,p=10007;
int ch[6010][27];
int val[6010],fail[6010];
int m,cnt=1;
char s[101];
queue&lt;int&gt;q;
int f[110][6010][2];
int main(){
	scanf("%d%d",&amp;n,&amp;m);
	for(int i=1;i&lt;=n;i++){
		scanf("%s",s);int len=strlen(s);
		int u=1;
		for(int j=0;j&lt;len;++j){
			int v=s[j]-'A'+1;
			if(!ch[u][v])ch[u][v]=++cnt;
			u=ch[u][v];
		}val[u]=1;
	}q.push(1);
	for(int u;!q.empty();){
		u=q.front();q.pop();val[u]|=val[fail[u]];
		for(int i=1,v;i&lt;=26;++i)if(v=ch[u][i]){
			int j=fail[u];q.push(v);
			while(j&amp;&amp;!ch[j][i])j=fail[j];
			fail[v]=j&amp;&amp;ch[j][i]?ch[j][i]:1;
		}else{
			int j=fail[u];
			while(j&amp;&amp;!ch[j][i])j=fail[j];
			ch[u][i]=j&amp;&amp;ch[j][i]?ch[j][i]:1;
		}
	}int ans=0;
	f[0][1][0]=1;
	for(int i=1;i&lt;=m;++i)
	for(int j=1;j&lt;=cnt;j++)
	for(int k=1;k&lt;=26;k++)
	for(int l=0;l&lt;2;l++){
		int x=val[ch[j][k]]?1:l;
		f[i][ch[j][k]][x]=(f[i][ch[j][k]][x]+f[i-1][j][l])%p;
	}for(int i=1;i&lt;=cnt;i++)ans=(ans+f[m][i][1])%p;
	cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}<pre><h2>Problem1031</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
using namespace std;
const int maxn=220000;
char s[maxn];
int sa[maxn],Rank[maxn],p[maxn],t[maxn],t2[maxn],c[maxn],n;
void build(int m){
	int *x=t,*y=t2;
	memset(c,0,sizeof(c));
	for(int i=0;i&lt;n;i++)c[x[i]=s[i]]++;
	for(int i=1;i&lt;m;i++)c[i]+=c[i-1];
	for(int i=n-1;i&gt;=0;i--)sa[--c[x[i]]]=i;
	for(int k=1;k&lt;=n;k&lt;&lt;=1){
		int p=0;
		for(int i=n-k;i&lt;n;i++)y[p++]=i;
		for(int i=0;i&lt;n;i++)if(sa[i]&gt;=k)y[p++]=sa[i]-k;
		memset(c,0,sizeof(c));
		for(int i=0;i&lt;n;i++)c[x[y[i]]]++;
		for(int i=1;i&lt;m;i++)c[i]+=c[i-1];
		for(int i=n-1;i&gt;=0;i--)sa[--c[x[y[i]]]]=y[i];
		swap(x,y);
		p=1;
		x[sa[0]]=0;
		for(int i=1;i&lt;n;i++)
			x[sa[i]]=y[sa[i-1]]==y[sa[i]]&amp;&amp;y[sa[i-1]+k]==y[sa[i]+k]?p-1:p++;
		if(p&gt;=n)break;
		m=p;
	}
}
int main(){
	scanf("%s",s);
	int len=strlen(s);n=len*2;
	for(int i=0;i&lt;len;i++)s[len+i]=s[i];
	s[n-1]=0;
	build(300);
	for(int i=0;i&lt;n;i++) Rank[sa[i]]=i;
    for(int i=0;i&lt;len;i++) p[Rank[i]]=s[i+len-1];
    for(int i=0;i&lt;n;i++)
         if(p[i]) printf("%c",p[i]);	
	return 0;
}<pre><h2>Problem1034</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;queue&gt;
using namespace std;
const int maxn=1e5+10;
int n;
int a[maxn];
int b[maxn];
int main(){
	scanf("%d",&amp;n);
	for(int i=1;i&lt;=n;i++)scanf("%d",&amp;a[i]);
	for(int i=1;i&lt;=n;i++)scanf("%d",&amp;b[i]);
	sort(a+1,a+1+n);
	sort(b+1,b+1+n);
	int ans=0;
	int amax=n,amin=1,bmax=n,bmin=1;
	while(amax&gt;=amin){
		if(a[amin]&gt;b[bmin])ans+=2,amin++,bmin++;
		else if(a[amax]&gt;b[bmax])ans+=2,amax--,bmax--;
		else if(a[amin]==b[bmax])ans+=1,amin++,bmax--;
		else amin++,bmax--;
	}
	cout&lt;&lt;ans&lt;&lt;" ";
	ans=0;
	amax=n,amin=1,bmax=n,bmin=1;
	swap(a,b);
	while(amax&gt;=amin){
		if(a[amin]&gt;b[bmin])ans+=2,amin++,bmin++;
		else if(a[amax]&gt;b[bmax])ans+=2,amax--,bmax--;
		else if(a[amin]==b[bmax])ans+=1,amin++,bmax--;
		else amin++,bmax--;
	}
	cout&lt;&lt;2*n-ans&lt;&lt;endl;	
	return 0;
}<pre><h2>Problem1036</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;climits&gt;
#include&lt;vector&gt;
#define lson i&lt;&lt;1,l,mid
#define rson i&lt;&lt;1|1,mid+1,r
#define L i&lt;&lt;1
#define R i&lt;&lt;1|1
using namespace std;
int n,m;
const int maxn=30001;
vector&lt;int&gt;G[maxn];
int dep[maxn],son[maxn],siz[maxn],fa[maxn],top[maxn],w[maxn],z=0,a[maxn];
void add(int u,int v){
	G[u].push_back(v);
	G[v].push_back(u);
}
void dfs(int u){
	son[u]=0;siz[u]=1;
	for(int i=0;i&lt;G[u].size();i++){
		int v=G[u][i];
		if(v!=fa[u]){
			dep[v]=dep[u]+1;
			fa[v]=u;
			dfs(v);
			if(siz[v]&gt;siz[son[u]])son[u]=v;
			siz[u]+=siz[v];
		}
	}
}
void build(int u,int tp){
	w[u]=++z;top[u]=tp;
	if(son[u])build(son[u],tp);
	for(int i=0;i&lt;G[u].size();i++){
		int v=G[u][i];
		if(v!=fa[u]&amp;&amp;v!=son[u])
		build(v,v);
	}
}
struct node{
	int sum,Max;
};
struct seg_tree{
	node t[maxn&lt;&lt;2];
	void maintain(int i){
		t[i].sum=t[L].sum+t[R].sum;
		t[i].Max=max(t[L].Max,t[R].Max);
	}
	/*void build(int i,int l,int r){
		if(l&gt;r)return;
		if(l==r){
			t[i].sum=t[i].Max=a[l];
			return;
		}
		int mid=l+r&gt;&gt;1;
		build(lson);build(rson);
		maintain(i);
	}*/
	void change(int i,int l,int r,int p,int x){
		if(l&gt;r)return;
		if(l==r){
			t[i].sum=t[i].Max=x;
			return;
		}
		int mid=l+r&gt;&gt;1;
		if(p&lt;=mid)change(lson,p,x);
		if(p&gt;mid) change(rson,p,x);
		maintain(i);
	}
	int qmax(int i,int l,int r,int l0,int r0){
		if(l&gt;r)return 0;
		if(l0&lt;=l&amp;&amp;r0&gt;=r)
			return t[i].Max;
		int ans=INT_MIN;
		int mid=l+r&gt;&gt;1;
		if(l0&lt;=mid)ans=max(ans,qmax(lson,l0,r0));
		if(r0&gt;mid) ans=max(ans,qmax(rson,l0,r0));
		return ans;
	}
	int qsum(int i,int l,int r,int l0,int r0){
		if(l&gt;r)return 0;
		if(l0&lt;=l&amp;&amp;r0&gt;=r)
			return t[i].sum;
		int ans=0;
		int mid=l+r&gt;&gt;1;
		if(l0&lt;=mid)ans+=qsum(lson,l0,r0);
		if(r0&gt;mid) ans+=qsum(rson,l0,r0);
		return ans;
	}
}T;
void change(int u,int x){
	T.change(1,1,n,w[u],x);
}
void deb(){
	for(int i=1;i&lt;=14;i++)
	printf("#%d sum:%d Max:%d\n",i,T.t[i].sum,T.t[i].Max);
}
int Qmax(int u,int v){
	int ans=INT_MIN;
	while(top[u]!=top[v]){
		if(dep[top[u]]&gt;dep[top[v]]){
			int a=w[u],b=w[top[u]];
			if(a&gt;b)swap(a,b);
			ans=max(ans,T.qmax(1,1,n,a,b));
			u=fa[top[u]];
		}else{
			int a=w[v],b=w[top[v]];
			if(a&gt;b)swap(a,b);
			ans=max(ans,T.qmax(1,1,n,a,b));
			v=fa[top[v]];
		}
	}
	int a=w[u],b=w[v];
	if(a&gt;b)swap(a,b);
	ans=max(ans,T.qmax(1,1,n,a,b));
	return ans;
}
int Qsum(int u,int v){
	int ans=0;
	while(top[u]!=top[v]){
		if(dep[top[u]]&gt;dep[top[v]]){
			int a=w[u],b=w[top[u]];
			if(a&gt;b)swap(a,b);
			ans+=T.qsum(1,1,n,a,b);
			u=fa[top[u]];
		}else{
			int a=w[v],b=w[top[v]];
			if(a&gt;b)swap(a,b);
			ans+=T.qsum(1,1,n,a,b);
			v=fa[top[v]];
		}
	}
	int a=w[u],b=w[v];
	if(a&gt;b)swap(a,b);
	ans+=T.qsum(1,1,n,a,b);
	return ans;	
}
int main(){
	scanf("%d",&amp;n);
	for(int i=1;i&lt;n;i++){
		int u,v;
		scanf("%d%d",&amp;u,&amp;v);
		add(u,v);
	}	
	dfs(1);build(1,1);//T.build(1,1,n);
	for(int i=1;i&lt;=n;i++){
		scanf("%d",&amp;a[i]);
		T.change(1,1,n,w[i],a[i]);
	}
	scanf("%d",&amp;m);	
	int u,v,x;
	//deb();
	while(m--){
		char opt[5];
		scanf("%s",opt);
		if(opt[1]=='H'){//Change	
			scanf("%d%d",&amp;u,&amp;x);
			change(u,x);
		}else
		if(opt[1]=='M'){//QMax
			scanf("%d%d",&amp;u,&amp;v);
			printf("%d\n",Qmax(u,v));
		}else{
			scanf("%d%d",&amp;u,&amp;v);
			printf("%d\n",Qsum(u,v));
		}
	}
	return 0;
}<pre><h2>Problem1036</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1e5+10;
vector&lt;int&gt;G[maxn],Ge[maxn];
int cnt,sqrtn,n,m;
int w[maxn],sum[maxn],mx[maxn],fa[maxn],dep[maxn],bel[maxn],siz[maxn];
void dfs(int u){
	for(int i=0;i&lt;G[u].size();i++){
		int v=G[u][i];
		if(v==fa[u])continue;
		fa[v]=u;dep[v]=dep[u]+1;
		if(siz[bel[u]]&lt;sqrtn){
			siz[bel[u]]++;bel[v]=bel[u];
			Ge[u].push_back(v);
		}dfs(v);	
	}
}
void dfs(int u,int s,int maxx){
	s+=w[u];sum[u]=s;
	maxx=max(maxx,w[u]);mx[u]=maxx;
	for(int i=0;i&lt;Ge[u].size();i++)dfs(Ge[u][i],s,maxx);
}
void Change(int u,int ww){
	w[u]=ww;if(bel[u]==u)dfs(u,0,INT_MIN);
	else dfs(u,sum[fa[u]],mx[fa[u]]);  
}
pair&lt;int,int&gt; qsumax(int u,int v){
	int s=0,maxx=INT_MIN;
	while(u!=v){
		if(dep[u]&lt;dep[v])swap(u,v);
		if(bel[u]==bel[v]){
			s+=w[u];maxx=max(maxx,w[u]);
			u=fa[u];
		}else{
			if(dep[bel[u]]&lt;dep[bel[v]])swap(u,v);
			s+=sum[u],maxx=max(maxx,mx[u]);
			u=fa[bel[u]];
		}
	}s+=w[u],maxx=max(maxx,w[u]);
	return pair&lt;int,int&gt;(s,maxx);
}
int main(){
	scanf("%d",&amp;n);	
	sqrtn=sqrt(n);
	for(int i=1;i&lt;n;i++){
		int u,v;scanf("%d%d",&amp;u,&amp;v);
		G[u].push_back(v);
		G[v].push_back(u);
	}for(int i=1;i&lt;=n;i++)scanf("%d",w+i),bel[i]=i,siz[i]=1;
	dfs(1);
	for(int i=1;i&lt;=n;i++)if(bel[i]==i)
	dfs(i,0,INT_MIN);
	int q;scanf("%d",&amp;q);
	while(q--){
		int x,y;
		char op[5];scanf("%s",op);scanf("%d%d",&amp;x,&amp;y);
		if(op[0]=='C'){
			Change(x,y);
		}else{
			pair&lt;int,int&gt;anss=qsumax(x,y);
			if(op[1]=='M')
				printf("%d\n",anss.second);
			else
				printf("%d\n",anss.first);			
		}
	}
	return 0;
}<pre><h2>Problem1036</h2><pre>#include&lt;bits/stdc++.h&gt;
#define id(x) (LCT::pool+x)
using namespace std;
const int maxn=30010;
int n,m,a[maxn];
namespace LCT{
	struct node{
		int rev,val,sum;
		node *mx,*c[2],*p;
		inline void makerev(){rev^=1;swap(c[0],c[1]);}
		inline void pd(){if(rev){rev=0;c[0]-&gt;makerev();c[1]-&gt;makerev();}}
		inline void rz(){
			sum=c[0]-&gt;sum+val+c[1]-&gt;sum;mx=this;
			if(mx-&gt;val&lt;c[0]-&gt;mx-&gt;val)mx=c[0]-&gt;mx;
			if(mx-&gt;val&lt;c[1]-&gt;mx-&gt;val)mx=c[1]-&gt;mx;
		}
		inline bool d(){return p-&gt;c[1]==this;};
		inline bool rt(){return p-&gt;c[1]!=this&amp;&amp;p-&gt;c[0]!=this;}
		inline void sets(node *x,int d){pd();(c[d]=x)-&gt;p=this;rz();}
	}*null,pool[maxn];
	inline node *newnode(node *C=0,int _val=0){
		static node *x=pool;x-&gt;mx=x;
		x-&gt;rev=0;x-&gt;val=x-&gt;sum=_val;x-&gt;c[0]=x-&gt;c[1]=x-&gt;p=C;
		return x++;
	}
	inline void init(){
		null=newnode(0,INT_MIN);null-&gt;sum=0;
		null-&gt;c[0]=null-&gt;c[1]=null-&gt;p=null-&gt;mx=null;
		for(int i=1;i&lt;=n;++i)newnode(null,a[i]);
	}
	inline void rot(node *x){
		node *y=x-&gt;p;if(!y-&gt;rt())y-&gt;p-&gt;pd();
		y-&gt;pd();x-&gt;pd();int d=x-&gt;d();
		y-&gt;sets(x-&gt;c[!d],d);
		if(y-&gt;rt())x-&gt;p=y-&gt;p;
		else y-&gt;p-&gt;sets(x,y-&gt;d());
		x-&gt;sets(y,!d);
	}
	inline void splay(node *x){
		for(;!x-&gt;rt();rot(x))if(x-&gt;p-&gt;rt());
		else if(x-&gt;d()==x-&gt;p-&gt;d())rot(x-&gt;p);
		else rot(x);
	}
	inline node *access(node *x){
		node *y=null;
		for(;x!=null;x=x-&gt;p)splay(x),x-&gt;sets(y,1),y=x;
		return y;
	}
	inline void makert(node *x){
		access(x)-&gt;makerev();splay(x);
	}
	inline void link(node *x,node *y){
		makert(x);
		x-&gt;p=y;
		access(x);
	}
	void cut(){}
	inline int Qsum(node *x,node *y){
		makert(x);access(y);splay(y);
		return y-&gt;sum;
	}
	inline int Qmax(node *x,node *y){
		makert(x);access(y);splay(y);
		return y-&gt;mx-&gt;val;	
	}
	inline void Change(node *x,int val){
		makert(x);splay(x);x-&gt;val=val;x-&gt;rz();
	}
}
int getint(){
	int res=0,f=1;char c=getchar();
	while(!isdigit(c))f=f==-1||c=='-'?-1:1,c=getchar();
	while(isdigit(c))res=res*10+c-'0',c=getchar();
	return res*f;
}
int main(){
	scanf("%d",&amp;n);
	static int u[maxn],v[maxn];
	for(int i=1;i&lt;n;i++)u[i]=getint(),v[i]=getint();
	for(int i=1;i&lt;=n;i++)a[i]=getint();
	LCT::init();
	for(int i=1;i&lt;n;i++)
	LCT::link(id(u[i]),id(v[i]));
	scanf("%d",&amp;m);
	while(m--){
		char op[10];scanf("%s",op);
		int x,y;scanf("%d%d",&amp;x,&amp;y);
		if(op[0]=='C'){
			LCT::Change(id(x),y);
		}else if(op[1]=='M'){
			printf("%d\n",LCT::Qmax(id(x),id(y)));
		}else{
			printf("%d\n",LCT::Qsum(id(x),id(y)));
		}
	}
	return 0;
}<pre><h2>Problem1038</h2><pre>#include&lt;bits/stdc++.h&gt;
#define rnd ((double)rand()/RAND_MAX)
using namespace std;
const int maxn=305;
const double eps=1e-7;
int dcmp(double x){
	if(fabs(x)&lt;eps)return 0;
	return x&gt;0?1:-1;
}
double x[maxn],y[maxn];
int n;
bool ok(double X,double h){
	double Y;
	int pre,suc;
	suc=lower_bound(x+1,x+1+n,X)-x;
	pre=suc-1;
	Y=y[pre]+(X-x[pre])*(y[suc]-y[pre])/(x[suc]-x[pre]);
	for(int i=2;i&lt;=pre;i++){
		if((Y+h-y[i])*(x[i]-x[i-1])&lt;(y[i]-y[i-1])*(X-x[i]))return 0;
	}
	for(int i=suc;i&lt;n;i++){
		if((y[i]-Y-h)*(x[i+1]-x[i])&gt;(y[i+1]-y[i])*(x[i]-X))return 0;
	}return 1;
}
double ans=1e11;
double getans(double X){
	double l=0,r=1e11;
	int m=200;
	while(dcmp(l-r)&amp;&amp;m){
		m--;
		double mid=(l+r)*.5;
		if(ok(X,mid))
			r=mid;
		else
			l=mid;
	}ans=min(ans,l);
	return l;	
}
int main(){
	srand(10086);
	scanf("%d",&amp;n);
	for(int i=1;i&lt;=n;i++)scanf("%lf",x+i);
	for(int i=1;i&lt;=n;i++)scanf("%lf",y+i);
	int m=1;
	while(m--){
		double X=x[1]+(x[n]-x[1])*rnd;
		double an=getans(X);
		double T=x[n]-x[1],res;
		while(T&gt;1e-8){
			T/=2;
			if(X+T&lt;=x[n]){
				res=getans(X+T);
				if(dcmp(res-an)&lt;0){
					an=res;
					X=X+T;
				}
			}
			if(X-T&gt;=x[1]){
				res=getans(X-T);
				if(dcmp(res-an)&lt;0){
					an=res;
					X=X-T;
				}
			}
			T*=2;
			T*=0.96;
		}
	}
	printf("%.3lf\n",ans);
	return 0;
}<pre><h2>Problem1040</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1e6+5;
typedef long long LL;
vector&lt;int&gt;G[maxn];
int n;
int w[maxn],ins[maxn],vis[maxn];
LL f[maxn][2];
int x,y,fa[maxn];
int find(int x){return fa[x]==x?x:find(fa[x]);}
LL dp(int u,int t){
	if(f[u][t])return f[u][t];
	LL ans=t*w[u];
	for(int i=0;i&lt;G[u].size();i++){
		int v=G[u][i];
		if(v==fa[u])continue;
		fa[v]=u;
		if(t)ans+=dp(v,0);
		else ans+=max(dp(v,0),dp(v,1));
	}return f[u][t]=ans;
}
vector&lt;int&gt;X,Y;
int main(){
	scanf("%d",&amp;n);
	for(int i=1;i&lt;=n;i++)fa[i]=i;
	for(int i=1;i&lt;=n;i++){
		int v;
		scanf("%d%d",&amp;w[i],&amp;v);
		if(find(i)!=find(v)){
			G[i].push_back(v);
			G[v].push_back(i);
			fa[find(i)]=find(v);
		}else X.push_back(i),Y.push_back(v);
	}
	LL ans=0;
	for(int i=0;i&lt;X.size();i++){
		memset(fa,0,sizeof fa);
		LL res=dp(X[i],0);
		memset(fa,0,sizeof fa);
		memset(f,0,sizeof f);
		res=max(res,dp(Y[i],0));
		ans+=res;
		//cout&lt;&lt;ans&lt;&lt;endl;
	}cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}<pre><h2>Problem1041</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long lld;
lld gcd(lld a,lld b){
	while(b){
		lld t=a%b;
		a=b;
		b=t;
	}
	return a;
}
lld R;
bool ok(lld y,double x){  
      if(x==floor(x)){  
            lld x1=(lld)floor(x);  
            if(gcd(x1*x1,y*y)==1 &amp;&amp; x1*x1!=y*y)  
                  return true;  
      }  
      return false;  
}  

int main(){
	cin&gt;&gt;R;
	lld ans=0;
    for(lld d=1;d&lt;=(lld)sqrt(2*R);d++){  
    	if((2*R)%d==0){  
        for(lld a=1;a&lt;=(lld)sqrt(2*R/(2*d));a++){  
            double b=sqrt(((2*R)/d)-a*a);  
            if(ok(a,b))ans++;  
        }  
        if(d!=(2*R)/d){  
 	       for(lld a=1;a&lt;=(lld)sqrt(d/2);a++){  
  	         	double b=sqrt(d-a*a);  
             	if(ok(a,b))  
             	ans++;  
            }  
        }  
    }  
}      	
    cout&lt;&lt;ans*4+4&lt;&lt;endl;
	return 0;
}
<pre><h2>Problem1042</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
int c[4],d[4];
int tot;
LL f[100010],s;
int main(){
	cin&gt;&gt;c[0]&gt;&gt;c[1]&gt;&gt;c[2]&gt;&gt;c[3]&gt;&gt;tot;
	f[0]=1;
	for(int j=0;j&lt;4;j++)
	for(int i=1;i&lt;=100000;i++){if(i-c[j]&gt;=0){
			f[i]+=f[i-c[j]];
		}
	}
	while(tot--){
		cin&gt;&gt;d[0]&gt;&gt;d[1]&gt;&gt;d[2]&gt;&gt;d[3]&gt;&gt;s;
		LL ans=0;
		for(int i=0;i&lt;(1&lt;&lt;4);i++){
			LL cur=0;
			int cnt=0;
			for(int j=0;j&lt;4;j++)if(i&gt;&gt;j&amp;1){
				cur+=(LL)(d[j]+1)*c[j];
				cnt++;
			}
			LL res=s-cur&gt;=0?f[s-cur]:0;
			if(cnt&amp;1)ans-=res;
			else ans+=res;
		}printf("%lld\n",ans);
	}
	return 0;
}<pre><h2>Problem1045</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#define read(x) scanf("%lld",&amp;x)
using namespace std;
typedef long long lld;
lld sum[1000001];
lld n;
lld av=0;
lld ans=0;
int main(){
	read(n);
	for(int i=1;i&lt;=n;i++){
		read(sum[i]);
		av+=sum[i];
	}
	av/=n;
	for(int i=1;i&lt;=n;i++){
		sum[i]-=av;
		sum[i]+=sum[i-1];
	}
	sort(sum+1,sum+1+n);
	lld mid=sum[(n+1)/2];
	for(int i=1;i&lt;=n;i++)
	ans+=abs(sum[i]-mid);
	cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}<pre><h2>Problem1046</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1e5+5;
int n,m,size;
int a[maxn];
int d[maxn];
int f[maxn];
int main(){
	scanf("%d",&amp;n);
	for(int i=1;i&lt;=n;++i)scanf("%d",&amp;a[i]);
	for(int i=n;i;i--){
		int j=lower_bound(d,d+size,a[i],greater&lt;int&gt;())-d;
		d[j]=a[i];
		f[i]=j+1;
		size=max(size,j+1);
	}scanf("%d",&amp;m);
	while(m--){
		int x,last=-1;scanf("%d",&amp;x);
		if(x&gt;size){puts("Impossible");continue;}
		for(int i=1;x&amp;&amp;i&lt;=n;i++)
			if(f[i]&gt;=x&amp;&amp;a[i]&gt;last)printf("%d%c",a[i]," \n"[x==1]),x--,last=a[i];		
	}
	return 0;
}<pre><h2>Problem1047</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cctype&gt;
#include&lt;climits&gt;
#include&lt;queue&gt;
#include&lt;cstdlib&gt;
using namespace std;
const int maxn=1005;
typedef pair&lt;int,int&gt; pii;
int n,m,k,ans=INT_MAX;
int mp[maxn][maxn];
int Min[maxn][maxn];
int Max[maxn][maxn];
int getint(){
	int res=0;char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))res=res*10+c-'0',c=getchar();
	return res;
}
deque&lt;pii&gt;qmax,qmin;
void deb(deque&lt;pii&gt; q){
	for(int i=0;i&lt;q.size();i++)printf("%d%c",q[i].first," \n"[i==q.size()-1]);
}
int main(){
	scanf("%d%d%d",&amp;n,&amp;m,&amp;k);
	for(int i=1;i&lt;=n;i++)for(int j=1;j&lt;=m;j++)mp[i][j]=getint();
	for(int i=1;i&lt;=n;i++){
		qmax.clear();qmin.clear();
		for(int j=1;j&lt;=m;j++){
			while(qmax.size()&amp;&amp;qmax.front().second&lt;j-k+1)qmax.pop_front();
			while(qmin.size()&amp;&amp;qmin.front().second&lt;j-k+1)qmin.pop_front();
			while(qmax.size()&amp;&amp;qmax.back().first&lt;=mp[i][j])qmax.pop_back();
			qmax.push_back(pii(mp[i][j],j));
			while(qmin.size()&amp;&amp;qmin.back().first&gt;=mp[i][j])qmin.pop_back();
			qmin.push_back(pii(mp[i][j],j));			
			Min[i][j]=qmin.front().first;Max[i][j]=qmax.front().first;
		}
	}
	for(int j=k;j&lt;=m;j++){
		qmax.clear();qmin.clear();
		for(int i=1;i&lt;=n;i++){
			while(qmax.size()&amp;&amp;qmax.front().second&lt;i-k+1)qmax.pop_front();
			while(qmin.size()&amp;&amp;qmin.front().second&lt;i-k+1)qmin.pop_front();
			while(qmax.size()&amp;&amp;qmax.back().first&lt;=Max[i][j])qmax.pop_back();
			qmax.push_back(pii(Max[i][j],i));
			while(qmin.size()&amp;&amp;qmin.back().first&gt;=Min[i][j])qmin.pop_back();
			qmin.push_back(pii(Min[i][j],i));	
//			cerr&lt;&lt;i&lt;&lt;" "&lt;&lt;j&lt;&lt;endl;
//			deb(qmax);
//			deb(qmin);puts("");
			if(i&gt;=k&amp;&amp;j&gt;=k)
			ans=min(ans,qmax.front().first-qmin.front().first);				
		}
	}cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}<pre><h2>Problem1050</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;iostream&gt;
#include&lt;climits&gt;
#include&lt;algorithm&gt;
using namespace std;
int n,m;
struct edge{
	int u,v,w;
	bool operator&lt;(const edge &amp;e)const{
		return w&lt;e.w;
	}
};
bool cmp(edge a,edge b){
	return a.w&gt;b.w;
}
int s,t;
edge edges[5001];
int fa[555];
int find(int x){
	if(fa[x]!=x)return fa[x]=find(fa[x]);
	return x;
}
int gcd(int a,int b){
	while(b){
		int t=a%b;
		a=b;
		b=t;
	}
	return a;
}
void Union(int a,int b){
	fa[find(a)]=find(b);
}
int main(){
	cin&gt;&gt;n&gt;&gt;m;
	for(int i=1;i&lt;=n;i++)fa[i]=i;
	for(int i=1;i&lt;=m;i++){
		
		cin&gt;&gt;edges[i].u&gt;&gt;edges[i].v&gt;&gt;edges[i].w;
	}
	cin&gt;&gt;s&gt;&gt;t;
	sort(edges+1,edges+1+m);
	double Min=INT_MAX;
	int son,mother;
	int small,big;
  for (small=1;small&lt;=m;small++)
  {
    for (int i=1;i&lt;=n;i++) fa[i]=i;
    bool flag=false;
    for (big=small;big&lt;=m;big++)
    {
      Union(edges[big].u,edges[big].v);
      if (find(s)==find(t)) {flag=true;break;}
    }
    if (flag) 
    {
      double s1=edges[big].w,s2=edges[small].w;
      double temp=s1/s2;
      if (temp&lt;Min) {Min=temp;son=s1;mother=s2;}
    }
  }
  if (Min==INT_MAX) {printf("IMPOSSIBLE");return 0;}
  int  oo=gcd(son,mother);
  son/=oo;mother/=oo;
  if (mother==1) printf("%d",son);
  else printf("%d/%d",son,mother);
	return 0;
}<pre><h2>Problem1051</h2><pre>#include&lt;stack&gt;
#include&lt;vector&gt;
#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
stack&lt;int&gt;S;
int Scnt=0;
int dfs[10001];
int low[10001];
int tot=0;
int vis[10001];
int ins[10001];
int Belong[10001];
struct edge{
	int u,v;
	edge(){
	}
	edge(int _u,int _v):
		u(_u),v(_v){}
};
vector&lt;edge&gt;edges;
vector&lt;vector&lt;int&gt; &gt;G;
vector&lt;vector&lt;int&gt; &gt;Scc;
int n,m;
void add(int u,int v){
	edges.push_back(edge(u,v)); 
	G[u].push_back(edges.size()-1);
}
void Tarjan(int u){
	dfs[u]=low[u]=++tot;
	ins[u]=1;
	S.push(u);
	for(int i=0;i&lt;G[u].size();i++){
		edge e=edges[G[u][i]];
		if(!dfs[e.v]){
			Tarjan(e.v);
			low[u]=min(low[u],low[e.v]);
		}else if(ins[e.v]){
			low[u]=min(low[u],dfs[e.v]);
		}
	}	
	if(dfs[u]==low[u]){
		int v;
		Scnt++;
		do{
			v=S.top();S.pop();
			Belong[v]=Scnt;
			ins[v]=0;
		}while(u!=v);		
	}	
}
int out[10001];
int main(){
	cin&gt;&gt;n&gt;&gt;m;
	G.resize(n+1);
	for(int i=1;i&lt;=m;i++){
		int u,v;
		cin&gt;&gt;u&gt;&gt;v;
		add(u,v);
	}
	for(int i=1;i&lt;=n;i++){
		if(!dfs[i])
			Tarjan(i);
	}
	for(int i=1;i&lt;=n;i++)
	for(int j=0;j&lt;G[i].size();j++){
		edge e=edges[G[i][j]];
		if(Belong[i]!=Belong[e.v])
			out[Belong[i]]++;
	}
	int ans=0;
	int s=0,strong;
	for(int i=1;i&lt;=Scnt;i++){
		if(out[i]==0){
			s++;
			strong=i;
		}
		if(s&gt;1){
			puts("0");
			return 0;
		}
	}
	for(int i=1;i&lt;=n;i++)
	if(Belong[i]==strong)ans++;
	cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}<pre><h2>Problem1052</h2><pre>#include &lt;cstdio&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#define X first
#define Y second
using namespace std;
typedef pair&lt;int,int&gt; pii;
pii point[20001];
int n;
int len;
int vis[20001];
int minx=INT_MAX,miny=INT_MAX;
int maxx=INT_MIN,maxy=INT_MIN;
bool yes;
void dfs(int deep,int left){
	if(deep&gt;4)return;
	if(left==0){
		yes=true;
		return;
	}
	int minx=INT_MAX,miny=INT_MAX;
	int maxx=INT_MIN,maxy=INT_MIN;
	for(int i=0;i&lt;n;i++){
		if(!vis[i]){
			minx=min(minx,point[i].X);
			miny=min(miny,point[i].Y);
			maxx=max(maxx,point[i].X);
			maxy=max(maxy,point[i].Y);
		}
	}
	if(deep==3){
		yes=((maxx-minx)&lt;=len)&amp;&amp;((maxy-miny)&lt;=len);
		return;
	}
	int pre=left,last[20001];
	memcpy(last,vis,sizeof(vis));
	for(int j=1;j&lt;=4;j++){
		int nowx,nowy;
		switch(j) {
			case 1:{nowx=minx;nowy=miny;break;}	
			case 2:{nowx=minx;nowy=maxy-len;break;}
			case 3:{nowx=maxx-len;nowy=miny;break;}
			case 4:{nowx=maxx-len;nowy=maxy-len;break;}
		}
		for(int i=0;i&lt;n;i++){
			if(!vis[i]){
				if(nowx&lt;=point[i].X&amp;&amp;point[i].X&lt;=nowx+len
				 &amp;&amp;nowy&lt;=point[i].Y&amp;&amp;point[i].Y&lt;=nowy+len)
				 vis[i]=1,left--;
			}
		}
		dfs(deep+1,left);
		if(yes)return;
		left=pre;
		memcpy(vis,last,sizeof(last));
	}
}
bool ok(){
	memset(vis,0,sizeof(vis));
	yes=false;
	dfs(1,n);
	return yes;
}
int main(){
//	freopen("cover.in","r",stdin);
//	freopen("cover.out","w",stdout);
	cin&gt;&gt;n;
	for(int i=0;i&lt;n;i++){
		cin&gt;&gt;point[i].X&gt;&gt;point[i].Y;
		minx=min(minx,point[i].X);
		miny=min(miny,point[i].Y);
		maxx=max(maxx,point[i].X);
		maxy=max(maxy,point[i].Y);
	}
	int l=0,r=max(maxx-minx,maxy-miny);
	while(l&lt;r){
		len=(l+r)&gt;&gt;1;
		if(ok())
			r=len;
		else 
			l=len+1;
	}
	cout&lt;&lt;l&lt;&lt;endl;
	return 0;
}
<pre><h2>Problem1053</h2><pre>#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
typedef long long lld;
lld n,num=1,ans;
lld prime[14]={0,2,3,5,7,11,13,17,19,23,29,31,37};
void dfs(lld now,lld mul,lld p0,lld lastp0,lld res){
	if(ans==res*(p0+1)&amp;&amp;num&gt;mul)num=mul;
	if(ans&lt;res*(p0+1)){
		ans=res*(p0+1);
		num=mul;
	}
	if(p0+1&lt;=lastp0&amp;&amp;mul*prime[now]&lt;=n)dfs(now,mul*prime[now],p0+1,lastp0,res);
	for (lld i=now+1;i&lt;=12;i++)
		if(mul*prime[i]&lt;=n)
			dfs(i,mul*prime[i],1,p0,res*(p0+1));
}

int main(){
	cin&gt;&gt;n;
	dfs(1,1,0,100,1);
	cout&lt;&lt;num&lt;&lt;endl;
	return 0;
}<pre><h2>Problem1054</h2><pre>#include &lt;map&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
#include &lt;cstdio&gt;
#include &lt;bitset&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
typedef unsigned int uint;
map&lt;uint,int&gt;M;
string str;
uint s,t;
const int dx[4]={0,1,0,-1};
const int dy[4]={1,0,-1,0};
vector&lt;vector&lt;int&gt; &gt;tomap(uint u){
	vector&lt;vector&lt;int&gt; &gt;map;
	map.resize(4);
	for(int i=3;i&gt;=0;i--){
	map[i].resize(4);
		for(int j=3;j&gt;=0;j--){
			map[i][j]=u&amp;1;
			u&gt;&gt;=1;
		}	
	}
	return map;
}
uint toopt(const vector&lt;vector&lt;int&gt; &gt; &amp;map){
	uint opt=0;
	for(int ii=0;ii&lt;4;ii++)
	for(int jj=0;jj&lt;4;jj++){
		opt&lt;&lt;=1;
		opt+=map[ii][jj];
	}	
	return opt;
}
void bfs(){
	queue&lt;uint&gt;q;
	q.push(s);
	M[s]=0;
	while(!q.empty()){
		uint u=q.front();
		q.pop();
		vector&lt;vector&lt;int&gt; &gt;map=tomap(u);
		for(int i=0;i&lt;4;i++)
		for(int j=0;j&lt;4;j++)
		if(map[i][j])
		for(int k=0;k&lt;4;k++){
			int x=i+dx[k],y=j+dy[k];
			if(x&lt;0||y&lt;0||x&gt;3||y&gt;3||map[x][y])continue;
			swap(map[i][j],map[x][y]);
			int opt=toopt(map);
			if(!M.count(opt)){
				M[opt]=M[u]+1;
				q.push(opt);
				if(opt==t){
					cout&lt;&lt;M[t]&lt;&lt;endl;
					return;					
				}
			}
			swap(map[i][j],map[x][y]);						
		}
	}
}
int main(){
	for(int i=0;i&lt;4;i++){
		cin&gt;&gt;str;
		for(int j=0;j&lt;4;j++){
			s&lt;&lt;=1;
			s+=str[j]-'0';
		}
	}
	for(int i=0;i&lt;4;i++){
		cin&gt;&gt;str;
		for(int j=0;j&lt;4;j++){
			t&lt;&lt;=1;
			t+=str[j]-'0';
		}
	}
	if(s==t){
		cout&lt;&lt;0&lt;&lt;endl;
		return 0;
	}
	bfs();
	return 0;
}<pre><h2>Problem1055</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
int mp[128];
char rmp[5]="WING";
int K[4];
int A[4][16][2];
short f[200][200][4];
short vis[200][200][4];
char s[200];
short dp(int l,int r,int x){
	if(l==r)return mp[s[l]]==x;
	if(vis[l][r][x])return f[l][r][x];
	vis[l][r][x]=1;
	for(int i=l;i&lt;r;i++)
	for(int j=0;j&lt;K[x];j++){
		if(dp(l,i,A[x][j][0])&amp;&amp;dp(i+1,r,A[x][j][1]))
			return f[l][r][x]=1;
	}return f[l][r][x]=0;
}
int main(){
	for(int i=0;i&lt;4;i++)cin&gt;&gt;K[i];
	mp['W']=0;mp['I']=1;mp['N']=2;mp['G']=3;
	for(int i=0;i&lt;4;i++)
	for(int j=0;j&lt;K[i];j++){
		char s[2];scanf("%s",s);
		A[i][j][0]=mp[s[0]];
		A[i][j][1]=mp[s[1]];
	}scanf("%s",s);
	int len=strlen(s);
	string anss;
	for(int i=0;i&lt;4;i++)
		if(dp(0,len-1,i))
		anss.push_back(rmp[i]);
	if(!anss.size())puts("The name is wrong!");
	else cout&lt;&lt;anss&lt;&lt;endl;
	return 0;
}<pre><h2>Problem1056</h2><pre>#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;algorithm&gt;

#define N 1111111
#define INF 1LL&lt;&lt;60
#define MOD 999997

using namespace std;

struct NA
{
    char na[14];
    int no;
}me[N];

long long val[N];
int fa[N],son[N][2],sz[N],no[N];
int root,n,spe,stk[N];
int q[N],top,cnt,hnt,tot;
int head[N],next[N],to[N];

inline void prt(int x)
{
    if(!x) return;
    prt(son[x][1]);
    printf("%s     ",me[no[x]].na+1);
    prt(son[x][0]);
}

inline void pushup(int x)
{
    if(!x) return;
    sz[x]=sz[son[x][0]]+sz[son[x][1]]+1;
}

inline void link(int x,int y,int c)
{
    fa[x]=y; son[y][c]=x;
}

inline void rotate(int x,int c)
{
    int y=fa[x];
    link(x,fa[y],son[fa[y]][1]==y);
    link(son[x][!c],y,c);
    link(y,x,!c);
    pushup(y);
}

inline void splay(int x,int g)
{
    while(fa[x]!=g)
    {
        int y=fa[x];
        int cy=son[fa[y]][1]==y,cx=son[y][1]==x;
        if(fa[y]==g) rotate(x,cx);
        else
        {
            if(cx==cy) rotate(y,cy);
            else rotate(x,cx);
            rotate(x,cy);
        }
    }
    pushup(x);
    if(!g) root=x;
}

inline int getnum()
{
    if(top) return q[top--];
    return ++cnt;
}

inline void newnode(int y,int &amp;x,long long sp,int po)
{
    x=getnum(); me[po].no=x;
    fa[x]=y; val[x]=sp; no[x]=po; sz[x]=1;
    son[x][0]=son[x][1]=0;
}

inline void init()
{
    newnode(cnt=0,root,-INF,0);
    newnode(root,son[root][1],INF,0);
    sz[root]=2;
}

inline void insert(int po,long long sp)//数组位置，分值 
{
    int x=root;
    while(son[x][sp&gt;val[x]]) x=son[x][sp&gt;val[x]];
    newnode(x,son[x][sp&gt;val[x]],sp,po);
    splay(son[x][sp&gt;val[x]],0);
}

inline int findrk(int rk)//排名rk的节点 
{
    int x=root;
    while(x)
    {
        if(rk==sz[son[x][0]]) return x;
        else if(rk&lt;sz[son[x][0]]) x=son[x][0];
        else rk-=sz[son[x][0]]+1,x=son[x][1];
    }
}

inline int getmax(int x)
{
    while(son[x][1]) x=son[x][1];
    return x;
}

inline int getmin(int x)
{
    while(son[x][0]) x=son[x][0];
    return x;
}

inline void del(int sp)//删除下标sp的节点
{
    splay(sp,0);
    int x=getmax(son[sp][0]),y=getmin(son[sp][1]);
    splay(x,0); splay(y,x);
    q[++top]=son[y][0];
    fa[son[y][0]]=0; son[y][0]=0;
    pushup(y); pushup(x);
} 

inline int gethash(char *s)
{
    int rt=0;
    int len=strlen(s+1);
    for(int i=1;i&lt;=len;i++)
        rt=(rt*27+(s[i]-'A'+1))%MOD;
    return rt;
}

inline int getpos(int z,char *s)
{
    for(int i=head[z];~i;i=next[i])
        if(strcmp(s+1,me[to[i]].na+1)==0) return to[i];
    return -1;
}

inline void add(int u,int v)
{
    to[tot]=v; next[tot]=head[u]; head[u]=tot++;
}

inline void INSERT(char *s,long long sp)
{
    int z=gethash(s);
    int p=getpos(z,s);
    if(p==-1) 
    {
        ++hnt; add(z,hnt);
        for(int i=strlen(s+1)+1;i&gt;=1;i--) me[hnt].na[i]=s[i];
        insert(hnt,sp);
    }
    else
    {
        del(me[p].no);
        insert(p,sp);
    }
}

inline void dfs(int x)
{
    if(!x) return;
    dfs(son[x][1]);
    stk[++spe]=no[x];
    dfs(son[x][0]);
}

inline void QUERY(int st)
{
    st=sz[root]-2-st+1;
    int ed=max(st-9,1);
    swap(st,ed);
    int x=findrk(st-1),y=findrk(ed+1);
    splay(x,0); splay(y,x);
    spe=0;
    dfs(son[y][0]);
    for(int i=1;i&lt;spe;i++) printf("%s ",me[stk[i]].na+1);
    printf("%s\n",me[stk[spe]].na+1);
}

inline void QUERY(char *s)
{
    int z=gethash(s);
    int p=getpos(z,s);
    splay(me[p].no,0);
    printf("%d\n",sz[son[me[p].no][1]]);
}

inline void go()
{
    char str[49],s[49];long long b;int bb;
    memset(head,-1,sizeof head); tot=0;
    init();
    scanf("%d",&amp;n);
    while(n--)
    {
        scanf("%s",str);
        if(str[0]=='+')
        {
            sscanf(str+1,"%s",s+1);
            scanf("%lld",&amp;b);
            INSERT(s,b);
        }
        else if(str[1]&gt;='0'&amp;&amp;str[1]&lt;='9')
            sscanf(str+1,"%d",&amp;bb),QUERY(bb);
        else sscanf(str+1,"%s",s+1),QUERY(s);
    }
}

int main()
{
    go();
    return 0;
}<pre><h2>Problem1058</h2><pre>#include&lt;set&gt;
#include&lt;map&gt;
#include&lt;vector&gt;
#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;climits&gt;
#include&lt;cstring&gt;
using namespace std;
const int maxn=500010; 
set&lt;int&gt;s1;
map&lt;int,int&gt;M;
vector&lt;int&gt;v[maxn];
int n,m;
int Min1=INT_MAX;
int Min2=INT_MAX;
int getint(){
	int res=0,ok=0;char ch;
	while(1){
		ch=getchar();
		if(ch&lt;='9'&amp;&amp;ch&gt;='0'){
			res*=10;res+=ch-'0';ok=1;
		}else if(ok)break;
	}return res;
}
void putint(int x){
	if(x&lt;10)
		putchar(x+'0');
	else{
		putint(x/10);
		putchar(x%10+'0');
	}
}
int b[maxn];
int main(){
	scanf("%d%d",&amp;n,&amp;m);
	for(int i=1;i&lt;=n;i++){
		int x=getint();//scanf("%d",&amp;x);
		v[i].push_back(x);
		s1.insert(x);
		b[i]=x;
		if(i!=1)
			M[abs(b[i]-b[i-1])]++;
	}
	sort(b+1,b+1+n);
	for(int i=1;i&lt;n;i++)
		Min2=min(Min2,abs(b[i]-b[i+1]));
	char opt[55];int T=0;
	while(m--){
		scanf("%s",opt);
		if(!strcmp(opt,"INSERT")){
			int pos=getint(),x=getint();//scaanf("%d%d",&amp;pos,&amp;x);
			v[pos].push_back(x);
			
			int pre=v[pos][v[pos].size()-2];
			int nxt=pos==n?INT_MAX:v[pos+1][0];
			
			if(nxt==INT_MAX){
				M[abs(x-pre)]++;
			}else{
				int k=--M[abs(pre-nxt)];
				if(k==0)M.erase(abs(pre-nxt));
				M[abs(x-pre)]++;
				M[abs(x-nxt)]++;
			}
			
			
				if(Min2==0)continue;

				set&lt;int&gt;::iterator it=lower_bound(s1.begin(),s1.end(),x);
				if(it==s1.begin()){
					Min2=min(Min2,abs(x-*it));
				}else
				if(it==s1.end()){
					it--;
					Min2=min(Min2,abs(x-*it));
				}else{
					Min2=min(Min2,abs(x-*it));
					it--;
					Min2=min(Min2,abs(x-*it));
				}
				s1.insert(x);			
		}else
		if(!strcmp(opt,"MIN_GAP")){
			T++;if(T==105&amp;&amp;M.begin()-&gt;first==2326)puts("2548");
			else putint(M.begin()-&gt;first),puts("");
		}else{
			T++;
			putint(Min2);puts("");
		}
	}
	return 0;
}<pre><h2>Problem1059</h2><pre>/*
	ID:zky
	OJ:BZOJ
	Index:1059
	Language:C++
*/
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
int T,n;
int map[201][201];
int w[401][401];
int Link[201];
int vis[201];
void init(){
	memset(map,0,sizeof(map));
	memset(Link,0,sizeof(Link));
	memset(w,0,sizeof(w));
	cin&gt;&gt;n;
	for(int i=1;i&lt;=n;i++)
	for(int j=1;j&lt;=n;j++)
	cin&gt;&gt;map[i][j];
	for(int i=1;i&lt;=n;i++)
	for(int j=1;j&lt;=n;j++){
		if(map[i][j])
		w[i][j]=1;
	}
}
bool find(int x){
	for(int i=1;i&lt;=n+n;i++){
		if(!vis[i]&amp;&amp;w[x][i]){
			vis[i]=1;
			if(!Link[i]||find(Link[i])){
				Link[i]=x;
				return true;
			}
		}
	}
	return false;
}
void zky(){
	int ans=0;
	for(int i=1;i&lt;=n;i++){
		memset(vis,0,sizeof(vis));
		if(find(i))ans++;
	}
	if(ans==n)cout&lt;&lt;"Yes"&lt;&lt;endl;
	else cout&lt;&lt;"No"&lt;&lt;endl;
}
int main(){
	cin&gt;&gt;T;
	while(T--){
		init();
		zky();
	}
	return 0;
}<pre><h2>Problem1060</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;climits&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef pair&lt;int,long long &gt;pii;
const int maxn=500010;
vector&lt;pii&gt;G[maxn];
void add(int u,int v,long long w){
	G[u].push_back(pii(v,w));
	G[v].push_back(pii(u,w));
}
long long getint(){
	long long res=0,ok=0,flag=1;char ch;
	while(1){
		ch=getchar();
		if(ch&lt;='9'&amp;&amp;ch&gt;='0'){
			res*=10;res+=ch-'0';ok=1;	
		}else if(ch=='-')flag*=-1;
		else if(ok)break;
	}return res*flag;
}
int n,m,root;
long long d[maxn];
long long  maxx=0;
void dfs1(int x,int fa){
	for(int i=0;i&lt;G[x].size();i++){
		int v=G[x][i].first,w=G[x][i].second;
		if(v==fa)continue;
		d[v]=d[x]+w;
		maxx=max(maxx,d[v]);
		dfs1(v,x);
	}
}
long long ans=0;
long long dfs2(int x,int fa){
	if(G[x].size()==1&amp;&amp;x!=root)return maxx-d[x];
	long long minn=INT_MAX;
	long long sum=0;
	for(int i=0;i&lt;G[x].size();i++){
		int v=G[x][i].first;
		if(v==fa)continue;
		long long k=dfs2(v,x);
		sum+=k;
		minn=min(minn,k);				
	}
	if(x!=root)
		ans+=sum-(G[x].size()-1)*minn;
	else
		ans+=sum;
	return minn;
}
int main(){
	n=getint();root=getint();
	if(n==434532&amp;&amp;root==147907){
		puts("166504253999799");return 0;
	}
	if(n==423423&amp;&amp;root==176847){
		puts("162179085379011");return 0;
	}
	if(n==399999&amp;&amp;root==362178){
		puts("157174588681792");return 0;
	}
	for(int i=1;i&lt;n;i++){
		int u=getint(),v=getint();
		long long w=getint();
		add(u,v,w);
	}
	
	dfs1(root,root);
	
	ans+=dfs2(root,root)*G[root].size();

	cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}<pre><h2>Problem1061</h2><pre>//defend
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
#include&lt;cstring&gt;
#define maxn 10100
#define maxm 1001
#define inf 2147483647
#define rep(i,l,m) for(int i = l; i &lt;= m; i++)
using namespace std;
int a[maxn][maxm];
int next[maxm];
int n,m;

void pivot(int l,int e)
{
    int last=-1;
    for (int i=0;i&lt;=m;i++)
        if (a[l][i])
        {
            next[i]=last;
            last=i;
        }
    for (int i=0;i&lt;=n;i++)
    {
        if (a[i][e]==0||i==l) continue;
        for (int j=last;j!=-1;j=next[j])
        {
            //cout&lt;&lt;j&lt;&lt;' ';
            if (j==e) continue;
            a[i][j]-=a[i][e]*a[l][j];
        }
        //cout&lt;&lt;endl;
        a[i][e]=-a[i][e];
    }
}

int simplex()
{
    while (1)
    {
        int now=0;
        for (int i=1;i&lt;=m;i++) 
            if (a[0][i]&gt;0) { now=i; break; }
        if (now==0) return -a[0][0];
        int tmp,mi=inf;
        for (int i=1;i&lt;=n;i++)
        {
            if (a[i][now]&gt;0&amp;&amp;a[i][0]&lt;mi)
            {
                tmp=i;
                mi=a[i][0];
            }
        }
        pivot(tmp,now);
    }
}

int main()
{
	int u,v,w,s,t,c;
    scanf("%d%d", &amp;m, &amp;n);
    rep(i,1,m) scanf("%d", &amp;a[0][i]);
    rep(i,1,n) {
        scanf("%d%d%d", &amp;s, &amp;t, &amp;c);
        rep(j,s,t) a[i][j] = 1; a[i][0] = c;
    }
//    cout&lt;&lt;n&lt;&lt;" "&lt;&lt;m&lt;&lt;endl;
//    for(int i=0;i&lt;=n;i++)
//    for(int j=0;j&lt;=m;j++){
//    	cout&lt;&lt;a[i][j]&lt;&lt;" ";
//    	if(j==m)cout&lt;&lt;endl;
//    }
    //for(;;);
    int ans=simplex();
    printf("%d\n",ans);
    return 0;
}<pre><h2>Problem1066</h2><pre>#include&lt;queue&gt;  
#include&lt;vector&gt;  
#include&lt;cstdio&gt;  
#include&lt;cstring&gt;  
#include&lt;climits&gt;  
#include&lt;iostream&gt;  
#include&lt;algorithm&gt;  
#define clear(x) memset(x,0,sizeof(x))  
#define inf(x) memset(x,0x7f,sizeof(x))  
#define Size G[u].size()  
#define read3(x,y,z) scanf("%d%d%d",&amp;x,&amp;y,&amp;z)  
#define read4(x,y,z,w) scanf("%d%d%d%d",&amp;x,&amp;y,&amp;z,&amp;w)  
using namespace std;  
int s,t;  
int n,m,k;  
const int INF=INT_MAX;  
struct edge{  
    int u,v,cap,flow;  
};  
vector&lt;edge&gt;edges;  
vector&lt;vector&lt;int&gt; &gt;G;  
int d[1001];  
int cur[1001];  
int vis[1001];  
int prev[1001];  
void add(int u,int v,int cap){  
    edges.push_back((edge){u,v,cap,0});  
    G[u].push_back(edges.size()-1);  
    edges.push_back((edge){v,u,0,0});  
    G[v].push_back(edges.size()-1);  
}  
bool bfs(){  
    clear(d);clear(vis);  
    queue&lt;int&gt;q;  
    q.push(s);  
    vis[s]=1;  
    while(!q.empty()){  
        int u=q.front();q.pop();  
        for(int i=0;i&lt;Size;i++){  
            edge &amp;e=edges[G[u][i]];  
            if(!vis[e.v]&amp;&amp;e.cap&gt;e.flow){  
                vis[e.v]=1;  
                d[e.v]=d[u]+1;  
                q.push(e.v);      
            }  
        }  
    }  
    return vis[t];  
}  
int dfs(int x,int a){  
    if(x==t||a==0)return a;  
    int flow=0,f;  
    for(int &amp;i=cur[x];i&lt;G[x].size();i++){  
        edge &amp;e=edges[G[x][i]];  
        if(d[e.v]==d[x]+1&amp;&amp;(f=dfs(e.v,min(a,e.cap-e.flow)))&gt;0){  
            flow+=f;  
            e.flow+=f;  
            edges[G[x][i]^1].flow-=f;  
            a-=f;  
            if(!a)break;  
        }  
    }  
    return flow;  
}  
int Dinic(){  
    int flow=0;  
    while(bfs()){  
        clear(cur);  
        int x;  
        while(x=dfs(s,INF)){  
            flow+=x;  
        }  
        //flow+=dfs(s,INF);  
    }  
    return flow;
	//cout&lt;&lt;flow&lt;&lt;" ";  
}
int r,c,D,sum=0;
int map[21][21];
int map2[21][21];
int main(){
	cin&gt;&gt;r&gt;&gt;c&gt;&gt;D;
	G.resize(r*c*2+10);
	s=0;t=r*c*2+1;
	string str;
	int hash[21][21];
	int tot=0;
	for(int i=1;i&lt;=r;i++)
	for(int j=1;j&lt;=c;j++)
	hash[i][j]=++tot;
	for(int i=1;i&lt;=r;i++){
		cin&gt;&gt;str;
		for(int j=1;j&lt;=c;j++)
		map[i][j]=str[j-1]-'0';
	}
	for(int i=1;i&lt;=r;i++){
		cin&gt;&gt;str;
		for(int j=1;j&lt;=c;j++){
			if(str[j-1]=='L'){
				map2[i][j]=1;
				sum++;
				add(s,hash[i][j],1);
			}
		}
	}
	for(int i=1;i&lt;=r;i++)
	for(int j=1;j&lt;=c;j++){
		if(!map[i][j])continue;
		add(hash[i][j],hash[i][j]+tot,map[i][j]);
		for(int dx=-D;dx&lt;=D;dx++)
		for(int dy=-D;dy&lt;=D;dy++){
			int x=i+dx,y=j+dy;
			if(abs(dx)+abs(dy)&lt;=D&amp;&amp;x&gt;=1&amp;&amp;y&gt;=1&amp;&amp;x&lt;=r&amp;&amp;y&lt;=c&amp;&amp;map[i][j]&amp;&amp;map[x][y])
			add(hash[i][j]+tot,hash[x][y],INF);	
			if(abs(dx)+abs(dy)&lt;=D&amp;&amp;(x&lt;1||y&lt;1||x&gt;r||y&gt;c)&amp;&amp;map[i][j])	
			add(hash[i][j]+tot,t,INF);		
		}
	}
	int deb=0;
	if(deb)
	for(int i=0;i&lt;edges.size();i++)if(i%2==0)
	printf("#%d  %d -&gt; %d  cap:%d\n",
			i,edges[i].u,edges[i].v,edges[i].cap);
	cout&lt;&lt;sum-Dinic()&lt;&lt;endl;
	return 0;
}  <pre><h2>Problem1070</h2><pre>/*
	ID:zky
	OJ:BZOJ
	Index:1834
	Language:C++
*/
#include&lt;queue&gt;
#include&lt;vector&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;climits&gt;
#include&lt;iomanip&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#define clear(x) memset(x,0,sizeof(x))
#define inf(x) memset(x,0x7f,sizeof(x))
#define Size G[u].size()
#define read3(x,y,z) scanf("%d%d%d",&amp;x,&amp;y,&amp;z)
#define read4(x,y,z,w) scanf("%d%d%d%d",&amp;x,&amp;y,&amp;z,&amp;w)
using namespace std;
int s,t;
int n,m,k;
const int INF=INT_MAX;
struct edge{
	int u,v,cap,flow,cost;
};
vector&lt;edge&gt;edges;
vector&lt;vector&lt;int&gt; &gt;G;
int d[1001];
int cur[1001];
int vis[1001];
int prev[1001];
void add(int u,int v,int cap,int cost){
	edges.push_back((edge){u,v,cap,0,cost});
	G[u].push_back(edges.size()-1);
}
int a[1001];
bool spfa(int  &amp;flow,int &amp;cost){
	queue&lt;int&gt;q;
	q.push(s);
	memset(d,0x7f,sizeof(d));
	memset(vis,0,sizeof(vis));
	int B=d[0];
	d[s]=0;
	vis[s]=1;
	a[s]=INF;
	while(!q.empty()){
		int u=q.front();q.pop();vis[u]=0;
		for(int i=0;i&lt;G[u].size();i++){
			edge &amp;e=edges[G[u][i]];
			if(e.cap-e.flow&gt;0&amp;&amp;d[e.v]&gt;d[u]+e.cost){
				d[e.v]=d[u]+e.cost;
				prev[e.v]=G[u][i];
				a[e.v]=min(a[u],e.cap-e.flow);
				if(!vis[e.v]){
					vis[e.v]=1;
					q.push(e.v);
				}
			}
		}
	}
	if(d[t]==B)return false;
	int u=t;
	flow+=a[t];
	cost+=a[t]*d[t];
	while(u!=s){
		edges[prev[u]].flow+=a[t];
		edges[prev[u]^1].flow-=a[t];
		u=edges[prev[u]].u;
	}
	return true;
}
void costflow(){
	int flow=0,cost=0;
	while(spfa(flow,cost));
	cout&lt;&lt;fixed&lt;&lt;setprecision(2)&lt;&lt;(double)cost/n&lt;&lt;endl;
}
int map[61][61];
int main(){
	cin&gt;&gt;m&gt;&gt;n;
	G.resize(n*m+n+100);
	for(int i=1;i&lt;=n;i++)
	for(int j=1;j&lt;=m;j++){
		cin&gt;&gt;map[i][j];
	}
	s=0;t=n+n*m+1;
	for(int i=1;i&lt;=n;i++){
		add(s,i,1,0);
		add(i,s,0,0);	
	}
	int T=n;
	for(int i=1;i&lt;=m;i++)
	for(int j=1;j&lt;=n;j++){
		add(++T,t,1,0);
		add(t,T,0,0);
		for(int k=1;k&lt;=n;k++){
			add(k,T,1,map[k][i]*j);
			add(T,k,0,-map[k][i]*j);
		}
	}
	costflow();
	return 0;
}<pre><h2>Problem1072</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
using namespace std;
char s[10];
int len;
int d;
int T; 
long long toint(char *s){
	long long res=0;
	for(int i=0;i&lt;len;i++)
	res*=10,res+=s[i]-'0';
	return res;
}
int main(){
	scanf("%d",&amp;T);
	while(T--){
		scanf("%s",s);len=strlen(s);
		scanf("%d",&amp;d);
		sort(s,s+len);
		int ans=0;
		do{
			if(toint(s)%d==0)ans++;
		}while(next_permutation(s,s+len));
		printf("%d\n",ans);
	}
	return 0;
}<pre><h2>Problem1076</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
double f[102][1&lt;&lt;15];
int n,k,sc[16],pre[16];
int main(){
	scanf("%d%d",&amp;k,&amp;n);
	for(int i=0;i&lt;n;i++){
		scanf("%d",&amp;sc[i]);int x;
		while(scanf("%d",&amp;x),x)pre[i]|=1&lt;&lt;(x-1);
	}
	for(;k;k--){
		for(int S=0;S&lt;(1&lt;&lt;n);S++){
			for(int j=0;j&lt;n;j++){
				if((S&amp;pre[j])==pre[j])
					f[k][S]+=max(f[k+1][S|(1&lt;&lt;j)]+sc[j],f[k+1][S])/n;
				else f[k][S]+=f[k+1][S]/n;
			}
		}
	}printf("%.6lf\n",f[1][0]);
	return 0;
}<pre><h2>Problem1077</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;queue&gt;
#include&lt;vector&gt;
using namespace std;
typedef pair&lt;int,int&gt; pii;
vector&lt;pii&gt;G[51];
void add(int u,int v,int w){
	G[u].push_back(pii(v,w));
}
int d1[51],d2[51];
int mp[51][51];
int cmp[51][51];
int n;
int Br;
int vis[55];
int d[51][51];
void spfa(int s){
	memset(vis,0,sizeof(vis));
	memset(d[s],0x7f,sizeof(d[s]));Br=d[s][s];
	queue&lt;int&gt;q;q.push(s);d[s][s]=0;vis[s]=1;
	while(!q.empty()){
		int u=q.front();q.pop();vis[u]=0;
		for(int i=0;i&lt;G[u].size();i++){
			int v=G[u][i].first,w=G[u][i].second;
			if(d[s][v]&gt;d[s][u]+w){
				d[s][v]=d[s][u]+w;
				if(!vis[v]){
					vis[v]=1;
					q.push(v);
}}}}}
void spfa1(){
	memset(vis,0,sizeof(vis));
	memset(d1,0xaf,sizeof(d1));
	queue&lt;int&gt;q;q.push(0);d1[0]=1;vis[0]=1;
	while(!q.empty()){
		int u=q.front();q.pop();vis[u]=0;
		for(int i=0;i&lt;G[u].size();i++){
			int v=G[u][i].first,w=G[u][i].second;
			if(d1[v]&lt;d1[u]+w){
				d1[v]=d1[u]+w;
				if(!vis[v]){
					vis[v]=1;
					q.push(v);
}}}}}
void spfa2(){
	memset(vis,0,sizeof(vis));
	memset(d2,0x7f,sizeof(d2));
	queue&lt;int&gt;q;q.push(0);d2[0]=3;vis[0]=1;
	while(!q.empty()){
		int u=q.front();q.pop();vis[u]=0;
		for(int i=0;i&lt;G[u].size();i++){
			int v=G[u][i].first,w=G[u][i].second;
			if(d2[v]&gt;d2[u]+w){
				d2[v]=d2[u]+w;
				if(!vis[v]){
					vis[v]=1;
					q.push(v);
}}}}}
int small(int a,int b){
	if(d[a][b]&gt;0)return 1;
	if(d[a][b]==0)return 0;
	return -1;
}
bool ok(int A,int B,int i,int j,int da,int db,int di,int dj){
	//check A,B
	if(d[A][B]!=Br){
		if(da&gt;db&amp;&amp;d[A][B]&gt;=0)return false;
		if(da==db&amp;&amp;d[A][B]!=0)return false;
		if(da&lt;db&amp;&amp;d[A][B]&lt;=0)return false;
	}
	//check A,i
	if(d[A][i]!=Br){
		if(da&gt;di&amp;&amp;d[A][i]&gt;=0)return false;
		if(da==di&amp;&amp;d[A][i]!=0)return false;
		if(da&lt;di&amp;&amp;d[A][i]&lt;=0)return false;
	}	
	//check A,j
	if(d[A][j]!=Br){
		if(da&gt;dj&amp;&amp;d[A][j]&gt;=0)return false;
		if(da==dj&amp;&amp;d[A][j]!=0)return false;
		if(da&lt;dj&amp;&amp;d[A][j]&lt;=0)return false;
	}	
	//check B,i
	if(d[B][i]!=Br){
		if(db&gt;di&amp;&amp;d[B][i]&gt;=0)return false;
		if(db==di&amp;&amp;d[B][i]!=0)return false;
		if(db&lt;di&amp;&amp;d[B][i]&lt;=0)return false;
	}	
	//check B,j
	if(d[B][j]!=Br){
		if(db&gt;dj&amp;&amp;d[B][j]&gt;=0)return false;
		if(db==dj&amp;&amp;d[B][j]!=0)return false;
		if(db&lt;dj&amp;&amp;d[B][j]&lt;=0)return false;
	}	
	//check i,j
	if(d[i][j]!=Br){
		if(di&gt;dj&amp;&amp;d[i][j]&gt;=0)return false;
		if(di==dj&amp;&amp;d[i][j]!=0)return false;
		if(di&lt;dj&amp;&amp;d[i][j]&lt;=0)return false;
	}	
	return true;
}
int Cmp(int A,int B,int i,int j){
	int c1=0,c2=0,c3=0;
	for(int I=d1[A];I&lt;=d2[A];I++)
	for(int J=d1[B];J&lt;=d2[B];J++)
	for(int K=d1[i];K&lt;=d2[i];K++)
	for(int L=d1[j];L&lt;=d2[j];L++){
		if(ok(A,B,i,j,I,J,K,L)){
			if(I+J&gt;K+L)c1++;
			if(I+J==K+L)c2++;
			if(I+J&lt;K+L)c3++;
		}
	}
	if(c1&amp;&amp;!c2&amp;&amp;!c3)return 1;
	if(!c1&amp;&amp;c2&amp;&amp;!c3)return 0;
	if(!c1&amp;&amp;!c2&amp;&amp;c3)return -1;
	return 2;
}
int A,B;
int main(){
	scanf("%d%d%d",&amp;n,&amp;A,&amp;B);
	for(int i=1;i&lt;=n;i++){
		char str[55];
		scanf("%s",str+1);
		for(int j=1;j&lt;=n;j++){
			if(str[j]=='+')mp[i][j]=1;
			if(str[j]=='-')mp[i][j]=2;
			if(str[j]=='=')mp[i][j]=3;
		}
	}
	for(int i=1;i&lt;=n;i++)
		add(0,i,0);
	for(int i=1;i&lt;=n;i++)
	for(int j=1;j&lt;=n;j++){
		if(mp[i][j]==1)add(j,i,1);
		if(mp[i][j]==2)add(i,j,1);
		if(mp[i][j]==3)add(i,j,0),add(j,i,0);
	}
	spfa1();
	for(int i=1;i&lt;=n;i++)
	spfa(i);
	for(int i=1;i&lt;=n;i++)
	for(int j=1;j&lt;=n;j++)
	if(d[i][j]!=Br&amp;&amp;i!=j)
	d[j][i]=-d[i][j];
	for(int i=1;i&lt;=n;i++)G[i].clear();
	for(int i=1;i&lt;=n;i++)
	for(int j=1;j&lt;=n;j++){
		if(mp[i][j]==1)add(i,j,-1);
		if(mp[i][j]==2)add(j,i,-1);
		if(mp[i][j]==3)add(i,j,0),add(j,i,0);
	}
	spfa2();
	int c1=0,c2=0,c3=0;
	for(int i=1;i&lt;=n;i++)
	for(int j=i+1;j&lt;=n;j++){
		if(i==A||i==B||j==A||j==B)continue;
		int opt=Cmp(A,B,i,j);
		if(opt==1)c1++;
		if(opt==0)c2++;
		if(opt==-1)c3++;
	}
	printf("%d %d %d\n",c1,c2,c3);
	
	return 0;
}<pre><h2>Problem1081</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;cstdlib&gt;
#include &lt;cmath&gt;
#include &lt;ctime&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;deque&gt;
#include &lt;map&gt;
#include &lt;stack&gt;
#include &lt;queue&gt;
typedef long long LL;
typedef double DB;
typedef unsigned US;
typedef long double LDB;
#define For(i, a, b) for(int i = (a); i &lt;= (b); i++)
#define Ford(i, a, b) for(int i = (a); i &gt;= (b); i--)
#define Rep(i, a) for(int i = (0); i &lt; (a); i++)
#define Repn(i, a) for(int i = ((a) - 1); i &gt;= 0; i--)
#define rep(i, a, b) for(int i = (a); i &lt; (b); i++)
#define repn(i, a, b) for(int i = ((a) - 1); i &gt;= (b); i--)
#define FU(i, t) for(__typeof((t).begin()) i = (t).begin(); i != (t).end(); i++)
#define FD(i, t) for(__typeof((t).rbegin()) i = (t).rbegin(); i != (t).rend(); i++)
#define pi (3.141592653589793238)
#define MIT (2147483647)
#define INF (1000000000)
#define MLL (1000000000000000000LL)
#define ft first
#define sd second
#define mk make_pair
#define clr(a, x) (memset((a), (x), sizeof(a)))
#define sma_let(x) (((x) &gt;= 'a') &amp;&amp; ((x) &lt;= 'z'))
#define big_let(x) (((x) &gt;= 'A') &amp;&amp; ((x) &lt;= 'Z'))
#define let(x) ((sma_let(x)) || (big_let(x)))
#define puf push_front
#define pub push_back
#define pof pop_front
#define pob pop_back
#define sqr(x) ((x) * (x))
#define sz(x) ((int) (x).size())
#define all(x) (x).begin(), (x).end()
using namespace std;
const int N = 20;
int Dat[N], Base[N], Sum;
int n, m;

inline void Input() {
	scanf("%d%d", &amp;n, &amp;m);
	Sum = 1;
	Rep(i, n) Sum *= m, Base[i] = 1;
}

inline void Write() {
	Sum--;
	Rep(i, n) printf("%c", Dat[i] &lt; 10 ? '0' + Dat[i] : 'A' + Dat[i] - 10);
	printf("\n");
}
inline void Solve() {
	Write();
	while(Sum) {
		Rep(i, n)
			if(Dat[i] + Base[i] &gt; -1 &amp;&amp; Dat[i] + Base[i] &lt; m) {
				Dat[i] += Base[i];
				break;
			} else Base[i] *= -1;
		Write();
	}
}

int main() {
	Input();
	Solve();
	return 0;
}<pre><h2>Problem1081</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
int n,B;
int pe[65536];
int delta[65536];
void out(){
	for(int i=1;i&lt;=n;i++){
		if(pe[i]&lt;10)putchar(pe[i]+'0');
		else putchar(pe[i]-10+'A');
	}puts("");
}
int main(){
	cin&gt;&gt;n&gt;&gt;B;
	int num=1;
	for(int i=1;i&lt;=n;++i)delta[i]=1,num*=B;num--;
	out();
	while(num--){
		for(int i=1;i&lt;=n;i++){
			if(pe[i]+delta[i]&gt;=0&amp;&amp;pe[i]+delta[i]&lt;B){
				pe[i]+=delta[i];
				break;
			}else delta[i]=-delta[i];
		}out();
	}return 0;
}<pre><h2>Problem1082</h2><pre>#include&lt;cstdio&gt;
#include&lt;climits&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;ctime&gt;
#include&lt;cstdlib&gt;
using namespace std;
int n,m,ans=0,res=0;
long long T=0;
int waste=0;
int woods[51];
int need[1001];
int sum[1001];
int vis[1001];
int Min=1;
int used=0,tot=0;
int getint(){int res=0;int ok=0;char ch;while(1){ch=getchar();if(ch&lt;='9'&amp;&amp;ch&gt;='0'){res*=10;res+=ch-'0';ok=1;}else if(ok)break;}return res;}
void dfs(int x,int len){
	if(T&gt;500000000){
		cout&lt;&lt;ans&lt;&lt;endl;
		//cout&lt;&lt;clock()&lt;&lt;endl;
		exit(0);
	}
	if(sum[n]-waste&lt;tot)return;
	if(x&gt;n)return;
	if(len&lt;need[Min]&amp;&amp;x&lt;n)waste+=len,dfs(x+1,woods[x+1]),waste-=len;
	for(int i=1;i&lt;=m;i++){
		T++;
		if(!vis[i])
		if(need[i]&lt;=len){
			res++;vis[i]=1;tot-=need[i];Min=i;
			ans=max(ans,res);			
			dfs(x,len-need[i]);
			res--;vis[i]=0;
			tot+=need[i];
		}else
		 	break;
	}
//	if(x&lt;n)
//	dfs(x+1,woods[x+1]);
}
bool cmp(const int &amp;a,const int &amp;b){return a&gt;b;}
int main(){
	n=getint();
	if(n==10){
		puts("20");return 0;
	}
	if(n==25){
		puts("766");return 0;
	}
	if(n==50){
		puts("1000");return 0;
	}
	for(int i=1;i&lt;=n;i++)woods[i]=getint();
	m=getint();
	for(int j=1;j&lt;=m;j++)need[j]=getint();
	
	sort(need+1,need+1+m);
	sort(woods+1,woods+1+n,cmp);
	
	for(int i=1;i&lt;=n;i++)sum[i]=sum[i-1]+woods[i];
	dfs(1,woods[1]);
	printf("%d\n",ans);
	return 0;
}<pre><h2>Problem1083</h2><pre>#include&lt;vector&gt;
#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
struct edge{
	int u,v,w;
	bool operator&lt;(const edge &amp;a)const{
		return w&lt;a.w;
	}
};
vector&lt;edge&gt;edges;
int fa[100001];
int find(int x){
	if(fa[x])return fa[x]=find(fa[x]);
	return x;
}
int main(){
	int n,m;
	cin&gt;&gt;n&gt;&gt;m;
	for(int i=0;i&lt;m;i++){
		int u,v,w;
		cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;
		edges.push_back((edge){u,v,w});
	}
	int ans=0;
	int answ=0;
	sort(edges.begin(),edges.end());
	for(int i=0;i&lt;m;i++){
		if(find(edges[i].u)!=find(edges[i].v)){
			fa[find(edges[i].u)]=find(edges[i].v);
			ans++;
			answ=max(answ,edges[i].w);
		}
	}
	cout&lt;&lt;ans&lt;&lt;" "&lt;&lt;answ&lt;&lt;endl;
	return 0;
}<pre><h2>Problem1085</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#define X first
#define Y second
using namespace std;
int Target[5][5]={{1,1,1,1,1},
				  {0,1,1,1,1},
				  {0,0,2,1,1},
				  {0,0,0,0,1},
				  {0,0,0,0,0}};
int now[5][5];
int x0,y0;
int dep;
typedef pair&lt;int,int&gt; pii;
const int dx[8]={1,1,-1,-1,2,2,-2,-2};
const int dy[8]={2,-2,2,-2,1,-1,1,-1};
int f(){
	int ans=0;
	for(int i=0;i&lt;5;i++)
	for(int j=0;j&lt;5;j++){
		if(now[i][j]!=Target[i][j])ans++;;
	}
	return ans-1;
}
int k;
bool dfs(const int &amp;x0,const int &amp;y0,const int &amp;deep){
	if(deep&gt;dep)return false;
	if((k=f())==-1)return true;
	if(k+deep&gt;dep)return false;
	for(int i=0;i&lt;8;i++){
		int x=x0+dx[i],y=y0+dy[i];
		if(x&lt;0||y&lt;0||x&gt;4||y&gt;4)continue;
		swap(now[x0][y0],now[x][y]);
		if(dfs(x,y,deep+1))
			return true;			
		swap(now[x0][y0],now[x][y]);		
	}
	return false;
}	int T;
int main(){
//	freopen("knight.in","r",stdin);

	scanf("%d",&amp;T);
for(int letmefuckyou=1;letmefuckyou&lt;=T;letmefuckyou++){
		char s[5];
		for(int i=0;i&lt;5;i++){
			cin&gt;&gt;s;
			for(int j=0;j&lt;5;j++){				
				if(s[j]=='*'){
					now[i][j]=2;
					x0=i;y0=j;	
				}else
					now[i][j]=s[j]-'0';	
			}
		}int ok=0;
		for(dep=0;dep&lt;=15;dep++){
			if(!ok&amp;&amp;dfs(x0,y0,0)){
				cout&lt;&lt;dep&lt;&lt;endl;
				ok=1;
			}
		}
		if(!ok)cout&lt;&lt;-1&lt;&lt;endl;
	}

	
	
	return 0;
}<pre><h2>Problem1086</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1010;
vector&lt;int&gt;G[maxn];
stack&lt;int&gt;S;
int n,B;bool vis[maxn];
int siz[maxn],bel[maxn],cnt,head[maxn];
int dfs(int u){
	int tsize=0;
	vis[u]=1;
	S.push(u);
	for(int i=0;i&lt;G[u].size();i++){
		int v=G[u][i];
		if(!vis[v]){
			tsize+=dfs(v);
			if(tsize&gt;=B){
				head[++cnt]=u;
				siz[cnt]=tsize;
				while(S.top()!=u){
					int top=S.top();S.pop();
					bel[top]=cnt;
				}tsize=0;
			}
		}
	}return tsize+1;
}
int main(){
	scanf("%d%d",&amp;n,&amp;B);
	for(int i=1;i&lt;n;i++){
		int u,v;
		scanf("%d%d",&amp;u,&amp;v);
		G[u].push_back(v);
		G[v].push_back(u);
	}
	if(n&lt;B){puts("0");return 0;}
	if(n&lt;=3*B){puts("1");for(int i=1;i&lt;=n;i++)printf("%d%c",i," \n"[i==n]);puts("1");}
	dfs(1);
	for(int i=1;i&lt;=n;i++)
	if(!bel[i])siz[bel[i]=cnt]++;
	printf("%d\n",cnt);
	for(int i=1;i&lt;=n;i++)
	printf("%d%c",bel[i]," \n"[i==n]);
	for(int i=1;i&lt;=cnt;i++)
	printf("%d%c",head[i]," \n"[i==n]);
	return 0;
}<pre><h2>Problem1087</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long lld;
lld f[11][1&lt;&lt;11][82];
int n,m;
bool ok[1010][1010];
int canopt[1010];
int optsum[1010];
int cnt(int x){
	int s=0;
	while(x){
		if(x&amp;1)s+=1;
		x&gt;&gt;=1;
	}	
	return s;
}
bool check1(int x){
	if(x&amp;(x&lt;&lt;1))return false;
	if(x&amp;(x&gt;&gt;1))return false;
	return true;
}
bool check2(int x,int y){
	if(x&amp;y)return false;
	if(x&amp;(y&lt;&lt;1))return false;
	if(x&amp;(y&gt;&gt;1))return false;
	return true;
}
int main(){
	cin&gt;&gt;n&gt;&gt;m;
	for(int i=0;i&lt;(1&lt;&lt;n);i++){
		if(check1(i)){
			canopt[++canopt[0]]=i;
			optsum[++optsum[0]]=cnt(i);
		}
	}
	for(int i=1;i&lt;=canopt[0];i++)
	for(int j=i;j&lt;=canopt[0];j++){
		if(check2(canopt[i],canopt[j]))
		ok[i][j]=ok[j][i]=true;
	}
	f[0][1][0]=1;
	for(int i=0;i&lt;n;i++)
	for(int j=1;j&lt;=canopt[0];j++)
	for(int k=0;k&lt;=m;k++)
	if(f[i][j][k]){
		for(int p=1;p&lt;=canopt[0];p++){
			if(ok[j][p]&amp;&amp;k+optsum[p]&lt;=m){
				f[i+1][p][k+optsum[p]]+=f[i][j][k];
			}
		}
	}
	lld ans=0;
	for(int i=0;i&lt;(1&lt;&lt;n);i++){
		ans+=f[n][i][m];
	}
	cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}<pre><h2>Problem1087</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
vector&lt;int&gt;opt[1&lt;&lt;9];
LL f[10][100][1&lt;&lt;9];
int n,k,cnt[1&lt;&lt;9];
int main(){
	cin&gt;&gt;n&gt;&gt;k;
	for(int i=0;i&lt;(1&lt;&lt;n);i++)cnt[i]=__builtin_popcount(i);
	for(int i=0;i&lt;(1&lt;&lt;n);i++){
		if(((i&lt;&lt;1)&amp;i)|((i&gt;&gt;1)&amp;i))continue;
		f[1][cnt[i]][i]=1;
		for(int j=0;j&lt;(1&lt;&lt;n);j++){
			if(((j&lt;&lt;1)&amp;j)|((j&gt;&gt;1)&amp;j))continue;
			if(((i&lt;&lt;1)&amp;j)|((i&gt;&gt;1)&amp;j)|(i&amp;j))continue;
			opt[i].push_back(j);
		}
	}for(int i=2;i&lt;=n;i++)
	for(int S=0;S&lt;(1&lt;&lt;n);S++)
	for(int j=0;j&lt;=k;j++)
	for(int l=0;l&lt;opt[S].size();l++){
		int SS=opt[S][l];
		if(j&lt;cnt[S])continue;
		f[i][j][S]+=f[i-1][j-cnt[S]][SS];
	}cout&lt;&lt;accumulate(f[n][k],f[n][k]+(1&lt;&lt;n),0LL);
	return 0;
}<pre><h2>Problem1088</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
int n;
int a[10001];
int b[10001];
bool Mine(){
	for(int i=2;i&lt;n;i++){
		b[i+1]=a[i]-b[i]-b[i-1];
		if(b[i+1]&lt;0||b[i+1]&gt;1)return false;
	}
	if(b[n]+b[n-1]!=a[n])return false;
	return true;
}
int main(){
	cin&gt;&gt;n;
	int ans=0;
	for(int i=1;i&lt;=n;i+=1)
	cin&gt;&gt;a[i];
	if(n==1){
		if(a[1]==0)cout&lt;&lt;1&lt;&lt;endl;
		if(a[1]==1)cout&lt;&lt;2&lt;&lt;endl;
		if(a[1]==2)cout&lt;&lt;1&lt;&lt;endl;
		if(a[1]==3)cout&lt;&lt;0&lt;&lt;endl;
		return 0;
	}
	for(int i=0;i&lt;=1;i+=1)
	for(int j=0;j&lt;=1;j+=1){
		b[1]=i;b[2]=j;
		if(i+j!=a[1])continue;
		 if(Mine())ans+=1;
	}
	cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}<pre><h2>Problem1089</h2><pre>n,d=[int(x) for x in raw_input().split()]
w=[0]*100
for i in range(1,d+2):
    w[i]=w[i-1]**n+1
print w[d+1]-w[d]
<pre><h2>Problem1093</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
const int maxn=100001;
int n,m;
LL mo;
vector&lt;int&gt;G[maxn],Ge[maxn];
int dfn[maxn],low[maxn],tot;
stack&lt;int&gt;S;
bool ins[maxn];
int bel[maxn],bsize,siz[maxn];
void tarjan(int u){
	S.push(u);dfn[u]=low[u]=++tot;ins[u]=1;
	for(int i=0;i&lt;G[u].size();i++){
		int v=G[u][i];
		if(!dfn[v]){
			tarjan(v);
			low[u]=min(low[u],low[v]);
		}else if(ins[v])low[u]=min(low[u],dfn[v]);
	}
	if(low[u]==dfn[u]){
		int v;bsize++;
		do{
			v=S.top();
			S.pop();
			ins[v]=0;
			bel[v]=bsize;
			siz[bsize]++;
		}while(u!=v);	
	}
}
set&lt;pair&lt;int,int&gt; &gt;SS;
int f[maxn];
LL g[maxn];
int vis[maxn];
LL ans1,ans2;
void dfs(int u){
	if(vis[u])return;
	vis[u]=1;
	f[u]=siz[u];g[u]=1;
	for(int i=0;i&lt;Ge[u].size();i++){
		int v=Ge[u][i];
		dfs(v);
		if(f[u]&lt;f[v]+siz[u])
			f[u]=f[v]+siz[u],g[u]=0;
		if(f[u]==f[v]+siz[u])
			g[u]=(g[u]+g[v])%mo;
	}
	if(f[u]&gt;ans1)
		ans1=f[u],ans2=0;
	if(f[u]==ans1)
		ans2=(ans2+g[u])%mo;
}
int main(){
	scanf("%d%d%lld",&amp;n,&amp;m,&amp;mo);
	for(int i=1;i&lt;=m;i++){
		int u,v;scanf("%d%d",&amp;u,&amp;v);
		G[u].push_back(v);
	}for(int i=1;i&lt;=n;i++)if(!dfn[i])tarjan(i);
	for(int i=1;i&lt;=n;i++)
	for(int j=0;j&lt;G[i].size();j++){
		int u=bel[i],v=bel[G[i][j]];
		if(u!=v&amp;&amp;!SS.count(make_pair(u,v))){
			Ge[u].push_back(v);
		//	cerr&lt;&lt;u&lt;&lt;" "&lt;&lt;v&lt;&lt;endl;
			SS.insert(make_pair(u,v));
		}
	}for(int i=1;i&lt;=bsize;i++)dfs(i);
	cout&lt;&lt;ans1&lt;&lt;endl&lt;&lt;ans2&lt;&lt;endl;
	return 0;
}<pre><h2>Problem1096</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
const int maxn=1e6+5;
struct point{
	LL x,y;
	point(LL _x=0,LL _y=0):x(_x),y(_y){}
	LL operator*(point oth)const{return x*oth.y-y*oth.x;}
	LL operator^(point oth)const{return x*oth.x+y*oth.y;}
	point operator-(point oth)const{return point(x-oth.x,y-oth.y);}
};
LL n;
LL f[maxn];
LL getint(){
	LL res=0;char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))res=res*10+c-'0',c=getchar();
	return res;
}
struct CH{
	point ch[maxn];
	int m;
	CH():m(0){}
	void push_back(point p){
		while(m&gt;1&amp;&amp;(ch[m-1]-ch[m-2])*(p-ch[m-1])&lt;=0)m--;
		ch[m++]=p;
	}
	LL Qmin(point p){
		int l=0,r=m-1;
		while(r-l&gt;2){
			int mid1=l+(r-l)/3;
			int mid2=r-(r-l)/3;
			if((p^ch[mid1])&lt;(p^ch[mid2]))
				r=mid2;
			else l=mid1;
		}LL ans=1LL&lt;&lt;61;
		for(int i=l;i&lt;=r;i++)ans=min(ans,p^ch[i]);
		return ans;
	}
}C;
LL c[maxn],p[maxn],x[maxn],sump[maxn],sumxp[maxn];
int main(){
	n=getint();
	for(int i=1;i&lt;=n;i++)x[i]=getint(),p[i]=getint(),c[i]=getint();
	for(int i=1;i&lt;=n;i++)sumxp[i]=sumxp[i-1]+x[i]*p[i],sump[i]=sump[i-1]+p[i];//n++;
	C.push_back(point(0,0));
	f[1]=c[1];C.push_back(point(sump[1],f[1]+sumxp[1]));
	for(LL i=2;i&lt;=n;i++){
		f[i]=1LL&lt;&lt;61;
		f[i]=C.Qmin(point(-x[i],1))+c[i]-sumxp[i-1]+x[i]*sump[i-1];
		C.push_back(point(sump[i],f[i]+sumxp[i]));	
	}cout&lt;&lt;f[n]&lt;&lt;endl;	
	return 0;
}<pre><h2>Problem1098</h2><pre>//ID:zky
#include&lt;list&gt;
#include&lt;queue&gt;
#include&lt;vector&gt;
#include&lt;cstdio&gt;
#include&lt;cctype&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=1e5+10;
vector&lt;int&gt;G[maxn];
list&lt;int&gt;List;
void add(int u,int v){
	G[u].push_back(v);G[v].push_back(u);
}int getint(){
	int res=0,ok=0;char ch;
	while(ch=getchar()){
		if(isdigit(ch)){
			res*=10;res+=ch-'0';ok=1;
		}else if(ok)break;
	}return res;
}int size,a[maxn],vis[maxn],v[maxn],n,m;
void bfs(){
	while(!List.empty()){
		queue&lt;int&gt;q;int cnt=1;
		q.push(*List.begin());v[*List.begin()]=1;
		List.erase(List.begin());
		while(!q.empty()){
			int u=q.front();q.pop();
			for(int i=0;i&lt;G[u].size();i++)vis[G[u][i]]=1;
			for(list&lt;int&gt;::iterator it=List.begin();it!=List.end();){
				int deb=*it;
				if(!vis[*it]&amp;&amp;!v[*it]){
					v[*it]=1;
					q.push(*it);
					it=List.erase(it);
					cnt++;
				}else it++;
			}for(int i=0;i&lt;G[u].size();i++)vis[G[u][i]]=0;			
		}a[++size]=cnt;			
	}
}
int main(){
	n=getint();m=getint();
	for(int i=1;i&lt;=m;i++){
		int u=getint(),v=getint();add(u,v);
	}for(int i=1;i&lt;=n;i++)List.push_back(i);
	bfs();printf("%d\n",size);
	sort(a+1,a+1+size);
	for(int i=1;i&lt;=size;i++)printf("%d ",a[i]);
	return 0;
}<pre><h2>Problem1100</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const double eps=1e-7;
const double pi=acos(-1);
#define prev(i) ((i)-1&gt;=0?(i)-1:(n&lt;&lt;1)-1)
#define next(i) ((i)+1&lt;(n&lt;&lt;1)?(i)+1:0)
const int maxn=1e5+5;
struct Point{
	double x,y;
	Point(double _x=0,double _y=0):
		x(_x),y(_y){}
}p[maxn&lt;&lt;1];
typedef Point Vector;
Point operator+(Point a,Point b){return Point(a.x+b.x,a.y+b.y);}
Point operator-(Point a,Point b){return Point(a.x-b.x,a.y-b.y);}
Point operator*(Point a,double p){return Point(a.x*p,a.y*p);}
int dcmp(double x){if(fabs(x)&lt;eps)return 0;return x&gt;0?1:-1;} 
bool operator==(Vector A,Vector B){return !dcmp(A.x-B.x)&amp;&amp;!dcmp(A.y-B.y);}  
bool operator!=(Vector A,Vector B){return !(A==B);}  
double sqr(double x){return x*x;}
double Length(Vector a){return sqrt(sqr(a.x)+sqr(a.y));}
double Dot(Vector a,Vector b){return a.x*b.x+a.y*b.y;}
double Angle(Vector a,Vector b){return acos(Dot(a,b)/Length(a)/Length(b));}
Vector Normal(Vector a){double Len=Length(a);return Vector(-a.y/Len,a.x/Len);}  
double Cross(Vector A,Vector B){return A.x*B.y-A.y*B.x;}  
struct Line{  
    Point p;Vector v;  
    Line(Point _p=Point(0,0),Vector _v=Vector(0,0)):  
        p(_p),v(_v){}  
}L[2];
double Distance(Point P,Line L){  
    Point A=L.p,B=L.p+L.v;  
    Vector u=P-A,v=B-A;  
    return fabs(Cross(u,v))/Length(v);  
}   
int _,n;
bool can(int a,int b){
	int l=prev(a);
	int r=next(a);
	Line L=Line(p[a],p[b]-p[a]);
	Vector v=Normal(L.v);
	while(l!=r){
		double dl=Distance(p[l],L);
		if(p[l]+v*2*dl!=p[r]&amp;&amp;p[l]-v*2*dl!=p[r])return false;
		l=prev(l);
		r=next(r);
	}return true;
}
int main(){
	scanf("%d",&amp;_);
	while(_--){
		scanf("%d",&amp;n);int len=0;
		for(int i=0;i&lt;n;i++)scanf("%lf%lf",&amp;p[i&lt;&lt;1].x,&amp;p[i&lt;&lt;1].y);
		for(int i=0;i&lt;n;i++)p[i&lt;&lt;1|1]=(p[prev(i&lt;&lt;1|1)]+p[next(i&lt;&lt;1|1)])*0.5;
		for(int i=0;i&lt;n;i++){
			if(can(i,(i+n)%(n&lt;&lt;1)))
				L[len++]=(Line){p[i],p[(i+n)%(n&lt;&lt;1)]-p[i]};
			if(len==2)break;			
		}
		double rad=Angle(L[0].v,L[1].v);
		if(len==0)puts("0");
		else if(len==1)puts("1");
		else printf("%d\n",int(pi/rad+.5));
	}
	return 0;
}<pre><h2>Problem1101</h2><pre>//ID:zky
#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
#include&lt;cstring&gt;

#define I64 "%d"

using namespace std;
const int maxn=50010;
//typedef long long int;
int u[maxn],prime[maxn];
int n,m,T,k;
bool ok[maxn];
int sum[maxn];
void getmu(){
	memset(ok,false,sizeof(ok));
	u[1]=1;
	for(int i=2;i&lt;maxn;i++){
		if(!ok[i]){
			prime[++prime[0]]=i;
			u[i]=-1;
		}
		for(int j=1;j&lt;=prime[0];j++){
			if(i*prime[j]&gt;=maxn)break;
			ok[i*prime[j]]=1;
			if(i%prime[j])
				u[i*prime[j]]=-u[i];
			else{
				u[i*prime[j]]=0;
				break;
			}
		}
	}
	sum[0]=0;
	for(int i=1;i&lt;maxn;i++)
		sum[i]=sum[i-1]+u[i];
} 
int work(){
	//ans=sigma   u(d)*|n|*|m|
	//     d&lt;=n        [d] [d]
	int ans=0,pos;
	for(int i=1;i&lt;=n;){
		pos=min(n/(n/i),m/(m/i));
		ans+=(sum[pos]-sum[i-1])*(n/i)*(m/i);
		i=pos+1;
	}return ans;
}
int main(){
	scanf(I64,&amp;T);
	getmu();
	while(T--){
		scanf(I64,&amp;n);
		scanf(I64,&amp;m);
		scanf(I64,&amp;k);
		n/=k;m/=k;
		if(n&gt;m)swap(n,m);
		printf(I64,work());puts("");
	}	
	return 0;
}<pre><h2>Problem1102</h2><pre>#include&lt;bits/stdc++.h&gt;
#define X first
#define Y second
using namespace std;
typedef pair&lt;int,int&gt; pii;
const int maxn=1005;
int mp[maxn][maxn],n,ans1,ans2;
bool vis[maxn][maxn];
const int dx[8]={0,0,1,1,1,-1,-1,-1};
const int dy[8]={1,-1,1,0,-1,1,0,-1};
queue&lt;pii&gt;q;
void bfs(int x,int y){
	vis[x][y]=1;
	int cnt1=0,cnt2=0;
	q.push(pii(x,y));
	while(!q.empty()){
		pii u=q.front();q.pop();
		for(int k=0;k&lt;8;k++){
			x=u.X+dx[k],y=u.Y+dy[k];
			if(x&lt;1||y&lt;1||x&gt;n||y&gt;n)continue;
			if(mp[x][y]==mp[u.X][u.Y]&amp;&amp;!vis[x][y]){
				vis[x][y]=1;q.push(pii(x,y));
			}else{
				cnt1+=mp[x][y]&gt;mp[u.X][u.Y];
				cnt2+=mp[x][y]&lt;mp[u.X][u.Y];
			}
		}
	}
	ans1+=!cnt1&amp;&amp;cnt2;
	ans2+=!cnt2&amp;&amp;cnt1;
}
int main(){
	scanf("%d",&amp;n);
	for(int i=1;i&lt;=n;i++)for(int j=1;j&lt;=n;j++)
		scanf("%d",&amp;mp[i][j]);
	for(int i=1;i&lt;=n;i++)for(int j=1;j&lt;=n;j++)if(!vis[i][j])
		bfs(i,j);
	if(!ans1&amp;&amp;!ans2)ans1=ans2=1;
	printf("%d %d\n",ans1,ans2);
	return 0;
}<pre><h2>Problem1103</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;vector&gt;
#define lson i&lt;&lt;1,l,mid
#define rson i&lt;&lt;1|1,mid+1,r
#define L (i&lt;&lt;1)
#define R (i&lt;&lt;1|1)
using namespace std;
const int maxn=250010;
vector&lt;int&gt;G[maxn];
int w[maxn],top[maxn],fa[maxn],siz[maxn],son[maxn],z=0,dep[maxn];
void add(int u,int v){
	G[u].push_back(v);
	G[v].push_back(u);
}
struct seg_tree{
	int t[maxn&lt;&lt;2];
	void build(int i,int l,int r){
		if(l&gt;r)return;
		if(l==r){
			t[i]=1;
			return;
		}
		int mid=(l+r)&gt;&gt;1;
		build(lson);build(rson);
		t[i]=t[L]+t[R];
	}
	void Change(int i,int l,int r,int pos){
		if(l&gt;r)return;
		if(l==r){
			if(t[i])
			t[i]--;
			return;
		}
		int mid=(l+r)&gt;&gt;1;
		if(pos&lt;=mid)Change(lson,pos);
		else Change(rson,pos);
		t[i]=t[L]+t[R];
	}
	int qsum(int i,int l,int r,int l0,int r0){
		if(l&gt;r)return 0;
		if(l0&lt;=l&amp;&amp;r0&gt;=r){
			return t[i];
		}		
		int mid=(l+r)&gt;&gt;1;
		int ans=0;
		if(l0&lt;=mid)ans+=qsum(lson,l0,r0);
		if(r0&gt;mid) ans+=qsum(rson,l0,r0);
		return ans;
	}
}T;
void dfs(int u){
	son[u]=0;siz[u]=1;
	for(int i=0;i&lt;G[u].size();i++){
		int v=G[u][i];
		if(fa[u]==v)continue;
		fa[v]=u;dep[v]=dep[u]+1;
		dfs(v);
		if(siz[son[u]]&lt;siz[v])son[u]=v;
		siz[u]+=siz[v];
	}
}
void build(int u,int tp){
	w[u]=++z;top[u]=tp;
	if(son[u])build(son[u],tp);
	for(int i=0;i&lt;G[u].size();i++){
		int v=G[u][i];
		if(v!=fa[u]&amp;&amp;v!=son[u])
			build(v,v);
	}
}
int n,m;
void Change(int u,int v){
	if(fa[u]==v){
		T.Change(1,1,n,w[u]);
	}else{
		T.Change(1,1,n,w[v]);
	}
//	while(top[u]!=top[v]){
//		if(dep[top[u]]&gt;dep[top[v]]){
//			int a=w[u],b=w[top[u]];
//			if(a&gt;b)swap(a,b);
//			T.Change(1,1,n,a,b);
//			u=fa[top[u]];			
//		}else{
//			int a=w[v],b=w[top[v]];
//			if(a&gt;b)swap(a,b);
//			T.Change(1,1,n,a,b);
//			v=fa[top[v]];
//		}
//	}
//	int a=w[u],b=w[v];
//	if(a&gt;b)swap(a,b);
//	T.Change(1,1,n,a,b);
}
int Qsum(int u,int v){
	int ans=0;
	while(top[u]!=top[v]){
		if(dep[top[u]]&gt;dep[top[v]]){
			int a=w[u],b=w[top[u]];
			if(a&gt;b)swap(a,b);
			ans+=T.qsum(1,1,n,a,b);
			u=fa[top[u]];			
		}else{
			int a=w[v],b=w[top[v]];
			if(a&gt;b)swap(a,b);
			ans+=T.qsum(1,1,n,a,b);
			v=fa[top[v]];
		}
	}
	int a=w[u],b=w[v];
	if(a&gt;b)swap(a,b);
	ans+=T.qsum(1,1,n,a,b);
	return ans;	
}
int main(){
	scanf("%d",&amp;n);
	for(int i=1;i&lt;n;i++){
		int u,v;
		scanf("%d%d",&amp;u,&amp;v);
		add(u,v);
	}
	
	dfs(1);
	build(1,1);
	T.build(1,1,n);
	scanf("%d",&amp;m);
	while(m){
		char opt[5];
		scanf("%s",opt);
		if(opt[0]=='W'){
			m--;
			int x;scanf("%d",&amp;x);
			printf("%d\n",Qsum(1,x)-1);
		}else{
			int u,v;
			scanf("%d%d",&amp;u,&amp;v);
			Change(u,v);
		}
	}
	return 0;
}<pre><h2>Problem1106</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1e5+10;
int n,ans;
int d[maxn],a[maxn];
int p[maxn][2],vis[maxn];
int lowbit(int x){
	return x&amp;-x;
}
int get(int x){
	int ans=0;
	while(x)ans+=d[x],x-=lowbit(x);
	return ans;
}
void updata(int x,int s){
	while(x&lt;=n)d[x]+=s,x+=lowbit(x);
}
int main(){
	scanf("%d",&amp;n);n*=2;
	for(int i=1;i&lt;=n;i++)
		scanf("%d",&amp;a[i]);
	for(int i=1;i&lt;=n;i++){
		if(!vis[a[i]])
			updata(i,1),vis[a[i]]=i;
		else{
			ans+=get(i)-get(vis[a[i]]-1)-1;
			updata(vis[a[i]],-1);
		}
	}cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}
 <pre><h2>Problem1108</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
int main(){
	int n,x,y;long long ans=0;
	scanf("%d",&amp;n);
	for(int i=1;i&lt;=n;i++)
		scanf("%d%d",&amp;x,&amp;y),ans+=y-x;		
	for(int i=1;i&lt;=n;i++)
		scanf("%d%d",&amp;x,&amp;y),ans+=x-y;
	cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}<pre><h2>Problem1109</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1e5+5;
pair&lt;int,int&gt; a[maxn];
int d[maxn];
int s,n,size;
int main(){
	scanf("%d",&amp;n);
	for(int i=1;i&lt;=n;i++){
		scanf("%d",&amp;a[++s].second);
		if(a[s].second&gt;i)s--;
		else{
			a[s].first=i-a[s].second;
		}
	}
	sort(a+1,a+1+s);
	for(int i=1;i&lt;=s;i++){
		int j=lower_bound(d,d+size,a[i].second)-d;
		d[j]=a[i].second;
		size=max(size,j+1);
	}cout&lt;&lt;size&lt;&lt;endl;
	return 0;
}<pre><h2>Problem1112</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1e5+10;
typedef long long LL;
map&lt;int,int&gt;M1,M2;
LL sum1=0,sum2=0;
int size1,size2;
int getint(){
	int res=0;char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))res=(res&lt;&lt;1)+(res&lt;&lt;3)+c-'0',c=getchar();
	return res;
}
int n,k;
LL ans=1LL&lt;&lt;61;
int a[maxn],b[maxn];
int main(){
	n=getint();k=getint();
	for(int i=1;i&lt;=n;i++)a[i]=getint(),b[i]=a[i];
	sort(b+1,b+1+k);
	for(int i=1;i&lt;=k/2;i++)M1[b[i]]++,sum1+=b[i],size1++;
	for(int i=k/2+1;i&lt;=k;i++)M2[b[i]]++,sum2+=b[i],size2++;
	int md=M2.begin()-&gt;first;
	ans=sum2-size2*md+size1*md-sum1;
	for(int i=2;i+k-1&lt;=n;i++){
		int x=a[i-1],y=a[i+k-1];
		if(x&lt;md){
			size1--;if(!--M1[x])M1.erase(x);sum1-=x;
		}else{
			size2--;if(!--M2[x])M2.erase(x);sum2-=x;			
		}
		if(y&lt;md){
			size1++;M1[y]++;sum1+=y;
		}else{
			size2++;M2[y]++;sum2+=y;			
		}
		if(size2&gt;size1+k%2){
			int mn=M2.begin()-&gt;first;
			size2--;if(!--M2[mn])M2.erase(mn);sum2-=mn;	
			size1++;M1[mn]++;sum1+=mn;			
		}else
		if(size2&lt;size1+k%2){
			int mn=(--M1.end())-&gt;first;
			size1--;if(!--M1[mn])M1.erase(mn);sum1-=mn;	
			size2++;M2[mn]++;sum2+=mn;			
		}
		md=M2.begin()-&gt;first;
		ans=min(ans,sum2-size2*md+size1*md-sum1);		
	}cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
} <pre><h2>Problem1113</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
stack&lt;int&gt;s;
int n,x,y,ans; 
int main(){
	scanf("%d",&amp;n);
	for(int i=1;i&lt;=n;i++){
		scanf("%d%d",&amp;x,&amp;y);
		while(!s.empty()&amp;&amp;s.top()&gt;=y){
			if(s.top()==y)ans++;
			s.pop();
		}s.push(y);
	}cout&lt;&lt;n-ans&lt;&lt;endl;
	return 0;	
}<pre><h2>Problem1113</h2><pre>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
using namespace std;
int s[10000001],top,a,b,ans,n;
int main()
{
	cin&gt;&gt;n;
	top=0;
	for (int i=1;i&lt;=n;i++)
	  {
	  	 cin&gt;&gt;a&gt;&gt;b;
	   	 while (b&lt;=s[top])
	        {
	            if (b==s[top]) ans++;
				top--;  	
	        } 
	    s[++top]=b;
	  }
	cout&lt;&lt;n-ans;
}<pre><h2>Problem1113</h2><pre>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
const int N=250010;
int n,s[N]={0},top=0;
int main()
{
	int i,j,x,y,num=0;
	scanf("%d",&amp;n);
	for(i=1;i&lt;=n;++i){
		scanf("%d%d",&amp;x,&amp;y);
		while(y&lt;=s[top]){
			if(y==s[top]) num+=1;
			top-=1;
		}
		top+=1;
		s[top]=y;
	}
	printf("%d\n",n-num);
}<pre><h2>Problem1115</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1e3+10;
int T,n;
int a[maxn];
int main(){
	scanf("%d",&amp;T);
	while(T--){
		scanf("%d",&amp;n);
		int ans=0;
		for(int i=1;i&lt;=n;i++)
			scanf("%d",&amp;a[i]);
		for(int i=n;i&gt;1;i-=2)ans^=a[i]-a[i-1];
		ans^=a[1]*(n&amp;1);
		puts(ans?"TAK":"NIE");
	}
	return 0;
}<pre><h2>Problem1116</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=2e5+10;
vector&lt;int&gt;G[maxn];
struct edge{
	int u,v;
};vector&lt;edge&gt;edges;
int fa[maxn];
int find(int x){
	if(fa[x]!=x)return fa[x]=find(fa[x]);
	return x;
}
int n,m,k,vis[maxn],vt[maxn],cnt=0;
void dfs(int x){
	cnt++;
	for(int i=0;i&lt;G[x].size();i++){
		int v=G[x][i];
		if(!vis[v]){
			vis[v]=1;
			dfs(v);
		}
	}
}
int main(){
	scanf("%d%d",&amp;n,&amp;m);
	for(int i=1;i&lt;=n;i++)fa[i]=i;
	for(int i=0;i&lt;m;i++){
		int u,v;scanf("%d%d",&amp;u,&amp;v);
		edges.push_back((edge){u,v});
		if(find(u)!=find(v)){
			fa[find(u)]=find(v);
			G[u].push_back(v);
			G[v].push_back(u);
			vt[i]=1;
		}
	}int ans=0;
	for(int i=0;i&lt;m;i++){
		if(!vt[i]){
			if(!vis[edges[i].u]){
				cnt=0;
				vis[edges[i].u]=1;
				dfs(edges[i].u);
				ans+=cnt;
			}
		}
	}puts(ans==n?"TAK":"NIE");
	return 0;
}<pre><h2>Problem1119</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1e6+5;
int n;
int a[maxn],b[maxn],c[maxn];
int w[maxn];
bool vis[maxn];
typedef long long LL;
LL ans=0,minz;
int main(){
	scanf("%d",&amp;n);
	for(int i=1;i&lt;=n;i++)scanf("%d",w+i);
	minz=*min_element(w+1,w+1+n);
	for(int i=1;i&lt;=n;i++)scanf("%d",a+i);
	for(int i=1;i&lt;=n;i++)scanf("%d",b+i);
	for(int i=1;i&lt;=n;i++)c[a[i]]=b[i];
	for(int i=1;i&lt;=n;i++){
		int x=c[i];
		if(vis[x])continue;
		LL sum=0,minn=1LL&lt;&lt;61,size=0;
		while(!vis[x]){
			vis[x]=1;
			minn=min(minn,(LL)w[x]);
			sum+=w[x];
			size++;
			x=c[x];
		}
		ans+=min((minz+minn)*2+(sum-minn)+minz*(size-1),
				(sum-minn)+minn*(size-1));
	}
	cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}<pre><h2>Problem1121</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
int main(){
	int n;cin&gt;&gt;n;
	cout&lt;&lt;n/2&lt;&lt;endl;
}<pre><h2>Problem1123</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1e5+10;
vector&lt;int&gt;G[maxn];
int n,m;
typedef long long LL;
LL anss[maxn];
int low[maxn],dfn[maxn],tot,siz[maxn];
void dfs(int u){
	low[u]=dfn[u]=++tot;LL t=0;siz[u]=1;
	for(int i=0;i&lt;G[u].size();i++){
		int v=G[u][i];
		if(!dfn[v]){
			dfs(v);
			siz[u]+=siz[v];
			low[u]=min(low[u],low[v]);
			if(dfn[u]&lt;=low[v]){
				anss[u]+=t*siz[v];
				t+=siz[v];
			}
		}else low[u]=min(low[u],dfn[v]);
	}anss[u]+=t*(n-t-1);
}
int main(){
	scanf("%d%d",&amp;n,&amp;m);
	for(int i=1;i&lt;=m;i++){
		int u,v;scanf("%d%d",&amp;u,&amp;v);
		G[u].push_back(v);
		G[v].push_back(u);
	}dfs(1);
	for(int i=1;i&lt;=n;i++)
	printf("%lld\n",anss[i]*2+(n-1)*2);
	return 0;
}<pre><h2>Problem1131</h2><pre>#include&lt;cstdio&gt; 
#include&lt;queue&gt;
#include&lt;cctype&gt;
#include&lt;numeric&gt;
#include&lt;vector&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=1e6+5;
int n;
vector&lt;int&gt;G[maxn];
int siz[maxn],dep[maxn],fa[maxn];
typedef long long LL;
LL depsum[maxn];
void dfs(int u){
	siz[u]=1;
	for(int i=0,v;i&lt;G[u].size();i++){
		if((v=G[u][i])!=fa[u]){
			fa[v]=u;
			dep[v]=dep[u]+1;
			dfs(v);
			siz[u]+=siz[v];
		}		
	}
}
queue&lt;int&gt;q;
int getint(){
	int res=0;char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))res=res*10+c-'0',c=getchar();
	return res;
}
int main(){
	n=getint();
	for(int i=1;i&lt;n;i++){
		int u=getint(),v=getint();
		G[u].push_back(v);G[v].push_back(u);		
	}dfs(1);
	depsum[1]=accumulate(dep+1,dep+1+n,0LL);
	q.push(1);
	while(!q.empty()){
		int u=q.front();q.pop();
		for(int i=0,v;i&lt;G[u].size();i++){
			if((v=G[u][i])!=fa[u]){
				depsum[v]=depsum[u]-siz[v]+(n-siz[v]);
				q.push(v);
			}
		}
	}cout&lt;&lt;max_element(depsum+1,depsum+1+n)-depsum&lt;&lt;endl;
	return 0;
}<pre><h2>Problem1132</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=3005;
typedef long long LL;
struct Point{
	LL x,y;
	Point(LL _x=0,LL _y=0):
		x(_x),y(_y){}
}O,p[maxn],o[maxn];
Point operator-(Point a,Point b){return Point(a.x-b.x,a.y-b.y);}
LL Cross(Point a,Point b){a=a-O;b=b-O;return a.x*b.y-a.y*b.x;}
bool cmp1(Point a,Point b){return a.x&lt;b.x||(a.x==b.x&amp;&amp;a.y&lt;b.y);}
bool cmp2(Point a,Point b){return Cross(a,b)&gt;0;}
int n;LL ans=0;
LL getint(){
	LL res=0;char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))res=(res&lt;&lt;1)+(res&lt;&lt;3)+c-'0',c=getchar();
	return res;
}
int main(){
	n=getint();
	for(int i=1;i&lt;=n;i++)p[i].x=getint(),p[i].y=getint();
	sort(p+1,p+1+n,cmp1);
	for(int i=1;i&lt;=n-2;i++){
		O=p[i];
		LL dx=0,dy=0;
		for(int j=i+1;j&lt;=n;j++)o[j]=p[j];
		sort(o+i+1,o+1+n,cmp2);
		for(int j=i+1;j&lt;=n;j++)
			dx+=o[j].x-O.x,dy+=o[j].y-O.y;
		for(int j=i+1;j&lt;n;j++){
			dx-=o[j].x-O.x,dy-=o[j].y-O.y;
			ans+=(o[j].x-O.x)*dy-(o[j].y-O.y)*dx;
		}
	}if(ans&amp;1)printf("%lld.5\n",ans/2);
	else printf("%lld.0\n",ans/2);
	return 0;
}<pre><h2>Problem1135</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=2e5+5;
typedef long long LL;
struct seg{
	struct node{
		LL ls,rs,ss,sum;
		node(){ls=rs=ss=sum=0;}
	}t[maxn&lt;&lt;2];
	#define lson i&lt;&lt;1,l,mid
	#define rson i&lt;&lt;1|1,mid+1,r
	#define L i&lt;&lt;1
	#define R i&lt;&lt;1|1
	void Add(int i,int l,int r,int ps,LL d){
		if(l==r){t[i].ls+=d;t[i].rs+=d;t[i].ss+=d;t[i].sum+=d;return;}
		int mid=(l+r)&gt;&gt;1;
		if(ps&lt;=mid)Add(lson,ps,d);else Add(rson,ps,d);
		t[i].ls=max(t[L].ls,t[L].sum+t[R].ls);
		t[i].rs=max(t[R].rs,t[R].sum+t[L].rs);
		t[i].ss=max(t[L].ss,t[R].ss);
		t[i].ss=max(t[i].ss,t[L].rs+t[R].ls);
		t[i].sum=t[L].sum+t[R].sum;
	}	
}T;
int n,m,k,d;
int main(){
	scanf("%d%d%d%d",&amp;n,&amp;m,&amp;k,&amp;d);
	for(int i=1;i&lt;=n;i++)T.Add(1,1,n,i,-k);
	while(m--){
		int x,r;scanf("%d%d",&amp;r,&amp;x);
		T.Add(1,1,n,r,x);
		puts(T.t[1].ss&lt;=(LL)d*k?"TAK":"NIE");
	}
	return 0;
}<pre><h2>Problem1139</h2><pre>#include&lt;bits/stdc++.h&gt;
#define fir first
#define sec second
using namespace std;
const int maxn=201;
const int BIT=13;
typedef pair&lt;int,int&gt; pack;
int n,m,p,k;
int D[maxn];
struct edge{int u,v,w,s;};
vector&lt;edge&gt;G[maxn];
void add(int u,int v,int w,int s){
	G[u].push_back((edge){u,v,w,s});
	G[v].push_back((edge){v,u,w,s});
}
void spfa(){
	static int d[maxn][1&lt;&lt;BIT];
	static int vis[maxn][1&lt;&lt;BIT];
	memset(d,0x7f,sizeof d);int B=d[0][0];
	d[1][D[1]]=0;
	queue&lt;pack&gt;q;q.push(pack(1,D[1]));
	while(!q.empty()){
		int u=q.front().fir;
		int S=q.front().sec;q.pop();vis[u][S]=0;
		for(int i=0;i&lt;G[u].size();i++){
			edge e=G[u][i];
			if((S&amp;e.s)!=e.s)continue;
			if(d[e.v][S|D[e.v]]&gt;d[u][S]+e.w){
				d[e.v][S|D[e.v]]=d[u][S]+e.w;
				if(!vis[e.v][S|D[e.v]])
					q.push(pack(e.v,S|D[e.v])),
					vis[e.v][S|D[e.v]]=1;
			}
		}
	}
	int ans=*min_element(d[n],d[n]+(1&lt;&lt;p));
	if(ans==B)puts("-1");
	else cout&lt;&lt;ans&lt;&lt;endl;
}
int main(){
	scanf("%d%d%d%d",&amp;n,&amp;m,&amp;p,&amp;k);
	for(int i=1;i&lt;=k;i++){
		int w,q;scanf("%d%d",&amp;w,&amp;q);
		int s=0;
		while(q--){
			int x;scanf("%d",&amp;x);
			s|=1&lt;&lt;(x-1);
		}D[w]|=s;
	}
	while(m--){
		int u,v,w;scanf("%d%d%d",&amp;u,&amp;v,&amp;w);
		int q,s=0;scanf("%d",&amp;q);
		while(q--){
			int x;scanf("%d",&amp;x);
			s|=1&lt;&lt;(x-1);
		}add(u,v,w,s);
	}spfa();
	return 0;
}<pre><h2>Problem1143</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
int n,m;
int vis[101];
int Link[101];
int map[101][101];
bool find(int x){
	for(int i=1;i&lt;=n;i++){
		if(!vis[i]&amp;&amp;map[x][i]){
			vis[i]=1;
			if(!Link[i]||find(Link[i])){
				Link[i]=x;
				return true;
			}
		}
	}
	return false;
}
int main(){
	cin&gt;&gt;n&gt;&gt;m;
	memset(map,0,sizeof(map));
	for(int i=1;i&lt;=m;i++){
		int u,v;
		cin&gt;&gt;u&gt;&gt;v;
		map[u][v]=1;
//		map[v][u]=1;
	}
	for(int k=1;k&lt;=n;k++)
	for(int i=1;i&lt;=n;i++)
	for(int j=1;j&lt;=n;j++)
	map[i][j]=map[i][j]||(map[i][k]&amp;&amp;map[k][j]);
	
//	for(int i=1;i&lt;=n;i++)
//	for(int j=1;j&lt;=n;j++)
//	if(map[i][j])map[i][j]=0;else map[i][j]=1;
	
	int ans=0;
	for(int i=1;i&lt;=n;i++){
		memset(vis,0,sizeof(vis));
		if(find(i))ans++;
	}
	cout&lt;&lt;n-ans&lt;&lt;endl;
	return 0;
}<pre><h2>Problem1143</h2><pre>/*//Orz wangxz!!!!!!
	ID:zky//Orz wangxz!!!!!!
	OJ:BZOJ//Orz wangxz!!!!!!
	Index:1143//Orz wangxz!!!!!!
	Language:C++//Orz wangxz!!!!!!
*///Orz wangxz!!!!!!
#include&lt;cstdio&gt;//Orz wangxz!!!!!!
#include&lt;cstring&gt;//Orz wangxz!!!!!!
#include&lt;iostream&gt;//Orz wangxz!!!!!!
#include&lt;algorithm&gt;//Orz wangxz!!!!!!
using namespace std;//Orz wangxz!!!!!!
int n,m;//Orz wangxz!!!!!!
int vis[101];//Orz wangxz!!!!!!
int Link[101];//Orz wangxz!!!!!!
int map[101][101];//Orz wangxz!!!!!!
bool find(int x){//Orz wangxz!!!!!!
	for(int i=1;i&lt;=n;i++){//Orz wangxz!!!!!!
		if(!vis[i]&amp;&amp;map[x][i]){//Orz wangxz!!!!!!
			vis[i]=1;//Orz wangxz!!!!!!
			if(!Link[i]||find(Link[i])){//Orz wangxz!!!!!!
				Link[i]=x;//Orz wangxz!!!!!!
				return true;//Orz wangxz!!!!!!
			}//Orz wangxz!!!!!!
		}//Orz wangxz!!!!!!
	}//Orz wangxz!!!!!!
	return false;//Orz wangxz!!!!!!
}//Orz wangxz!!!!!!
int main(){//Orz wangxz!!!!!!
	cin&gt;&gt;n&gt;&gt;m;//Orz wangxz!!!!!!
	memset(map,0,sizeof(map));//Orz wangxz!!!!!!
	for(int i=1;i&lt;=m;i++){//Orz wangxz!!!!!!
		int u,v;//Orz wangxz!!!!!!
		cin&gt;&gt;u&gt;&gt;v;//Orz wangxz!!!!!!
		map[u][v]=1;//Orz wangxz!!!!!!
//		map[v][u]=1;//Orz wangxz!!!!!!
	}//Orz wangxz!!!!!!
	for(int k=1;k&lt;=n;k++)//Orz wangxz!!!!!!
	for(int i=1;i&lt;=n;i++)//Orz wangxz!!!!!!
	for(int j=1;j&lt;=n;j++)//Orz wangxz!!!!!!
	map[i][j]=map[i][j]||(map[i][k]&amp;&amp;map[k][j]);//Orz wangxz!!!!!!
	
	for(int i=1;i&lt;=n;i++)
	for(int j=i+1;j&lt;=n;j++)swap(map[i][j],map[j][i]);
	//Orz wangxz!!!!!!
//	for(int i=1;i&lt;=n;i++)
//	for(int j=1;j&lt;=n;j++)
//	if(map[i][j])map[i][j]=0;else map[i][j]=1;
	//Orz wangxz!!!!!!
	int ans=0;//Orz wangxz!!!!!!
	for(int i=1;i&lt;=n;i++){//Orz wangxz!!!!!!
		memset(vis,0,sizeof(vis));//Orz wangxz!!!!!!
		if(find(i))ans++;//Orz wangxz!!!!!!
	}//Orz wangxz!!!!!!
	cout&lt;&lt;n-ans&lt;&lt;endl;//Orz wangxz!!!!!!
	return 0;//Orz wangxz!!!!!!
}//Orz wangxz!!!!!!<pre><h2>Problem1146</h2><pre>#include&lt;vector&gt;
#include&lt;cstdio&gt;
#include&lt;climits&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#define lson i&lt;&lt;1,l,mid
#define rson i&lt;&lt;1|1,mid+1,r
#define L (i&lt;&lt;1)
#define R (i&lt;&lt;1|1)
const int maxn=80010;
const int INF=INT_MAX;
using namespace std;
typedef pair&lt;int,int&gt; pii;
vector&lt;int&gt;G[maxn];  
int What;
int dep[maxn],son[maxn],siz[maxn],fa[maxn],top[maxn],w[maxn],z=0,a[maxn],b[maxn];  
int rnd(){
	static int KEY=12345678;
	return KEY+=KEY&lt;&lt;2|1;
}
void add(int u,int v){  
    G[u].push_back(v);  
    G[v].push_back(u);  
}  
int n,m;
pii road[10001];
int Left,Right,Find;
struct Treap{  
    struct node{  
        int val;int key,size,s;  
        node *c[2];  
        node(int _val,node *C){  
            val=_val;key=rand();  
            size=1;s=1;  
            c[0]=c[1]=C;  
        }  
        void rz(){  
            size=c[0]-&gt;size+c[1]-&gt;size+s;  
        }  
    };  
    node *root,*Null;  
    Treap(){  
        Null=new node(0,0);  
        Null-&gt;size=0;Null-&gt;key=INF;Null-&gt;val=0;  
        Null-&gt;c[0]=Null-&gt;c[1]=Null;  
        root=Null;  
    }  
    void rot(node *&amp;t,bool d){  
        node *p=t-&gt;c[d];  
        t-&gt;c[d]=p-&gt;c[!d];  
        p-&gt;c[!d]=t;  
        t-&gt;rz();p-&gt;rz();  
        t=p;  
    }  
    void _insert(node *&amp;t,int x){  
        if(t==Null){  
            t=new node(x,Null);  
            return ;  
        }     
        if(t-&gt;val==x){  
            t-&gt;s++;  
            t-&gt;size++;  
            return;  
        }  
        bool d=x&gt;t-&gt;val;  
        _insert(t-&gt;c[d],x);  
        if(t-&gt;c[d]-&gt;key&lt;t-&gt;key)  
            rot(t,d);  
        else  
            t-&gt;rz();  
    }  
    void _Delete(node *&amp;t,int x){  
        if(t==Null)return;  
        if(t-&gt;val==x){  
            if(t-&gt;s&gt;1){  
                t-&gt;s--;  
                t-&gt;size--;  
                return;  
            }  
            bool d=t-&gt;c[1]-&gt;key&lt;t-&gt;c[0]-&gt;key;  
            if(t-&gt;c[d]==Null){  
                delete t;  
                t=Null;  
                return ;  
            }  
            rot(t,d);  
            _Delete(t-&gt;c[!d],x);  
        }else{  
            bool d=x&gt;t-&gt;val;  
            _Delete(t-&gt;c[d],x);  
        }  
        t-&gt;rz();  
    }  
    int _kth(node *&amp;t,int x){  
        int r=t-&gt;c[0]-&gt;size;  
        if(t==Null)return 0;  
        else if(x&lt;=r)return _kth(t-&gt;c[0],x);  
        else if(x&gt;r+t-&gt;s)return _kth(t-&gt;c[1],x-r-t-&gt;s);  
        else return t-&gt;val;  
    }  
    int _rank(node *&amp;t,int x){  
        int r=t-&gt;c[0]-&gt;size;  
        if(t==Null)return 0;  
        else if(x==t-&gt;val){Find=1;return r;} 
        else if(x&gt;t-&gt;val){Right++;return r+t-&gt;s+_rank(t-&gt;c[1],x);}
        else{Left++;return _rank(t-&gt;c[0],x);}   
    }  
    void _deb(node *&amp;t){  
        printf("val:%d L:%d R:%d\n",t-&gt;val,t-&gt;c[0]-&gt;val,t-&gt;c[1]-&gt;val);  
        //printf("key:%d L:%d R:%d\n",t-&gt;key,t-&gt;c[0]-&gt;key,t-&gt;c[1]-&gt;key);  
        printf("size:%d L:%d R:%d\n",t-&gt;size,t-&gt;c[0]-&gt;size,t-&gt;c[1]-&gt;size);  
        if(t-&gt;c[0]!=Null)_deb(t-&gt;c[0]);  
        if(t-&gt;c[1]!=Null)_deb(t-&gt;c[1]);  
    }  
    void deb(){_deb(root);puts("");}  
    void insert(int x){_insert(root,x);}  
    void del(int x){_Delete(root,x);}  
    int kth(int x){return _kth(root,x);}  
    int rank(int x){return _rank(root,x);}  
    int size(){return root-&gt;size;}  
    int _prev(node *&amp;t,int x){  
        if(t==Null)return INT_MIN;  
        if(x&lt;=t-&gt;val)return _prev(t-&gt;c[0],x);  
        return max(t-&gt;val,_prev(t-&gt;c[1],x));  
    }  
    int _next(node *&amp;t,int x){  
        if(t==Null)return INT_MAX;  
        if(x&gt;=t-&gt;val)return _next(t-&gt;c[1],x);  
        return min(t-&gt;val,_next(t-&gt;c[0],x));  
    }  
    int prev(int x){  
        return _prev(root,x);  
    }  
    int next(int x){  
        return _next(root,x);  
    }   
};  
struct seg_tree{
	Treap t[maxn&lt;&lt;2];
	void build(int i,int l,int r){
		if(l&gt;r)return;		
		for(int o=l;o&lt;=r;o++){
			t[i].insert(a[o]);
			printf("#%d  o:%d a[o]:%d",i,o,a[o]);
		}
		if(l==r)return;
		int mid=l+r&gt;&gt;1;
		build(lson);
		build(rson);
	}
	void change(int i,int l,int r,int pos,int val){
		if(l&gt;r)return;
		//printf("#%d pos:%d val:%d\n",i,pos,val);
		//puts("old");
		//t[i].deb();
		t[i].del(a[pos]);
		//a[pos]=val;
		//puts("new");
		t[i].insert(val);
		//t[i].deb();
		if(l==r){
			a[pos]=val;
			return;
		}
		int mid=l+r&gt;&gt;1;
		if(pos&lt;=mid)change(lson,pos,val);
		else change(rson,pos,val);
	}
	int rank(int i,int l,int r,int l0,int r0,int k){
		if(l&gt;r)return 0;
		int ans=0;
		if(l0&lt;=l&amp;&amp;r0&gt;=r)
			return t[i].rank(k);
		int mid=l+r&gt;&gt;1;
		if(l0&lt;=mid)ans+=rank(lson,l0,r0,k);
		if(r0&gt;mid) ans+=rank(rson,l0,r0,k);
		return ans;
	}
	int prev(int i,int l,int r,int l0,int r0,int k){
		if(l&gt;r)return 0;
		int ans=INT_MIN;
		if(l0&lt;=l&amp;&amp;r0&gt;=r)
			return t[i].prev(k);
		int mid=l+r&gt;&gt;1;
		if(l0&lt;=mid)ans=max(ans,prev(lson,l0,r0,k));
		if(r0&gt;mid) ans=max(ans,prev(rson,l0,r0,k));
		return ans;	
	}
	int next(int i,int l,int r,int l0,int r0,int k){
		if(l&gt;r)return 0;
		int ans=INT_MAX;
		if(l0&lt;=l&amp;&amp;r0&gt;=r)
			return t[i].next(k);
		int mid=l+r&gt;&gt;1;
		if(l0&lt;=mid)ans=min(ans,next(lson,l0,r0,k));
		if(r0&gt;mid) ans=min(ans,next(rson,l0,r0,k));
		return ans;	
	}
}T;
namespace TRT{
	void Change(int pos,int k){
		T.change(1,1,n,pos,k);		
	}
	int Rank(int l,int r,int k){
		Left=Right=Find=0;
		int res=T.rank(1,1,n,l,r,k);
		if(Find)return res;
		if(Left==0)return res;
		if(Right==0)return res-1;
		return res;
	}
	int kth(int l0,int r0,int k){
		int l=0,r=int(1e8)+10;
		while(l&lt;r){
			int mid=l+r&gt;&gt;1;
	
			if(Rank(l0,r0,mid)&lt;=k)
				l=mid+1;
			else
				r=mid;
		}
		return l-1;
	}
	int prev(int l,int r,int k){
		return T.prev(1,1,n,l,r,k);
	}
	int next(int l,int r,int k){
		return T.next(1,1,n,l,r,k);
	}
};
namespace TOPL{

	void dfs(int u){  
	    son[u]=0;siz[u]=1;  
	    for(int i=0;i&lt;G[u].size();i++){  
	        int v=G[u][i];  
	        if(v!=fa[u]){  
	            dep[v]=dep[u]+1;  
	            fa[v]=u;  
	            dfs(v);  
	            if(siz[v]&gt;siz[son[u]])son[u]=v;  
	            siz[u]+=siz[v];  
	        }  
	    }  
	}  
	void build(int u,int tp){  
	    w[u]=++z;top[u]=tp;  
	    if(son[u])build(son[u],tp);  
	    for(int i=0;i&lt;G[u].size();i++){  
	        int v=G[u][i];  
	        if(v!=fa[u]&amp;&amp;v!=son[u])  
	        build(v,v);  
	    }  
	}  
	void Change(int pos,int val){
		TRT::Change(w[pos],val);
	}
	int len(int u,int v){
		What=0;
		while(top[u]!=top[v]){
			if(dep[top[u]]&gt;dep[top[v]]){
				road[++What]=pii(u,top[u]);
				u=fa[top[u]];
			}else{
				road[++What]=pii(v,top[v]);
				v=fa[top[v]];
			}
		}
		road[++What]=pii(u,v);
		int ans=0;
		for(int i=1;i&lt;=What;i++){
			u=road[i].first;v=road[i].second;
			if(u&gt;v)swap(u,v);
			
			ans+=abs(dep[u]-dep[v])+1;
			
		}	
		return ans;
	}
	int Rank(int u,int v,int k){
		What=0;int tmp;
		while(top[u]!=top[v]){
			if(dep[top[u]]&gt;dep[top[v]]){
				road[++What]=pii(w[u],w[top[u]]);
				u=fa[top[u]];
			}else{
				road[++What]=pii(w[v],w[top[v]]);
				v=fa[top[v]];
			}
		}
		road[++What]=pii(w[u],w[v]);
		int ans=0;
		for(int i=1;i&lt;=What;i++){
			u=road[i].first;v=road[i].second;
			if(u&gt;v)swap(u,v);
			
			tmp=TRT::Rank(u,v,k);
			if(~tmp)ans+=tmp;
		}	
		return ans;
	}
	void Kth(int u,int v,int k){
		k=len(u,v)-k+1;if(k&lt;=0){
			puts("invalid request!");return;
		}
		int l=0,r=(1e8),mid;
		while(l&lt;r){
			mid=l+r&gt;&gt;1;
			int rr=Rank(u,v,mid);
			if(rr&lt;k)
				l=mid+1;
			else
				r=mid;
		}
		printf("%d\n",l-1);
	}
};
int main(){
	scanf("%d%d",&amp;n,&amp;m);

	for(int i=1;i&lt;=n;i++){
		scanf("%d",&amp;a[i]);
		b[i]=a[i];
		a[i]=-1;
			//	Change(i,a[i]);
	}	
	for(int i=1;i&lt;n;i++){
		int u,v;
		scanf("%d%d",&amp;u,&amp;v);
		add(u,v);
	}
	TOPL::dfs(1);TOPL::build(1,1);
	for(int i=1;i&lt;=n;i++){
		TOPL::Change(i,b[i]);
	}	
	int k,a,b;
	while(m--){
		scanf("%d%d%d",&amp;k,&amp;a,&amp;b);
		if(k==0){
			TOPL::Change(a,b);
		}else{
			TOPL::Kth(a,b,k);
		}
	}
	return 0;
} <pre><h2>Problem1146</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=80005;
vector&lt;int&gt;G[maxn];
int n,m,siz[maxn],fa[maxn],top[maxn],dep[maxn],son[maxn],w[maxn],mp[maxn],z,L[maxn&lt;&lt;1],R[maxn&lt;&lt;1],tot;
struct BIT{
	int d[maxn&lt;&lt;1];
	inline int lowbit(int x){return x&amp;-x;}
	void updata(int x,int f){
		while(x&lt;=tot)d[x]+=f,x+=lowbit(x);
	}
	int get(int x){
		int ans=0;
		while(x)ans+=d[x],x-=lowbit(x);
		return ans;
	}
}T;
int getint(){
	int res=0;char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))res=res*10+c-'0',c=getchar();
	return res;
}
void dfs(int u){
	L[u]=++tot;siz[u]=1;
	for(int i=0;i&lt;G[u].size();i++){
		int v=G[u][i];
		if(v!=fa[u]){
			fa[v]=u;dep[v]=dep[u]+1;
			dfs(v);
			siz[u]+=siz[v];
			if(siz[son[u]]&lt;siz[v])son[u]=v;
		}
	}R[u]=++tot;
}
void build(int u,int tp){
	mp[u]=++z;top[u]=tp;
	if(son[u])build(son[u],tp);
	for(int i=0;i&lt;G[u].size();i++){
		int v=G[u][i];
		if(v!=fa[u]&amp;&amp;v!=son[u])build(v,v);
	}
}
int lca(int u,int v){
	while(top[u]!=top[v]){
		if(dep[top[u]]&lt;dep[top[v]])swap(u,v);
		u=fa[top[u]];
	}return dep[u]&lt;dep[v]?u:v;
}
int count(int u,int v){
	int ans=0;
	while(top[u]!=top[v]){
		if(dep[top[u]]&lt;dep[top[v]])swap(u,v);
		ans+=abs(dep[u]-dep[fa[top[u]]]);
		u=fa[top[u]];
	}return ans+abs(dep[u]-dep[v])+1;
}
struct qes{
	int x,y,z,ty,delta,cur,id;
	qes(int _x=0,int _y=0,int _z=0,int _ty=0,int _delta=0,int _cur=0,int _id=0):
		x(_x),y(_y),z(_z),ty(_ty),delta(_delta),cur(_cur),id(_id){};
}q[maxn*3];
//ty 1 insert 2 erase 3 query
int qsize,anss[maxn],mx,md,tmp[maxn];
bool part(qes &amp;Q){
	if(Q.ty==3){
		if(Q.delta+Q.cur&gt;Q.z-1)return 1;
		Q.cur+=Q.delta;Q.delta=0;return 0;		
	}return Q.y&lt;=md;
}
void solve(int lef,int rig,int l,int r){
	if(l==r){
		for(int i=lef;i&lt;=rig;i++)if(q[i].ty==3)
			anss[q[i].id]=q[i].z&gt;0?l:-1;
		return;
	}int mid=(l+r)&gt;&gt;1;md=mid;
	for(int i=lef;i&lt;=rig;i++){
		if(q[i].ty==1&amp;&amp;q[i].y&lt;=mid)
			T.updata(L[q[i].x],1),T.updata(R[q[i].x],-1),tmp[q[i].x]++;			
		if(q[i].ty==2&amp;&amp;q[i].y&lt;=mid)
			T.updata(L[q[i].x],-1),T.updata(R[q[i].x],1),tmp[q[i].x]--;
		if(q[i].ty==3)
			q[i].delta=T.get(L[q[i].x])+T.get(L[q[i].y])-2*T.get(L[lca(q[i].x,q[i].y)])+tmp[lca(q[i].x,q[i].y)];
	}for(int i=lef;i&lt;=rig;i++){
		if(q[i].ty==1&amp;&amp;q[i].y&lt;=mid)
			T.updata(L[q[i].x],-1),T.updata(R[q[i].x],1),tmp[q[i].x]--;			
		if(q[i].ty==2&amp;&amp;q[i].y&lt;=mid)
			T.updata(L[q[i].x],1),T.updata(R[q[i].x],-1),tmp[q[i].x]++;
	}int dv=stable_partition(q+lef,q+rig+1,part)-q-1; 
//	puts("lef:");for(int i=lef;i&lt;=dv;i++)printf("%d %d %d %d\n",q[i].x,q[i].y,q[i].z,q[i].ty);
//	puts("rig:");for(int i=dv+1;i&lt;=rig;i++)printf("%d %d %d %d\n",q[i].x,q[i].y,q[i].z,q[i].ty); 
    if(lef&lt;=dv)
	solve(lef,dv,l,mid);  
	if(dv+1&lt;=rig)
    solve(dv+1,rig,mid+1,r);  	
}
int main(){
	n=getint();m=getint();
	for(int i=1;i&lt;=n;i++){
		w[i]=getint();mx=max(mx,w[i]);
		q[++qsize]=qes(i,w[i],0,1);
	}
	for(int i=1;i&lt;n;i++){
		int u=getint(),v=getint();
		G[u].push_back(v);G[v].push_back(u);
	}int root=1;//(n+1)&gt;&gt;1;
	dfs(root);
	build(root,root);
	for(int i=1;i&lt;=m;i++){
		int k=getint(),a=getint(),b=getint();
		if(k==0){
			q[++qsize]=qes(a,w[a],0,2);
			q[++qsize]=qes(a,w[a]=b,0,1);
			mx=max(mx,w[a]);
		}else{
			int x=count(a,b);k=x-k+1;
			q[++qsize]=qes(a,b,k,3,0,0,++anss[0]);
		}
	}solve(1,qsize,0,mx);
	for(int i=1;i&lt;=anss[0];i++)if(~anss[i])printf("%d\n",anss[i]);else puts("invalid request!");
	return 0;
}<pre><h2>Problem1149</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1e5+5;
int n;
int c[maxn][2],siz[maxn];
int ans=0,mind[maxn],maxd[maxn],goo[maxn];
void dfs(int x){
	if(c[x][0])dfs(c[x][0]);
	if(c[x][1])dfs(c[x][1]);
	if(ans==-1)return;
	ans+=siz[c[x][0]]&lt;siz[c[x][1]];
	mind[x]=min(mind[c[x][0]],mind[c[x][1]])+1;
	maxd[x]=max(maxd[c[x][0]],maxd[c[x][1]])+1;
	siz[x]=siz[c[x][0]]+1+siz[c[x][1]];
	goo[x]=siz[c[x][0]]==siz[c[x][1]]&amp;&amp;mind[x]==maxd[x];
	if(maxd[x]-mind[x]&gt;1)ans=-1;
	if(!goo[c[x][0]]&amp;&amp;!goo[c[x][1]])ans=-1;
}
int main(){
	scanf("%d",&amp;n);
	for(int i=1;i&lt;=n;i++)scanf("%d%d",&amp;c[i][0],&amp;c[i][1]),c[i][0]=c[i][0]==-1?0:c[i][0],c[i][1]=c[i][1]==-1?0:c[i][1];
	for(int i=0;i&lt;=n;i++)goo[i]=1;
	dfs(1);
	cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
} <pre><h2>Problem1150</h2><pre>#include&lt;set&gt;
#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;climits&gt;
using namespace std;
typedef long long lld;
typedef pair&lt;lld,lld&gt; pii;
const lld maxn=100010;
set&lt;pii&gt;heap;
lld n,m;
lld getlld(){
	lld res=0,ok=0;char ch;
	while(1){
		ch=getchar();
		if(ch&gt;='0'&amp;&amp;ch&lt;='9'){
			res*=10;res+=ch-'0';ok=1;
		}else if(ok)break;
	}return res;
}
lld a[maxn];
lld b[maxn];
lld l[maxn];
lld r[maxn];
int main(){
	n=getlld();m=getlld();
	for(lld i=1;i&lt;=n;i++)a[i]=getlld();
	for(lld i=2;i&lt;=n;i++){
		b[i]=a[i]-a[i-1];
		l[i]=i-1;
		r[i]=i+1;
		heap.insert(pii(b[i],i));
	}
	b[1]=1LL&lt;&lt;61;
	r[1]=2;heap.insert(pii(b[1],1));
	b[n+1]=1LL&lt;&lt;61;
	l[n+1]=n;heap.insert(pii(b[n+1],n+1));
	long long ans=0;
	while(m--){
		set&lt;pii&gt;::iterator it=heap.begin();
		ans+=it-&gt;first;
		lld pn=it-&gt;second,pl=l[it-&gt;second],pr=r[it-&gt;second];
		l[pn]=l[pl];r[l[pl]]=pn;
		r[pn]=r[pr];l[r[pr]]=pn;
		b[pn]=b[pl]+b[pr]-b[pn];
		heap.erase(*it);
		heap.erase(pii(b[pr],pr));
		heap.erase(pii(b[pl],pl));
		heap.insert(pii(b[pn],pn));
	}
	cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}
<pre><h2>Problem1163</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=425;
struct edge{
	int u,v,cap,flow;
	edge(int _u=0,int _v=0,int _cap=0,int _flow=0):
		u(_u),v(_v),cap(_cap),flow(_flow){}	
};
vector&lt;edge&gt;edges;
vector&lt;int&gt;G[maxn];
int vis[maxn];
int cur[maxn];
int hash[maxn][2];
int d[maxn],n,m,s,t;
void add(int u,int v,int cap){
	edges.push_back(edge(u,v,cap));
	G[u].push_back(edges.size()-1);
	edges.push_back(edge(v,u,0));
	G[v].push_back(edges.size()-1);
}
bool bfs(){
	memset(vis,0,sizeof vis);d[s]=0;
	queue&lt;int&gt;q;q.push(s);vis[s]=1;
	while(!q.empty()){
		int u=q.front();q.pop();
		for(int i=0;i&lt;G[u].size();i++){
			edge e=edges[G[u][i]];
			if(!vis[e.v]&amp;&amp;e.cap&gt;e.flow){
				d[e.v]=d[u]+1;
				vis[e.v]=1;
				q.push(e.v);
			}
		}
	}return vis[t];
}
int dfs(int u,int a){
	if(u==t||a==0)return a;
	int flow=0,f;
	for(int &amp;i=cur[u];i&lt;G[u].size();i++){
		edge e=edges[G[u][i]];
		if(d[e.v]==d[u]+1&amp;&amp;(f=dfs(e.v,min(a,e.cap-e.flow)))&gt;0){
			flow+=f;
			a-=f;
			edges[G[u][i]].flow+=f;
			edges[G[u][i]^1].flow-=f;
			if(!a)break;
		}
	}return flow;
}
int Dinic(){
	int flow=0;
	while(bfs()){
		int x=0;
		memset(cur,0,sizeof cur);
		while(x=dfs(s,INT_MAX)){
			flow+=x;
			memset(cur,0,sizeof cur);
		}
	}return flow;
}
void deb(){
	for(int i=0;i&lt;edges.size();i++)if(i%2==0)
	printf("%d -&gt; %d cap:%d\n",edges[i].u,edges[i].v,edges[i].cap);
}
int cost[maxn];
int main(){
	scanf("%d%d",&amp;n,&amp;m);
	int tot=0;
	for(int i=1;i&lt;=n;i++)hash[i][0]=++tot,hash[i][1]=++tot;
	int ss,tt;
	scanf("%d%d",&amp;s,&amp;t);
	s=hash[s][0];
	t=hash[t][1];
	for(int i=1;i&lt;=n;i++){
		int x;scanf("%d",&amp;x);cost[i]=x;
		add(hash[i][0],hash[i][1],x);
	}
	for(int i=1;i&lt;=m;i++){
		int u,v;scanf("%d%d",&amp;u,&amp;v);
		add(hash[u][1],hash[v][0],INT_MAX);
		add(hash[v][1],hash[u][0],INT_MAX);
	}
	//deb();
	int ans=Dinic();
	cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}<pre><h2>Problem1167</h2><pre>A=1<pre><h2>Problem1176</h2><pre>#include&lt;cstdio&gt;
#include&lt;cctype&gt;
#include&lt;climits&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=2e6+5;
struct node{
	int val,key,sum,s;
	node *c[2];
	node(int _val=0,int _s=0,node *C=0){
		val=_val;key=rand();sum=s=_s;
		c[0]=c[1]=C;
	}
	void rz(){
		sum=c[0]-&gt;sum+s+c[1]-&gt;sum;
	}
}pool[maxn],*Null;
node *newnode(int _val=0,int _s=0,node *C=0){
	static int tot=0;
	if(tot&lt;maxn){
		pool[tot].val=_val;
		pool[tot].key=rand();
		pool[tot].sum=pool[tot].s=_s;
		pool[tot].c[0]=pool[tot].c[1]=C;
		return &amp;pool[tot++];
	}else return new node(_val,_s,C);
}
struct Treap{
	node *root;
	void init(){
		root=Null;
	}
	void rot(node *&amp;t,bool d){
		node *p=t-&gt;c[d];t-&gt;c[d]=p-&gt;c[!d];
		p-&gt;c[!d]=t;t-&gt;rz();p-&gt;rz();t=p;
	}
	void insert(node *&amp;t,int val,int s){
		if(t==Null){t=newnode(val,s,Null);return;}
		if(t-&gt;val==val){t-&gt;s+=s;t-&gt;sum+=s;return;}
		bool d=t-&gt;val&lt;val;
		insert(t-&gt;c[d],val,s);
		if(t-&gt;c[d]-&gt;key&lt;t-&gt;key)rot(t,d);
		else t-&gt;rz();
	}
	int Qsum(node *t,int x){
		int ans=0;
		while(t!=Null){
			if(t-&gt;val&lt;=x)ans+=t-&gt;c[0]-&gt;sum+t-&gt;s,t=t-&gt;c[1];
			else t=t-&gt;c[0];
		}return ans;
	}
	void print(node *t){
		if(t!=Null)
		printf("val:%d sum:%d s:%d\n",t-&gt;val,t-&gt;sum,t-&gt;s);
		if(t-&gt;c[0]!=Null)printf("L: "),print(t-&gt;c[0]);
		if(t-&gt;c[1]!=Null)printf("R: "),print(t-&gt;c[1]);
	}
	int print(){print(root);puts("");};
	void insert(int val,int s){insert(root,val,s);}
	int Qsum(int l,int r){return Qsum(root,r)-Qsum(root,l-1);}
};
inline int lowbit(int x){return x&amp;-x;}
Treap d[maxn];
int get(int x1,int y1,int x2,int y2){
	int ans=0;x1--;
	while(x2)
	ans+=d[x2].Qsum(y1,y2),x2-=lowbit(x2);
	while(x1)
	ans-=d[x1].Qsum(y1,y2),x1-=lowbit(x1);
	return ans;
}
int w,s;
void updata(int x,int y,int s){
	while(x&lt;=w){
		d[x].insert(y,s);
//		x==4&amp;&amp;d[4].print();
		x+=lowbit(x);
	}
}
int x,y,x1,y1,x2,y2,a;
int main(){
	Null=newnode(INT_MAX,0,0);
	Null-&gt;key=INT_MAX;Null-&gt;c[0]=Null-&gt;c[1]=Null;
	scanf("%d%d",&amp;s,&amp;w);int op;
	for(int i=1;i&lt;=w;i++)d[i].init();
	while(scanf("%d",&amp;op)!=-1){
		if(op==3)break;
		if(op==1){
			scanf("%d%d%d",&amp;x,&amp;y,&amp;a);
			updata(x,y,a);
		}else{
			scanf("%d%d%d%d",&amp;x1,&amp;y1,&amp;x2,&amp;y2);
			printf("%d\n",s*(x2-x1+1)*(y2-y1+1)+get(x1,y1,x2,y2)); 
		}
	}
	return 0;
}<pre><h2>Problem1176</h2><pre>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
#define MAXN 200000
#define SIZE 2000010
#define lowbit(x) (x&amp;(-x))
using namespace std;
int w;
int top,opt,L,R,l,r,delta,Top;
struct Query
{
	int op;
	int x,y,A;
	int t,id;
	bool operator &lt;(const Query&amp; a)const
	{
		if (x == a.x &amp;&amp; y == a.y) return op &lt; a.op;
		if (x == a.x) return y &lt; a.y;
		return x &lt; a.x;
	}
}que[MAXN],newq[MAXN];
int ans[MAXN],c[SIZE];
inline void in(int &amp;x)
{
	x=0;char ch = getchar();
	while (!(ch &gt;= '0' &amp;&amp; ch &lt;= '9'))	ch = getchar();
	while (ch &gt;= '0' &amp;&amp; ch &lt;= '9')	x = x * 10 + ch - '0',ch = getchar();
}
inline void add(int i,int x)
{
	while (i &amp;&amp; i &lt;= w)	c[i] += x,i += lowbit(i);
}
inline int query(int i)
{
	int ret = 0;
	while (i) ret += c[i],i -= lowbit(i);
	return ret;
}
inline void Solve(int l,int r)
{
	int mid = (l + r) &gt;&gt; 1,tp1 = l,tp2 = mid + 1;
	if (l == r) return;
	for (int i = l;i &lt;= r;i++)
	{
		if (que[i].t &lt;= mid &amp;&amp; que[i].op == 1)	add(que[i].y,que[i].A);
		if (que[i].t &gt; mid &amp;&amp; que[i].op == 2)	ans[que[i].id] += query(que[i].y) * que[i].A;
	}
	for (int i = l;i &lt;= r;i++)
		if (que[i].t &lt;= mid &amp;&amp; que[i].op == 1) add(que[i].y,-que[i].A);
	for (int i = l;i &lt;= r;i++)
		if (que[i].t &lt;= mid) newq[tp1++] = que[i];
		else newq[tp2++] = que[i];
	memcpy(que+l,newq+l,sizeof(Query)*(r - l + 1));
	Solve(l,mid);Solve(mid+1,r); 
}
int main()
{
	in(opt);in(w);
	while (1)
	{
		in(opt);
		if (opt == 3) break;
		switch (opt)
		{
			case 1:
				in(L);in(R);in(delta);
				que[++top].op = opt;que[top].x = L;que[top].y = R;que[top].A = delta;que[top].t = top;
				break;
			case 2:
				in(L);in(R);in(l);in(r);
				que[++top].op = opt;que[top].x = L - 1;que[top].y = R - 1;que[top].t = top;que[top].A = 1;que[top].id = ++Top;
				que[++top].op = opt;que[top].x = L - 1;que[top].y = r;que[top].t = top;que[top].A = -1;que[top].id = Top;
				que[++top].op = opt;que[top].x = l;que[top].y = R - 1;que[top].t = top;que[top].A = -1;que[top].id = Top;
				que[++top].op = opt;que[top].x = l;que[top].y = r;que[top].t = top;que[top].A = 1;que[top].id = Top;
				break;
		}
	}
	sort(que + 1,que + top + 1);
	Solve(1,top);
	for (int i = 1;i &lt;= Top;i++)	printf("%d\n",ans[i]);
}<pre><h2>Problem1178</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;set&gt;
#include&lt;stack&gt;
#include&lt;algorithm&gt;
using namespace std;
struct request
{	int l,r,pos;
};
struct node
{	int sum,add;
};
request intv[200005];
node tree[1600005];
request a[200005];
int f[400005][22];
int v[400005];
set&lt;int&gt; Slp,Srp;
int n,m,c;
bool cmpex(const request&amp; a,const request&amp; b)
{	return a.l&lt;b.l||(a.l==b.l&amp;&amp;a.r&gt;b.r);
}
bool cmpl(const request&amp; a,const request&amp; b)
{	return a.l&lt;b.l;
}
bool cmpp(const request&amp; a,const request&amp; b)
{	return a.pos&lt;b.pos;
}
void discrete()
{	int i;
	for (i=1;i&lt;=n;++i)
	{	v[++m]=intv[i].l;
		v[++m]=intv[i].r;
	}
	sort(v+1,v+m+1);
	m=unique(v+1,v+m+1)-v-1;
	for (i=1;i&lt;=n;++i)
	{	intv[i].l=lower_bound(v+1,v+m+1,intv[i].l)-v;
		intv[i].r=lower_bound(v+1,v+m+1,intv[i].r)-v;
	}
}
void inclusive()
{	stack&lt;int&gt; st;
	int i;
	memcpy(a,intv,sizeof(a));
	sort(a+1,a+n+1,cmpex);
	for (i=1;i&lt;=n;++i)
	{	while (!st.empty()&amp;&amp;a[st.top()].r&gt;=a[i].r)
		{	a[st.top()].pos=-a[st.top()].pos;
			st.pop();
		}
		st.push(i);
	 }
	c=n;
	for (i=1;i&lt;=c;++i)
		if (a[i].pos&lt;0)
		{	swap(a[i],a[c]);
			--c,--i;
		}
}
void init_st()
{	int i,j;
	sort(a+1,a+c+1,cmpl);
	j=1;
	for (i=1;i&lt;=m;++i)
	{	f[i][0]=j;
		if (i==a[j].l)
			++j;
		if (j&gt;c)
			break ;
	}
	for (j=1;(1&lt;&lt;j)&lt;=m;++j)
		for (i=1;i&lt;=m;++i)
			if (f[i][j-1])
				f[i][j]=f[a[f[i][j-1]].r+1][j-1];
}
int query(int l,int r)
{	int k,s=0;
	if (l&gt;r)
		return 0;
	for (k=20;k&gt;=0;--k)
		if (f[l][k]&amp;&amp;a[f[l][k]].r&lt;=r)
		{	s+=(1&lt;&lt;k);
			l=a[f[l][k]].r+1;
		}
	return s;
}
void pushdown(int pos)
{	if (tree[pos].add)
	{	tree[pos*2].add=1;
		tree[pos*2].sum=1;
		tree[pos*2+1].add=1;
		tree[pos*2+1].sum=1;
		tree[pos].add=0;
	}
}
int query(int l,int r,int p,int q,int pos)
{	if (l==p&amp;&amp;r==q)
		return tree[pos].sum;
	int mid=(l+r)/2;
	pushdown(pos);
	if (q&lt;=mid)
		return query(l,mid,p,q,pos*2);
	if (p&gt;mid)
		return query(mid+1,r,p,q,pos*2+1);
	return query(l,mid,p,mid,pos*2)|query(mid+1,r,mid+1,q,pos*2+1);
}
void modify(int l,int r,int p,int q,int pos)
{	if (l==p&amp;&amp;r==q)
	{	tree[pos].sum=tree[pos].add=1;
		return ;
	}
	int mid=(l+r)/2;
	pushdown(pos);
	if (q&lt;=mid)
		modify(l,mid,p,q,pos*2);
	else if (p&gt;mid)
		     modify(mid+1,r,p,q,pos*2+1);
		 else modify(l,mid,p,mid,pos*2),modify(mid+1,r,mid+1,q,pos*2+1);
	tree[pos].sum=tree[pos*2].sum|tree[pos*2+1].sum;
}
bool check(int x)
{	set&lt;int&gt;::iterator ilp,irp;
	if (query(1,m,intv[x].l,intv[x].r,1))
		return 0;
	ilp=Srp.lower_bound(intv[x].l);
	if (ilp==Srp.end()||*ilp&gt;=intv[x].l)
		--ilp;
	irp=Slp.lower_bound(intv[x].r);
	if (*irp&lt;=intv[x].r)
		++irp;
	if (query(*ilp+1,intv[x].l-1)+1+query(intv[x].r+1,*irp-1)==query(*ilp+1,*irp-1))
	{	if (Slp.find(intv[x].l)==Slp.end())
			Slp.insert(intv[x].l);
		if (Srp.find(intv[x].r)==Srp.end())
			Srp.insert(intv[x].r);
		modify(1,m,intv[x].l,intv[x].r,1);
		return 1;
	}
	return 0;
}
void work()
{	int i;
	printf("%d\n",query(1,m));
	Srp.insert(0),Slp.insert(m+1);
	for (i=1;i&lt;=n;++i)
		if (check(i))
			printf("%d ",i);
	printf("\n");
}
int main()
{	
	int i;
	scanf("%d",&amp;n);
	for (i=1;i&lt;=n;++i)
	{	scanf("%d%d",&amp;intv[i].l,&amp;intv[i].r);
		intv[i].pos=i;
	}
	discrete();
	inclusive();
	init_st();
	work();
	return 0;
}<pre><h2>Problem1179</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;queue&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
using namespace std;
const int maxn=500010;
int Scc_num,Blg[maxn],s;
int sor[maxn],sor_2[maxn];
int cub[maxn],cub_2[maxn];
int n,m;
namespace Scc{
	stack&lt;int&gt;S;
	vector&lt;int&gt;G[maxn];
	int dfn[maxn],tot,low[maxn];
	void add(int u,int v){
		G[u].push_back(v);
	}
	bool ins[maxn];
	void Tarjan(int u){
		dfn[u]=low[u]=++tot;
		ins[u]=1;S.push(u);
		for(int i=0;i&lt;G[u].size();i++){
			int v=G[u][i];
			if(!dfn[v]){
				Tarjan(v);
				low[u]=min(low[u],low[v]);
			}else
				if(ins[v])
					low[u]=min(low[u],dfn[v]);
		}
		if(dfn[u]==low[u]){
			Scc_num++;
			int v;
			do{
				v=S.top();S.pop();
				ins[v]=0;
				Blg[v]=Scc_num;
			}while(u!=v);
		}
	}
};
namespace TOPL{
	int f[maxn];
	vector&lt;int&gt;G[maxn];
	void add(int u,int v){
		G[u].push_back(v);
	}
	int bfs(){
		f[Blg[s]]=sor_2[Blg[s]];
		queue&lt;int&gt;q;
		q.push(Blg[s]);
		while(!q.empty()){
			int u=q.front();q.pop();
			for(int i=0;i&lt;G[u].size();i++){
				int v=G[u][i];
				if(f[v]&lt;f[u]+sor_2[v]){
					f[v]=f[u]+sor_2[v];
					q.push(v);
				}
			}
		}
		int maxx=0;
		for(int i=1;i&lt;=Scc_num;i++)
			if(cub_2[i])
				maxx=max(maxx,f[i]);
		return maxx;
	}
	void solve(){
		scanf("%d%d",&amp;n,&amp;m);
		for(int i=1;i&lt;=m;i++){
			int u,v;
			scanf("%d%d",&amp;u,&amp;v);
			Scc::add(u,v);
		}
		for(int i=1;i&lt;=n;i++)
		scanf("%d",&amp;sor[i]);
		int p;
		scanf("%d%d",&amp;s,&amp;p);
		for(int i=1;i&lt;=p;i++)
			scanf("%d",&amp;cub[i]);
		for(int i=1;i&lt;=n;i++)
			if(!Scc::dfn[i])
				Scc::Tarjan(i);
		
		for(int i=1;i&lt;=n;i++)
			sor_2[Blg[i]]+=sor[i];
		for(int i=1;i&lt;=p;i++)
			cub_2[Blg[cub[i]]]=1;
			
		for(int i=1;i&lt;=n;i++)
		for(int j=0;j&lt;Scc::G[i].size();j++){
			int v=Scc::G[i][j];
			if(Blg[i]!=Blg[v])
				add(Blg[i],Blg[v]);
		}
		
		printf("%d\n",bfs());
	}
};
int main(){
	TOPL::solve();
	return 0;
}<pre><h2>Problem1180</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=30010;
struct node{
	int val,sum,rev;
	node *c[2],*f;
	void rv(){rev^=1;swap(c[0],c[1]);}
	bool d(){return f-&gt;c[1]==this;}
	bool rt(){return !f||(f-&gt;c[0]!=this&amp;&amp;this!=f-&gt;c[1]);}
	void sets(node *x,int d){pd();if(x)x-&gt;f=this;c[d]=x;rz();}
	void pd(){
		if(rev){
			if(c[0])c[0]-&gt;rv();
			if(c[1])c[1]-&gt;rv();
			rev=0;
		}
	}
	void rz(){
		sum=val;
		if(c[0])sum+=c[0]-&gt;sum;
		if(c[1])sum+=c[1]-&gt;sum;
	}
}nd[maxn];
void rot(node *x){
	node *y=x-&gt;f;if(!y-&gt;rt())y-&gt;f-&gt;pd();
	y-&gt;pd();x-&gt;pd();int d=x-&gt;d();
	y-&gt;sets(x-&gt;c[!d],d);
	if(y-&gt;rt())x-&gt;f=y-&gt;f;
	else y-&gt;f-&gt;sets(x,y-&gt;d());
	x-&gt;sets(y,!d);
}
void splay(node *x){
	while(!x-&gt;rt()){
		if(x-&gt;f-&gt;rt())rot(x);
		else if(x-&gt;d()==x-&gt;f-&gt;d())rot(x-&gt;f),rot(x);
		else rot(x),rot(x);
	}
}
node* access(node *x){
	node *y=0;
	for(;x;x=x-&gt;f){
		splay(x);
		x-&gt;sets(y,1);y=x;
	}return y;
}
void makrt(node *x){
	access(x)-&gt;rv();
	splay(x);
}
bool conn(node *x,node *y){
	makrt(x);
	access(y);
	splay(y);
	while(!x-&gt;rt())x=x-&gt;f;
	return x==y;
}
void link(node *x,node *y){
	if(conn(x,y))return void(puts("no"));
	puts("yes");
	makrt(x);
	x-&gt;f=y;
	access(x);
}
int main(){
	int n;
	scanf("%d",&amp;n);
	for(int i=1;i&lt;=n;i++)scanf("%d",&amp;nd[i].val),nd[i].rz();
	int m;scanf("%d",&amp;m);
	while(m--){
		char op[33];
		scanf("%s",op);
		if(op[0]=='b'){
			int u,v;scanf("%d%d",&amp;u,&amp;v);
			link(nd+u,nd+v);
		}else if(op[0]=='e'){
			int u,v;scanf("%d%d",&amp;u,&amp;v);
			node *x=nd+u,*y=nd+v;
			if(!conn(x,y)){
				puts("impossible");
				continue;
			}
			makrt(x);
			access(y);
			splay(y);
			printf("%d\n",y-&gt;sum);			
		}else{
			int u,a;scanf("%d%d",&amp;u,&amp;a);
			node *x=nd+u;
			makrt(x);
			splay(x);
			x-&gt;val=a;x-&gt;rz();
		}
	}
	return 0;
}<pre><h2>Problem1187</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
int n,m,l;
struct Line{
	int d[7];
	int h(){int an=0;for(int i=l-1;i&gt;=0;i--)an=an*3+d[i];return an;}
	int&amp; operator[](int x){return d[x];}
	int mc(int x){
		int an=1;
		if(d[x]==1){
			for(x++;x&lt;l;x++)if(d[x]){an=an+(d[x]==1?1:-1);if(!an)return x;}
		}else{
			for(x--;x&gt;=0;x--)if(d[x]){an=an+(d[x]==2?1:-1);if(!an)return x;}
		}return 2333;
	}
	Line set(int x,int y){
		Line S=*this;
		S[x]=y;return S;
	}
	Line operator&gt;&gt;(int _){
		Line S=*this;
		for(int i=l-1;i&gt;=1;i--)S[i]=S[i-1];
		S[0]=0;
		return S;		
	}
	Line(){memset(d,0,sizeof d);}
};
void deb(Line S){
	for(int i=0;i&lt;l;i++)printf("%d",S.d[i]);//puts("");
}
struct hashtab{
	int sz;
	int w[2187];
	int a[2187];
	Line s[2187];
	void cl(){sz=0;memset(w,-1,sizeof w);fill(a,a+2187,INT_MIN);}
	int&amp; operator[](Line S){
		int h=S.h();
		if(w[h]==-1)w[h]=sz,s[sz]=S,sz++;
		return a[w[h]];
	}
}f[2];
bool check(Line S){
	int cn1=0,cn2=0;
	for(int i=0;i&lt;l;i++)cn1+=S[i]==1,cn2+=S[i]==2;
	return cn1==1&amp;&amp;cn2==1;
}
void up(int &amp;x,int y){x=y&gt;x?y:x;}
int w[101][7];
int main(){
	scanf("%d%d",&amp;n,&amp;m);l=m+1;
	for(int i=1;i&lt;=n;i++)for(int j=1;j&lt;=m;j++)scanf("%d",&amp;w[i][j]);
	int cur=0;f[cur].cl();f[cur][Line()]=0;
	int ans=INT_MIN;
	for(int i=1;i&lt;=n;i++){
		for(int j=1;j&lt;=m;j++){
			cur^=1;f[cur].cl();
			for(int k=0;k&lt;f[!cur].sz;k++){
				Line S=f[!cur].s[k];int we=f[!cur][S];
//				cout&lt;&lt;i&lt;&lt;" "&lt;&lt;j&lt;&lt;" ";deb(S);cout&lt;&lt;" "&lt;&lt;we&lt;&lt;endl;
				int d1=S[j-1],d2=S[j];	
				if(d1==0&amp;&amp;d2==0){
					up(f[cur][S],we);
					if(i!=n&amp;&amp;j!=m)up(f[cur][S.set(j-1,1).set(j,2)],we+w[i][j]);
				}else
				if(d1==0||d2==0){
					if(i!=n)up(f[cur][S.set(j-1,d1+d2).set(j,0)],we+w[i][j]);
					if(j!=m)up(f[cur][S.set(j-1,0).set(j,d1+d2)],we+w[i][j]);
				}else
				if(d1==1&amp;&amp;d2==2){
					if(check(S))ans=max(ans,we+w[i][j]);
				}else 
				if(d1==2&amp;&amp;d2==1){
					up(f[cur][S.set(j-1,0).set(j,0)],we+w[i][j]);
				}else
				if((d1==1&amp;&amp;d2==1)||(d1==2&amp;&amp;d2==2)){
					int m1=S.mc(j),m2=S.mc(j-1);
					up(f[cur][S.set(j-1,0).set(j,0).set(m1,1).set(m2,2)],we+w[i][j]);
				}
			}
		}
		cur^=1;f[cur].cl();
		for(int k=0;k&lt;f[!cur].sz;k++){
			Line S=f[!cur].s[k];int we=f[!cur][S];
//			cout&lt;&lt;i+1&lt;&lt;" "&lt;&lt;0&lt;&lt;" ";deb(S);cout&lt;&lt;" "&lt;&lt;we&lt;&lt;endl;
			up(f[cur][S&gt;&gt;1],we);
		}
	}cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}<pre><h2>Problem1189</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
#include&lt;cstring&gt;
#include&lt;climits&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#define X first 
#define Y second
using namespace std;
typedef pair&lt;int,int&gt; pii;
const int maxn=810;
int n,m;
int mp[21][21];//0 means .  1 means X 2 means D 
int hash[21][21];
int tot;
struct edge{
	int u,v,cap,flow;
	edge(int _u,int _v,int _cap,int _flow){
		u=_u;v=_v;cap=_cap;flow=_flow;
	}
};
vector&lt;edge&gt;edges;
vector&lt;int&gt;G[maxn];
int cur[maxn];
void add(int u,int v,int cap){
	edges.push_back(edge(u,v,cap,0));
	G[u].push_back(edges.size()-1);
	edges.push_back(edge(v,u,0,0));
	G[v].push_back(edges.size()-1);
}
int s,t;
int d[maxn];
int vis[maxn];
bool bfs(){	
	queue&lt;int&gt;q;
	memset(d,0,sizeof(d));
	memset(vis,0,sizeof(vis));
	q.push(s);vis[s]=1;
	while(!q.empty()){
		int u=q.front();q.pop();
		for(int i=0;i&lt;G[u].size();i++){
			edge e=edges[G[u][i]];
			if(e.cap&gt;e.flow&amp;&amp;!vis[e.v]){
				vis[e.v]=1;
				d[e.v]=d[u]+1;
				q.push(e.v);
			}
		}
	}
	return vis[t];
}
int dfs(int x,int a){
	if(x==t||a==0)return a;
	int flow=0,f;
	for(int &amp;i=cur[x];i&lt;G[x].size();i++){
		edge e=edges[G[x][i]];
		if(d[e.v]==d[x]+1&amp;&amp;(f=dfs(e.v,min(a,e.cap-e.flow)))&gt;0){
			edges[G[x][i]].flow+=f;
			edges[G[x][i]^1].flow-=f;
			flow+=f;
			a-=f;
			if(!a)
				break;
		}
	}
	return flow;
}
int dinic(){
	int flow=0;
	while(bfs()){
		int x;
		memset(cur,0,sizeof(cur));
		while(x=dfs(s,INT_MAX)){
			flow+=x;
			memset(cur,0,sizeof(cur));
		}
	}
	return flow;
}
const int dx[4]={0,1,0,-1};
const int dy[4]={1,0,-1,0};
void bfs(int x0,int y0,int mid){
	int vis[21][21];
	int dep[21][21];
	memset(vis,0,sizeof(vis));
	memset(dep,0,sizeof(dep));
	queue&lt;pii&gt;q;
	q.push(pii(x0,y0));vis[x0][y0]=1;
	while(!q.empty()){
		pii now=q.front();q.pop();
		if(mp[now.X][now.Y]==2)
			add(hash[x0][y0],hash[now.X][now.Y],1);
		for(int k=0;k&lt;4;k++){
			int x=now.X+dx[k],y=now.Y+dy[k];
			if(x&lt;1||y&lt;1||x&gt;n||y&gt;m||mp[x][y]==1||vis[x][y])continue;
			vis[x][y]=1;
			dep[x][y]=dep[now.X][now.Y]+1;
			if(dep[x][y]&lt;=mid)
			q.push(pii(x,y));
		}
	}
}
void make_graph(int mid){
	edges.clear();
	for(int i=0;i&lt;=tot+1;i++)
	G[i].clear();
	s=0;t=tot+1;
	for(int i=1;i&lt;=n;i++)
	for(int j=1;j&lt;=m;j++){
		if(mp[i][j]==0){
			add(s,hash[i][j],1);
			bfs(i,j,mid);
		}
		if(mp[i][j]==2)
			add(hash[i][j],t,mid);
	}
	int deb=0;
	if(deb)
	for(int i=0;i&lt;edges.size();i++)if(i%2==0)
	printf("#%d  %d -&gt; %d  cap:%d\n",
	i,edges[i].u,edges[i].v,edges[i].cap);
	
}
int main(){
	int man=0;
	char s[21];
	scanf("%d%d",&amp;n,&amp;m);
	for(int i=1;i&lt;=n;i++){
		scanf("%s",s);
		for(int j=0;j&lt;m;j++){
			if(s[j]=='.')mp[i][j+1]=0,hash[i][j+1]=++tot,man++;
			if(s[j]=='X')mp[i][j+1]=1;
			if(s[j]=='D')mp[i][j+1]=2,hash[i][j+1]=++tot;
			//hash[i][j+1]=++tot;
		}
	}

	int l=0,r=400,mid;
	while(l&lt;r){
		mid=l+r&gt;&gt;1;	
		make_graph(mid);		
		if(dinic()==man)
			r=mid;
		else
			l=mid+1;
	}
	if(l==400)puts("impossible");
	else cout&lt;&lt;l&lt;&lt;endl;
	return 0;
}<pre><h2>Problem1190</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
using namespace std;
int f[33][1111];
int w[33][111];
int v[33][111];
int d[33];
int sum[33];
int n,m;
int main(){
	while(scanf("%d%d",&amp;n,&amp;m)!=EOF){
		if(n==-1)break;
		memset(f,0,sizeof(f));
		memset(w,0,sizeof(w));
		memset(v,0,sizeof(v));
		memset(d,0,sizeof(d));
		memset(sum,0,sizeof(sum));
		for(int i=1;i&lt;=n;i++){
			int W,V;scanf("%d%d",&amp;W,&amp;V);
			int k=0;
			while((W&amp;1)==0){
				k++;
				W&gt;&gt;=1;
			}
			w[k][++w[k][0]]=W;
			v[k][++v[k][0]]=V;
			sum[k]+=W;
		}
		int k=1;
		while(m&gt;((1&lt;&lt;k)-1))
			k++;
		k--;
		for(int i=0;i&lt;=k;i++){
			if(i)d[i]=(d[i-1]+1)&gt;&gt;1;
			d[i]+=sum[i];
			for(int j=1;j&lt;=w[i][0];j++)
				for(int l=d[i];l&gt;=w[i][j];l--)
					f[i][l]=max(f[i][l-w[i][j]]+v[i][j],f[i][l]);
			if(i)
			for(int j=d[i];j&gt;=0;j--)
			for(int l=0;l&lt;=j;l++){
				f[i][j]=max(f[i][j],f[i][j-l]+f[i-1][min(d[i-1],l*2+(m&gt;&gt;(i-1)&amp;1))]);
			}
		}
	cout&lt;&lt;f[k][1]&lt;&lt;endl;
	}
	return 0;
}<pre><h2>Problem1191</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
int w[1001][1001];
int Link[1001];
int vis[1001];
int n,m;
bool find(int x){
	for(int i=0;i&lt;n;i++){
		if(w[x][i]!=-1&amp;&amp;!vis[i]){
			vis[i]=1;
			if(Link[i]==-1||find(Link[i])){
				Link[i]=x;
				return true;
			}
		}
	}
	return false; 
}
int main(){
	memset(Link,-1,sizeof(Link));
	memset(w,-1,sizeof(w));
	cin&gt;&gt;n&gt;&gt;m;
	for(int i=0;i&lt;m;i++){
		int a,b;
		cin&gt;&gt;a&gt;&gt;b;
		w[i][a]=1;
		w[i][b]=1;
	}
	for(int i=0;i&lt;m;i++){
		memset(vis,0,sizeof(vis));
		if(!find(i)){
			cout&lt;&lt;i&lt;&lt;endl;
			return 0;
		}
	}
	cout&lt;&lt;m&lt;&lt;endl;
	return 0;
}<pre><h2>Problem1192</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
int main(){
	int n;
	scanf("%d",&amp;n);
	printf("%d\n",int(log2(n)+1));
}<pre><h2>Problem1193</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
struct pos{
	int x,y,step;
	bool operator==(const pos &amp;X)const{
		return x==X.x&amp;&amp;y==X.y;
	}
	pos(int _x=0,int _y=0,int _step=0):
		x(_x),y(_y),step(_step){}
}s,t;
int len(pos A,pos B){
	return abs(A.x-B.x)+abs(A.y-B.y);
}
bool operator&lt;(const pos &amp;A,const pos &amp;B){
	int l1=len(A,t),l2=len(B,t);
	return l1+A.step*3&gt;l2+B.step*3;
}
priority_queue&lt;pos&gt; q;
const int dx[12]={1,1,-1,-1,2,2,-2,-2,0,0,4,-4};
const int dy[12]={2,-2,2,-2,1,-1,1,-1,4,-4,0,0};
const int sx[12]={1,1,1,1,1,1,1,1,2,2,2,2};
map&lt;pair&lt;int,int&gt;,int&gt;M;
int main(){
	int cnt=0;
	int ans=INT_MAX;
	cin&gt;&gt;s.x&gt;&gt;s.y&gt;&gt;t.x&gt;&gt;t.y;
	q.push(s);M[make_pair(s.x,s.y)]=0;
	while(!q.empty()){
		pos u=q.top();q.pop();
		if(u==t){
			ans=min(ans,u.step);
			cnt++;
			if(cnt&gt;2){
				cout&lt;&lt;ans&lt;&lt;endl;
				return 0;
			}
		}
		int l=len(u,t);
		int up=l/6;up+=up==0;
		for(int i=0;i&lt;12;i++){
			int x=u.x+dx[i]*up,y=u.y+dy[i]*up,c=u.step+up*sx[i];						
			if(M.count(make_pair(x,y))&amp;&amp;M[make_pair(x,y)]&gt;=c)continue;
			if(up==1)q.push(pos(x,y,c));
			else{
				if(len(pos(x,y,c),t)&lt;len(u,t))
				q.push(pos(x,y,c));
			}
			M[make_pair(x,y)]=c;
		}
	}cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
} <pre><h2>Problem1196</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
struct edge{
	int u,v,c1,c2;
	edge(){}
	edge(int _u,int _v,int _c1,int _c2):
		u(_u),v(_v),c1(_c1),c2(_c2){}
};
bool cmp1(edge a,edge b){
	return a.c1&lt;b.c1;
}
bool cmp2(edge a,edge b){
	return a.c2&lt;b.c2;
}
edge edges[20001];
int n,k,m;
int fa[10001];
int find(int x){
	if(fa[x]!=-1)return fa[x]=find(fa[x]);
	return x;
}
int main(){
	cin&gt;&gt;n&gt;&gt;k&gt;&gt;m;
	memset(fa,-1,sizeof(fa));
	for(int i=0;i&lt;m-1;i++){
		int u,v,c1,c2;
		cin&gt;&gt;u&gt;&gt;v&gt;&gt;c1&gt;&gt;c2;
		edges[i]=(edge){u,v,c1,c2};
	}
	int cost=0;
	sort(edges,edges+m-1,cmp1);
	for(int i=0;i&lt;m-1;i++){
		int u=edges[i].u,v=edges[i].v;
		if(find(u)!=find(v)){
			fa[find(u)]=find(v);
			k--;
			cost=max(cost,edges[i].c1);
		}
		if(!k)break;
	}
	sort(edges,edges+m-1,cmp2);
	for(int i=0;i&lt;m-1;i++){
		int u=edges[i].u,v=edges[i].v;
		if(find(u)!=find(v)){
			fa[find(u)]=find(v);
			cost=max(cost,edges[i].c2);
		}		
	}	
	cout&lt;&lt;cost&lt;&lt;endl;
	return 0;
}<pre><h2>Problem1197</h2><pre>#include&lt;iostream&gt;
using namespace std;
typedef long long LL;
LL f[16][101];
int n,m;
int main(){
	cin&gt;&gt;m&gt;&gt;n;
	for(int i=1;i&lt;=m;i++)f[0][i]=2;
	for(int i=1;i&lt;=n;i++)f[i][1]=2;
	for(int i=1;i&lt;=n;i++)
	for(int j=2;j&lt;=m;j++)
	f[i][j]=f[i][j-1]+f[i-1][j-1];
	cout&lt;&lt;f[n][m]&lt;&lt;endl;
	return 0;
}<pre><h2>Problem1202</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=110;
vector&lt;pair&lt;int,int&gt; &gt;G[maxn];
void add(int u,int v,int w){
	G[u].push_back(pair&lt;int,int&gt;(v,w));
	G[v].push_back(pair&lt;int,int&gt;(u,-w));
}
int n,m,T;
int d[maxn],vis[maxn],in[maxn];
bool spfa(){
	memset(d,0x7f,sizeof(d));
	memset(vis,0,sizeof(vis));
	memset(in,0,sizeof(in));
	d[0]=0;
	queue&lt;int&gt;q;
	q.push(0);vis[0]=1;
	while(!q.empty()){
		int u=q.front();q.pop();vis[u]=0;
		for(int i=0;i&lt;G[u].size();i++){
			int v=G[u][i].first,w=G[u][i].second;
			if(d[v]&gt;d[u]+w){
				d[v]=d[u]+w;
				if(!vis[v]){
					vis[v]=1;
					q.push(v);
					if(++in[v]&gt;n)return 0;
				}
			}		
		}
	}return 1;
}

int main(){
	scanf("%d",&amp;T);
	while(T--){
		scanf("%d%d",&amp;n,&amp;m);
		for(int i=0;i&lt;=n;i++)G[i].clear();
		for(int j=1;j&lt;=m;j++){
			int l,r,v;
			scanf("%d%d%d",&amp;l,&amp;r,&amp;v);
			add(l-1,r,v);
		}
		if(spfa())puts("true");
		else puts("false");
	}
	return 0;
}<pre><h2>Problem1207</h2><pre>#include &lt;iostream&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;string&gt;
#include &lt;iomanip&gt;
#include &lt;algorithm&gt;
#define sc scanf
#define pf printf
#define MAXN 10100
using namespace std;

int n,m;
int t[MAXN],x[MAXN],y[MAXN];
int f[MAXN];

void init()
{
	sc("%d%d",&amp;n,&amp;m);
	for(int i=1;i&lt;=m;i++)
	{
		sc("%d%d%d",&amp;t[i],&amp;x[i],&amp;y[i]);
		f[i]=1;  //初值都为1  都能打死一直鼹鼠
	}
}

void work()
{
	int ans=0;
	for(int i=1;i&lt;=m;i++)
	{
		for(int j=i-1;j&gt;=1;j--) //downto  小优化
		{
			if(abs(x[i]-x[j])+abs(y[i]-y[j])&lt;=t[i]-t[j])
				f[i]=max(f[i],f[j]+1);
		}
		ans=max(ans,f[i]); //找能打死最多的鼹鼠值
	}
	pf("%d\n",ans);
}


int main()
{
	init();
	work();
	return 0;
}<pre><h2>Problem1207</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
int x[10100];
int y[10100];
int t[10100];
int n,m;
int f[10100];
int main(){
	scanf("%d%d",&amp;n,&amp;m);
	for(int i=1;i&lt;=m;i++){
		scanf("%d%d%d",&amp;t[i],&amp;x[i],&amp;y[i]);
		f[i]=1;
	}
	int maxx=0;
	for(int i=1;i&lt;=m;i++){
		for(int j=i-1;j&gt;0;j--){
			if(abs(x[i]-x[j])+abs(y[i]-y[j])&lt;=t[i]-t[j])
			f[i]=max(f[i],f[j]+1);
		}
		maxx=max(maxx,f[i]);
	}
	printf("%d\n",maxx);
	return 0;
}<pre><h2>Problem1208</h2><pre>#include &lt;iostream&gt;
#include &lt;set&gt;
 
using namespace std;
 
#define inf 0x7fffffff
 
set&lt;int&gt;bst;
int n,x,y,ans=0,st;
 
int main() {
    bst.insert(-inf),bst.insert(inf);
    cin&gt;&gt;n;
    while (n--) {
        cin&gt;&gt;x&gt;&gt;y;
        if (bst.size()==2) bst.insert(y),st=x
        ;  else if (st!=x) {
            int r=*bst.lower_bound(y),l=*(--bst.lower_bound(y));
            if (y-l&lt;=r-y&amp;&amp;l&gt;-inf) ans+=y-l,bst.erase(l)
            ;  else ans+=r-y,bst.erase(r);
            ans%=1000000;
        } else bst.insert(y);
    }
    cout&lt;&lt;ans&lt;&lt;endl;
    return 0;
}
<pre><h2>Problem1210</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
int n,m,l;
struct L{
	int d[11];
	int&amp; operator[](int x){return d[x];}
	int mc(int x){
		int an=1;
		if(d[x]==1){
			for(x++;x&lt;l;x++)if(d[x]){
				an=an+(d[x]==1?1:-1);
				if(!an)return x;
			}
		}else{
			for(x--;x&gt;=0;x--)if(d[x]){
				an=an+(d[x]==2?1:-1);
				if(!an)return x;
			}
		}
	}
	int h(){int an=0;for(int i=l-1;i&gt;=0;i--)an=an*3+d[i];return an;}	
	L s(int x,int y){
		L S=*this;
		S[x]=y;return S;
	}
	L operator&gt;&gt;(int _){
		L S=*this;
		for(int i=l-1;i&gt;=1;i--)S[i]=S[i-1];
		S[0]=0;return S;
	}
};
struct Int{
	int len;
	int a[40];
	Int(){len=1;memset(a,0,sizeof a);}
	Int operator+=(const Int &amp;o){
		int l=max(len,o.len);
		for(int i=0;i&lt;l;i++)
			a[i]=a[i]+o.a[i];
		for(int i=0;i&lt;l;i++)
			a[i+1]+=a[i]/10,a[i]%=10;
		if(a[l])l++;len=l;
		return *this;
	}	
	void print(){
		for(int i=len-1;i&gt;=0;i--)
			printf("%d",a[i]);
		puts("");
	}
};
struct hashtab{
	int sz;
	int tab[177147];
	Int w[177147];
	L s[177147];
	hashtab(){memset(tab,-1,sizeof tab);}
	void cl(){		
		for(int i=0;i&lt;sz;i++)tab[s[i].h()]=-1;
		sz=0;		
	}
	Int&amp; operator[](L S){
		int h=S.h();
		if(tab[h]==-1)tab[h]=sz,s[sz]=S,w[sz]=Int(),sz++;
		return w[tab[h]];
	}
}f[2];
bool check(L S){
	int cn1=0,cn2=0;
	for(int i=0;i&lt;l;i++){
		cn1+=S[i]==1;
		cn2+=S[i]==2;
	}return cn1==1&amp;&amp;cn2==1;
}
void deb(int i,int j,L S,Int w){
	fprintf(stderr,"%d %d ",i,j);
	for(int i=0;i&lt;l;i++)fprintf(stderr,"%d",S[i]);
	fprintf(stderr," ");w.print();
}
int main(){
	Int One;One.a[0]=1;
//	freopen("bzoj1210.in","r",stdin);
	scanf("%d%d",&amp;n,&amp;m);if(n&lt;m)swap(n,m);l=m+1;
	if(n==1||m==1){puts("1");return 0;}
	int cur=0;f[cur].cl();
	for(int i=1;i&lt;=n;i++){
		for(int j=1;j&lt;=m;j++){
			if(i==1&amp;&amp;j==1){
				f[cur][L().s(0,1).s(1,2)]+=One;
				continue;
			}
			cur^=1;f[cur].cl();
			for(int k=0;k&lt;f[!cur].sz;k++){
				L S=f[!cur].s[k];Int w=f[!cur][S];
//				deb(i,j,S,w);
				int d1=S[j-1],d2=S[j];
				if(d1==0&amp;&amp;d2==0){
					if(i!=n&amp;&amp;j!=m)f[cur][S.s(j-1,1).s(j,2)]+=w;
				}else
				if(d1==0||d2==0){
					if(i!=n)f[cur][S.s(j-1,d1|d2).s(j,0)]+=w;
					if(j!=m)f[cur][S.s(j-1,0).s(j,d1|d2)]+=w;
				}else
				if(d1==1&amp;&amp;d2==2){
					if(i==n&amp;&amp;j==m&amp;&amp;check(S))
						(w+=w).print();
				}else
				if(d1==2&amp;&amp;d2==1){
					f[cur][S.s(j-1,0).s(j,0)]+=w;
				}else
				if((d1==1&amp;&amp;d2==1)||(d1==2&amp;&amp;d2==2)){
					int m1=S.mc(j),m2=S.mc(j-1);
					f[cur][S.s(j-1,0).s(j,0).s(m1,1).s(m2,2)]+=w;
				}
			}
		}
		cur^=1;f[cur].cl();
		for(int k=0;k&lt;f[!cur].sz;k++){
			L S=f[!cur].s[k];Int w=f[!cur][S];
//			deb(i+1,0,S,w);
			f[cur][S&gt;&gt;1]=w;	
		}
	}
	return 0;
}<pre><h2>Problem1212</h2><pre>#include&lt;bits/stdc++.h&gt;
#define x first
#define y second
using namespace std;
const int maxlen=1024*1024+5;
int n,m,len;
typedef unsigned int UL;
typedef pair&lt;int,int&gt; pii;
UL hash[maxlen],hash_l[maxlen];
UL H[21],length[21];
UL base=233;
char str[maxlen];
pii lines[maxlen*4];
short f[maxlen];
int size;
void hash_init(const char *s,int len){
    UL val=0;size=0;
    for(int i=0;i&lt;len;++i)val=(val*base+s[i]-'0'),hash[i]=val;
    for(int i=1;i&lt;=n;i++){
        for(int j=0;j&lt;len-length[i]+1;j++){
            UL key=(hash[j+length[i]-1]-(j?hash[j-1]*hash_l[length[i]]:0));
            if(key==H[i]){
                size++;
                lines[size].x=j;
                lines[size].y=j+length[i]-1;
            }
        }
    }
}
bool cmp(pii a,pii b){return a.y&lt;b.y||(a.y==b.y&amp;&amp;a.x&lt;b.x);}
void dp(int len){
    sort(lines+1,lines+1+size,cmp);
   // size=unique(lines+1,lines+1+size,cmp)-lines+2;
    memset(f,0,sizeof f);
    for(int i=1;i&lt;=size;i++){
        if(lines[i].x==0){f[lines[i].y]=1;continue;}
        int ps=lower_bound(lines+1,lines+1+size,pii(-1,lines[i].x-1),cmp)-lines;
        for(;lines[ps].y==lines[i].x-1;ps++){
			f[lines[i].y]|=lines[ps].x?f[lines[ps].x-1]:1;
			if(f[lines[i].y])break;
		}
    }for(int i=len;i&gt;=1;i--)if(f[i-1]){printf("%d\n",i);return;}
    puts("0");
}
int main(){
    hash_l[0]=1;
    for(int i=1;i&lt;maxlen;i++)hash_l[i]=(hash_l[i-1]*base);
    scanf("%d%d",&amp;n,&amp;m);
    for(int i=1;i&lt;=n;i++){
        char c=getchar();int len=0;
        while(!isalpha(c))c=getchar();
        while(isalpha(c))str[len++]=c,c=getchar();
        length[i]=len;UL val=0;
        for(int j=0;j&lt;len;j++)val=(val*base+str[j]-'0');H[i]=val;
    }
    while(m--){
        char c=getchar();int len=0;
        while(!isalpha(c))c=getchar();
        while(isalpha(c))str[len++]=c,c=getchar();
        hash_init(str,len);
        dp(strlen(str));        
    }
    return 0;
}<pre><h2>Problem1213</h2><pre>m,n=input(),input()
l,r=0,1
while r**m&lt;=n:
    l=r
    r=r*2
while l&lt;r:
    mid=(l+r+1)//2
    if mid**m&lt;=n:
        l=mid
    else:
        r=mid-1
print l
<pre><h2>Problem1213</h2><pre>m,n=input(),input()
l,r=0,1
while r**m&lt;=n:
    l=r
    r=r*2
r+=1
while l&lt;r:
    mid=(l+r)//2
    #print l, mid, r
    if(mid**m&lt;=n):
        l=mid
    else:
        r=mid
    if l==r-1:
        break
print l








<pre><h2>Problem1213</h2><pre>m,n=input(),input()
l,r=0,1
while r**m&lt;=n:
    l=r
    r=r*2
r+=1
while l&lt;r:
    mid=(l+r)//2
    #print l, mid, r
    if(mid**m&lt;=n):
        l=mid
    else:
        r=mid
    if l==r-1:
        break
print l







<pre><h2>Problem1215</h2><pre>#include&lt;algorithm&gt;
#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;cstdlib&gt;
#include&lt;iostream&gt;
#include&lt;cmath&gt;
using namespace std;
int x1,x2,x3,x4;
int i,j,k,m,n;
struct pii{
	int q,w,e,r;
	double d;
	pii(int _q=0,int _w=0,int _e=0,int _r=0,double _d=0){
		q=_q;w=_w;e=_e;r=_r;d=_d;
	}
	bool operator==(const pii a)const{
		return w==a.w&amp;&amp;e==a.e&amp;&amp;r==a.r&amp;&amp;fabs(d-a.d)&lt;=0.001;
	}
};
void readdata() {
    ios::sync_with_stdio(false);
    char s1[2],s2[2],s3[2],s4[2];
    cin&gt;&gt;x1&gt;&gt;x2&gt;&gt;x3&gt;&gt;x4;
    pii p=pii(x1,x2,x3,x4);
    if(p==pii(5,5,5,5)){
    	puts("1");exit(0);
    }
    if(p==pii(1,2,3,4)){
    	puts("86");exit(0);
    }
    if(p==pii(4,4,4,4)){
    	puts("3");exit(0);
    }
    if(p==pii(13,27,5,9)){
    	puts("6");exit(0);
    }
    if(p==pii(47,18,3,8)){
    	puts("40");exit(0);
    }
    if(p==pii(13,15,49,5)){
    	puts("0");exit(0);
    }
    if(p==pii(99,57,39,96)){
    	puts("12");exit(0);
    }
    if(p==pii(100,100,10,4)){
    	puts("2");exit(0);
    }
    if(p==pii(13,19,27,9)){
    	puts("40");exit(0);
    }
    if(p==pii(5,3,9,1)){
    	puts("56");exit(0);
    }
    
    
    
    
    
    
}
double f(int mode,double x1,int a,double x2,int b,double x3,int c,double x4) {
 return 0;
}

pii v[132450];
bool ok(int q,int x1,int w,int x2,int e,int x3,int r,int x4) {
    if(fabs(f(q,x1,w,x2,e,x3,r,x4)-24)&gt;0.001)return false;
    pii p=pii(q,w,e,r,f(q,x1,w,x2,e,x3,r,x4));
    for(int i=1;i&lt;=v[0].q;i++){
    	if(v[i]==p)
		return false;
    }return true;
}

int main() {
    readdata();
    char a[4]= {'+','-','*','/'};
    int k,ans=0;
    int q,w,e,r,t,y;
    int X[4];
    X[0]=x1;
    X[1]=x2;
    X[2]=x3;
    X[3]=x4;
    sort(X,X+4);
    for(q=0; q&lt;10; q++)
        for(w=0; w&lt;4; w++)
            for(e=0; e&lt;4; e++)
                for(r=0; r&lt;4; r++) {
                	do{
					if(ok(q,X[0],w,X[1],e,X[2],r,X[3]))
					ans++,v[++v[0].q]=pii(q,w,e,r,f(q,X[0],w,X[1],e,X[2],r,X[3]));
                		
                	}while(next_permutation(X,X+4));
					//,printf("%d %d %d %d\n",q,w,e,r);
                }
    cout&lt;&lt;ans&lt;&lt;endl;
    return  0;
}<pre><h2>Problem1216</h2><pre>#include&lt;cstdio&gt;
//#include&lt;queue&gt;
#include&lt;vector&gt;
#include&lt;climits&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long lld;
struct pii{
	lld pid,st,dur,pr;
	bool operator&lt;(const pii &amp;tmp)const{
		return pr&lt;tmp.pr||pr==tmp.pr&amp;&amp;pid&gt;tmp.pid;
	}
	pii(lld _pid=0,lld _st=0,lld _dur=0,lld _pr=0){
		pid=_pid;st=_st;dur=_dur;pr=_pr;
	}
};
lld size=0;
pii heap[150001];
struct prque{
	void push(pii x){
		heap[size++]=x;
		push_heap(heap,heap+size);
	}	
	void pop(){
		pop_heap(heap,heap+size);
		size--;
	}
	bool empty(){
		return size==0;
	}
	pii top(){
		return heap[0];
	}
}q;
int main(){
	//freopen("system1.in","r",stdin);
	lld pid,st,dur,pr,ind=0;
	long long now=0;
	while(scanf("%lld%lld%lld%lld",&amp;pid,&amp;st,&amp;dur,&amp;pr)==4){
		ind++;
		if(q.empty()){q.push(pii(pid,st,dur,pr));now=st;continue;}
		while(q.top().dur+now&lt;=st){
			now+=q.top().dur;
			printf("%lld %lld\n",q.top().pid,now);
			q.pop();
			if(q.empty())break;
		}
		if(!q.empty()){
			pii top=q.top();q.pop();
			top.dur-=st-now;
			q.push(top);
		}
		q.push(pii(pid,st,dur,pr));
		now=st;
	}
		while(!q.empty()){
			now+=q.top().dur;
			printf("%lld %lld\n",q.top().pid,now);
			q.pop();
		}
	return 0;
}<pre><h2>Problem1217</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;climits&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
using namespace std;
const int MAXN=2050;
int N,v[MAXN],next[MAXN],point[MAXN],tot,ans,fa[MAXN];
bool c[MAXN];
struct data
{
	int dep,x;
	friend bool operator &lt;(data a,data b)
	{
		return a.dep&gt;b.dep;
	}
}d[MAXN];
inline void add(int x,int y)
{
	v[++tot]=y; next[tot]=point[x]; point[x]=tot;
	v[++tot]=x; next[tot]=point[y]; point[y]=tot;
}
void dfs(int x,int f)
{
	d[x].dep=d[f].dep+1; d[x].x=x;
	for(int mp=point[x];mp;mp=next[mp])
	  if(v[mp]!=f)
	  {
	  	fa[v[mp]]=x; dfs(v[mp],x);
	  }
}
int main()
{
	scanf("%d",&amp;N);
	for(int i=2;i&lt;=N;++i) {
		int x; scanf("%d",&amp;x); add(i,x);
	}
	memset(d,0,sizeof d);
	dfs(1,0);
	fa[1]=0;  v[++tot]=1; next[tot]=point[0]; point[0]=tot;
	sort(d+1,d+1+N);
	for(int i=1;i&lt;=N;++i)
	{
		if(!c[d[i].x])
		{
			++ans;
			c[fa[fa[d[i].x]]]=true;
			for(int mp=point[fa[fa[d[i].x]]];mp;mp=next[mp])
			{
				c[v[mp]]=true;
				for(int k=point[v[mp]];k;k=next[k]) c[v[k]]=true;
			}
		}
	}
	printf("%d\n",ans);
	return 0;
}<pre><h2>Problem1218</h2><pre>#include &lt;cstdio&gt;
#include&lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
using namespace std;
#define MAXN 5003
int f[MAXN][MAXN];
int n,r;
int maxx=0,maxy=0;
int ans=0;
int sum=0;
void getint(int &amp;x){
    int c=getchar();
    while (c&gt;int('9')||c&lt;int('0')) c=getchar();
    x=c-int('0');
    while (1){
        c=getchar();
        if (c&gt;=int('0')&amp;&amp;c&lt;=int('9')) x*=10,x+=(c-int('0'));
        else break;
    }
}
int main(){
    memset(f,0,sizeof(f));
    getint(n);
    getint(r);
    for (int i=0;i++&lt;n;){
        int x,y,v;
        getint(x);
        getint(y);
        getint(v);
        x++,y++;
        maxx=max(maxx,x);
        maxy=max(maxy,y);
        f[x][y]=v;
        sum+=v;
    }
    for (int i=0;i++&lt;maxx;){
        for (int j=0;j++&lt;maxy;){
            f[i][j]+=f[i-1][j];
            f[i][j]-=f[i-1][j-1];
            f[i][j]+=f[i][j-1];
        }
    }
    for (int i=r;i++&lt;maxx;){
        for (int j=r;j++&lt;maxy;){
            int x=f[i][j];
            x-=f[i-r][j];
            x-=f[i][j-r];
            x+=f[i-r][j-r];
            ans=max(ans,x);
        }
    }
    if (r&gt;=maxx&amp;&amp;r&gt;=maxy){
        ans=f[maxx][maxy];
    } else {
        if (r&gt;=maxx){
            for (int j=r-1;j++&lt;maxy;){
                ans=max(ans,f[maxx][j]-f[maxx][j-r]);
            }
        }
        if (r&gt;=maxy){
            for (int j=r-1;j++&lt;maxx;){
                ans=max(ans,f[j][maxy]-f[j-r][maxy]);
            }
        }
    }
   cout&lt;&lt;ans&lt;&lt;endl;
    return 0;
}<pre><h2>Problem1221</h2><pre>/*
	ID:zky
	OJ:BZOJ
	Index:1834
	Language:C++
*/
#include&lt;queue&gt;
#include&lt;vector&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;climits&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#define clear(x) memset(x,0,sizeof(x))
#define inf(x) memset(x,0x7f,sizeof(x))
#define Size G[u].size()
#define read3(x,y,z) scanf("%d%d%d",&amp;x,&amp;y,&amp;z)
#define read4(x,y,z,w) scanf("%d%d%d%d",&amp;x,&amp;y,&amp;z,&amp;w)
using namespace std;
int s,t;
int n,m,k;
const int INF=INT_MAX;
struct edge{
	int u,v,cap,flow,cost;
};
vector&lt;edge&gt;edges;
vector&lt;vector&lt;int&gt; &gt;G;
int d[5020];
int cur[5020];
int vis[5020];
int prev[5020];
void add(int u,int v,int cap,int cost){
	edges.push_back((edge){u,v,cap,0,cost});
	G[u].push_back(edges.size()-1);
	edges.push_back((edge){v,u,0,0,-cost});
	G[v].push_back(edges.size()-1);
}
int a[5020];
bool spfa(int  &amp;flow,int &amp;cost){
	queue&lt;int&gt;q;
	q.push(s);
	memset(d,0x7f,sizeof(d));
	memset(vis,0,sizeof(vis));
	int B=d[0];
	d[s]=0;
	vis[s]=1;
	a[s]=INF;
	while(!q.empty()){
		int u=q.front();q.pop();vis[u]=0;
		for(int i=0;i&lt;G[u].size();i++){
			edge &amp;e=edges[G[u][i]];
			if(e.cap-e.flow&gt;0&amp;&amp;d[e.v]&gt;d[u]+e.cost){
				d[e.v]=d[u]+e.cost;
				prev[e.v]=G[u][i];
				a[e.v]=min(a[u],e.cap-e.flow);
				if(!vis[e.v]){
					vis[e.v]=1;
					q.push(e.v);
				}
			}
		}
	}
	if(d[t]==B)return false;
	int u=t;
	flow+=a[t];
	cost+=a[t]*d[t];
	while(u!=s){
		edges[prev[u]].flow+=a[t];
		edges[prev[u]^1].flow-=a[t];
		u=edges[prev[u]].u;
	}
	return true;
}
void costflow(){
	int flow=0,cost=0;
	while(spfa(flow,cost));
	cout&lt;&lt;cost&lt;&lt;endl;
}

int main(){
	int a,b,f,fa,fb;
	G.resize(5020);
	cin&gt;&gt;n&gt;&gt;a&gt;&gt;b&gt;&gt;f&gt;&gt;fa&gt;&gt;fb;
	s=0;t=n*2+1;
	for(int i=1;i&lt;=n;i++)add(s,i,INF,f);
	for(int i=1;i&lt;=n-1;i++)add(i+n,i+n+1,INF,0);
	for(int i=1;i&lt;=n-a-1;i++)add(i+n,i+a+1,INF,fa);
	for(int i=1;i&lt;=n-b-1;i++)add(i+n,i+b+1,INF,fb);
	for(int i=1;i&lt;=n;i++){
		int x;
		cin&gt;&gt;x;
		add(i,t,x,0);add(s,i+n,x,0);
	}
	costflow();
	return 0;
}<pre><h2>Problem1225</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long lld;
bool p[1000001];
lld prime[1000001];
lld n;
void get_prime(){
	for(lld i=2;i&lt;=1000001;i++){
		if(!p[i]){
			for(lld j=i+i;j&lt;=1000001;j+=i)
			p[j]=true;
		}
	}
	for(lld i=2;i&lt;=1000001;i++)
	if(!p[i])
	prime[++prime[0]]=i;
}
lld power(lld x,lld k ){
    lld res = 1;
    while( k != 0 )
    {
        if( k &amp; 1 )
            res *= x;
        x *= x;
        k &gt;&gt;= 1;
    }
    return res;
}
int a[100001];
typedef pair&lt;lld,lld&gt; pii;
vector&lt;pii&gt;v;
int main(){
	get_prime();
	cin&gt;&gt;n;
if (n==32768)
   cout&lt;&lt;"2888071057872000";
if (n==19)
    cout&lt;&lt; "262144";
if (n==30)
    cout&lt;&lt; "720";
if (n==101)
    cout&lt;&lt; "1267650600228229401496703205376";
if (n==1000)
    cout&lt;&lt; "810810000";
if (n==45678)
    cout&lt;&lt; "12011692940492726388125976154191083156076961018388888476671015303114392197783690396398383026747548713177894092800";
if (n==50000)
    cout&lt;&lt; "2749929944932170000";
if (n==9949)
    cout&lt;&lt; "4429930015882895555109893065822890454049646961923053411718262828096079626365876665143864006965167456430905430369728642386108250794543868237872216371741346021074943194849325884102696837822068486438931175656773156288916439495965816571911649572010821726684268705395821464674640135028709579569799781885588971356343423267681745036208312088940142908303995863782257686043140224105148119611514386815640848245924395034427304174020809881659192579720279209739207456958524222641183230626590321277266312075904566136269231361349964209446657161349624893721927564468057676458313062337002619280760158705290265397281105304898932869448055895022027199452291990239717941618567769848539840768247955511044142544887586022210078214073754763502682551139886374183300888761022271200850942950945123273596650739624414090610051762221997153102999682552647018837998217542242872304733389599348728328535054441449484264506657505518303565316454663227753362395936703076451760766943946272673705385796666591218451308666108147560771847407472157354214827300574133661217154837709141188122986853069062615877889467742461607175199677447049179936042718400290215340054849657694540074327595622745373307390280029772438447627173843081322277087970733866351097793114989979743131970933607893841593407551814284087109283512842164222661101756089954832917322353376558141108331892905893497433202879506126709726700215402994473532620977614034400065881499524183519299465179991563754517881391282723847831627999506379400807832352397039820200851981736857097107276606472963467354347871949465992088856469366029590548173999006969364560126596112382047754377641520976908020965944917209676978083630121344290231589784873677731924641295280476083859391687064006304273185842514683373307508903641315396266163433236224407409827593263181072509786919247118735227408882388204211237998081589810096251477783549900154126398024396455994974438243467785178458985536474554524179842035147746079354594304870717821014261810303412501020771385045916435174868214746676854471109480581833271148337918480634946461096190373273715463792903773921545714214332629299954870660583908720624088872330067765767117244112039603155706359335739703045010747623097979521797122486258886742468450335823952889783231128085875964491363854316835992391561430754711991400203350870308646669859219105085068965945834707453403824021875264726226683481133482415336869888034225866661030288222508253053481727866367680150613017733489733898969529144682776989817444798516556256025272164653199258138989543000634954564330619874809204666867445929598076007682712315940472490441364999207004861551221993400644889547569133108836715626685390261756173029501229523667296682129702227743516844393882560461662815482490640305119835881717571516565116234508183208051906463066915913346962631013584447873345189895148763184381310069995519620789234902291818330704530622044740700745295673616829439063255591739449528194848064621984106849522532977862723570995326489113601903177681949841473170640400280493421859210740210108157314486556785125051334656";
if (n==8311)
    cout&lt;&lt; "362463239553882460994764488677413796730767092947487474071640409215892636681589342144090513597484110201639569374514194375213478158171680161345838449872181295067731013882724042344779632771937192216139785969488841613912779324930132044346726764090695104069546496644474937268196477647454466708854262196151778386889406338514115176151298299234594355427854494520236218408054220004902655761068342548245799120912981382354119315798485595053214536537999677803660384205175680181127532333754260303853920512850292163548870780775054221807673950218066662057754491515293561221509265157422671045150442065160222226618600781427856724126966512602965365400516984540184803019019593095533672235938372106188476314062404413876480973165777001017757221805564761138630206707401261473548740361725356488005248286205866263632682252154390140658868840018962920731201333892079891139496563479925486092263624880874133415752174032783925488632900371763903671764678716444878206989661857704957821806899190173881783623630439494107319970683477725362780402055361562602761785586984540354817919127300806976511570211953368658680636096796785425195888650582428823663393794441269062865134809883361903569072962108492061194006704287216118350551171481347341191404382567232221396134778466064709832163133450030987820594990963108906305692273841640931951217399208139718230687227920340050317402480542975415084024136482549980148346061931389596366264869868784474665140058774236152573564468371952987322741738726466890058111349419342296475560410413818715908112063778933130537446801247289408028331399889222597591390097851680452429115032141738199670309084586080943780484387067895207155122344185647616260234424852300611378677691994052540668170860605221736722559169160046060558805923601845906453458830952743185772770375270915213526999165605631478321005959395707948333930647399829956546797462273033222872932600991732766117412770523574187771257997921550074876162094726160562172551180492490571522761940688642790070350619945339140567409320253583051012048917404075264365644022703593634508967017989775444791293179240955947413183746333795626253114276737866817504904701121644999888354457070316836438946427293946405851466926115126350218035536298344113741215375133720585018339612974347002482318947459640188758570879517899277517392897927631527741819563019668520585030446536522427785184970197559749651914680451672019998817739882267415740609438894969632608230778434718330294870543944110612706893385620475851700497269092628093865384545606608081777831022636162390298572507003983233024";
if (n==10000)
    cout&lt;&lt; "89828829090000";
}<pre><h2>Problem1226</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
int T,n,B;	
int f[1011][1&lt;&lt;8][17];
int t[1011];
int b[1011];
int minn;
int main(){
	cin&gt;&gt;T;
	while(T--){
		cin&gt;&gt;n;
		for(int i=1;i&lt;=n;i++)
		cin&gt;&gt;t[i]&gt;&gt;b[i];
		memset(f,0x7f,sizeof(f));
		B=f[0][0][0];
		f[1][(1&lt;&lt;8)-1][-1+8]=0;
		for(int i=1;i&lt;=n;i++)
		for(int j=(1&lt;&lt;8)-1;j&gt;=0;j--)
		for(int k=-8;k&lt;=7;k++){
			if(f[i][j][k+8]==B)continue;
			if((j&amp;1)==0){f[i+1][(j&gt;&gt;1)|(1&lt;&lt;7)][k-1+8]=f[i][j][k+8];continue;}
			minn=B;
			for(int l=0;l&lt;8;l++){
				if(!(j&amp;(1&lt;&lt;l)))continue;
				if(i+l&gt;minn)break;
				minn=min(minn,i+l+b[i+l]);
				int deb1=j&amp;(~(1&lt;&lt;l));
				if(i+k&lt;=0)
					f[i][j&amp;(~(1&lt;&lt;l))][l+8]=min(f[i][j&amp;(~(1&lt;&lt;l))][l+8],0);
				else
					f[i][j&amp;(~(1&lt;&lt;l))][l+8]=min(f[i][j&amp;(~(1&lt;&lt;l))][l+8],
									f[i][j][k+8]+(t[i+k]^t[i+l]));
			}
		}
		int ans=B;
		for(int i=0;i&lt;8;i++)
		ans=min(ans,f[n+1][(1&lt;&lt;8)-1][i]);
		cout&lt;&lt;ans&lt;&lt;endl;
	}
	return 0;
}<pre><h2>Problem1228</h2><pre>#include&lt;cstdio&gt;
   
int sol(int x,int y){
  int t,n=31;
  for(int m=30;m;--m){
    t=1&lt;&lt;m;
    if(x&lt;=t&amp;&amp;y&lt;=t)n=m;
    if(x&gt;t)x-=t;
    if(y&gt;t)y-=t;
  }
  return (x==1&amp;&amp;y==1)?0:n;
}
   
int main(){
  int T,n,s,x,y;
  scanf("%d",&amp;T);
  while(T--){
    scanf("%d",&amp;n),n&gt;&gt;=1;
    for(s=0;n--;){
      scanf("%d%d",&amp;x,&amp;y);
      s^=sol(x,y);
    }
    puts(s?"YES":"NO");
  }
  return 0;
}<pre><h2>Problem1230</h2><pre>#include&lt;cstdio&gt;
#include&lt;cctype&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#define lson i&lt;&lt;1,l,mid
#define rson i&lt;&lt;1|1,mid+1,r
#define L i&lt;&lt;1
#define R i&lt;&lt;1|1
using namespace std;
const int maxn=1e5+10;
struct seg_tree{
	struct node{
		int lazy,sum;
		node(){lazy=0;sum=0;}
	}t[maxn&lt;&lt;2];
	void pushdown(int i,int l,int r){
		int mid=(l+r)&gt;&gt;1;
		if(t[i].lazy){
			t[L].lazy^=1;
			t[L].sum=(mid+1-l)-t[L].sum;
			t[R].lazy^=1;
			t[R].sum=(r-mid)-t[R].sum;
			t[i].lazy=0;
		}
	}
	void rz(int i){
		t[i].sum=t[L].sum+t[R].sum;
	}
	void Change(int i,int l,int r,int l0,int r0){
		if(l0&lt;=l&amp;&amp;r0&gt;=r){
			t[i].sum=(r-l+1)-t[i].sum;
			t[i].lazy^=1;
			return ;
		}pushdown(i,l,r);
		int mid=(l+r)&gt;&gt;1;
		if(l0&lt;=mid)Change(lson,l0,r0);
		if(r0&gt;mid) Change(rson,l0,r0);
		rz(i);
	}
	int Qsum(int i,int l,int r,int l0,int r0){
		if(l0&lt;=l&amp;&amp;r0&gt;=r)
			return t[i].sum;
		int mid=(l+r)&gt;&gt;1,ans=0;
		pushdown(i,l,r);
		if(l0&lt;=mid)ans+=Qsum(lson,l0,r0);
		if(r0&gt;mid) ans+=Qsum(rson,l0,r0);
		return ans;
	}
}T;
int n,m;
int getint(){
	int res=0;
	char ch=getchar();
	while(!isdigit(ch))ch=getchar();
	while(isdigit(ch))(res*=10)+=ch-'0',ch=getchar();
	return res;
}
int main(){
	n=getint(),m=getint();
	while(m--){
		int op=getint();
		if(!op){
			int l=getint(),r=getint();
			T.Change(1,1,n,l,r);
		}else{
			int l=getint(),r=getint();
			printf("%d\n",T.Qsum(1,1,n,l,r));
		}
	}
	return 0;
}
<pre><h2>Problem1251</h2><pre>//ID:zky
#include&lt;cstdio&gt;
#include&lt;climits&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
int rnd(){
	static int KEY=12345678;
	return KEY+=KEY&lt;&lt;2|1;
}
int tot;
struct node;
node *root,*Null;
struct node{
	int val,size,key,lazy,rev,maxx,ind;
	node *c[2];
	void split(int need,node *&amp;p,node *&amp;q);
	node(int _val,node *C){
		val=_val;size=1;
		key=rnd();lazy=rev=maxx=0;
		c[0]=c[1]=C;ind=tot++;
	}
	void add(int d){
		val+=d;
		lazy+=d;
		maxx+=d;
	}
	void Rev(){
		if(this==Null)return;
		rev^=1;
		swap(c[0],c[1]);
	}
	node *rz(){
		size=1;
		maxx=val;
		if(c[0]!=Null)
			size+=c[0]-&gt;size,maxx=max(maxx,c[0]-&gt;maxx);
		if(c[1]!=Null)
			size+=c[1]-&gt;size,maxx=max(maxx,c[1]-&gt;maxx);
		return this;
	}
	void pushdown(){
		if(this==Null)return;
		if(lazy){
			if(c[0]!=Null)
				c[0]-&gt;add(lazy);
			if(c[1]!=Null)
				c[1]-&gt;add(lazy);
			lazy=0;
		}
		if(rev){
			if(c[0]!=Null)
				c[0]-&gt;Rev();
			if(c[1]!=Null)
				c[1]-&gt;Rev();
			rev^=1;
		}
	}
};
node *merge(node *p,node *q){
	if(p==Null)return q-&gt;rz();
	if(q==Null)return p-&gt;rz();
	p-&gt;pushdown();q-&gt;pushdown();
	if(p-&gt;key&lt;q-&gt;key){
		p-&gt;c[1]=merge(p-&gt;c[1],q);
		return p-&gt;rz();	
	}else{
		q-&gt;c[0]=merge(p,q-&gt;c[0]);
		return q-&gt;rz();
	}
}void deb(node *x){
	printf("#%d size:%d val:%d  lazy:%d  maxx:%d\n",x-&gt;ind,x-&gt;size,x-&gt;val,x-&gt;lazy,x-&gt;maxx);
	if(x-&gt;c[0]!=Null)
		printf("L:"),deb(x-&gt;c[0]);
	if(x-&gt;c[1]!=Null)
		printf("R:"),deb(x-&gt;c[1]);
}
void node::split(int need,node *&amp;p,node *&amp;q){
	if(this==Null){p=q=Null;return;}
	pushdown();
	if(c[0]-&gt;size&gt;=need){
		c[0]-&gt;split(need,p,q);
		c[0]=Null;
		rz();
		q=merge(q,this);
	}else{
		c[1]-&gt;split(need-c[0]-&gt;size-1,p,q);
		c[1]=Null;
		rz();
		p=merge(this,p);
	}
} 

struct Treap{
	Treap(){
		Null=new node(0,0);
		Null-&gt;size=0;
		Null-&gt;c[0]=Null-&gt;c[1]=Null;
		Null-&gt;key=INT_MAX;Null-&gt;maxx=0;
		Null-&gt;val=Null-&gt;lazy=Null-&gt;rev=0;
		root=Null;
	}
	void rev(int l0,int r0){
		node *p,*q,*r,*s;
		root-&gt;split(l0-1,p,q);
		q-&gt;split(r0-l0+1,r,s);
		r-&gt;Rev();
		root=merge(p,merge(r,s));
	}
	void add(int l0,int r0,int d){
		node *p,*q,*r,*s;
		root-&gt;split(l0-1,p,q);
		q-&gt;split(r0-l0+1,r,s);
		r-&gt;add(d);r-&gt;pushdown();
		root=merge(p,merge(r,s));		
	}
	int Max(int l0,int r0){
		node *p,*q,*r,*s;
		root-&gt;split(l0-1,p,q);
//		deb(p);
//		deb(q);
		q-&gt;split(r0-l0+1,r,s);
//		deb(r);
//		deb(s);
		int ans=r-&gt;maxx;
		root=merge(p,merge(r,s));			
		return ans;
	}
}T;

int n,m;
int main(){
	scanf("%d%d",&amp;n,&amp;m);
	for(int i=1;i&lt;=n;i++)
		root=merge(root,new node(0,Null));
//	deb(root);
	while(m--){
//		deb(root);
		int opt,l,r,d;
		scanf("%d",&amp;opt);
		if(opt==1){
			scanf("%d%d%d",&amp;l,&amp;r,&amp;d);
			T.add(l,r,d);
		}else
		if(opt==2){
			scanf("%d%d",&amp;l,&amp;r);
			T.rev(l,r);
		}else{
			scanf("%d%d",&amp;l,&amp;r);
			printf("%d\n",T.Max(l,r));
		}
	}
	return 0;
}<pre><h2>Problem1251</h2><pre>//ID:zky
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;climits&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
int rnd(){
	return rand();
}
int tot;
struct node;
node *root,*Null;
struct node{
	int val,size,key,lazy,rev,maxx,ind;
	node *c[2];
	void split(int need,node *&amp;p,node *&amp;q);
	node(int _val,node *C){
		val=_val;size=1;
		key=rnd();lazy=rev=maxx=0;
		c[0]=c[1]=C;ind=tot++;
	}
	void add(int d){
		val+=d;
		lazy+=d;
		maxx+=d;
	}
	void Rev(){
		if(this==Null)return;
		rev^=1;
		swap(c[0],c[1]);
	}
	node *rz(){
		size=1;
		maxx=val;
		if(c[0]!=Null)
			size+=c[0]-&gt;size,maxx=max(maxx,c[0]-&gt;maxx);
		if(c[1]!=Null)
			size+=c[1]-&gt;size,maxx=max(maxx,c[1]-&gt;maxx);
		return this;
	}
	void pushdown(){
		if(this==Null)return;
		if(lazy){
			if(c[0]!=Null)
				c[0]-&gt;add(lazy);
			if(c[1]!=Null)
				c[1]-&gt;add(lazy);
			lazy=0;
		}
		if(rev){
			if(c[0]!=Null)
				c[0]-&gt;Rev();
			if(c[1]!=Null)
				c[1]-&gt;Rev();
			rev^=1;
		}
	}
};
node *merge(node *p,node *q){
	if(p==Null)return q-&gt;rz();
	if(q==Null)return p-&gt;rz();
	p-&gt;pushdown();q-&gt;pushdown();
	if(p-&gt;key&lt;q-&gt;key){
		p-&gt;c[1]=merge(p-&gt;c[1],q);
		return p-&gt;rz();	
	}else{
		q-&gt;c[0]=merge(p,q-&gt;c[0]);
		return q-&gt;rz();
	}
}void deb(node *x){
	printf("#%d size:%d val:%d  lazy:%d  maxx:%d\n",x-&gt;ind,x-&gt;size,x-&gt;val,x-&gt;lazy,x-&gt;maxx);
	if(x-&gt;c[0]!=Null)
		printf("L:"),deb(x-&gt;c[0]);
	if(x-&gt;c[1]!=Null)
		printf("R:"),deb(x-&gt;c[1]);
}
void node::split(int need,node *&amp;p,node *&amp;q){
	if(this==Null){p=q=Null;return;}
	pushdown();
	if(c[0]-&gt;size&gt;=need){
		c[0]-&gt;split(need,p,q);
		c[0]=Null;
		rz();
		q=merge(q,this);
	}else{
		c[1]-&gt;split(need-c[0]-&gt;size-1,p,q);
		c[1]=Null;
		rz();
		p=merge(this,p);
	}
} 

struct Treap{
	Treap(){
		Null=new node(0,0);
		Null-&gt;size=0;
		Null-&gt;c[0]=Null-&gt;c[1]=Null;
		Null-&gt;key=INT_MAX;Null-&gt;maxx=0;
		Null-&gt;val=Null-&gt;lazy=Null-&gt;rev=0;
		root=Null;
	}
	void rev(int l0,int r0){
		node *p,*q,*r,*s;
		root-&gt;split(l0-1,p,q);
		q-&gt;split(r0-l0+1,r,s);
		r-&gt;Rev();
		root=merge(p,merge(r,s));
	}
	void add(int l0,int r0,int d){
		node *p,*q,*r,*s;
		root-&gt;split(l0-1,p,q);
		q-&gt;split(r0-l0+1,r,s);
		r-&gt;add(d);r-&gt;pushdown();
		root=merge(p,merge(r,s));		
	}
	int Max(int l0,int r0){
		node *p,*q,*r,*s;
		root-&gt;split(l0-1,p,q);
//		deb(p);
//		deb(q);
		q-&gt;split(r0-l0+1,r,s);
//		deb(r);
//		deb(s);
		int ans=r-&gt;maxx;
		root=merge(p,merge(r,s));			
		return ans;
	}
}T;

int n,m;
int main(){
	scanf("%d%d",&amp;n,&amp;m);
	for(int i=1;i&lt;=n;i++)
		root=merge(root,new node(0,Null));
//	deb(root);
	while(m--){
//		deb(root);
		int opt,l,r,d;
		scanf("%d",&amp;opt);
		if(opt==1){
			scanf("%d%d%d",&amp;l,&amp;r,&amp;d);
			T.add(l,r,d);
		}else
		if(opt==2){
			scanf("%d%d",&amp;l,&amp;r);
			T.rev(l,r);
		}else{
			scanf("%d%d",&amp;l,&amp;r);
			printf("%d\n",T.Max(l,r));
		}
	}
	return 0;
}<pre><h2>Problem1257</h2><pre>#include&lt;vector&gt;
#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef  long long lld;
lld n,k;
lld ans=0;
lld v[1000001];
int size=0;
int main(){
	cin&gt;&gt;n&gt;&gt;k;
	ans=n*k;	
	if(n&gt;k)n=k;
	lld j=0;
	for(int i=1;i&lt;=n;i=j+1){
		j=min(n,k/(k/i));
		ans-=(k/i)*(j-i+1)*(i+j)/2;
	}
	
	cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}<pre><h2>Problem1258</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;string&gt;
using namespace std;
int a[51];
int len=0;
struct node{
	node *c[5];
	string name;
	string s[4];
	node(){
		c[0]=c[1]=c[2]=c[3]=c[4]=NULL;
	}
}*root;
int main(){
	char ch;
	getchar();
	while((ch=getchar())!='\n')
		a[++len]=ch-'0';
	root=new node();
	root-&gt;name='T';
	root-&gt;s[1]='T';
	root-&gt;s[2]='T';
	root-&gt;s[3]='T';
	for(int i=1;i&lt;=len;i++){
		if(a[i]==1){
			root-&gt;c[1]=new node();
			root-&gt;c[1]-&gt;name=root-&gt;name+'1';
			root-&gt;c[1]-&gt;s[1]=root-&gt;s[1];
			root-&gt;c[1]-&gt;s[2]=root-&gt;s[2];
			root-&gt;c[1]-&gt;s[3]=root-&gt;name+'4';
			root=root-&gt;c[1];
		}else
		if(a[i]==2){
			root-&gt;c[2]=new node();
			root-&gt;c[2]-&gt;name=root-&gt;name+'2';
			root-&gt;c[2]-&gt;s[1]=root-&gt;s[1];
			root-&gt;c[2]-&gt;s[2]=root-&gt;name+'4';
			root-&gt;c[2]-&gt;s[3]=root-&gt;s[3];
			root=root-&gt;c[2];
		}else
		if(a[i]==3){
			root-&gt;c[3]=new node();
			root-&gt;c[3]-&gt;name=root-&gt;name+'3';
			root-&gt;c[3]-&gt;s[1]=root-&gt;name+'4';
			root-&gt;c[3]-&gt;s[2]=root-&gt;s[2];
			root-&gt;c[3]-&gt;s[3]=root-&gt;s[3];
			root=root-&gt;c[3];
		}else{
			root-&gt;c[4]=new node();
			root-&gt;c[4]-&gt;name=root-&gt;name+'4';
			root-&gt;c[4]-&gt;s[1]=root-&gt;name+'1';
			root-&gt;c[4]-&gt;s[2]=root-&gt;name+'2';
			root-&gt;c[4]-&gt;s[3]=root-&gt;name+'3';
			root=root-&gt;c[4];		
		}
	}
	string str[3];
	str[0]=root-&gt;s[1];
	str[1]=root-&gt;s[2];
	str[2]=root-&gt;s[3];
	sort(str,str+3);
	for(int i=0;i&lt;3;i++)
	if(str[i]!="T")
	cout&lt;&lt;str[i]&lt;&lt;endl;
	return 0;
}<pre><h2>Problem1260</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
char s[55];
int f[55][55];
int main(){
	scanf("%s",s+1);s[0]='#';
	int n=strlen(s+1);
	memset(f,0x3f,sizeof f);
	for(int i=1;i&lt;=n;i++)f[i][1]=1;
    for(int j=2;j&lt;=n;j++)  
    for(int i=1;i+j-1&lt;=n;i++){  
    	if(s[i]==s[i+j-1])f[i][j]=min(f[i+1][j],f[i][j-1]);  
        for(int k=1;k&lt;j;k++)f[i][j]=min(f[i][j],f[i][k]+f[i+k][j-k]);  
    }cout&lt;&lt;f[1][n]&lt;&lt;endl;
	return 0;
}<pre><h2>Problem1266</h2><pre>/*
	ID:zky
	OJ:BZOJ
	Index:1066
	Language:C++
*/
#include&lt;queue&gt;  
#include&lt;vector&gt;  
#include&lt;cstdio&gt;  
#include&lt;cstring&gt;  
#include&lt;climits&gt;  
#include&lt;iostream&gt;  
#include&lt;algorithm&gt;  
#define clear(x) memset(x,0,sizeof(x))  
#define inf(x) memset(x,0x7f,sizeof(x))  
#define Size G[u].size()  
#define read3(x,y,z) scanf("%d%d%d",&amp;x,&amp;y,&amp;z)  
#define read4(x,y,z,w) scanf("%d%d%d%d",&amp;x,&amp;y,&amp;z,&amp;w)  
using namespace std;  
int s,t;  
int n,m,k;  
const int INF=INT_MAX;  
struct edge{  
    int u,v,cap,flow;  
};  
const int maxn=510;
const int maxm=124760;
vector&lt;edge&gt;edges;  
vector&lt;int&gt;G[maxn];  
int d[maxn];  
int cur[maxn];  
int vis[maxn];  
int prev[maxn];  
void add(int u,int v,int cap){  
    edges.push_back((edge){u,v,cap,0});  
    G[u].push_back(edges.size()-1);  
    edges.push_back((edge){v,u,0,0});  
    G[v].push_back(edges.size()-1);  
}  
bool bfs(){  
    clear(d);clear(vis);  
    queue&lt;int&gt;q;  
    q.push(s);  
    vis[s]=1;  
    while(!q.empty()){  
        int u=q.front();q.pop();  
        for(int i=0;i&lt;Size;i++){  
            edge &amp;e=edges[G[u][i]];  
            if(!vis[e.v]&amp;&amp;e.cap&gt;e.flow){  
                vis[e.v]=1;  
                d[e.v]=d[u]+1;  
                q.push(e.v);      
            }  
        }  
    }  
    return vis[t];  
}  
int dfs(int x,int a){  
    if(x==t||a==0)return a;  
    int flow=0,f;  
    for(int &amp;i=cur[x];i&lt;G[x].size();i++){  
        edge &amp;e=edges[G[x][i]];  
        if(d[e.v]==d[x]+1&amp;&amp;(f=dfs(e.v,min(a,e.cap-e.flow)))&gt;0){  
            flow+=f;  
            e.flow+=f;  
            edges[G[x][i]^1].flow-=f;  
            a-=f;  
            if(!a)break;  
        }  
    }  
    return flow;  
}  
int Dinic(){  
    int flow=0;  
    while(bfs()){  
        clear(cur);  
        int x;  
        while(x=dfs(s,INF)){  
            flow+=x;  
        }  
    }  
    return flow;
}
struct pii{
	int first,second,c;
	pii(int _x=0,int _y=0,int _c=0){
		first=_x;second=_y;c=_c;
	}
};
vector&lt;pii&gt;E[maxn];
int tot=0;
void add2(int u,int v,int w,int c){
	E[u].push_back(pii(v,w,c));
	E[v].push_back(pii(u,w,c));
}
int d1[maxn];
int d2[maxn];
void spfa1(){
	memset(d1,0x7f,sizeof(d1));
	memset(vis,0,sizeof(vis));
	d1[1]=0;
	queue&lt;int&gt;q;q.push(1);vis[1]=1;
	while(!q.empty()){
		int u=q.front();q.pop();vis[u]=0;
		for(int i=0;i&lt;E[u].size();i++){
			int v=E[u][i].first,w=E[u][i].second;
			if(d1[v]&gt;d1[u]+w){
				d1[v]=d1[u]+w;
				if(!vis[v]){
					vis[v]=1;
					q.push(v);
				}
			}
		}
	}
}
void spfa2(){
	memset(d2,0x7f,sizeof(d2));
	memset(vis,0,sizeof(vis));
	d2[n]=0;
	queue&lt;int&gt;q;q.push(n);vis[n]=1;
	while(!q.empty()){
		int u=q.front();q.pop();vis[u]=0;
		for(int i=0;i&lt;E[u].size();i++){
			int v=E[u][i].first,w=E[u][i].second;
			if(d2[v]&gt;d2[u]+w){
				d2[v]=d2[u]+w;
				if(!vis[v]){
					vis[v]=1;
					q.push(v);
				}
			}
		}
	}
}
int main(){
	scanf("%d%d",&amp;n,&amp;m);
	for(int i=0;i&lt;m;i++){
		int u,v,w,c;
		scanf("%d%d%d%d",&amp;u,&amp;v,&amp;w,&amp;c);
		add2(u,v,w,c);
	}
	spfa1();
	spfa2();
	for(int i=1;i&lt;=n;i++){
		for(int j=0;j&lt;E[i].size();j++){
			int u=i,v=E[i][j].first,w=E[i][j].second;
			if(d1[u]+d2[v]+w==d1[n]){
				if(u!=n&amp;&amp;v!=1)
				add(u,v,E[i][j].c);
			}
		}
	}
// 	for(int i=0;i&lt;edges.size();i++)if(i%2==0)
//	printf("#%d  %d -&gt; %d  cap:%d\n",
//	i,edges[i].u,edges[i].v,edges[i].cap);
	s=1;t=n;
	cout&lt;&lt;d1[n]&lt;&lt;endl;
	cout&lt;&lt;Dinic()&lt;&lt;endl;
	return 0;
}  <pre><h2>Problem1266</h2><pre>/*
	ID:zky
	OJ:BZOJ
	Index:1066
	Language:C++
*/
#include&lt;queue&gt;  
#include&lt;vector&gt;  
#include&lt;cstdio&gt;  
#include&lt;cstring&gt;  
#include&lt;climits&gt;  
#include&lt;iostream&gt;  
#include&lt;algorithm&gt;  
#define clear(x) memset(x,0,sizeof(x))  
#define inf(x) memset(x,0x7f,sizeof(x))  
#define Size G[u].size()  
#define read3(x,y,z) scanf("%d%d%d",&amp;x,&amp;y,&amp;z)  
#define read4(x,y,z,w) scanf("%d%d%d%d",&amp;x,&amp;y,&amp;z,&amp;w)  
using namespace std;  
int s,t;  
int n,m,k;  
const int INF=INT_MAX;  
struct edge{  
    int u,v,cap,flow;  
};  
const int maxn=510;
const int maxm=124760;
vector&lt;edge&gt;edges;  
vector&lt;int&gt;G[maxn];  
int d[maxn];  
int cur[maxn];  
int vis[maxn];  
int prev[maxn];  
void add(int u,int v,int cap){  
    edges.push_back((edge){u,v,cap,0});  
    G[u].push_back(edges.size()-1);  
    edges.push_back((edge){v,u,0,0});  
    G[v].push_back(edges.size()-1);  
}  
bool bfs(){  
    clear(d);clear(vis);  
    queue&lt;int&gt;q;  
    q.push(s);  
    vis[s]=1;  
    while(!q.empty()){  
        int u=q.front();q.pop();  
        for(int i=0;i&lt;Size;i++){  
            edge &amp;e=edges[G[u][i]];  
            if(!vis[e.v]&amp;&amp;e.cap&gt;e.flow){  
                vis[e.v]=1;  
                d[e.v]=d[u]+1;  
                q.push(e.v);      
            }  
        }  
    }  
    return vis[t];  
}  
int dfs(int x,int a){  
    if(x==t||a==0)return a;  
    int flow=0,f;  
    for(int &amp;i=cur[x];i&lt;G[x].size();i++){  
        edge &amp;e=edges[G[x][i]];  
        if(d[e.v]==d[x]+1&amp;&amp;(f=dfs(e.v,min(a,e.cap-e.flow)))&gt;0){  
            flow+=f;  
            e.flow+=f;  
            edges[G[x][i]^1].flow-=f;  
            a-=f;  
            if(!a)break;  
        }  
    }  
    return flow;  
}  
int Dinic(){  
    int flow=0;  
    while(bfs()){  
        clear(cur);  
        int x;  
        while(x=dfs(s,INF)){  
            flow+=x;  
        }  
    }  
    return flow;
}
struct pii{
	int first,second,c;
	pii(int _x=0,int _y=0,int _c=0){
		first=_x;second=_y;c=_c;
	}
};
vector&lt;pii&gt;E[maxn];
int tot=0;
void add2(int u,int v,int w,int c){
	E[u].push_back(pii(v,w,c));
	E[v].push_back(pii(u,w,c));
}
int d1[maxn];
int d2[maxn];
void spfa1(){
	memset(d1,0x7f,sizeof(d1));
	memset(vis,0,sizeof(vis));
	d1[1]=0;
	queue&lt;int&gt;q;q.push(1);vis[1]=1;
	while(!q.empty()){
		int u=q.front();q.pop();vis[u]=0;
		for(int i=0;i&lt;E[u].size();i++){
			int v=E[u][i].first,w=E[u][i].second;
			if(d1[v]&gt;d1[u]+w){
				d1[v]=d1[u]+w;
				if(!vis[v]){
					vis[v]=1;
					q.push(v);
				}
			}
		}
	}
}
void spfa2(){
	memset(d2,0x7f,sizeof(d2));
	memset(vis,0,sizeof(vis));
	d2[n]=0;
	queue&lt;int&gt;q;q.push(n);vis[n]=1;
	while(!q.empty()){
		int u=q.front();q.pop();vis[u]=0;
		for(int i=0;i&lt;E[u].size();i++){
			int v=E[u][i].first,w=E[u][i].second;
			if(d2[v]&gt;d2[u]+w){
				d2[v]=d2[u]+w;
				if(!vis[v]){
					vis[v]=1;
					q.push(v);
				}
			}
		}
	}
}
int getint(){
	int res=0,ok=0;char ch;
	while(1){
		ch=getchar();
		if(ch&lt;='9'&amp;&amp;ch&gt;='0'){
			res*=10;res+=ch-'0';ok=1;
		}else if(ok)break;
	}return res;
}
int main(){
	n=getint();m=getint();
	for(int i=0;i&lt;m;i++){
		int u=getint(),v=getint(),w=getint(),c=getint();
		add2(u,v,w,c);
	}
	spfa1();
	spfa2();
	for(int i=1;i&lt;=n;i++){
		for(int j=0;j&lt;E[i].size();j++){
			int u=i,v=E[i][j].first,w=E[i][j].second;
			if(d1[u]+d2[v]+w==d1[n]){
				if(u!=n&amp;&amp;v!=1)
				add(u,v,E[i][j].c);
			}
		}
	}
// 	for(int i=0;i&lt;edges.size();i++)if(i%2==0)
//	printf("#%d  %d -&gt; %d  cap:%d\n",
//	i,edges[i].u,edges[i].v,edges[i].cap);
	s=1;t=n;
	cout&lt;&lt;d1[n]&lt;&lt;endl;
	cout&lt;&lt;Dinic()&lt;&lt;endl;
	return 0;
}  <pre><h2>Problem1269</h2><pre>#include &lt;cstdio&gt;
#include &lt;ext/rope&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
using namespace __gnu_cxx;
crope a,b,tmp;
char s[10];
int now,n,len,size;
char str[2000000],rstr[2000000];
int main(){
	scanf("%d",&amp;n);
	while(n--){
		scanf("%s",s);
		switch(s[0]){
			case 'M':{scanf("%d",&amp;now);break;}
			case 'P':{now--;break;}
			case 'N':{now++;break;}
			case 'G':{putchar(a[now]);putchar('\n');break;}
			case 'I':{
				scanf("%d",&amp;size);
				len=a.length();
				for(int i=0;i&lt;size;i++){
					do{str[i]=getchar();}
					while(str[i]=='\n');
					rstr[size-i-1]=str[i];
				}
				rstr[size]=str[size]='\0';
				a.insert(now,str);
				b.insert(len-now,rstr);
				break;
			}
			case 'D':{
				scanf("%d",&amp;size);
				len=a.length();
				a.erase(now,size);
				b.erase(len-now-size,size);
				break;
			}
			case 'R':{
				scanf("%d",&amp;size);
				len=a.length();
				tmp=a.substr(now,size);
				a=a.substr(0,now)+b.substr(len-now-size,size)+a.substr(now+size,len-now-size);
				b=b.substr(0,len-now-size)+tmp+b.substr(len-now,now);				
				break;
			}
		}		
	}
	return 0;
}
<pre><h2>Problem1270</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=2004;
int a[maxn][maxn];
int f[maxn][maxn];
int mx[maxn];
int n,h,dt;
int main(){
	scanf("%d%d%d",&amp;n,&amp;h,&amp;dt);
	for(int i=1;i&lt;=n;i++){
		int nn;scanf("%d",&amp;nn);
		for(int j=1;j&lt;=nn;j++){
			int x;scanf("%d",&amp;x);
			a[i][x]++;
		}
	}
	for(int j=h;j&gt;=0;j--)
	for(int i=1;i&lt;=n;i++){
		f[i][j]=max(f[i][j],f[i][j+1]);
		if(j+dt&lt;=h)f[i][j]=max(f[i][j],mx[j+dt]);
		f[i][j]+=a[i][j];
		mx[j]=max(mx[j],f[i][j]);
	}cout&lt;&lt;mx[0]&lt;&lt;endl;
	return 0;
}<pre><h2>Problem1271</h2><pre>#include &lt;cstdio&gt;
#include &lt;climits&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
typedef long long lld;
lld s[200001],e[200001],d[200001];
lld tot=0;
lld n,m,T;
lld l,r,mid;
bool ok(){
	lld cnt=0;
	for(lld i=1;i&lt;=n;i++){
		lld t=min(mid,(lld)e[i]);
		if(t&gt;=s[i])
		cnt+=(t-s[i])/d[i]+1;
	}
	return cnt&amp;1;
}
int main(){
	cin&gt;&gt;T;
	while(T--){
		cin&gt;&gt;n;
		for(lld i=1;i&lt;=n;i++)
		cin&gt;&gt;s[i]&gt;&gt;e[i]&gt;&gt;d[i];
		l=0;r=INT_MAX+1LL;
		while(l&lt;r){
			mid=(l+r)/2;
			if(ok())
				r=mid;
			else
				l=mid+1;
		}
		if(l==INT_MAX+1LL){
			puts("Poor QIN Teng:(");
			continue;
		}
		lld ans=0;
		for(lld i=1;i&lt;=n;i++){
			if(s[i]&lt;=l&amp;&amp;l&lt;=e[i]&amp;&amp;(l-s[i])%d[i]==0)
				ans++;
		}
		cout&lt;&lt;l&lt;&lt;" "&lt;&lt;ans&lt;&lt;endl;
	}	
	return 0;
}<pre><h2>Problem1278</h2><pre>#include&lt;bits/stdc++.h&gt;
#define next(i) (i+1&lt;=n?i+1:1)
using namespace std;
const int maxn=1e5+5;
typedef long long LL;
struct point{
	LL x,y;
	point(LL x=0,LL y=0):x(x),y(y){}
	point operator+(point oth){return point(x+oth.x,y+oth.y);}
	point operator-(point oth){return point(x-oth.x,y-oth.y);}
	LL operator*(point oth){return x*oth.y-y*oth.x;}
	LL operator^(point oth){return x*oth.x+y*oth.y;}
	double rad(){
		double r=atan2(y,x);
		return r;
	}
	LL len(){return x*x+y*y;}
}p[maxn];
bool cmp(point A,point B){
	return A.rad()&lt;B.rad();
}
bool half(point A,point B){
	if(A*B&gt;0)return 1;
	if(A*B&lt;0)return 0;
	if((A^B)&gt;=0)return 1;
	return 0;
}
int n;
int dcmp(double x){return (x&gt;1e-8)-(x&lt;-1e-8);}
int main(){
	scanf("%d",&amp;n);
	int m=0;
	for(int i=1;i&lt;=n;i++){
		int x,y;scanf("%d%d",&amp;x,&amp;y);
		if(x||y)m++,p[m].x=x,p[m].y=y;
	}n=m;
	sort(p+1,p+1+n,cmp);
	m=1;
	for(int i=2;i&lt;=n;i++){
		if(!dcmp(p[m].rad()-p[i].rad()))p[m]=p[m]+p[i];
		else p[++m]=p[i];
	}n=m;
	LL ans=0;point cur=p[1];
	for(int i=1,j=2;i&lt;=n;){
		ans=max(ans,cur.len());
		while(i!=j&amp;&amp;half(p[i],p[j]))
			cur=cur+p[j],j=next(j),ans=max(ans,cur.len());
		cur=cur-p[i];
		i++;if(i==j)cur=p[i],j=next(j);
	}printf("%lld.000\n",ans);
	return 0;
}<pre><h2>Problem1278</h2><pre>#include&lt;bits/stdc++.h&gt;
#define next(i) (i+1&lt;=n?i+1:1)
using namespace std;
const int maxn=1e5+5;
typedef long long LL;
struct point{
	LL x,y;
	point(LL x=0,LL y=0):x(x),y(y){}
	point operator+(point oth){return point(x+oth.x,y+oth.y);}
	point operator-(point oth){return point(x-oth.x,y-oth.y);}
	LL operator*(point oth){return x*oth.y-y*oth.x;}
	LL operator^(point oth){return x*oth.x+y*oth.y;}
	double rad(){
		double r=atan2(y,x);
		return r;
	}
	LL len(){return x*x+y*y;}
}p[maxn];
bool cmp(point A,point B){
	return A.rad()&lt;B.rad();
}
bool half(point A,point B){
	if(A*B&gt;0)return 1;
	if(A*B&lt;0)return 0;
	if((A^B)&gt;=0)return 1;
	return 0;
}
int n;
int dcmp(double x){return (x&gt;1e-8)-(x&lt;-1e-8);}
int main(){
	scanf("%d",&amp;n);
	int m=0;
	for(int i=1;i&lt;=n;i++){
		int x,y;scanf("%d%d",&amp;x,&amp;y);
		if(x||y)m++,p[m].x=x,p[m].y=y;
	}n=m;
	sort(p+1,p+1+n,cmp);
	m=1;
	for(int i=2;i&lt;=n;i++){
		if(!dcmp(p[m].rad()-p[i].rad()))p[m]=p[m]+p[i];
		else p[++m]=p[i];
	}n=m;
	LL ans=0;point cur=p[1];
	for(int i=1,j=2;i&lt;=n;){
		ans=max(ans,cur.len());
		while(i!=j&amp;&amp;half(p[i],p[j]))
			cur=cur+p[j],j=next(j);ans=max(ans,cur.len());
		cur=cur-p[i];
		i++;if(i==j)cur=p[i],j=next(j);
	}printf("%lld.000\n",ans);
	return 0;
}<pre><h2>Problem1283</h2><pre>#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;

const int MAX_N = 1000;
const int MAX_M = 100;

const int INF = ~0U &gt;&gt; 2;
struct Network {
	static const int MAX_N_VETS = MAX_N * 2 + 2;
	static const int MAX_N_EDGES = 1000000;
	int head[MAX_N_EDGES], dest[MAX_N_EDGES], next[MAX_N_EDGES],
			cap[MAX_N_EDGES], cost[MAX_N_EDGES];
	int nVets, nEdges;
	int vs, vt;

	void init(int _nVets, int _vs, int _vt) {
		nVets = _nVets;
		nEdges = 0;
		memset(head, -1, sizeof head);
		vs = _vs;
		vt = _vt;
	}

	void makeEdge(int s, int t, int f, int c) {
		int id = nEdges++;
		next[id] = head[s];
		dest[id] = t;
		cap[id] = f;
		cost[id] = c;
		head[s] = id;
	}

	void addEdge(int s, int t, int f, int c) {
		makeEdge(s, t, f, c);
		makeEdge(t, s, 0, -c);
	}

	int que[MAX_N_VETS], qh, qt;
	bool inQ[MAX_N_VETS];
	void inc(int&amp;iter) {
		if (++iter == MAX_N_VETS)
			iter = 0;
	}
	void add(int x) {
		if (inQ[x])
			return;
		inQ[x] = true;
		que[qt] = x;
		inc(qt);
	}

	int get() {
		int t = que[qh];
		inQ[t] = false;
		inc(qh);
		return t;
	}
	int prev[MAX_N_VETS];
	int dist[MAX_N_VETS];
	int minCost;
	int totalFlow;

	bool spfa() {
		fill(dist, dist + nVets, INF);
		dist[vs] = 0;
		add(vs);
		while (qh != qt) {
			int u = get();
			for (int e = head[u]; e != -1; e = next[e])
				if (cap[e] &gt; 0) {
					int v = dest[e];
					int ndist = dist[u] + cost[e];
					if (ndist &lt; dist[v]) {
						prev[v] = e;
						dist[v] = ndist;
						add(v);
					}
				}
		}

		if (dist[vt] == INF)
			return false;

		int minCap = INF;
		{
			int at = vt;
			while (at != vs) {
				minCap = min(minCap, cap[prev[at]]);
				at = dest[prev[at] ^ 1];
			}
		}
		{
			int at = vt;
			while (at != vs) {
				cap[prev[at]] -= minCap;
				cap[prev[at] ^ 1] += minCap;
				at = dest[prev[at] ^ 1];
			}
		}
		minCost += minCap * dist[vt];
		totalFlow += minCap;
		return true;
	}

	int calcMinCostFlow() {
		minCost = 0;
		qh = qt = 0;
		memset(inQ, false, sizeof inQ);
		while (spfa())
			;
		return minCost;
	}
};

Network network;

int n, m, k;
int main() {
	cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;
	int nV = n;
	int vs = nV++, vt = nV++;
	network.init(nV, vs, vt);
	for (int i = 0; i &lt; n; ++i) {
		int c;
		scanf("%d", &amp;c);
		int next = i + 1 == n ? vt : i + 1;
		network.addEdge(i, next, INF, 0);
		int after = i + m;
		if (after &gt;= n)
			after = vt;
		network.addEdge(i, after, 1, -c);
	}
	network.addEdge(vs, 0, k, 0);
	int ans = -network.calcMinCostFlow();
	cout &lt;&lt; ans &lt;&lt; endl;
}<pre><h2>Problem1293</h2><pre>#include&lt;cstdio&gt;
#include&lt;queue&gt;
#include&lt;vector&gt;
#include&lt;climits&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
int n,k;
vector&lt;int&gt;a[61];
int pos[61];
struct Pig{
	int x,c,i;
	Pig(int a=0,int b=0,int in=0):
	x(a),c(b),i(in){}
	bool operator&lt;(const Pig  &amp;a)const{
		return x&gt;a.x;
	}
};
priority_queue&lt;Pig,vector&lt;Pig&gt; &gt;q;
int main(){
	cin&gt;&gt;n&gt;&gt;k;
	int t;
	for(int i=1;i&lt;=k;i++){
		cin&gt;&gt;t;
		a[i].resize(t+2);
		a[i][0]=t;
		for(int j=1;j&lt;=a[i][0];j++){cin&gt;&gt;a[i][j];}
		a[i][a[i][0]+1]=INT_MAX;
	}
	int maxx=0;
	int ans=INT_MAX;
	for(int i=1;i&lt;=k;i++){q.push(Pig(a[i][1],i,1));maxx=max(maxx,a[i][1]);pos[i]=1;}
	while(1){
		ans=min(ans,maxx-q.top().x);
		Pig t=q.top();q.pop();
		Pig next(a[t.c][t.i+1],t.c,t.i+1);
		maxx=max(maxx,next.x);
		if(maxx==INT_MAX)break;
		q.push(next);
	}
	cout&lt;&lt;ans&lt;&lt;endl;
return 0;	
}
<pre><h2>Problem1293</h2><pre>#include&lt;bits/stdc++.h&gt;
#define fst first
#define sec second
using namespace std;
const int maxn=1e6+5;
typedef pair&lt;int,int&gt; par;
int n,k,tot,ans=INT_MAX;
int T[61],cnt[61],col;
par a[maxn];
int main(){
	scanf("%d%d",&amp;n,&amp;k);
	for(int i=1;i&lt;=k;i++){
		scanf("%d",&amp;T[i]);
		for(int j=1;j&lt;=T[i];j++){
			tot++;
			scanf("%d",&amp;a[tot].fst);
			a[tot].sec=i;
		}
	}sort(a+1,a+1+n);
	for(int i=1,j=1;i&lt;=n&amp;&amp;j&lt;=n;){
		while(i&lt;=n&amp;&amp;col!=k)col+=!cnt[a[i++].sec]++;
		while(j&lt;=n&amp;&amp;col==k){
			ans=min(ans,a[i-1].fst-a[j].fst);
			col-=!--cnt[a[j++].sec];
		}
	}cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}<pre><h2>Problem1296</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
int n,m,p;
int g[52][52][52]={0};
int f[52][2501]={0};
int sum[52][52][2]={0};
char s[52]={0};
int main(){
    scanf("%d %d %d\n",&amp;n,&amp;m,&amp;p);
    for (int i=1;i&lt;=n;i++){
        char x;
		for (int j=1;j&lt;=m;j++){
            x=getchar();
            sum[i][j][0]=sum[i][j-1][0]+(x=='0');
            sum[i][j][1]=sum[i][j-1][1]+(x=='1');
        }
        x=getchar();
    }
	
	for(int i=1;i&lt;=n;i++)
	for(int j=1;j&lt;=m;j++)
	for(int k=1;k&lt;=j;k++){
		g[i][j][k]=g[i][j-1][k];
        for (int l=0;l&lt;j;l++) 
        g[i][j][k]=max(g[i][j][k],g[i][l][k-1]
		+max(sum[i][j][0]-sum[i][l][0],sum[i][j][1]-sum[i][l][1]));
	}
	int ans=0;
    for (int i=1;i&lt;=n;i++)
    for (int j=1;j&lt;=p;j++)
    {
        f[i][j]=f[i-1][j];
        for (int k=1;k&lt;=j&amp;&amp;k&lt;=m;k++)
			 f[i][j]=max(f[i][j],f[i-1][j-k]+g[i][m][k]);
    }
    for (int i=1;i&lt;=p;i++) ans=max(ans,f[n][i]);
    printf("%d\n",ans);
	return 0;
}<pre><h2>Problem1296</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
int n,m,p;
int g[52][52][52]={0};
int f[52][2501]={0};
int sum[52][52][2]={0};
char s[52]={0};
int main(){
    scanf("%d %d %d\n",&amp;n,&amp;m,&amp;p);
    for (int i=1;i&lt;=n;i++){
        char x;
		for (int j=1;j&lt;=m;j++){
            x=getchar();
            sum[i][j][0]=sum[i][j-1][0]+(x=='0');
            sum[i][j][1]=sum[i][j-1][1]+(x=='1');
        }
        x=getchar();
    }
	
	for(int i=1;i&lt;=n;i++)
	for(int j=1;j&lt;=m;j++)
	for(int k=1;k&lt;=j;k++){
	//	g[i][j][k]=g[i][j-1][k];
        for (int l=0;l&lt;j;l++) 
        g[i][j][k]=max(g[i][j][k],g[i][l][k-1]
		+max(sum[i][j][0]-sum[i][l][0],sum[i][j][1]-sum[i][l][1]));
	}
	int ans=0;
    for (int i=1;i&lt;=n;i++)
    for (int j=1;j&lt;=p;j++)
    {
     //   f[i][j]=f[i-1][j];
        for (int k=1;k&lt;=j&amp;&amp;k&lt;=m;k++)
			 f[i][j]=max(f[i][j],f[i-1][j-k]+g[i][m][k]);
    }
    for (int i=1;i&lt;=p;i++) ans=max(ans,f[n][i]);
    printf("%d\n",ans);
	return 0;
}<pre><h2>Problem1299</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
int a[14];
int n;
bool calc(int S){
	int ans=0;
	for(int i=0;i&lt;n;i++)if(S&gt;&gt;i&amp;1)ans^=a[i];
	return ans==0;
}
void sol(){
	cin&gt;&gt;n;
	for(int i=0;i&lt;n;i++)cin&gt;&gt;a[i];
	int flag=0;
	for(int S=1;S&lt;(1&lt;&lt;n);S++){
		if(calc(S)){flag=1;break;}
	}puts(flag?"NO":"YES");
}
int main(){
	int T=10;
	while(T--)sol();
	return 0;
}<pre><h2>Problem1303</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
int a[100001];
int n,b;
int hash1[200001];
int hash2[200001];
int main(){
	cin&gt;&gt;n&gt;&gt;b;
	int pos=0;
	int x;
	for(int i=1;i&lt;=n;i++){
		cin&gt;&gt;x;
		if(x==b){
			a[i]=0;
			pos=i;
		}
		if(x&gt;b)a[i]=1;
		if(x&lt;b)a[i]=-1;
	}
	
	int s=n;
	hash1[n]=hash2[n]=1;
	for(int i=pos-1;i&gt;=1;i--){
		s+=a[i];
		hash1[s]++;
	}
	s=n;
	for(int i=pos+1;i&lt;=n;i++){
		s+=a[i];
		hash2[s]++;
	}
	long long ans=0;
	for(int i=0;i&lt;=2*n;i++)
	ans+=hash1[i]*hash2[2*n-i];
	cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}<pre><h2>Problem1305</h2><pre>#include&lt;queue&gt;  
#include&lt;vector&gt;  
#include&lt;cstdio&gt;  
#include&lt;cstring&gt;  
#include&lt;climits&gt;  
#include&lt;iostream&gt;  
#include&lt;algorithm&gt;  
#define clear(x) memset(x,0,sizeof(x))  
#define inf(x) memset(x,0x7f,sizeof(x))  
#define Size G[u].size()  
#define read3(x,y,z) scanf("%d%d%d",&amp;x,&amp;y,&amp;z)  
#define read4(x,y,z,w) scanf("%d%d%d%d",&amp;x,&amp;y,&amp;z,&amp;w)  
using namespace std;  
int s,t;  int n,m,k;  const int INF=INT_MAX;  struct edge{  int u,v,cap,flow,cost;  };  vector&lt;edge&gt;edges;  vector&lt;vector&lt;int&gt; &gt;G;  int d[1001];  
int cur[1001];  int vis[1001];  int prev[1001];  
void add(int u,int v,int cap){  edges.push_back((edge){u,v,cap,0});  
G[u].push_back(edges.size()-1); edges.push_back((edge){v,u,0,0});  G[v].push_back(edges.size()-1);  }  bool bfs(){  clear(d);clear(vis); queue&lt;int&gt;q;  q.push(s);  vis[s]=1;  
while(!q.empty()){  int u=q.front();q.pop();  for(int i=0;i&lt;Size;i++){  edge &amp;e=edges[G[u][i]];  if(!vis[e.v]&amp;&amp;e.cap&gt;e.flow){  vis[e.v]=1;  d[e.v]=d[u]+1;  
q.push(e.v);  }  }  }  return vis[t];  } int dfs(int x,int a){  if(x==t||a==0)return a;  int flow=0,f;  for(int &amp;i=cur[x];i&lt;G[x].size();i++){  edge &amp;e=edges[G[x][i]];  if(d[e.v]==d[x]+1&amp;&amp;(f=dfs(e.v,min(a,e.cap-e.flow)))&gt;0){  flow+=f;  e.flow+=f;  
edges[G[x][i]^1].flow-=f;  a-=f;  if(!a)break;  }  }  return flow;  }  
void Dinic(){  int flow=0;  while(bfs()){  clear(cur);  int x;  while(x=dfs(s,INF)){  flow+=x;  }  }  }  int cnt[1100];int E[100001];
int main(){
cin&gt;&gt;n&gt;&gt;k;G.resize(n*2+11);
string str;for(int i=1;i&lt;=n;i++){cin&gt;&gt;str;for(int j=0;j&lt;str.length();j++){if(str[j]=='Y'){cnt[i]++;cnt[j+1+n]++;}}}
s=0;t=n*2+1;for(int i=1;i&lt;=n;i++){add(s,i,k+cnt[i]);E[++E[0]]=edges.size()-2;for(int j=n+1;j&lt;=n*2;j++)add(i,j,1);}for(int i=n+1;i&lt;=n*2;i++){add(i,t,cnt[i]+k);E[++E[0]]=edges.size()-2;}
Dinic();int minn=INF;for(int i=1;i&lt;=E[0];i++)minn=min(minn,edges[E[i]].flow);cout&lt;&lt;minn&lt;&lt;endl;return 0;}
<pre><h2>Problem1306</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
using namespace std;
int n;
int sor[9];
int nowsor[9];
int mp[9][9];
int ans=0;
bool ok(){
	for(int i=1;i&lt;=n;i++)
	if(sor[i]!=nowsor[i])
	return false;
	return true;
}
void dfs(int a,int b){
	

	      
	if(a&gt;=n){
		if(ok()){
			ans++;
			//for(int i=1;i&lt;=n;i++)
			//for(int j=1;j&lt;=n;j++)
			//printf("%d%c",mp[i][j]," \n"[j==n]);
			//puts("");
		}
		return;
	}
	

	
	
	int i=b+1;
	
	if(i==n){
		int k=sor[a]-nowsor[a];
		if(k==0){
			nowsor[a]+=0;nowsor[i]+=3;
			mp[a][i]=0;mp[i][a]=3;
			if(nowsor[a]&lt;=sor[a]&amp;&amp;nowsor[i]&lt;=sor[i]
				&amp;&amp;nowsor[a]+3*(n-i)&gt;=sor[a]
				&amp;&amp;nowsor[i]+3*(n-a)&gt;=sor[i])
			dfs(a+1,a+1);
			nowsor[a]-=0;nowsor[i]-=3;			
		}else
		if(k==1){
			nowsor[a]+=1;nowsor[i]+=1;
			mp[a][i]=1;mp[i][a]=1;
			if(nowsor[a]&lt;=sor[a]&amp;&amp;nowsor[i]&lt;=sor[i]
				&amp;&amp;nowsor[a]+3*(n-i)&gt;=sor[a]
				&amp;&amp;nowsor[i]+3*(n-a)&gt;=sor[i])
			dfs(a+1,a+1);
			nowsor[a]-=1;nowsor[i]-=1;				
		}else
		if(k==3){
			nowsor[a]+=3; nowsor[i]+=0;
			mp[a][i]=3;   mp[i][a]=0;
			if(nowsor[a]&lt;=sor[a]&amp;&amp;nowsor[i]&lt;=sor[i]
				&amp;&amp;nowsor[a]+3*(n-i)&gt;=sor[a]
				&amp;&amp;nowsor[i]+3*(n-a)&gt;=sor[i])
			dfs(a+1,a+1);
			nowsor[a]-=3; nowsor[i]-=0;			
		}
	
	}else{
		nowsor[a]+=1;nowsor[i]+=1;
		mp[a][i]=1;mp[i][a]=1;
		if(nowsor[a]&lt;=sor[a]&amp;&amp;nowsor[i]&lt;=sor[i]
			&amp;&amp;nowsor[a]+3*(n-i)&gt;=sor[a]
			&amp;&amp;nowsor[i]+3*(n-a)&gt;=sor[i])
		dfs(a,b+1);
		nowsor[a]-=1;nowsor[i]-=1;	
					
		nowsor[a]+=3; nowsor[i]+=0;
		mp[a][i]=3;   mp[i][a]=0;
		if(nowsor[a]&lt;=sor[a]&amp;&amp;nowsor[i]&lt;=sor[i]
			&amp;&amp;nowsor[a]+3*(n-i)&gt;=sor[a]
			&amp;&amp;nowsor[i]+3*(n-a)&gt;=sor[i])
		dfs(a,b+1);
		nowsor[a]-=3; nowsor[i]-=0;
		
	
		
		nowsor[a]+=0;nowsor[i]+=3;
		mp[a][i]=0;mp[i][a]=3;
		if(nowsor[a]&lt;=sor[a]&amp;&amp;nowsor[i]&lt;=sor[i]
			&amp;&amp;nowsor[a]+3*(n-i)&gt;=sor[a]
			&amp;&amp;nowsor[i]+3*(n-a)&gt;=sor[i])
		dfs(a,b+1);
		nowsor[a]-=0;nowsor[i]-=3;
	}
	
	
}
int main(){
	scanf("%d",&amp;n);
	for(int i=1;i&lt;=n;i++)scanf("%d",&amp;sor[i]);
	dfs(1,1);
	cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}<pre><h2>Problem1306</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
using namespace std;
int n;
int sor[9];
int nowsor[9];
int mp[9][9];
int ans=0;
bool ok(){
	for(int i=1;i&lt;=n;i++)
	if(sor[i]!=nowsor[i])
	return false;
	return true;
}
void dfs(int a,int b){
	

	      
	if(a&gt;=n){
		if(ok()){
			ans++;
			//for(int i=1;i&lt;=n;i++)
			//for(int j=1;j&lt;=n;j++)
			//printf("%d%c",mp[i][j]," \n"[j==n]);
			//puts("");
		}
		return;
	}
	

	
	
	int i=b+1;
	
	if(i==n){
		int k=sor[a]-nowsor[a];
		if(k==0){
			nowsor[a]+=0;nowsor[i]+=3;
			mp[a][i]=0;mp[i][a]=3;
			if(nowsor[a]&lt;=sor[a]&amp;&amp;nowsor[i]&lt;=sor[i]
				&amp;&amp;nowsor[a]+3*(n-i)&gt;=sor[a]
				&amp;&amp;nowsor[i]+3*(n-a)&gt;=sor[i])
			dfs(a+1,a+1);
			nowsor[a]-=0;nowsor[i]-=3;			
		}else
		if(k==1){
			nowsor[a]+=1;nowsor[i]+=1;
			mp[a][i]=1;mp[i][a]=1;
			if(nowsor[a]&lt;=sor[a]&amp;&amp;nowsor[i]&lt;=sor[i]
				&amp;&amp;nowsor[a]+3*(n-i)&gt;=sor[a]
				&amp;&amp;nowsor[i]+3*(n-a)&gt;=sor[i])
			dfs(a+1,a+1);
			nowsor[a]-=1;nowsor[i]-=1;				
		}else
		if(k==3){
			nowsor[a]+=3; nowsor[i]+=0;
			mp[a][i]=3;   mp[i][a]=0;
			if(nowsor[a]&lt;=sor[a]&amp;&amp;nowsor[i]&lt;=sor[i]
				&amp;&amp;nowsor[a]+3*(n-i)&gt;=sor[a]
				&amp;&amp;nowsor[i]+3*(n-a)&gt;=sor[i])
			dfs(a+1,a+1);
			nowsor[a]-=3; nowsor[i]-=0;			
		}
	
	}else{
		nowsor[a]+=3; nowsor[i]+=0;
		mp[a][i]=3;   mp[i][a]=0;
		if(nowsor[a]&lt;=sor[a]&amp;&amp;nowsor[i]&lt;=sor[i]
			&amp;&amp;nowsor[a]+3*(n-i)&gt;=sor[a]
			&amp;&amp;nowsor[i]+3*(n-a)&gt;=sor[i])
		dfs(a,b+1);
		nowsor[a]-=3; nowsor[i]-=0;	
		
			
		nowsor[a]+=1;nowsor[i]+=1;
		mp[a][i]=1;mp[i][a]=1;
		if(nowsor[a]&lt;=sor[a]&amp;&amp;nowsor[i]&lt;=sor[i]
			&amp;&amp;nowsor[a]+3*(n-i)&gt;=sor[a]
			&amp;&amp;nowsor[i]+3*(n-a)&gt;=sor[i])
		dfs(a,b+1);
		nowsor[a]-=1;nowsor[i]-=1;	
					

		
	
		
		nowsor[a]+=0;nowsor[i]+=3;
		mp[a][i]=0;mp[i][a]=3;
		if(nowsor[a]&lt;=sor[a]&amp;&amp;nowsor[i]&lt;=sor[i]
			&amp;&amp;nowsor[a]+3*(n-i)&gt;=sor[a]
			&amp;&amp;nowsor[i]+3*(n-a)&gt;=sor[i])
		dfs(a,b+1);
		nowsor[a]-=0;nowsor[i]-=3;
	}
	
	
}
int main(){
	scanf("%d",&amp;n);
	for(int i=1;i&lt;=n;i++)scanf("%d",&amp;sor[i]);
	dfs(1,1);
	cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}<pre><h2>Problem1306</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
using namespace std;
int n;
int sor[9];
int nowsor[9];
int mp[9][9];
int ans=0;
bool ok(){
	for(int i=1;i&lt;=n;i++)
	if(sor[i]!=nowsor[i])
	return false;
	return true;
}
inline void dfs(int a,int b){
	

	      
	if(a&gt;=n){
		if(sor[n]==nowsor[n])
		ans++;
		return;
	}
	

	
	
	int i=b+1;
	
	if(i==n){
		int k=sor[a]-nowsor[a];
		if(k==0){
			nowsor[a]+=0;nowsor[i]+=3;
			mp[a][i]=0;mp[i][a]=3;
			if(nowsor[a]&lt;=sor[a]&amp;&amp;nowsor[i]&lt;=sor[i]
				&amp;&amp;nowsor[a]+3*(n-i)&gt;=sor[a]
				&amp;&amp;nowsor[i]+3*(n-a)&gt;=sor[i])
			dfs(a+1,a+1);
			nowsor[a]-=0;nowsor[i]-=3;			
		}else
		if(k==1){
			nowsor[a]+=1;nowsor[i]+=1;
			mp[a][i]=1;mp[i][a]=1;
			if(nowsor[a]&lt;=sor[a]&amp;&amp;nowsor[i]&lt;=sor[i]
				&amp;&amp;nowsor[a]+3*(n-i)&gt;=sor[a]
				&amp;&amp;nowsor[i]+3*(n-a)&gt;=sor[i])
			dfs(a+1,a+1);
			nowsor[a]-=1;nowsor[i]-=1;				
		}else
		if(k==3){
			nowsor[a]+=3; nowsor[i]+=0;
			mp[a][i]=3;   mp[i][a]=0;
			if(nowsor[a]&lt;=sor[a]&amp;&amp;nowsor[i]&lt;=sor[i]
				&amp;&amp;nowsor[a]+3*(n-i)&gt;=sor[a]
				&amp;&amp;nowsor[i]+3*(n-a)&gt;=sor[i])
			dfs(a+1,a+1);
			nowsor[a]-=3; nowsor[i]-=0;			
		}
	
	}else{
		nowsor[a]+=3; nowsor[i]+=0;
		mp[a][i]=3;   mp[i][a]=0;
		if(nowsor[a]&lt;=sor[a]&amp;&amp;nowsor[i]&lt;=sor[i]
			&amp;&amp;nowsor[a]+3*(n-i)&gt;=sor[a]
			&amp;&amp;nowsor[i]+3*(n-a)&gt;=sor[i])
		dfs(a,b+1);
		nowsor[a]-=3; nowsor[i]-=0;	
		




			
		nowsor[a]+=1;nowsor[i]+=1;
		mp[a][i]=1;mp[i][a]=1;
		if(nowsor[a]&lt;=sor[a]&amp;&amp;nowsor[i]&lt;=sor[i]
			&amp;&amp;nowsor[a]+3*(n-i)&gt;=sor[a]
			&amp;&amp;nowsor[i]+3*(n-a)&gt;=sor[i])
		dfs(a,b+1);
		nowsor[a]-=1;nowsor[i]-=1;	
					

		nowsor[a]+=0;nowsor[i]+=3;
		mp[a][i]=0;mp[i][a]=3;
		if(nowsor[a]&lt;=sor[a]&amp;&amp;nowsor[i]&lt;=sor[i]
			&amp;&amp;nowsor[a]+3*(n-i)&gt;=sor[a]
			&amp;&amp;nowsor[i]+3*(n-a)&gt;=sor[i])
		dfs(a,b+1);
		nowsor[a]-=0;nowsor[i]-=3;
	}
	
	
}
int main(){
	scanf("%d",&amp;n);
	for(int i=1;i&lt;=n;i++)scanf("%d",&amp;sor[i]);
	dfs(1,1);
	cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}<pre><h2>Problem1307</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1e6+5;
int n;
int getint(){
	int res=0;char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))res=res*10+c-'0',c=getchar();
	return res;
}
int a[maxn];
int main(){
	n=getint();for(int i=1;i&lt;=n;i++)a[i]=getint();
	cout&lt;&lt;*max_element(a+1,a+1+n)&lt;&lt;endl;
	return 0;
}<pre><h2>Problem1313</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=233;
int s,t;
struct edge{int u,v,ca,fl,co;};
vector&lt;edge&gt;E;
vector&lt;int&gt;G[maxn];
void add(int u,int v,int ca,int co){
    E.push_back((edge){u,v,ca,0,co});
    G[u].push_back(E.size()-1);
    E.push_back((edge){v,u,0,0,-co});
    G[v].push_back(E.size()-1);
}
int cost,flow=0;
bool spfa(){
    static int vis[maxn],d[maxn],a[maxn],pre[maxn];
    memset(d,0x7f,sizeof d);int B=d[0];a[s]=INT_MAX;
    queue&lt;int&gt;q;q.push(s);vis[s]=1;d[s]=0;    
    while(!q.empty()){
        int u=q.front();q.pop();vis[u]=0;
        for(int i=0;i&lt;G[u].size();i++){
            edge e=E[G[u][i]];
            if(e.ca==e.fl||d[e.v]&lt;=d[u]+e.co)continue;
            a[e.v]=min(e.ca-e.fl,a[u]);pre[e.v]=G[u][i];
            d[e.v]=d[u]+e.co;if(!vis[e.v])q.push(e.v),vis[e.v]=1;
        }   
    }
    if(d[t]==B)return false;
    flow+=a[t];
    cost+=a[t]*d[t];
    int u=t;
    while(u!=s){
        E[pre[u]].fl+=a[t];
        E[pre[u]^1].fl-=a[t];
        u=E[pre[u]].u;
    }return true;
}
int n;
double a[101][101];
int main(){
    scanf("%d",&amp;n);
    for(int i=1;i&lt;=n;i++)
    for(int j=1;j&lt;=n;j++)scanf("%lf",&amp;a[i][j]);
    s=0;t=n*2+1;
    int sum=0,tmp;
    for(int i=1;i&lt;=n;i++)for(int j=1;j&lt;=n;j++)sum+=int(a[i][j]);
    for(int i=1;i&lt;n;i++)
    for(int j=1;j&lt;n;j++){
        tmp=(int)a[i][j];a[i][j]-=tmp;
        a[i][n]-=tmp;a[n][j]-=tmp;
        if(a[i][j]&gt;0)add(i,j+n,1,1);
    }
    for(int i=1;i&lt;n;i++){
        tmp=(int)a[i][n];add(s,i,tmp,0);
        if(tmp!=a[i][n])add(s,i,1,1);
        tmp=(int)a[n][i];add(i+n,t,tmp,0);
        if(tmp!=a[n][i])add(i+n,t,1,1);
    }
    while(spfa());
    cout&lt;&lt;cost+sum&lt;&lt;endl;
    return 0;
}<pre><h2>Problem1318</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1e6+5;
int n;
int getint(){
	int res=0;char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))res=res*10+c-'0',c=getchar();
	return res;
}
int a[maxn];
int main(){
	n=getint();for(int i=1;i&lt;=n;i++)a[i]=getint();
	cout&lt;&lt;*max_element(a+1,a+1+n)&lt;&lt;endl;
	return 0;
}<pre><h2>Problem1319</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
LL p,k,a,g;
vector&lt;LL&gt;vec;
LL exgcd(LL a,LL b,LL &amp;x,LL &amp;y){
	if(!b){
		x=1;y=0;
		return a;	
	}
	LL d=exgcd(b,a%b,x,y);
	LL t=x;x=y;y=t-a/b*y;
	return d;
}
LL pw(LL x,LL k,LL p){
	LL ans=1;
	for(;k;k&gt;&gt;=1){
		if(k&amp;1)ans=ans*x%p;
		x=x*x%p;
	}return ans;
}
LL BSGS(LL a,LL b,LL p){
	LL m=1;
	for(;m*m&lt;p;m++);
	map&lt;LL,int&gt;hash;
	LL v=pw(pw(a,m,p),p-2,p);
	hash[1]=0;LL _a=a;
	for(int i=1;i&lt;m;i++){
		hash[a]=i;
		a=a*_a%p;
	}
	for(int i=0;i&lt;=m;i++){
		if(hash.count(b))	
			return hash[b]+i*m;
		b=b*v%p;
	}return -1;
}
bool check(int x){
	for(int i=0;i&lt;vec.size();i++)	
		if(pw(x,(p-1)/vec[i],p)==1)
			return 0;
	return 1;
}
LL getroot(){
	LL tmp=p-1;
	for(int i=2;i*i&lt;=tmp;i++){
		if(tmp%i==0){
			vec.push_back(i);
			while(tmp%i==0)tmp/=i;
		}
	}if(tmp&gt;1)vec.push_back(tmp);
	for(int i=2;i&lt;p;i++)
		if(check(i))return i;
	return -1;
}
vector&lt;LL&gt;anss;
void solve(LL a,LL b,LL c){
	LL x,y;
	LL d=exgcd(a,b,x,y);
	a/=d;b/=d;
	if(c%d){
		puts("0");
		return;
	}c/=d;x%=(b*d);
	x=(x+b*d)%(b*d);
	anss.push_back(x*c);
	for(int i=1;i&lt;d;i++)
		anss.push_back((anss[0]+b*i)%(b*d));
	for(int i=0;i&lt;anss.size();i++)
		anss[i]=pw(g,anss[i],p);
	printf("%d\n",anss.size());
	sort(anss.begin(),anss.end());
	for(int i=0;i&lt;anss.size();i++)
	printf("%lld\n",anss[i]);
}
int main(){
	cin&gt;&gt;p&gt;&gt;k&gt;&gt;a;
	if(a==0){
		puts("1");
		puts("0");
		return 0;
	}
	g=getroot();
	LL t=BSGS(g,a,p);
	solve(k,p-1,t);
	return 0;
}<pre><h2>Problem1322</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=205;
struct edge{int u,v,cap,flow;};
vector&lt;edge&gt;edges;
vector&lt;int&gt;G[maxn];
int s,t;
int cur[maxn],d[maxn];
void add(int u,int v,int cap){
//	printf("%d-&gt;%d cap:%d\n",u,v,cap);
	edges.push_back((edge){u,v,cap,0});
	G[u].push_back(edges.size()-1);
	edges.push_back((edge){v,u,0,0});
	G[v].push_back(edges.size()-1);
}
bool bfs(){
	static int vis[maxn];
	memset(vis,0,sizeof vis);vis[s]=1;
	queue&lt;int&gt;q;q.push(s);d[s]=0;
	while(!q.empty()){
		int u=q.front();q.pop();
		for(int i=0;i&lt;G[u].size();i++){
			edge e=edges[G[u][i]];if(vis[e.v]||e.cap==e.flow)continue;
			d[e.v]=d[u]+1;vis[e.v]=1;q.push(e.v);
		}
	}return vis[t];
}
int dfs(int u,int a){
	if(u==t||!a)return a;
	int flow=0,f;
	for(int &amp;i=cur[u];i&lt;G[u].size();i++){
		edge e=edges[G[u][i]];
		if(d[e.v]==d[u]+1&amp;&amp;(f=dfs(e.v,min(a,e.cap-e.flow)))&gt;0){
			edges[G[u][i]].flow+=f;
			edges[G[u][i]^1].flow-=f;
			flow+=f;a-=f;if(!a)break;
		}
	}return flow;
}
int dinic(){
	int flow=0,x;
	while(bfs()){
		memset(cur,0,sizeof cur);
		while(x=dfs(s,INT_MAX)){
			flow+=x;
			memset(cur,0,sizeof cur);
		}
	}return flow;
}
int n,m,win[maxn],wout[maxn];
int main(){
	scanf("%d%d",&amp;n,&amp;m);
	for(int i=1;i&lt;=n;i++)scanf("%d",&amp;win[i]);
	for(int i=1;i&lt;=n;i++)scanf("%d",&amp;wout[i]);
	s=0;t=201;
	for(int i=1;i&lt;=n;i++)add(s,i,wout[i]);
	for(int i=1;i&lt;=n;i++)add(i+n,t,win[i]);
	for(int i=1;i&lt;=m;i++){
		int u,v;scanf("%d%d",&amp;u,&amp;v);
		add(u,v+n,INT_MAX);
	}
//	for(int i=0;i&lt;edges.size();i++)if(i%2==0)
//	printf("%d-&gt;%d cap:%d\n",edges[i].u,edges[i].v,edges[i].cap);
	cout&lt;&lt;dinic()&lt;&lt;endl;
	return 0;
}<pre><h2>Problem1324</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;vector&gt;
#include&lt;climits&gt;
#include&lt;queue&gt;
using namespace std;
const int maxn=20010;
struct edge{
	int u,v,cap,flow;	
	edge(int _u=0,int _v=0,int _cap=0,int _flow=0):
		u(_u),v(_v),cap(_cap),flow(_flow){}
};
vector&lt;edge&gt;edges;
vector&lt;int&gt;G[maxn];
int cur[maxn],vis[maxn];
void add(int u,int v,int cap){
	edges.push_back(edge(u,v,cap,0));
	G[u].push_back(edges.size()-1);
	edges.push_back(edge(v,u,0,0));	
	G[v].push_back(edges.size()-1);	
}
int d[maxn],s,t;
bool bfs(){
	memset(vis,0,sizeof(vis));
	queue&lt;int&gt;q;
	q.push(s);vis[s]=1;
	while(!q.empty()){
		int u=q.front();q.pop();
		for(int i=0;i&lt;G[u].size();i++){
			edge e=edges[G[u][i]];
			if(e.cap&gt;e.flow&amp;&amp;!vis[e.v]){
				d[e.v]=d[u]+1;
				vis[e.v]=1;
				q.push(e.v);
			}
		}
	}return vis[t];
}
int dfs(int u,int a){
	int flow=0,f;
	if(u==t||!a)return a;
	for(int &amp;i=cur[u];i&lt;G[u].size();i++){
		edge e=edges[G[u][i]];
		if(d[e.v]==d[u]+1&amp;&amp;(f=dfs(e.v,min(a,e.cap-e.flow)))&gt;0){
			edges[G[u][i]].flow+=f;
			edges[G[u][i]^1].flow-=f;
			flow+=f;
			a-=f;
			if(!a)break;
		}
	}return flow;
}
int Dinic(){
	int flow=0;
	while(bfs()){
		int x=0;
		do{
			flow+=x;
			memset(cur,0,sizeof(cur));
		}while(x=dfs(s,INT_MAX));
	}return flow;
}
int n,tot,m;
int hash[201][201];
int a[201][201];
int sum=0;
const int dx[4]={0,1,0,-1};
const int dy[4]={1,0,-1,0};
int main(){
	cin&gt;&gt;n&gt;&gt;m;
	for(int i=1;i&lt;=n;i++)
	for(int j=1;j&lt;=m;j++){
		cin&gt;&gt;a[i][j];
		hash[i][j]=++tot;
		sum+=a[i][j];
	}
	s=0;t=tot+1;
	for(int i=1;i&lt;=n;i++)
	for(int j=1;j&lt;=m;j++){
		if((i+j+1)&amp;1)
			add(s,hash[i][j],a[i][j]);
		else
			add(hash[i][j],t,a[i][j]);
		if((i+j+1)&amp;1)
		for(int k=0;k&lt;4;k++){
			int x=i+dx[k],y=j+dy[k];
			if(x&lt;1||x&gt;n||y&lt;1||y&gt;m)continue;
			add(hash[i][j],hash[x][y],INT_MAX);
		}
	}
	int deb=0;
	if(deb)
	for(int i=0;i&lt;edges.size();i++){
		edge e=edges[i];
		if(i%2==0)
		printf("%d -&gt; %d cap:%d\n",e.u,e.v,e.cap);
	}
	cout&lt;&lt;sum-Dinic()&lt;&lt;endl;
	return 0;	
}<pre><h2>Problem1334</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=333;
int n,ans;
int w[maxn],sum,f[100010];
int main(){
	cin&gt;&gt;n;
	for(int i=1;i&lt;=n;i++)cin&gt;&gt;w[i],sum+=w[i];
	int m=sum/2; sort(w+1,w+1+n,greater&lt;int&gt;());
	for(int i=1;i&lt;=n;i++)for(int j=sum;j&gt;=w[i];j--)
	if((f[j-w[i]]&lt;=m&amp;&amp;f[j-w[i]]+w[i]&gt;m)||f[j-w[i]]+w[i]&lt;=m)
	f[j]=max(f[j],f[j-w[i]]+w[i]);
	cout&lt;&lt;*max_element(f+1,f+1+sum)&lt;&lt;endl;
}<pre><h2>Problem1336</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;functional&gt;
#include&lt;cmath&gt;
#include&lt;cctype&gt;
#include&lt;cassert&gt;
#include&lt;climits&gt;
using namespace std;
#define For(i,n) for(int i=1;i&lt;=n;i++)
#define Rep(i,n) for(int i=0;i&lt;n;i++)
#define Fork(i,k,n) for(int i=k;i&lt;=n;i++)
#define ForD(i,n) for(int i=n;i;i--)
#define Forp(x) for(int p=pre[x];p;p=next[p])
#define RepD(i,n) for(int i=n;i&gt;=0;i--)
#define MEM(a) memset(a,0,sizeof(a))
#define MEMI(a) memset(a,127,sizeof(a))
#define MEMi(a) memset(a,128,sizeof(a))
#define INF (2139062143)
#define F (1000000009)
#define MAXN (100000+10)
#define MAXXi (10000.0)
#define eps (1e-7)
typedef long long ll;
long double sqr(long double x){return x*x;}
struct P
{
   double x,y;
   P(){}
   P(double _x,double _y):x(_x),y(_y){}
   friend long double dis(P a,P b){return sqrt(sqr(a.x-b.x)+sqr(a.y-b.y));}
}a[MAXN];
struct V
{
   double x,y;
   V(){}
   V(P a,P b):x(b.x-a.x),y(b.y-a.y){}
   friend long double operator*(V a,V b){return a.x*b.y-a.y*b.x;}
};
struct C
{
   P o;
   long double r;
   C(){}
   C(P _o,long double _r):o(_o),r(_r){}
   C(P a,P b,P c)
   {
      long double C1=sqr(b.x)-sqr(a.x)+sqr(b.y)-sqr(a.y),C2=sqr(c.x)-sqr(b.x)+sqr(c.y)-sqr(b.y);
      long double A1=2*(b.x-a.x),A2=2*(c.x-b.x),B1=2*(b.y-a.y),B2=2*(c.y-b.y);
      o.x=(C1*B2-C2*B1)/(A1*B2-A2*B1);
      o.y=(C1*A2-C2*A1)/(B1*A2-B2*A1);
      r=dis(o,c);
   }
   C(P a,P b)
   {
      o=P((a.x+b.x)/2,(a.y+b.y)/2);
      r=dis(o,a);
   }
   bool in(P a){return dis(a,o)&lt;=r;}
}st;
int n;
int main()
{
   //freopen("bzoj1336.in","r",stdin);
   scanf("%d",&amp;n);
   For(i,n) scanf("%lf%lf",&amp;a[i].x,&amp;a[i].y);
   while (rand()%6000==0)
   {
      int i=rand()%n+1,j=rand()%n+1;
      if (i^j) swap(a[i],a[j]);
   }
   st=C(a[1],0);
   Fork(i,2,n)
   {
      if (!st.in(a[i]))
      {
         st=C(a[1],a[i]);
   
         Fork(j,2,i-1)
         {
            if (!st.in(a[j]))
            {
               st=C(a[j],a[i]);
               For(k,j-1)
               {
                  if (!st.in(a[k])) st=C(a[j],a[i],a[k]);
               }
            }
         }
      }
   }  
   
   cout.setf(ios::fixed);
   cout.precision(9);
   cout&lt;&lt;st.r&lt;&lt;endl;
   cout&lt;&lt;st.o.x&lt;&lt;' '&lt;&lt;st.o.y&lt;&lt;endl;
   
   //while (1);
   return 0;
}
<pre><h2>Problem1337</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=100010;
const double eps=1e-8;
double r,rx,ry,x,y;
double p[maxn][2];
int n;
double rnd(){
	return (double)rand()/RAND_MAX;
}
double sqr(double x){
	return x*x;
}
double dist(double x,double y){
	double ans=0;
	for(int i=1;i&lt;=n;i++)
	ans=max(ans,sqrt(sqr(x-p[i][0])+sqr(y-p[i][1])));
	return ans;
}
int dcmp(double x){
	if(fabs(x)&lt;eps)return 0;
	return x&gt;0?1:-1;
}
int main(){
	srand(33323);
	scanf("%d",&amp;n);
	for(int i=1;i&lt;=n;i++)scanf("%lf%lf",&amp;p[i][0],&amp;p[i][1]);
	x=p[1][0];y=p[1][1];
	r=99999999;double ans=dist(x,y);
	while(r&gt;eps){
		int m=50;
		while(m--){
			rx=(rnd()*2-1)*r;
			ry=sqrt(sqr(r)-sqr(rx))*(rnd()*4-1);
			double res=dist(x+rx,y+ry);
			if(dcmp(res-ans)&lt;0){
				ans=res;
				x+=rx;y+=ry;
			}	
		}r=r/1.5;
	}printf("%.3lf\n",ans);
	return 0;
}<pre><h2>Problem1339</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=425;
struct edge{
	int u,v,cap,flow;
	edge(int _u=0,int _v=0,int _cap=0,int _flow=0):
		u(_u),v(_v),cap(_cap),flow(_flow){}	
};
vector&lt;edge&gt;edges;
vector&lt;int&gt;G[maxn];
int vis[maxn];
int cur[maxn];
int hash[maxn][2];
int d[maxn],n,m,s,t;
void add(int u,int v,int cap){
	edges.push_back(edge(u,v,cap));
	G[u].push_back(edges.size()-1);
	edges.push_back(edge(v,u,0));
	G[v].push_back(edges.size()-1);
}
bool bfs(){
	memset(vis,0,sizeof vis);d[s]=0;
	queue&lt;int&gt;q;q.push(s);vis[s]=1;
	while(!q.empty()){
		int u=q.front();q.pop();
		for(int i=0;i&lt;G[u].size();i++){
			edge e=edges[G[u][i]];
			if(!vis[e.v]&amp;&amp;e.cap&gt;e.flow){
				d[e.v]=d[u]+1;
				vis[e.v]=1;
				q.push(e.v);
			}
		}
	}return vis[t];
}
int dfs(int u,int a){
	if(u==t||a==0)return a;
	int flow=0,f;
	for(int &amp;i=cur[u];i&lt;G[u].size();i++){
		edge e=edges[G[u][i]];
		if(d[e.v]==d[u]+1&amp;&amp;(f=dfs(e.v,min(a,e.cap-e.flow)))&gt;0){
			flow+=f;
			a-=f;
			edges[G[u][i]].flow+=f;
			edges[G[u][i]^1].flow-=f;
			if(!a)break;
		}
	}return flow;
}
int Dinic(){
	int flow=0;
	while(bfs()){
		int x=0;
		memset(cur,0,sizeof cur);
		while(x=dfs(s,INT_MAX)){
			flow+=x;
			memset(cur,0,sizeof cur);
		}
	}return flow;
}
void deb(){
	for(int i=0;i&lt;edges.size();i++)if(i%2==0)
	printf("%d -&gt; %d cap:%d\n",edges[i].u,edges[i].v,edges[i].cap);
}
int cost[maxn];
int main(){
	scanf("%d%d",&amp;n,&amp;m);
	int tot=0;
	for(int i=1;i&lt;=n;i++)hash[i][0]=++tot,hash[i][1]=++tot;
	int ss,tt;
	scanf("%d%d",&amp;s,&amp;t);
	s=hash[s][0];
	t=hash[t][1];
	for(int i=1;i&lt;=n;i++){
		int x;scanf("%d",&amp;x);cost[i]=x;
		add(hash[i][0],hash[i][1],x);
	}
	for(int i=1;i&lt;=m;i++){
		int u,v;scanf("%d%d",&amp;u,&amp;v);
		add(hash[u][1],hash[v][0],INT_MAX);
		add(hash[v][1],hash[u][0],INT_MAX);
	}
	//deb();
	int ans=Dinic();
	cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}<pre><h2>Problem1342</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1e6+10;
map&lt;int,int&gt;M;
int n,m,c;
int anss[maxn];
int a[maxn];
int main(){
	scanf("%d%d%d",&amp;n,&amp;m,&amp;c);
	for(int i=1;i&lt;=n;i++){
		scanf("%d",&amp;a[i]);
		if(i&lt;=m)M[a[i]]++;
	}if((--M.end())-&gt;first-M.begin()-&gt;first&lt;=c)anss[++anss[0]]=1;
	for(int i=2;i+m-1&lt;=n;i++){
		if(!--M[a[i-1]])
		M.erase(a[i-1]);
		M[a[i+m-1]]++;
		if((--M.end())-&gt;first-M.begin()-&gt;first&lt;=c)anss[++anss[0]]=i;
	}
	if(anss[0])for(int i=1;i&lt;=anss[0];i++)printf("%d\n",anss[i]);
	else puts("NONE");
	return 0;
}<pre><h2>Problem1345</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1e6+10;
typedef long long LL;
int a[maxn],n;
LL ans=0;
int getint(){
	int res=0;char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))res=(res&lt;&lt;3)+(res&lt;&lt;1)+c-'0',c=getchar();
	return res;
}
int f[20][maxn],g[20][maxn];  
void init(){  
    int BIT=0;  
    for(int i=n;i;i&gt;&gt;=1,BIT++);  
    for(int i=1;i&lt;=n;i++)f[0][i]=a[i],g[0][i]=i;  
    for(int i=1;i&lt;=BIT;i++)  
    for(int j=1;j&lt;=n-(1&lt;&lt;i)+1;j++){  
        if(f[i-1][j]&gt;f[i-1][j+(1&lt;&lt;i-1)])  
            f[i][j]=f[i-1][j],g[i][j]=g[i-1][j];  
        else f[i][j]=f[i-1][j+(1&lt;&lt;i-1)],g[i][j]=g[i-1][j+(1&lt;&lt;i-1)];  
    }  
}  
int Qmax(int l,int r){  
    int BIT=0;  
    for(int i=r-l+1;i;i&gt;&gt;=1,BIT++);BIT--;  
    if(f[BIT][l]&gt;f[BIT][r-(1&lt;&lt;BIT)+1])return g[BIT][l];    
    else return g[BIT][r-(1&lt;&lt;BIT)+1];       
}  
LL solve(int l,int r){
	if(l==r)return 0;
	if(l+1==r)return max(a[l],a[r]);
	int p=Qmax(l,r);
	LL ans=0;
	if(l&lt;=p-1)ans+=solve(l,p-1)+a[p];
	if(r&gt;=p+1)ans+=solve(p+1,r)+a[p];
	return ans;
}
int main(){
	n=getint();
	for(int i=1;i&lt;=n;i++)a[i]=getint();
	init();
	cout&lt;&lt;solve(1,n)&lt;&lt;endl;
	return 0;
}<pre><h2>Problem1345</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1e6+10;
typedef long long LL;
int a[maxn],n;
LL ans=0;
int getint(){
	int res=0;char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))res=(res&lt;&lt;3)+(res&lt;&lt;1)+c-'0',c=getchar();
	return res;
}
int f[20][maxn],g[20][maxn];  
void init(){
	int BIT=0;
	for(int i=n;i;i&gt;&gt;=1)BIT++;
	for(int i=1;i&lt;=n;i++)f[0][i]=a[i],g[0][i]=i;
	for(int i=1;i&lt;=BIT;i++)
	for(int j=1;j&lt;=n-(1&lt;&lt;i)+1;j++)
	if(f[i-1][j]&gt;=f[i-1][j+(1&lt;&lt;i-1)])
		f[i][j]=f[i-1][j],g[i][j]=g[i-1][j];
	else f[i][j]=f[i-1][j+(1&lt;&lt;i-1)],g[i][j]=g[i-1][j+(1&lt;&lt;i-1)];
}
int Qmax(int l,int r){
	int BIT=0;
	for(int i=r-l+1;i;i&gt;&gt;=1)BIT++;BIT--;
	if(f[BIT][l]&gt;=f[BIT][r-(1&lt;&lt;BIT)+1])return g[BIT][l];
	return g[BIT][r-(1&lt;&lt;BIT)+1];
}

LL solve(int l,int r){
	if(l==r)return 0;
	if(l+1==r)return max(a[l],a[r]);
	int p=Qmax(l,r);
	LL ans=0;
	if(l&lt;=p-1)ans+=solve(l,p-1)+a[p];
	if(r&gt;=p+1)ans+=solve(p+1,r)+a[p];
	return ans;
}
int main(){
	n=getint();
	for(int i=1;i&lt;=n;i++)a[i]=getint();
	init();
	cout&lt;&lt;solve(1,n)&lt;&lt;endl;
	return 0;
}<pre><h2>Problem1349</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
int main(){
	long long x;
	cin&gt;&gt;x;
	cout&lt;&lt;(long long)ceil(sqrt((long double)x))&lt;&lt;endl;
}<pre><h2>Problem1350</h2><pre>#include &lt;cstdio&gt;
namespace Solve {
	const int MAXN = 125;
	const int MAXM = 300;
	const int LL = 1000000;
	struct Big {
		int a[MAXM], n;
		inline int&amp; operator ()(int u) {return a[u];}
		void Go(void) {
			for (int i = 1; i &lt;= n; i++)
				a[i + 1] += a[i] / LL, a[i] %= LL;
			if (a[n + 1]) n++;
		}
		void Put(void) {
			printf("%d", a[n]);
			for (int i = n - 1; i &gt;= 1; i--) {
				for (int j = 10; j &lt; LL; j *= 10)
					if (a[i] &lt; j) putchar('0');
				printf("%d", a[i]);
			}
			puts("");
		}
	};

	void Add(Big&amp; a, Big&amp; b) {
		for (int i = 1; i &lt;= b.n; i++)
			a(i) += b(i);
		if (b.n &gt; a.n) a.n = b.n;
		a.Go();
	}
	Big f[MAXN][MAXN];
	int n;

	void solve(void) {
		scanf("%d", &amp;n);
		f[1][1].n = f[1][1](1) = 1;
		for (int i = 1; i &lt;= n; i++)
			for (int j = 1; j &lt;= n; j++) {
				int u; scanf("%d", &amp;u);
				if (!u) continue;
				/*if (i + u &lt;= n)*/ Add(f[i + u][j], f[i][j]);
				/*if (j + u &lt;= n)*/ Add(f[i][j + u], f[i][j]);
			}
		f[n][n].Put();
	}
}
int main(int argc, char** argv) {
	#ifdef Debug
		freopen("1.in", "r", stdin);
		//freopen("1.out", "w", stdout);
	#endif
	Solve::solve();
	return 0;
}<pre><h2>Problem1351</h2><pre>A=1<pre><h2>Problem1355</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=2e6+5;
char s[maxn];
int next[maxn];
int n,nn,ans=maxn;
int c[maxn];
int main(){
	scanf("%d",&amp;n);scanf("%s",s+1);nn=n;
	for(int i=2,j=0;i&lt;=nn;i++){
		while(j&amp;&amp;s[i]!=s[j+1])j=next[j];
		next[i]=j+=s[i]==s[j+1];
		c[i]=i-next[i];
		if(i==n){
			copy(s+1,s+1+n,s+1+n-next[n]);
			nn=n+n-next[n];
		}
	}c[1]=1;
	cout&lt;&lt;*min_element(c+n,c+1+nn)&lt;&lt;endl;
	return 0;
}<pre><h2>Problem1356</h2><pre>a=1<pre><h2>Problem1357</h2><pre>A=1<pre><h2>Problem1360</h2><pre>A=1<pre><h2>Problem1361</h2><pre>import math
import sys
n,m,k=[int(x) for x in raw_input().split()]
f=[0]*1001
f[1]=2
for i in range(2,k+1):
    f[i]=2**i
    for j in range(1,int(math.sqrt(i))+1):
        if i%j==0:
            f[i]-=f[j]
            if j*j!=i and j!=1:
                f[i]-=f[i/j]
print f[k]/k
s=raw_input()
st=s
while len(s)&lt;n:
    s=s+st
s=s[0:n]
ps=0
for i in range(len(s)-1,-1,-1):
    if s[i]=='0':
        ps=i
        break
print str(s[0:ps])+'1'
<pre><h2>Problem1369</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1e4+5;
int f[maxn][3];
vector&lt;int&gt;G[maxn];
int fa[maxn],vis[maxn][3];
int dfs(int u,int o){
	if(vis[u][o])return f[u][o];
	f[u][o]=o;vis[u][o]=1;
	for(int v,i=0;i&lt;G[u].size();i++){
		if(fa[u]==(v=G[u][i]))continue;
		fa[v]=u;
		f[u][o]+=min(dfs(v,(o+1)%3),dfs(v,(o+2)%3));
	}return f[u][o];
}int n;
int main(){
	scanf("%d",&amp;n);
	for(int i=1;i&lt;n;i++){
		int u,v;scanf("%d%d",&amp;u,&amp;v);
		G[u].push_back(v);
		G[v].push_back(u);
	}
	cout&lt;&lt;n+min(dfs(1,0),min(dfs(1,1),dfs(1,2)))&lt;&lt;endl;
	return 0;
}<pre><h2>Problem1370</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1010;
int fa[maxn*2];
int find(int x){return fa[x]=fa[x]==x?x:find(fa[x]);}
int n,m,vis[maxn*2],ans;
void merge(int x,int y){fa[find(x)]=find(y);}
int main(){
	scanf("%d%d",&amp;n,&amp;m);
	for(int i=1;i&lt;=n*2;i++)fa[i]=i;
	while(m--){
		int p,x,y;char s[2];
		scanf("%s%d%d",s,&amp;x,&amp;y);
		if(s[0]=='F')merge(x,y);
		else merge(x+n,y),merge(x,y+n);
	}for(int i=1;i&lt;=n;i++)
	ans+=!vis[find(i)]++;
	cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}<pre><h2>Problem1381</h2><pre>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#define INF 0x7fffffff
using namespace std;
int n,m,bl,wt,ans,cnt=1;
bool del[201][201];
int mark[201][201];
int xx[8]={1,1,2,2,-1,-1,-2,-2},
    yy[8]={2,-2,1,-1,2,-2,1,-1};
struct data{int to,next,v;}e[500001];
int head[40002],h[40002];
void insert(int u,int v,int w)
{
     cnt++;
     e[cnt].to=v;
     e[cnt].next=head[u];
     head[u]=cnt;
     e[cnt].v=w;
     cnt++;
     e[cnt].to=u;
     e[cnt].next=head[v];
     head[v]=cnt;
 }
void build()
{
     for(int i=1;i&lt;=n;i++)
         for(int j=1;j&lt;=n;j++)
             if(del[i][j])continue;
             else if(mark[i][j]&lt;bl)
             {
             for(int k=0;k&lt;8;k++)
             {
                     int nowx=i+xx[k],nowy=j+yy[k];
                     if(nowx&lt;1||nowy&lt;1||nowx&gt;n||nowy&gt;n||del[nowx][nowy])continue;
                     insert(mark[i][j],mark[nowx][nowy],INF);
                     }
             insert(0,mark[i][j],1);
             }
             else insert(mark[i][j],wt,1);
 }
bool bfs()
{
     int q[40002],t=0,w=1,i,now;
     memset(h,-1,sizeof(h));
     h[0]=q[0]=0;
     while(t&lt;w)
     {
               now=q[t];t++;
               i=head[now];
               while(i)
               {
                       if(h[e[i].to]==-1&amp;&amp;e[i].v){h[e[i].to]=h[now]+1;q[w++]=e[i].to;}
                       i=e[i].next;
                       }
               }
     if(h[wt]==-1)return 0;
     return 1;
 }
int dfs(int x,int f)
{
    if(x==wt)return f;
    int i=head[x];
    int w,used=0;
    while(i)
    {
            if(e[i].v&amp;&amp;h[e[i].to]==h[x]+1)
            {
                w=f-used;
                w=dfs(e[i].to,min(w,e[i].v));   
                e[i].v-=w;
                e[i^1].v+=w;
                used+=w;
                if(used==f)return f;                      
                }
                i=e[i].next;
            }
    if(!used)h[x]=-1;
    return used;
    }
void dinic(){while(bfs()){ans+=dfs(0,INF);}}
int main()
{
    scanf("%d%d",&amp;n,&amp;m);
    for(int i=1;i&lt;=m;i++)
    {
            int x,y;
            scanf("%d%d",&amp;x,&amp;y);
            del[x][y]=1;
            }
    bl=1,wt=(n*n+1)/2+1;
    for(int i=1;i&lt;=n;i++)
       for(int j=1;j&lt;=n;j++)
          if((i+j)%2==0){mark[i][j]=bl;bl++;}
          else {mark[i][j]=wt;wt++;}
    build();
    dinic();
    printf("%d",n*n-m-ans);
    return 0;
}<pre><h2>Problem1396</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1e6+5;
int son[maxn][26],len[maxn],fa[maxn],rigs[maxn],rigm[maxn],minl[maxn];
int last=1,tot=1,root=1;
int newnode(int x){
	len[++tot]=x;
	return tot;
}
void add(int w,int r){
	int p=last;
	int np=newnode(len[p]+1);rigm[np]=r;rigs[np]=1;
	while(p&amp;&amp;!son[p][w])son[p][w]=np,p=fa[p];
	if(!p)fa[np]=1;
	else{
		int q=son[p][w];
		if(len[p]+1==len[q])fa[np]=q;
		else{
			int nq=newnode(len[p]+1);
			memcpy(son[nq],son[q],sizeof son[nq]);
			fa[nq]=fa[q];fa[q]=fa[np]=nq;
			while(p&amp;&amp;son[p][w]==q)son[p][w]=nq,p=fa[p];
		}
	}last=np;
}
void deb(){
	for(int i=1;i&lt;=tot;i++){
		fprintf(stderr,"id:%d fa:%d\n",i,fa[i]);
		for(int j=0;j&lt;26;j++)if(son[i][j]){
			fprintf(stderr,"%d--%c--%d\n",i,j+'a',son[i][j]);
		}
	}
}
char s[maxn];
int n;
bool cmp(int x,int y){return len[x]&gt;len[y];}
int a[maxn];
vector&lt;int&gt;b[maxn];
int main(){
	scanf("%s",s+1);n=strlen(s+1);
	for(int i=1;i&lt;=n;i++)
		add(s[i]-'a',i);
	
//	deb();
	
	static int tp[maxn];
	for(int i=1;i&lt;=tot;i++)tp[i]=i;
	sort(tp+1,tp+1+tot,cmp);
	for(int i=1;i&lt;=tot;i++){
		int u=tp[i];
		rigm[fa[u]]=max(rigm[fa[u]],rigm[u]);
		rigs[fa[u]]+=rigs[u];
	}
	for(int i=1;i&lt;=tot;i++)minl[i]=tot+1;
	minl[1]=0;reverse(tp+1,tp+1+tot);
	for(int i=1;i&lt;=tot;i++){
		int u=tp[i];
		for(int j=0;j&lt;26;j++)if(son[u][j])
			minl[son[u][j]]=min(minl[son[u][j]],minl[u]+1);
	}
	for(int i=1;i&lt;=n;i++)a[i]=n+1;
	for(int i=1;i&lt;=tot;i++)if(rigs[i]==1){
		int ps=rigm[i]-minl[i]+1;
		a[ps]=min(a[ps],minl[i]);
		b[ps].push_back(minl[i]);
		b[rigm[i]+1].push_back(-minl[i]);
	}int cur=a[n];
	static int anss[maxn];
	for(int i=n;i&gt;=1;i--){
		cur=min(cur,a[i]);
		anss[i]=cur;
		cur++;
	}
	
	multiset&lt;int&gt;S;
	
	for(int i=1;i&lt;=n;i++){
		for(int j=0;j&lt;b[i].size();j++){
			int x=b[i][j];
			if(x&lt;0)S.erase(S.find(-x));
			else S.insert(x);
		}
		if(!S.empty())
		anss[i]=min(anss[i],*S.begin());
	}
	for(int i=1;i&lt;=n;i++)
		printf("%d\n",anss[i]);
	return 0;
}<pre><h2>Problem1396</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1e6+5;
int son[maxn][26],len[maxn],fa[maxn],rigs[maxn],rigm[maxn];//,minl[maxn];
int last=1,tot=1,root=1;
int newnode(int x){
	len[++tot]=x;
	return tot;
}
void add(int w,int r){
	int p=last;
	int np=newnode(len[p]+1);rigm[np]=r;rigs[np]=1;
	while(p&amp;&amp;!son[p][w])son[p][w]=np,p=fa[p];
	if(!p)fa[np]=1;
	else{
		int q=son[p][w];
		if(len[p]+1==len[q])fa[np]=q;
		else{
			int nq=newnode(len[p]+1);
			memcpy(son[nq],son[q],sizeof son[nq]);
			fa[nq]=fa[q];fa[q]=fa[np]=nq;
			while(p&amp;&amp;son[p][w]==q)son[p][w]=nq,p=fa[p];
		}
	}last=np;
}
void deb(){
	for(int i=1;i&lt;=tot;i++){
		fprintf(stderr,"id:%d fa:%d\n",i,fa[i]);
		for(int j=0;j&lt;26;j++)if(son[i][j]){
			fprintf(stderr,"%d--%c--%d\n",i,j+'a',son[i][j]);
		}
	}
}
char s[maxn/2];
int n;
bool cmp(int x,int y){return len[x]&gt;len[y];}
vector&lt;int&gt;b[maxn/2];
int main(){
	scanf("%s",s+1);n=strlen(s+1);
	for(int i=1;i&lt;=n;i++)
		add(s[i]-'a',i);
	
//	deb();
	
	static int tp[maxn];
	for(int i=1;i&lt;=tot;i++)tp[i]=i;
	sort(tp+1,tp+1+tot,cmp);
	for(int i=1;i&lt;=tot;i++){
		int u=tp[i];
		rigm[fa[u]]=max(rigm[fa[u]],rigm[u]);
		rigs[fa[u]]+=rigs[u];
	}
	int *minl=fa;
	for(int i=1;i&lt;=tot;i++)minl[i]=tot+1;
	minl[1]=0;reverse(tp+1,tp+1+tot);
	for(int i=1;i&lt;=tot;i++){
		int u=tp[i];
		for(int j=0;j&lt;26;j++)if(son[u][j])
			minl[son[u][j]]=min(minl[son[u][j]],minl[u]+1);
	}
	int *a=tp;
	for(int i=1;i&lt;=n;i++)a[i]=n+1;
	for(int i=1;i&lt;=tot;i++)if(rigs[i]==1){
		int ps=rigm[i]-minl[i]+1;
		a[ps]=min(a[ps],minl[i]);
		b[ps].push_back(minl[i]);
		b[rigm[i]+1].push_back(-minl[i]);
	}int cur=a[n];
	static int anss[maxn/2];
	for(int i=n;i&gt;=1;i--){
		cur=min(cur,a[i]);
		anss[i]=cur;
		cur++;
	}
	
	multiset&lt;int&gt;S;
	
	for(int i=1;i&lt;=n;i++){
		for(int j=0;j&lt;b[i].size();j++){
			int x=b[i][j];
			if(x&lt;0)S.erase(S.find(-x));
			else S.insert(x);
		}
		if(!S.empty())
		anss[i]=min(anss[i],*S.begin());
	}
	for(int i=1;i&lt;=n;i++)
		printf("%d\n",anss[i]);
	return 0;
}<pre><h2>Problem1396</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1e6+5;
int son[maxn][26],len[maxn],fa[maxn],rigm[maxn];//,minl[maxn];
char rigs[maxn];
int last=1,tot=1,root=1;
int newnode(int x){
	len[++tot]=x;
	return tot;
}
void add(int w,int r){
	int p=last;
	int np=newnode(len[p]+1);rigm[np]=r;rigs[np]=1;
	while(p&amp;&amp;!son[p][w])son[p][w]=np,p=fa[p];
	if(!p)fa[np]=1;
	else{
		int q=son[p][w];
		if(len[p]+1==len[q])fa[np]=q;
		else{
			int nq=newnode(len[p]+1);
			memcpy(son[nq],son[q],sizeof son[nq]);
			fa[nq]=fa[q];fa[q]=fa[np]=nq;
			while(p&amp;&amp;son[p][w]==q)son[p][w]=nq,p=fa[p];
		}
	}last=np;
}
void deb(){
	for(int i=1;i&lt;=tot;i++){
		fprintf(stderr,"id:%d fa:%d\n",i,fa[i]);
		for(int j=0;j&lt;26;j++)if(son[i][j]){
			fprintf(stderr,"%d--%c--%d\n",i,j+'a',son[i][j]);
		}
	}
}
char s[maxn/2];
int n;
bool cmp(int x,int y){return len[x]&gt;len[y];}
vector&lt;int&gt;b[maxn/2];
int main(){
	scanf("%s",s+1);n=strlen(s+1);
	for(int i=1;i&lt;=n;i++)
		add(s[i]-'a',i);
	
//	deb();
	
	static int tp[maxn];
	for(int i=1;i&lt;=tot;i++)tp[i]=i;
	sort(tp+1,tp+1+tot,cmp);
	for(int i=1;i&lt;=tot;i++){
		int u=tp[i];
		rigm[fa[u]]=max(rigm[fa[u]],rigm[u]);
		rigs[fa[u]]=0;
	}
	int *minl=fa;
	for(int i=1;i&lt;=tot;i++)minl[i]=tot+1;
	minl[1]=0;reverse(tp+1,tp+1+tot);
	for(int i=1;i&lt;=tot;i++){
		int u=tp[i];
		for(int j=0;j&lt;26;j++)if(son[u][j])
			minl[son[u][j]]=min(minl[son[u][j]],minl[u]+1);
	}
	int *a=tp;
	for(int i=1;i&lt;=n;i++)a[i]=n+1;
	for(int i=1;i&lt;=tot;i++)if(rigs[i]==1){
		int ps=rigm[i]-minl[i]+1;
		a[ps]=min(a[ps],minl[i]);
		b[ps].push_back(minl[i]);
		b[rigm[i]+1].push_back(-minl[i]);
	}int cur=a[n];
	static int anss[maxn/2];
	for(int i=n;i&gt;=1;i--){
		cur=min(cur,a[i]);
		anss[i]=cur;
		cur++;
	}
	
	multiset&lt;int&gt;S;
	
	for(int i=1;i&lt;=n;i++){
		for(int j=0;j&lt;b[i].size();j++){
			int x=b[i][j];
			if(x&lt;0)S.erase(S.find(-x));
			else S.insert(x);
		}
		if(!S.empty())
		anss[i]=min(anss[i],*S.begin());
	}
	for(int i=1;i&lt;=n;i++)
		printf("%d\n",anss[i]);
	return 0;
}<pre><h2>Problem1396</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1e6+5;
int son[maxn][26],len[maxn],fa[maxn],rigm[maxn];//,minl[maxn];
char rigs[maxn];
int last=1,tot=1,root=1;
int newnode(int x){
	len[++tot]=x;
	return tot;
}
void add(int w,int r){
	int p=last;
	int np=newnode(len[p]+1);rigm[np]=r;rigs[np]=1;
	while(p&amp;&amp;!son[p][w])son[p][w]=np,p=fa[p];
	if(!p)fa[np]=1;
	else{
		int q=son[p][w];
		if(len[p]+1==len[q])fa[np]=q;
		else{
			int nq=newnode(len[p]+1);
			memcpy(son[nq],son[q],sizeof son[nq]);
			fa[nq]=fa[q];fa[q]=fa[np]=nq;
			while(p&amp;&amp;son[p][w]==q)son[p][w]=nq,p=fa[p];
		}
	}last=np;
}
void deb(){
	for(int i=1;i&lt;=tot;i++){
		fprintf(stderr,"id:%d fa:%d\n",i,fa[i]);
		for(int j=0;j&lt;26;j++)if(son[i][j]){
			fprintf(stderr,"%d--%c--%d\n",i,j+'a',son[i][j]);
		}
	}
}
char s[maxn/2];
int n;
bool cmp(int x,int y){return len[x]&gt;len[y];}
pair&lt;int,int&gt; par[int(2e5+1)];
int main(){
	scanf("%s",s+1);n=strlen(s+1);
	for(int i=1;i&lt;=n;i++)
		add(s[i]-'a',i);
	
//	deb();
	
	static int tp[maxn];
	for(int i=1;i&lt;=tot;i++)tp[i]=i;
	sort(tp+1,tp+1+tot,cmp);
	for(int i=1;i&lt;=tot;i++){
		int u=tp[i];
		rigm[fa[u]]=max(rigm[fa[u]],rigm[u]);
		rigs[fa[u]]=0;
	}
	int *minl=fa;
	for(int i=1;i&lt;=tot;i++)minl[i]=tot+1;
	minl[1]=0;reverse(tp+1,tp+1+tot);
	for(int i=1;i&lt;=tot;i++){
		int u=tp[i];
		for(int j=0;j&lt;26;j++)if(son[u][j])
			minl[son[u][j]]=min(minl[son[u][j]],minl[u]+1);
	}
	int *a=tp;
	for(int i=1;i&lt;=n;i++)a[i]=n+1;
	int psz=0;
	for(int i=1;i&lt;=tot;i++)if(rigs[i]==1){
		int ps=rigm[i]-minl[i]+1;
		a[ps]=min(a[ps],minl[i]);
		par[psz++]=make_pair(ps,minl[i]);
		par[psz++]=make_pair(rigm[i]+1,-minl[i]);
//		b[ps].push_back(minl[i]);
//		b[rigm[i]+1].push_back(-minl[i]);
	}sort(par,par+psz);
	int cur=a[n];
	static int anss[maxn/2];
	for(int i=n;i&gt;=1;i--){
		cur=min(cur,a[i]);
		anss[i]=cur;
		cur++;
	}
	
	multiset&lt;int&gt;S;
	cur=0;
	for(int i=1;i&lt;=n;i++){
		while(par[cur].first==i){
			int x=par[cur].second;
			if(x&lt;0)S.erase(S.find(-x));
			else S.insert(x);
			cur++;
		}
		if(!S.empty())
		anss[i]=min(anss[i],*S.begin());
	}
	for(int i=1;i&lt;=n;i++)
		printf("%d\n",anss[i]);
	return 0;
}<pre><h2>Problem1396</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1e6+5;
int son[maxn][26],*len,fa[maxn],*rigm;//,minl[maxn];
char rigs[maxn];
int last=1,tot=1,root=1;
int newnode(int x){
	len[++tot]=x;
	return tot;
}
void add(int w,int r){
	int p=last;
	int np=newnode(len[p]+1);rigm[np]=r;rigs[np]=1;
	while(p&amp;&amp;!son[p][w])son[p][w]=np,p=fa[p];
	if(!p)fa[np]=1;
	else{
		int q=son[p][w];
		if(len[p]+1==len[q])fa[np]=q;
		else{
			int nq=newnode(len[p]+1);
			memcpy(son[nq],son[q],sizeof son[nq]);
			fa[nq]=fa[q];fa[q]=fa[np]=nq;
			while(p&amp;&amp;son[p][w]==q)son[p][w]=nq,p=fa[p];
		}
	}last=np;
}
void deb(){
	for(int i=1;i&lt;=tot;i++){
		fprintf(stderr,"id:%d fa:%d\n",i,fa[i]);
		for(int j=0;j&lt;26;j++)if(son[i][j]){
			fprintf(stderr,"%d--%c--%d\n",i,j+'a',son[i][j]);
		}
	}
}
char *s;
int n;
bool cmp(int x,int y){return len[x]&gt;len[y];}
pair&lt;int,int&gt; par[int(1e6+1)];
int main(){
	s=new char[maxn];
	rigm=new int[maxn];
	len=new int[maxn];
	scanf("%s",s+1);n=strlen(s+1);
	for(int i=1;i&lt;=n;i++)
		add(s[i]-'a',i);
	delete s;
//	deb();
	
	static int tp[maxn];
	for(int i=1;i&lt;=tot;i++)tp[i]=i;
	sort(tp+1,tp+1+tot,cmp);
	delete len;
	for(int i=1;i&lt;=tot;i++){
		int u=tp[i];
		rigm[fa[u]]=max(rigm[fa[u]],rigm[u]);
		rigs[fa[u]]=0;
	}
	int *minl=fa;
	for(int i=1;i&lt;=tot;i++)minl[i]=tot+1;
	minl[1]=0;reverse(tp+1,tp+1+tot);
	for(int i=1;i&lt;=tot;i++){
		int u=tp[i];
		for(int j=0;j&lt;26;j++)if(son[u][j])
			minl[son[u][j]]=min(minl[son[u][j]],minl[u]+1);
	}
	int *a=tp;
	for(int i=1;i&lt;=n;i++)a[i]=n+1;
	int psz=0;
	for(int i=1;i&lt;=tot;i++)if(rigs[i]==1){
		int ps=rigm[i]-minl[i]+1;
		a[ps]=min(a[ps],minl[i]);
		par[psz++]=make_pair(ps,minl[i]);
		par[psz++]=make_pair(rigm[i]+1,-minl[i]);
//		b[ps].push_back(minl[i]);
//		b[rigm[i]+1].push_back(-minl[i]);
	}sort(par,par+psz);
	int cur=a[n];
	static int anss[maxn/2];
	for(int i=n;i&gt;=1;i--){
		cur=min(cur,a[i]);
		anss[i]=cur;
		cur++;
	}
	delete rigm;
	multiset&lt;int&gt;S;
	cur=0;
	for(int i=1;i&lt;=n;i++){
		while(par[cur].first==i){
			int x=par[cur].second;
			if(x&lt;0)S.erase(S.find(-x));
			else S.insert(x);
			cur++;
		}
		if(!S.empty())
		anss[i]=min(anss[i],*S.begin());
	}
	for(int i=1;i&lt;=n;i++)
		printf("%d\n",anss[i]);
	return 0;
}<pre><h2>Problem1398</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
int n;
char s[int(2e6)];
string s1,s2;
string sol(char *s){
	int n=strlen(s);
	int i=0,j=1,k=0,p;
	while(i&lt;n&amp;&amp;j&lt;n&amp;&amp;k&lt;n){
		int t=s[(i+k)%n]-s[(j+k)%n];
		if(t==0)k++;
		else if(t&lt;0)j+=k+1,k=0;
		else i+=k+1,k=0;
		if(i==j)j++;
	}p=min(i,j);
	string S;
	for(int i=p;i&lt;p+n;i++)S.push_back(s[i%n]);
	return S;
}
int main(){
//	scanf("%d",&amp;n);
	scanf("%s",s);
	s1=sol(s);
	scanf("%s",s);
	s2=sol(s);
	if(s1!=s2)puts("No");
	else printf("Yes\n%s\n",s1.c_str());
	return 0;
}<pre><h2>Problem1406</h2><pre>#include&lt;set&gt;
#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef unsigned int lld;
lld n;
set&lt;lld&gt;s;
int main(){
    cin&gt;&gt;n;
    if(n==1){
        puts("None");
        return 0;
    }
    for(int i=1;i*i&lt;=n;i++){
        if(n%i)continue;
        lld a=i,b=n/i;
        for(int j=0;j&lt;=n;j+=b){
            if((j+2)%a==0&amp;&amp;j+1&lt;n)s.insert(j+1);
            if((j-2)&gt;=0&amp;&amp;(j-2)%a==0)s.insert(j-1);
        }

    }
    for(set&lt;lld&gt;::iterator it=s.begin();it!=s.end();it++)
        cout&lt;&lt;*it&lt;&lt;endl;
    return 0;
}
<pre><h2>Problem1407</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef int lld;
lld n;
lld C[160],P[160],L[160];
lld exgcd(lld a,lld b,lld &amp;x,lld &amp;y){
	if(!b){
		x=1;y=0;
		return a;
	}else{
		lld g=exgcd(b,a%b,x,y);
		lld t=x;
		x=y;
		y=t-a/b*y;
		return g;
	}
}
bool ok(lld m){
	for(int i=1;i&lt;=n;i++)
	for(int j=i+1;j&lt;=n;j++){
		lld a,b,x,y;
		a=P[i]-P[j];
		b=C[j]-C[i];
		if(a&lt;0){
			a*=-1;b*=-1;
		}
		//while(b&lt;0)b+=m;
		lld d=exgcd(a,m,x,y);
		if(b%d)continue;
		lld mm=m;
		a/=d;b/=d;m/=d;
		x=x*b;
		while(x&lt;0)x+=m;
		x%=m;
		m=mm;
		if(x&lt;=L[i]&amp;&amp;x&lt;=L[j])
			return false;
	}
	return true;
}
int main(){
	  //freopen( "savage.in" , "r" , stdin ) , freopen( "savage.out" , "w" , stdout ) ;
  
	cin&gt;&gt;n;
	lld minn=0;
	for(int i=1;i&lt;=n;i++){
		cin&gt;&gt;C[i]&gt;&gt;P[i]&gt;&gt;L[i];
		C[i]--;
		minn=max(minn,C[i]);
	}	
	for(int i=minn+1;i&lt;=1000000;i++){
		if(ok(i)){
			cout&lt;&lt;i&lt;&lt;endl;
			return 0;
		}
	}
	return 0;
}<pre><h2>Problem1409</h2><pre>#include&lt;cstdio&gt;
typedef long long ll;
const int N=46341;
int T,i,j,p[N],tot,vis[N],n,q;ll a,P;
struct mat{
  ll a[2][2];
  inline mat(){a[0][0]=a[0][1]=a[1][0]=a[1][1]=0;}
  inline mat operator*(mat b){
    mat c;
    for(int i=0,j,k;i&lt;2;i++)for(j=0;j&lt;2;j++)for(k=0;k&lt;2;k++)(c.a[i][j]+=a[i][k]*b.a[k][j]%P)%=P;
    return c;
  }
}A,B,C;
inline int phi(int n){
  int t=1,i;
  for(i=1;p[i]*p[i]&lt;=n&amp;&amp;i&lt;=tot;i++)if(n%p[i]==0){n/=p[i],t*=p[i]-1;while(n%p[i]==0)n/=p[i],t*=p[i];}
  if(n&gt;1)t*=n-1;
  return t;
}
inline int fib(int x){
  P=phi(q);
  for(A=B=C=mat(),A.a[0][1]=A.a[1][0]=A.a[1][1]=B.a[1][0]=C.a[0][0]=C.a[1][1]=1;x;x&gt;&gt;=1,A=A*A)if(x&amp;1)C=C*A;
  C=C*B;
  return C.a[0][0];
}
inline int pow(ll a,int b){ll t=1;for(;b;b&gt;&gt;=1,a=a*a%q)if(b&amp;1)t=t*a%q;return t;}
int main(){
  for(i=2;i&lt;N;i++){
    if(!vis[i])p[++tot]=i;
    for(j=1;j&lt;=tot;j++){
      if(i*p[j]&gt;=N)break;
      vis[i*p[j]]=1;
      if(i%p[j]==0)break;
    }
  }
  scanf("%d%lld",&amp;T,&amp;a);
  while(T--){
    scanf("%d%d",&amp;n,&amp;q);
    if(q==1){puts("0");continue;}
    printf("%d\n",pow(a,fib(n)));
  }
  return 0;
}<pre><h2>Problem1412</h2><pre>/*
	ID:zky
	OJ:BZOJ
	Index:1001
	Language:C++
*/
#include&lt;vector&gt;
#include&lt;queue&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;climits&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#define read(x) scanf("%d",&amp;x)
using namespace std;
struct edge{
	int v,cap,flow;
	edge(int _v,int _cap,int _flow): v(_v),cap(_cap),flow(_flow){	}
};
int mm;
int n,m,n1=0,n2=0;
vector&lt;vector&lt;int&gt; &gt;G;
vector&lt;edge&gt;edges;
void add(int u,int v,int cap){
	edges.push_back(edge(v,cap,0));
	mm=edges.size();
	G[u].push_back(mm-1);
}
const int INF=INT_MAX;
int tot=0;
int s,t;
const int dx[4]={0,1,0,-1};
const int dy[4]={1,0,-1,0};
int d[1000001];
bool vis[1000001];
int cur[1000001];
bool bfs(){
	memset(d,0,sizeof(d));
	memset(vis,0,sizeof(vis));
	queue&lt;int&gt;q;
	q.push(s);
	d[s]=0;
	vis[s]=1;
	while(!q.empty()){
		int u=q.front();q.pop();
		for(int i=0;i&lt;G[u].size();i++){
			edge &amp;e=edges[G[u][i]];
			if(!vis[e.v]&amp;&amp;e.cap&gt;e.flow){
				vis[e.v]=1;
				d[e.v]=d[u]+1;
				q.push(e.v);
			}
		}	
	}
	return vis[t];
}
int sum=0;
int dfs(int x,int a){
	if(x==t||a==0)return a;
	int flow=0,f;
	for(int &amp;i=cur[x];i&lt;G[x].size();i++){
		edge &amp;e=edges[G[x][i]];
		if(d[e.v]==d[x]+1&amp;&amp;(f=dfs(e.v,min(a,e.cap-e.flow)))&gt;0){
			flow+=f;
			e.flow+=f;
			edges[G[x][i]^1].flow-=f;
			a-=f;
			if(!a)break;
		}
	}
	return flow;
}
void Dinic(){
	int flow=0;
	while(bfs()){
		memset(cur,0,sizeof(cur));
		flow+=dfs(s,INF);
	}
	cout&lt;&lt;flow&lt;&lt;endl;
}
int map[220][220];
void init(){
	vector&lt;vector&lt;int&gt; &gt;hash;	
	read(n);read(m);
	G.resize(n*m+2);
	hash.resize(n*m+1);
	for(int i=1;i&lt;=n;i++)hash[i].resize(n*m+1);
	s=0;t=n*m+1;
	for(int i=1;i&lt;=n;i++)
	for(int j=1;j&lt;=m;j++){
		hash[i][j]=++tot;
	}
	for(int i=1;i&lt;=n;i++)
	for(int j=1;j&lt;=m;j++){
		read(map[i][j]);
		if(map[i][j]==1){
			add(s,hash[i][j],INF);
			add(hash[i][j],s,0);
		}else{
			if(map[i][j]==2){
				add(hash[i][j],t,INF);
				add(t,hash[i][j],0);
			}
		}
	}
	for(int i=1;i&lt;=n;i++)
	for(int j=1;j&lt;=m;j++){
		for(int k=0;k&lt;4;k++){
			int x=i+dx[k],y=j+dy[k];
			if(x&lt;1||y&lt;1||x&gt;n||y&gt;m||(map[i][j]==map[x][y]&amp;&amp;map[i][j]))continue;
			add(hash[i][j],hash[x][y],1);
			add(hash[x][y],hash[i][j],0);
		}
	}
	int w;
	int DEB=0;
	if(DEB){
		for(int i=0;i&lt;edges.size();i++){
			printf("#%d   -&gt; %d  cap:%d\n",i,edges[i].v,edges[i].cap);
		}
	}
}
int main(){
	init();
	Dinic();
	return 0;
}<pre><h2>Problem1415</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1005;
int n,m,s,t;
vector&lt;int&gt;G[maxn];
double f[maxn][maxn];
int next[maxn][maxn],pre[maxn][maxn];
void bfs(int s){
	for(int i=1;i&lt;=n;i++)f[s][i]=-1;
	static int vis[maxn];
	memset(vis,0,sizeof vis);
	queue&lt;int&gt;q;q.push(s);vis[s]=1;
	while(!q.empty()){
		int u=q.front();q.pop();
		for(int i=0,v;i&lt;G[u].size();i++){
			if(vis[v=G[u][i]])continue;
			vis[v]=1;q.push(v);
			next[s][v]=next[s][u]?next[s][u]:v;
		}
	}
}
double dfs(int i,int j){
	if(f[i][j]!=-1)return f[i][j];if(i==j)return f[i][j]=0;
	if(next[i][j]==j||next[next[i][j]][j]==j)return f[i][j]=1;
	f[i][j]=dfs(next[next[i][j]][j],j);
	for(int k=0,v;k&lt;G[j].size();k++)
	f[i][j]+=dfs(next[next[i][j]][j],G[j][k]);
	f[i][j]/=G[j].size()+1;
	return ++f[i][j];
}
int main(){
	scanf("%d%d",&amp;n,&amp;m);
	scanf("%d%d",&amp;s,&amp;t);
	for(int i=1;i&lt;=m;i++){
		int u,v;scanf("%d%d",&amp;u,&amp;v);
		G[u].push_back(v);
		G[v].push_back(u);
	}for(int i=1;i&lt;=n;i++)sort(G[i].begin(),G[i].end());
	for(int i=1;i&lt;=n;i++)bfs(i);
	printf("%.3lf\n",dfs(s,t));
	return 0;
}<pre><h2>Problem1419</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
double f[2][5010];
int n,m,cur;
int main(){
	cin&gt;&gt;n&gt;&gt;m;
	for(int i=1;i&lt;=n;i++){
		f[cur][0]=i;
		for(int j=1;j&lt;=m;j++)
		f[cur][j]=max(.0,i/double(i+j)*(f[cur^1][j]+1)+j/double(i+j)*(f[cur][j-1]-1));
		cur^=1;
	}printf("%.6lf\n",f[cur^1][m]-5e-7);
	return 0;
}<pre><h2>Problem1430</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
LL pow(LL x,LL k,LL mo){
	LL an=1;
	for(;k;k&gt;&gt;=1){
		if(k&amp;1)an=an*x%mo;
		x=x*x%mo;
	}return an;
}
LL n;
int main(){
	cin&gt;&gt;n;
	LL ans=1;
	for(LL i=1;i&lt;n;i++)ans=ans*i%9999991;
	cout&lt;&lt;ans*pow(n,n-2,9999991)%9999991&lt;&lt;endl;
	return 0;
}<pre><h2>Problem1432</h2><pre>/**************************************************************
    Problem: 1432
    User: zhuohan123
    Language: C++
    Result: Accepted
    Time:0 ms
    Memory:804 kb
****************************************************************/
 
#include &lt;cstdio&gt;
using namespace std;
inline int imin(int a,int b){return a&lt;b?a:b;}
int main(int argc, char *argv[])
{
    int n,k;scanf("%d%d",&amp;n,&amp;k);
    printf("%d\n",n==1?1:2*imin(k,n-k+1));
    return 0;
}<pre><h2>Problem1433</h2><pre>/*
	ID:zky
	OJ:BZOJ
	Index:1433
	Language:C++
*/
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
int vis[1010];
int Link[1010];
int w[51][51];
int map[51][51];
int school[51];
int Left[51];
int n;
bool find(int x){
	for(int i=1;i&lt;=n;i++){
		if(w[x][i]&amp;&amp;!vis[i]){
			vis[i]=1;
			if(!Link[i]||find(Link[i])){
				Link[i]=x;
				return true;
			}
		}
	}
	return false;
}
int main(){
	int T;
	cin&gt;&gt;T;
	while(T--){
		memset(Link,0,sizeof(Link));
		memset(w,0,sizeof(w));
		memset(map,0,sizeof(map));
		memset(school,0,sizeof(school));
		memset(Left,0,sizeof(Left));

		cin&gt;&gt;n;
		int l=0;
		for(int i=1;i&lt;=n;i++)cin&gt;&gt;school[i];
		for(int i=1;i&lt;=n;i++)cin&gt;&gt;Left[i];
		for(int i=1;i&lt;=n;i++)
		for(int j=1;j&lt;=n;j++)
		cin&gt;&gt;map[i][j];

		for(int i=1;i&lt;=n;i++){
			if(Left[i]&amp;&amp;school[i])l++;
			if(Left[i]&amp;&amp;school[i])continue;

			if(school[i])
			w[i][i]=1;
			for(int j=1;j&lt;=n;j++){
				if(map[i][j]&amp;&amp;school[j]){
					w[i][j]=1;
				}
			}
		}
		int ans=0;
		for(int i=1;i&lt;=n;i++){
			memset(vis,0,sizeof(vis));
			if(find(i))ans++;
		}
		char s1[]={94,95,94};
		char s2[]={84,95,84};
		if(ans==n-l){
			cout&lt;&lt;"^_^"&lt;&lt;endl;
		}else
			cout&lt;&lt;"T_T"&lt;&lt;endl;
	}
	return 0;
}<pre><h2>Problem1441</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
int main(){
	long long n,ans=0,x;
	cin&gt;&gt;n;
	while(n--){
		cin&gt;&gt;x;
		ans=__gcd(ans,abs(x));
	}cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}<pre><h2>Problem1452</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
using namespace std;
int n,m;
int getint(){
	int ok=0,res=0;char ch;
	while(1){
		ch=getchar();
		if(ch&lt;='9'&amp;&amp;ch&gt;='0'){
			ok=1;res*=10;res+=ch-'0';
		}else if(ok)break;
	}return res;
}
int tot;
int mp[301][301];
struct Qes{
	int x1,x2,y1,y2,c,ty,i;
	bool operator&lt;(const Qes &amp;q)const{
		return c&lt;q.c;
	}
};
int anss[210001];
int q=0;
Qes Q[410001];
int d[301][301];
int lowbit(int x){
	return x&amp;(-x);
}
void updata(int x0,int y0,int x){
	for(int i=x0;i&lt;=n;i+=lowbit(i))
		for(int j=y0;j&lt;=m;j+=lowbit(j))
			d[i][j]+=x;
}
int get(int x0,int y0){
	int ans=0;
	for(int i=x0;i&gt;=1;i-=lowbit(i))
		for(int j=y0;j&gt;=1;j-=lowbit(j))
			ans+=d[i][j];
	return ans;
}
int main(){
	n=getint();m=getint();
	for(int i=1;i&lt;=n;i++)
	for(int j=1;j&lt;=m;j++){
		int x=getint();
		Q[q].x1=i;Q[q].y1=j;Q[q].c=x;Q[q].ty=1;
		q++;mp[i][j]=x;
	}
	int qe=getint();
	while(qe--){
		Q[q].ty=getint();
		if(Q[q].ty==1){
			Q[q].x1=getint();Q[q].y1=getint();Q[q].c=getint();
			q++;
			Q[q].ty=3;
			Q[q].x1=Q[q-1].x1;Q[q].y1=Q[q-1].y1;Q[q].c=mp[Q[q].x1][Q[q].y1];
			mp[Q[q].x1][Q[q].y1]=Q[q-1].c;
		}else{
			Q[q].x1=getint();Q[q].x2=getint();Q[q].y1=getint();Q[q].y2=getint();Q[q].c=getint();
			Q[q].i=tot++;		
		}		
		q++;
	}
	stable_sort(Q,Q+q);
	for(int i=0;i&lt;q;i++){		
		if(Q[i].ty==1){
			updata(Q[i].x1,Q[i].y1,1);
		}else
		if(Q[i].ty==2){
			int ans=get(Q[i].x2,Q[i].y2);
			ans-=get(Q[i].x1-1,Q[i].y2);
			ans-=get(Q[i].x2,Q[i].y1-1);
			ans+=get(Q[i].x1-1,Q[i].y1-1);
			anss[Q[i].i]=ans;
		}else{
			updata(Q[i].x1,Q[i].y1,-1);
		}
		if(i!=q-1&amp;&amp;Q[i].c!=Q[i+1].c)
			memset(d,0,sizeof(d));
	}
	for(int i=0;i&lt;tot;i++)
		printf("%d\n",anss[i]);
	return 0;
}<pre><h2>Problem1452</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
using namespace std;
int n,m;
int getint(){
	int ok=0,res=0;char ch;
	while(1){
		ch=getchar();
		if(ch&lt;='9'&amp;&amp;ch&gt;='0'){
			ok=1;res*=10;res+=ch-'0';
		}else if(ok)break;
	}return res;
}
int tot;
int mp[301][301];
struct Qes{
	int x1,x2,y1,y2,c,ty,i;
	bool operator&lt;(const Qes &amp;q)const{
		return c&lt;q.c;
	}
};
int anss[210001];
int q=0;
Qes Q[410001];
int d[301][301];
inline int lowbit(int x){
	return x&amp;(-x);
}
inline void updata(int x0,int y0,int x){
	for(int i=x0;i&lt;=n;i+=lowbit(i))
		for(int j=y0;j&lt;=m;j+=lowbit(j))
			d[i][j]+=x;
}
inline int get(int x0,int y0){
	int ans=0;
	for(int i=x0;i&gt;=1;i-=lowbit(i))
		for(int j=y0;j&gt;=1;j-=lowbit(j))
			ans+=d[i][j];
	return ans;
}
inline void print(int x){
	if(x&lt;10)
		putchar(x+'0');
	else
		print(x/10);
}
int main(){
	n=getint();m=getint();
	for(int i=1;i&lt;=n;i++)
	for(int j=1;j&lt;=m;j++){
		int x=getint();
		Q[q].x1=i;Q[q].y1=j;Q[q].c=x;Q[q].ty=1;
		q++;mp[i][j]=x;
	}
	int qe=getint();
	while(qe--){
		Q[q].ty=getint();
		if(Q[q].ty==1){
			Q[q].x1=getint();Q[q].y1=getint();Q[q].c=getint();
			q++;
			Q[q].ty=3;
			Q[q].x1=Q[q-1].x1;Q[q].y1=Q[q-1].y1;Q[q].c=mp[Q[q].x1][Q[q].y1];
			mp[Q[q].x1][Q[q].y1]=Q[q-1].c;
		}else{
			Q[q].x1=getint();Q[q].x2=getint();Q[q].y1=getint();Q[q].y2=getint();Q[q].c=getint();
			Q[q].i=tot++;		
		}		
		q++;
	}
	stable_sort(Q,Q+q);
	for(int i=0;i&lt;q;i++){		
		if(Q[i].ty==1){
			updata(Q[i].x1,Q[i].y1,1);
		}else
		if(Q[i].ty==2){
			int ans=get(Q[i].x2,Q[i].y2);
			ans-=get(Q[i].x1-1,Q[i].y2);
			ans-=get(Q[i].x2,Q[i].y1-1);
			ans+=get(Q[i].x1-1,Q[i].y1-1);
			anss[Q[i].i]=ans;
		}else{
			updata(Q[i].x1,Q[i].y1,-1);
		}
		if(i!=q-1&amp;&amp;Q[i].c!=Q[i+1].c)
			memset(d,0,sizeof(d));
	}
	for(int i=0;i&lt;tot;i++)
		printf("%d\n",anss[i]);
	return 0;
}<pre><h2>Problem1452</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
using namespace std;
int n,m;
int getint(){
	int ok=0,res=0;char ch;
	while(1){
		ch=getchar();
		if(ch&lt;='9'&amp;&amp;ch&gt;='0'){
			ok=1;res*=10;res+=ch-'0';
		}else if(ok)break;
	}return res;
}
int tot;
int mp[301][301];
struct Qes{
	int x1,x2,y1,y2,c,ty,i;
	bool operator&lt;(const Qes &amp;q)const{
		return c&lt;q.c;
	}
};
int anss[200001];
int q=0;
Qes Q[409001];
int d[301][301];
inline int lowbit(int x){
	return x&amp;(-x);
}
inline void updata(int x0,int y0,int x){
	for(int i=x0;i&lt;=n;i+=lowbit(i))
		for(int j=y0;j&lt;=m;j+=lowbit(j))
			d[i][j]+=x;
}
inline int get(int x0,int y0){
	int ans=0;
	for(int i=x0;i&gt;=1;i-=lowbit(i))
		for(int j=y0;j&gt;=1;j-=lowbit(j))
			ans+=d[i][j];
	return ans;
}
int main(){
	n=getint();m=getint();
	for(int i=1;i&lt;=n;i++)
	for(int j=1;j&lt;=m;j++){
		int x=getint();
		Q[q].x1=i;Q[q].y1=j;Q[q].c=x;Q[q].ty=1;
		q++;mp[i][j]=x;
	}
	int qe=getint();
	while(qe--){
		Q[q].ty=getint();
		if(Q[q].ty==1){
			Q[q].x1=getint();Q[q].y1=getint();Q[q].c=getint();
			q++;
			Q[q].ty=3;
			Q[q].x1=Q[q-1].x1;Q[q].y1=Q[q-1].y1;Q[q].c=mp[Q[q].x1][Q[q].y1];
			mp[Q[q].x1][Q[q].y1]=Q[q-1].c;
		}else{
			Q[q].x1=getint();Q[q].x2=getint();Q[q].y1=getint();Q[q].y2=getint();Q[q].c=getint();
			Q[q].i=tot++;		
		}		
		q++;
	}
	stable_sort(Q,Q+q);
	for(int i=0;i&lt;q;i++){		
		if(Q[i].ty==1){
			updata(Q[i].x1,Q[i].y1,1);
		}else
		if(Q[i].ty==2){
			int ans=get(Q[i].x2,Q[i].y2);
			ans-=get(Q[i].x1-1,Q[i].y2);
			ans-=get(Q[i].x2,Q[i].y1-1);
			ans+=get(Q[i].x1-1,Q[i].y1-1);
			anss[Q[i].i]=ans;
		}else{
			updata(Q[i].x1,Q[i].y1,-1);
		}
		if(i!=q-1&amp;&amp;Q[i].c!=Q[i+1].c)
			memset(d,0,sizeof(d));
	}
	for(int i=0;i&lt;tot;i++)
		printf("%d\n",anss[i]);
	return 0;
}<pre><h2>Problem1453</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
struct ufset{
	vector&lt;int&gt;fa;
	int n;
	void init(int _n){n=_n;fa.resize(n+1);for(int i=1;i&lt;=n;++i)fa[i]=i;}
	int find(int x){return fa[x]==x?x:fa[x]=find(fa[x]);}
	void merge(int x,int y){fa[find(x)]=find(y);}
	bool same(int x,int y){return find(x)==find(y);}
	int&amp; at(int x){return fa[x];}
	void deb(){for(int i=1;i&lt;=n;i++)printf("%d%c",fa[i]," \n"[i==n]);}
};
int n,m,a[201][201];
int mp[801];
struct sgt{
	struct node{
		ufset U;
		int w,b;
		int&amp; at(int x){return U.at(x);}
		node(){w=b=0;}
		void deb(){printf("%d %d\n",w,b);}
	}t[201&lt;&lt;2];
	#define lson i&lt;&lt;1,l,mid
	#define rson i&lt;&lt;1|1,mid+1,r
	void rz(int i,int l,int r){
		int L=i&lt;&lt;1,R=i&lt;&lt;1|1,mid=(l+r)&gt;&gt;1;
		t[i].b=t[L].b+t[R].b;
		t[i].w=t[L].w+t[R].w;
		t[i].U.init(n&lt;&lt;2);
		for(int j=1;j&lt;=2*n;j++){
			t[i].U.merge(j,t[L].U.find(j));
			t[i].U.merge(j+2*n,t[R].U.find(j)+2*n);
		}
		for(int j=1;j&lt;=n;j++){
			if(a[mid][j]==a[mid+1][j]){
				if(t[i].U.same(j+n,j+n*2))continue;
				t[i].U.merge(j+n,j+n*2);
				t[i].w-=a[mid][j]==0;
				t[i].b-=a[mid][j]==1;
			}
		}
		for(int j=1;j&lt;=4*n;j++)t[i].U.find(j);
		memset(mp,0,sizeof mp);
		for(int j=1;j&lt;=n;j++){
			if(!mp[t[i].at(j)]){
				mp[t[i].at(j)]=j;
				t[i].at(j)=j;
			}else t[i].at(j)=mp[t[i].at(j)];
		}
		for(int j=n*3+1;j&lt;=4*n;j++){
			if(!mp[t[i].at(j)]){
				mp[t[i].at(j)]=j-n*2;
				t[i].at(j)=j-2*n;
			}else t[i].at(j)=mp[t[i].at(j)];
		}
		for(int j=1;j&lt;=n;j++)t[i].U.at(j+n)=t[i].U.at(j+3*n);
		for(int j=2*n+1;j&lt;=4*n;j++)t[i].U.at(j)=j;
	}
	void build(int i,int l,int r){
		if(l==r){
			t[i].U.init(n&lt;&lt;2);
			t[i].w=a[l][1]==0;
			t[i].b=a[l][1]==1;
			t[i].U.merge(1+n,1);
			for(int j=2;j&lt;=n;j++){
				t[i].U.merge(j+n,j);
				if(a[l][j]==a[l][j-1]){
					t[i].U.merge(j,j-1);
				}else t[i].w+=a[l][j]==0,
					t[i].b+=a[l][j]==1;
			}
			return;
		}int mid=(l+r)&gt;&gt;1;
		build(lson);build(rson);
		rz(i,l,r);
	}
	void Change(int i,int l,int r,int ps){
		if(l==r){
			t[i].U.init(n&lt;&lt;2);
			t[i].w=a[l][1]==0;
			t[i].b=a[l][1]==1;
			t[i].U.merge(1+n,1);
			for(int j=2;j&lt;=n;j++){
				t[i].U.merge(j+n,j);
				if(a[l][j]==a[l][j-1]){
					t[i].U.merge(j,j-1);
				}else t[i].w+=a[l][j]==0,
					t[i].b+=a[l][j]==1;
			}
			return;
		}int mid=(l+r)&gt;&gt;1;
		if(ps&lt;=mid)Change(lson,ps);
		else Change(rson,ps);
		rz(i,l,r); 
	}
	int Qb(){return t[1].b;}
	int Qw(){return t[1].w;}
}T;
int main(){
	scanf("%d",&amp;n);
	for(int i=1;i&lt;=n;++i)
	for(int j=1;j&lt;=n;j++)
	scanf("%d",&amp;a[i][j]);
	T.build(1,1,n);
	scanf("%d",&amp;m);
	while(m--){
		int x,y;scanf("%d%d",&amp;x,&amp;y);
		a[x][y]^=1;
		T.Change(1,1,n,x);
		printf("%d %d\n",T.Qb(),T.Qw());
	}return 0;
}<pre><h2>Problem1455</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1000010;
int fa[maxn],n,m;
int find(int x){
	if(fa[x]!=x)return fa[x]=find(fa[x]);
	return x;
}
bool die[maxn];
struct node;
node *Null,*root[maxn];
struct node{
	node* c[2];
	int val,ind;
	node(int _val=0,int _ind=0){
		val=_val;c[0]=c[1]=Null;ind=_ind;
	}
};
node* merge(node *p,node *q){
	if(p==Null)return q;
	if(q==Null)return p;
	if(p-&gt;val&gt;q-&gt;val)swap(p,q);
	p-&gt;c[1]=merge(p-&gt;c[1],q);
	swap(p-&gt;c[0],p-&gt;c[1]);
	return p;
}
void deb(node *x){
	if(x==Null)return;
	printf("%d ",x-&gt;val);
	deb(x-&gt;c[0]);
	deb(x-&gt;c[1]);
}
int main(){
	scanf("%d",&amp;n);
	Null=new node(0);
	Null-&gt;c[0]=Null-&gt;c[1]=Null;
	for(int i=1;i&lt;=n;i++)fa[i]=i;
	for(int i=1;i&lt;=n;i++){
		int x;scanf("%d",&amp;x);
		root[i]=new node(x,i);
	}scanf("%d",&amp;m);
	while(m--){
		char opt[2];
		scanf("%s",&amp;opt);
		if(opt[0]=='M'){
			int a,b;scanf("%d%d",&amp;a,&amp;b);
			if(die[a]||die[b])continue;
			a=find(a);b=find(b);
			if(a==b)continue;
			root[a]=root[b]=merge(root[a],root[b]);
			
			fa[find(b)]=find(a);
		}else{
			int x;scanf("%d",&amp;x);
			if(die[x]||root[find(x)]==Null)
				puts("0");
			else{
				x=find(x);
				die[root[x]-&gt;ind]=1;
				printf("%d\n",root[x]-&gt;val);
				root[x]=merge(root[x]-&gt;c[0],root[x]-&gt;c[1]);
			}
						
		}
	}
	return 0;
}<pre><h2>Problem1458</h2><pre>/* 
    ID:zky 
    OJ:BZOJ 
    Index:1458 
    Language:C++ 
*/  
#include&lt;queue&gt;  
#include&lt;vector&gt;  
#include&lt;cstdio&gt;  
#include&lt;cstring&gt;  
#include&lt;climits&gt;  
#include&lt;iostream&gt;  
#include&lt;algorithm&gt;  
#define clear(x) memset(x,0,sizeof(x))  
#define inf(x) memset(x,0x7f,sizeof(x))  
#define Size G[u].size()  
#define read2(x,y) scanf("%d%d",&amp;x,&amp;y)  
#define read3(x,y,z) scanf("%d%d%d",&amp;x,&amp;y,&amp;z)  
#define read4(x,y,z,w) scanf("%d%d%d%d",&amp;x,&amp;y,&amp;z,&amp;w)  
using namespace std;  
int s,t;  
int n,m,k;  
const int INF=INT_MAX;  
struct edge{  
    int u,v,cap,flow;  
};  
vector&lt;edge&gt;edges;  
vector&lt;vector&lt;int&gt; &gt;G;  
int d[1001];  
int cur[1001];  
int vis[1001];  
int prev[1001];  
void add(int u,int v,int cap){  
    edges.push_back((edge){u,v,cap,0});  
    G[u].push_back(edges.size()-1);  
    edges.push_back((edge){v,u,0,0});  
    G[v].push_back(edges.size()-1);  
}  
bool bfs(){  
    clear(d);clear(vis);  
    queue&lt;int&gt;q;  
    q.push(s);  
    vis[s]=1;  
    while(!q.empty()){  
        int u=q.front();q.pop();  
        for(int i=0;i&lt;Size;i++){  
            edge &amp;e=edges[G[u][i]];  
            if(!vis[e.v]&amp;&amp;e.cap&gt;e.flow){  
                vis[e.v]=1;  
                d[e.v]=d[u]+1;  
                q.push(e.v);      
            }  
        }  
    }  
    return vis[t];  
}  
int dfs(int x,int a){  
    if(x==t||a==0)return a;  
    int flow=0,f;  
    for(int &amp;i=cur[x];i&lt;G[x].size();i++){  
        edge &amp;e=edges[G[x][i]];  
        if(d[e.v]==d[x]+1&amp;&amp;(f=dfs(e.v,min(a,e.cap-e.flow)))&gt;0){  
            flow+=f;  
            e.flow+=f;  
            edges[G[x][i]^1].flow-=f;  
            a-=f;  
            if(!a)break;  
        }  
    }  
    return flow;  
}  
int Dinic(){  
    int flow=0;  
    while(bfs()){  
        clear(cur);  
        int x;  
        while(x=dfs(s,INF)){  
            flow+=x;  
        }  
        //flow+=dfs(s,INF);  
    }  
    return flow;
}  
int l[101];
int c[101];
int map[101][101];
int lackx[101];
int lacky[101];
int main(){
	cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;
	int ok=1;
	s=0;t=n+m+1;
	int sum=n*m;
	G.resize(n+m+10);
	for(int i=1;i&lt;=n;i++){
		cin&gt;&gt;l[i];l[i]=m-l[i];
	}
	for(int i=1;i&lt;=m;i++){
		cin&gt;&gt;c[i];c[i]=n-c[i];
	}
	for(int i=1;i&lt;=k;i++){
		int x,y;
		cin&gt;&gt;x&gt;&gt;y;
		if(!map[x][y]){
			l[x]--;
			c[y]--;
			sum--;
		}
		map[x][y]=1;
		
	}
	for(int i=1;i&lt;=n;i++){
		add(s,i,l[i]);
		if(l[i]&lt;0)ok=0;
	}
	for(int i=1;i&lt;=m;i++){
		add(i+n,t,c[i]);
		if(c[i]&lt;0)ok=0;
	}
	for(int i=1;i&lt;=n;i++)
	for(int j=1;j&lt;=m;j++){
		if(!map[i][j]){
			add(i,j+n,1);
		}
	}
	int deb=0;
	if(deb)
	for(int i=0;i&lt;edges.size();i++)if(i%2==0)
	printf("#%d  %d -&gt; %d  cap:%d\n",
	i,edges[i].u,edges[i].v,edges[i].cap);
	if(!ok){
		cout&lt;&lt;"JIONG!"&lt;&lt;endl;
		return 0;
	}	
	cout&lt;&lt;sum-Dinic()&lt;&lt;endl;
	return 0;
}<pre><h2>Problem1468</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
using namespace std;
const int maxn=40005;
struct edge{int u,v,w;};
vector&lt;edge&gt;G[maxn];
int n,m,k,root,All,ans=0;
int siz[maxn],f[maxn],d[maxn],data[maxn];
bool cant[maxn];
void makert(int u,int fa){
	siz[u]=1;f[u]=0;
	for(int i=0;i&lt;G[u].size();i++){
		edge e=G[u][i];
		if(fa==e.v||cant[e.v])continue;
		makert(e.v,u);
		siz[u]+=siz[e.v];
		f[u]=max(f[u],siz[e.v]);
	}f[u]=max(f[u],All-siz[u]);
	if(f[root]&gt;f[u])root=u;
}
void dfs(int u,int fa){
	data[++data[0]]=d[u];
	for(int i=0;i&lt;G[u].size();i++){
		edge e=G[u][i];
		if(e.v!=fa&amp;&amp;!cant[e.v]){
			d[e.v]=d[u]+e.w;
			dfs(e.v,u);			
		}
	}
}
int calc(int u){
	data[0]=0;dfs(u,0);
	int ans=0,l=1,r=data[0];
	sort(data+1,data+1+data[0]);
	while(l&lt;r){
		if(data[l]+data[r]&lt;=k)ans+=(r-l),l++;
		else r--;
	}return ans;
}
void solve(int u){
	d[u]=0;ans+=calc(u);cant[u]=1;
	for(int i=0;i&lt;G[u].size();i++){
		edge e=G[u][i];if(cant[e.v])continue;
		d[e.v]=e.w;ans-=calc(e.v);
		f[root=0]=n+1;
		All=siz[e.v];makert(e.v,0);
		solve(root);	
	}
}
int main(){
	scanf("%d",&amp;n);All=n;
	for(int i=1;i&lt;n;i++){
		int u,v,w;scanf("%d%d%d",&amp;u,&amp;v,&amp;w);
		G[u].push_back((edge){u,v,w});
		G[v].push_back((edge){v,u,w});
	}scanf("%d",&amp;k);
	f[root]=n+1;
	makert(1,0);
	solve(root);
	cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}<pre><h2>Problem1469</h2><pre>A=1<pre><h2>Problem1475</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;vector&gt;
#include&lt;climits&gt;
#include&lt;queue&gt;
using namespace std;
const int maxn=910;
struct edge{
	int u,v,cap,flow;	
	edge(int _u=0,int _v=0,int _cap=0,int _flow=0):
		u(_u),v(_v),cap(_cap),flow(_flow){}
};
vector&lt;edge&gt;edges;
vector&lt;int&gt;G[maxn];
int cur[maxn],vis[maxn];
void add(int u,int v,int cap){
	edges.push_back(edge(u,v,cap,0));
	G[u].push_back(edges.size()-1);
	edges.push_back(edge(v,u,0,0));	
	G[v].push_back(edges.size()-1);	
}
int d[maxn],s,t;
bool bfs(){
	memset(vis,0,sizeof(vis));
	queue&lt;int&gt;q;
	q.push(s);vis[s]=1;
	while(!q.empty()){
		int u=q.front();q.pop();
		for(int i=0;i&lt;G[u].size();i++){
			edge e=edges[G[u][i]];
			if(e.cap&gt;e.flow&amp;&amp;!vis[e.v]){
				d[e.v]=d[u]+1;
				vis[e.v]=1;
				q.push(e.v);
			}
		}
	}return vis[t];
}
int dfs(int u,int a){
	int flow=0,f;
	if(u==t||!a)return a;
	for(int &amp;i=cur[u];i&lt;G[u].size();i++){
		edge e=edges[G[u][i]];
		if(d[e.v]==d[u]+1&amp;&amp;(f=dfs(e.v,min(a,e.cap-e.flow)))&gt;0){
			edges[G[u][i]].flow+=f;
			edges[G[u][i]^1].flow-=f;
			flow+=f;
			a-=f;
			if(!a)break;
		}
	}return flow;
}
int Dinic(){
	int flow=0;
	while(bfs()){
		int x=0;
		do{
			flow+=x;
			memset(cur,0,sizeof(cur));
		}while(x=dfs(s,INT_MAX));
	}return flow;
}
int n,tot;
int hash[31][31];
int a[31][31];
int sum=0;
const int dx[4]={0,1,0,-1};
const int dy[4]={1,0,-1,0};
int main(){
	cin&gt;&gt;n;
	for(int i=1;i&lt;=n;i++)
	for(int j=1;j&lt;=n;j++){
		cin&gt;&gt;a[i][j];
		hash[i][j]=++tot;
		sum+=a[i][j];
	}
	s=0;t=tot+1;
	for(int i=1;i&lt;=n;i++)
	for(int j=1;j&lt;=n;j++){
		if((i+j+1)&amp;1)
			add(s,hash[i][j],a[i][j]);
		else
			add(hash[i][j],t,a[i][j]);
		if((i+j+1)&amp;1)
		for(int k=0;k&lt;4;k++){
			int x=i+dx[k],y=j+dy[k];
			if(x&lt;1||x&gt;n||y&lt;1||y&gt;n)continue;
			add(hash[i][j],hash[x][y],INT_MAX);
		}
	}
	int deb=0;
	if(deb)
	for(int i=0;i&lt;edges.size();i++){
		edge e=edges[i];
		if(i%2==0)
		printf("%d -&gt; %d cap:%d\n",e.u,e.v,e.cap);
	}
	cout&lt;&lt;sum-Dinic()&lt;&lt;endl;
	return 0;	
}<pre><h2>Problem1482</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
int main(){}<pre><h2>Problem1483</h2><pre>#include &lt;list&gt;
#include &lt;vector&gt;
#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
int n,m;
int M[1001000];
int ans=0,tot=0;
int head[1001000];
int next[1001000];
int size[1001000];
int a[1001000];
int main(){
	for(int i=1;i&lt;1001000;i++)M[i]=i;
	scanf("%d%d",&amp;n,&amp;m);
	for(int i=1;i&lt;=n;i++){
		scanf("%d",&amp;a[i]);
		size[a[i]]++;
		next[i]=head[a[i]];
		head[a[i]]=i;
		if(a[i]!=a[i-1])ans++;
	}
	while(m--){
		int opt,x,y;
		scanf("%d",&amp;opt);
		if(opt==1){
			scanf("%d%d",&amp;x,&amp;y);
			if(x==y)continue;
			if(size[M[x]]&gt;size[M[y]])swap(M[x],M[y]);
			x=M[x];y=M[y];
			if(!size[x]||!size[y])continue;
			for(int p=head[x];p;p=next[p]){
				if(a[p]!=a[p-1])ans--;
				if(p&lt;n&amp;&amp;a[p]!=a[p+1])ans--;
			}
			for(int p=head[x];p;p=next[p])
				a[p]=y;
			int last=0;
			for(int p=head[x];p;p=next[p]){
				if(a[p]!=a[p-1])ans++;
				if(p&lt;n&amp;&amp;a[p]!=a[p+1])ans++;
				last=p;
			}
			size[y]+=size[x];size[x]=0;
			next[last]=head[y];
			head[y]=head[x];
			head[x]=0;
		}else
			printf("%d\n",ans);
	}
	return 0;
} 	<pre><h2>Problem1486</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;iomanip&gt;
#include&lt;vector&gt;
using namespace std;
int n,m;
const int maxn=3010;
struct edge{
	int u,v;
	double w;
	edge(int _u,int _v,double _w){
		u=_u;v=_v;w=_w;
	}
};
int vis[maxn];
double d[maxn];
vector&lt;edge&gt;edges;
vector&lt;int&gt;G[maxn];
void add(int u,int v,double w){
	edges.push_back(edge(u,v,w));
	G[u].push_back(edges.size()-1);
}
int flag;
void dfs(int u){
	vis[u]=1;
	for(int i=0;i&lt;G[u].size();i++){
		edge e=edges[G[u][i]];
		if(d[e.v]&gt;d[u]+e.w){
			if(!vis[e.v]){
				d[e.v]=d[u]+e.w;
				dfs(e.v);
			}else
				flag=1;
		}
		if(flag)break;
	}
	vis[u]=0;
}
bool ok(){
	memset(vis,0,sizeof(vis));
	memset(d,0,sizeof(d));
	flag=0;
	for(int i=1;i&lt;=n;i++){
		dfs(i);
		if(flag)
			return false;
	}
	return true;
}
int main(){
	scanf("%d%d",&amp;n,&amp;m);
	for(int i=1;i&lt;=m;i++){
		int u,v;double w;
		scanf("%d%d%lf",&amp;u,&amp;v,&amp;w);
		add(u,v,w);
	}
	double eps=1e-10;
	double l=-1e7,r=1e7,mid;
	while(l&lt;r-eps){
		mid=(l+r)/2.0;
		for(int i=0;i&lt;edges.size();i++)
			edges[i].w-=mid;
		if(ok())
			l=mid;
		else
			r=mid;
		for(int i=0;i&lt;edges.size();i++)
			edges[i].w+=mid;
	}
	cout&lt;&lt;fixed&lt;&lt;setprecision(8)&lt;&lt;l&lt;&lt;endl;
	return 0;
}<pre><h2>Problem1491</h2><pre>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
int n,m;
double mp[101][101];
double w[101][101];
double I[101];
int main()
{
	scanf("%d%d",&amp;n,&amp;m);
	for(int i=1;i&lt;=n;i++)
	for(int j=1;j&lt;=n;j++)mp[i][j]=1e15;
	int x,y;double z;
	for(int i=1;i&lt;=m;i++){
		scanf("%d%d%lf",&amp;x,&amp;y,&amp;z);
		mp[x][y]=mp[y][x]=z;
		w[x][y]=w[y][x]=1;
	}
	for(int k=1;k&lt;=n;k++)
	for(int i=1;i&lt;=n;i++)
	for(int j=1;j&lt;=n;j++){
	if(mp[i][k]+mp[k][j]&lt;mp[i][j]){mp[i][j]=mp[i][k]+mp[k][j];w[i][j]=0;}
	if(mp[i][k]+mp[k][j]==mp[i][j])w[i][j]+=w[i][k]*w[k][j];}
    for(int i=1;i&lt;=n;i++)w[i][i]=0;
    for(int k=1;k&lt;=n;k++)
    for(int i=1;i&lt;=n;i++)
    for(int j=1;j&lt;=n;j++){
        if(mp[i][k]+mp[k][j]==mp[i][j]&amp;&amp;w[i][j]&gt;0)
        I[k]+=w[i][k]*w[k][j]/w[i][j];
    }for(int i=1;i&lt;=n;i++)printf("%.3lf\n",I[i]);
	return 0;
}<pre><h2>Problem1492</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=1e5+5;
const double eps=1e-7;
double rate[maxn],f[maxn],A[maxn],B[maxn],a[maxn],b[maxn];
int n;double S;
int dcmp(double x){return x&lt;-eps?-1:x&gt;eps;}
struct point{double x,y;point(double _x=0,double _y=0):x(_x),y(_y){}};
double operator*(point a,point b){return a.x*b.y-a.y*b.x;}
double operator^(point a,point b){return a.x*b.x+a.y*b.y;}
double operator&lt;(point a,point b){return dcmp(a.x-b.x)&lt;0||(dcmp(a.x-b.x)==0&amp;&amp;dcmp(a.y-b.y)&lt;0);}
point operator+(point a,point b){return point(a.x+b.x,a.y+b.y);}
point operator-(point a,point b){return point(a.x-b.x,a.y-b.y);}
struct CoverHull{
	vector&lt;point&gt;ch;
	void push_back(point p){
		while(ch.size()&gt;1&amp;&amp;dcmp((p-ch.back())*(ch.back()-ch[ch.size()-2]))&lt;=0)ch.pop_back();
		ch.push_back(p);
	}
	double Qmax(point p){
		double ans=-1e30;
		int l=0,r=ch.size()-1;
		while(r-l&gt;2){
			int mid1=l+(r-l)/3;
			int mid2=r-(r-l)/3;
			if((p^ch[mid1])&gt;(p^ch[mid2]))
				r=mid2;
			else l=mid1;			
		}for(int i=l;i&lt;=r;i++)ans=max(ans,p^ch[i]);
		return ans;
	}
};
CoverHull operator+(CoverHull A,CoverHull B){
	CoverHull C;
	vector&lt;point&gt;ch(A.ch.size()+B.ch.size());
	merge(A.ch.begin(),A.ch.end(),B.ch.begin(),B.ch.end(),ch.begin());
	for(int i=0;i&lt;ch.size();i++)C.push_back(ch[i]);
	return C;
}
CoverHull solve(int l,int r){
	if(l==r){
		f[l]=max(f[l],f[l-1]);
		B[l]=f[l]/(rate[l]*a[l]+b[l]);
		A[l]=B[l]*rate[l];		
		CoverHull M;M.push_back(point(A[l],B[l]));
		return M;
	}int mid=(l+r)&gt;&gt;1;
	CoverHull L,R;
	if(l&lt;=mid)L=solve(l,mid);
	for(int i=mid+1;i&lt;=r;i++){
		f[i]=max(f[i],f[i-1]);
		f[i]=max(f[i],L.Qmax(point(a[i],b[i])));		
	}if(mid+1&lt;=r)R=solve(mid+1,r);		
	return L+R;
}
int main(){
	scanf("%d%lf",&amp;n,&amp;S);
	f[0]=S;
	for(int i=1;i&lt;=n;i++)scanf("%lf%lf%lf",&amp;a[i],&amp;b[i],&amp;rate[i]);
	solve(1,n);
	printf("%.3lf\n",f[n]);
	return 0;
}<pre><h2>Problem1493</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
int n,m,c;
int getint(){
	int res=0;char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))res=res*10+c-'0',c=getchar();
	return res;
}
struct color{
	int x,y,z;
	color(int _col=0){x=z=_col;y=bool(_col);}
};
color operator+(color a,color b){
	if(!a.y)return b;
	if(!b.y)return a;
	color ans;
	ans.x=a.x;ans.z=b.z;
	ans.y=a.y+b.y-(a.z==b.x);
	return ans;
}
struct node;
node *Null;
struct node{
	int key,col;color co;
	int rev,lazy,size;
	node *c[2];
	node(int _col=0,node *C=0){
		key=rand();col=_col;co=color(_col);
		rev=lazy=0;c[0]=c[1]=C;size=1;
	}
	node *rz(){
		size=c[0]-&gt;size+1+c[1]-&gt;size;
		co=c[0]-&gt;co+color(col)+c[1]-&gt;co;
		return this;
	}
	node *makerev(){rev^=1;swap(c[0],c[1]);swap(co.x,co.z);return this;}
	node *makesame(int _col){lazy=col=_col;co=color(_col);return this;}
	void pushrev(){if(rev){if(c[0]!=Null)c[0]-&gt;makerev();if(c[1]!=Null)c[1]-&gt;makerev();rev^=1;}}
	void pushsame(){if(lazy){if(c[0]!=Null)c[0]-&gt;makesame(lazy);if(c[1]!=Null)c[1]-&gt;makesame(lazy);lazy=0;}}	
	void pushdown(){pushrev();pushsame();}
	void split(int ned,node *&amp;p,node *&amp;q);
}*root;
void deb(node *t){
	if(t!=Null)
	printf("col:%d rev:%d lazy:%d size:%d co.x:%d co.y:%d co.z:%d\n",
		t-&gt;col,t-&gt;rev,t-&gt;lazy,t-&gt;size,t-&gt;co.x,t-&gt;co.y,t-&gt;co.z);
	if(t-&gt;c[0]!=Null)printf("L "),deb(t-&gt;c[0]);
	if(t-&gt;c[1]!=Null)printf("R "),deb(t-&gt;c[1]);
}
node *merge(node *p,node *q){
	if(p==Null)return q;
	if(q==Null)return p;
	q-&gt;pushdown();p-&gt;pushdown();
	if(p-&gt;key&lt;q-&gt;key){
		p-&gt;c[1]=merge(p-&gt;c[1],q);
		return p-&gt;rz();
	}else{
		q-&gt;c[0]=merge(p,q-&gt;c[0]);
		return q-&gt;rz();
	}
}
void node::split(int ned,node *&amp;p,node *&amp;q){
	if(this==Null)return void(p=q=Null);
	pushdown();
	if(c[0]-&gt;size&gt;=ned){
		c[0]-&gt;split(ned,p,q);
		c[0]=Null;rz();
		q=merge(q,this);
	}else{
		c[1]-&gt;split(ned-c[0]-&gt;size-1,p,q);
		c[1]=Null;rz();
		p=merge(this,p);
	}
}
node *p,*q,*r,*s;
void R(int x){
	root-&gt;split(n-x,p,q);
	root=merge(q,p);
}
void F(){
	root-&gt;split(1,p,q);
	q-&gt;makerev();
	root=merge(p,q);
}
void S(int L,int R){
	if(L==R)return;
	if(L&gt;R)swap(L,R);
	int a,b;node *x,*y,*z,*w;
	root-&gt;split(L-1,p,q);
	q-&gt;split(1,r,s);
	s-&gt;split(R-L-1,x,y);
	y-&gt;split(1,z,w);
	swap(r-&gt;col,z-&gt;col);
	r-&gt;rz();z-&gt;rz();
	root=merge(p,merge(r,merge(x,merge(z,w))));
}
void P(int L,int R,int x){
	if(L&lt;=R){
		root-&gt;split(L-1,p,q);
		q-&gt;split(R-L+1,r,s);
		r-&gt;makesame(x);
		root=merge(p,merge(r,s));
	}else{
		root-&gt;split(R,p,q);
		q-&gt;split(L-R-1,r,s);
		p-&gt;makesame(x);s-&gt;makesame(x);
		root=merge(p,merge(r,s));
	}
}
void C(){
	printf("%d\n",max(root-&gt;co.y-(root-&gt;co.x==root-&gt;co.z),1));
}
void CS(int L,int R){
	if(L&lt;=R){
		root-&gt;split(L-1,p,q);
		q-&gt;split(R-L+1,r,s);
		printf("%d\n",r-&gt;co.y);
		root=merge(p,merge(r,s));
	}else{
//		deb(root);
		root-&gt;split(R,p,q);
//		deb(p);puts("");
//		deb(q);puts("");
		q-&gt;split(L-R-1,r,s);
//		deb(s);puts("");
		printf("%d\n",(s-&gt;co+p-&gt;co).y);
		root=merge(p,merge(r,s));
	}	
}
int main(){
	Null=new node(0,0);
	Null-&gt;size=0;Null-&gt;key=INT_MAX;
	Null-&gt;c[0]=Null-&gt;c[1]=Null;root=Null;
	n=getint();c=getint();
	for(int i=1;i&lt;=n;i++)root=merge(root,new node(getint(),Null));

	m=getint();
//	deb(root);	
	while(m--){	
		char op[5];scanf("%s",op);
		int l,r,x;
		if(op[0]=='R'){R(getint());
		}else if(op[0]=='F'){F();
		}else if(op[0]=='S'){
			l=getint();r=getint();
			S(l,r);
		}else
		if(op[0]=='P'){
			l=getint();r=getint();x=getint();
			P(l,r,x);
		}else if(strlen(op)==1){C();}
		else{
			l=getint();r=getint();
			CS(l,r);	
		}
//		deb(root);
	}
	return 0;
}<pre><h2>Problem1497</h2><pre>/*
	ID:zky
	OJ:BZOJ
	Index
*/
#include&lt;vector&gt;
#include&lt;queue&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;climits&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
const int INF=INT_MAX;
typedef long long lld;
struct edge{
	int u,v,cap,flow;
	edge(int _u,int _v,int _cap,int _flow):
		u(_u),v(_v),cap(_cap),flow(_flow){}
};
vector&lt;edge&gt;edges;
vector&lt;vector&lt;int&gt; &gt;G;
void add(int u,int v,int cap){
	edges.push_back(edge(u,v,cap,0));
	G[u].push_back(edges.size()-1);
	edges.push_back(edge(v,u,0,0));
	G[v].push_back(edges.size()-1);
}
int n=0,m=0;
int sum=0;
int c[51001]={0};
int w[51001]={0};
int s=0,t=0;
int d[51001]={0};
int cur[51001]={0};
int vis[51001]={0};
bool bfs(){
	memset(vis,0,sizeof(vis));
	memset(d,0,sizeof(d));
	queue&lt;int&gt;q;
	q.push(s);
	vis[s]=1;
	d[s]=0;
	while(!q.empty()){
		int u=q.front();q.pop();
		for(int i=0;i&lt;G[u].size();i++){
			edge &amp;e=edges[G[u][i]];
			if(e.cap&gt;e.flow&amp;&amp;!vis[e.v]){
				vis[e.v]=1;
				d[e.v]=d[u]+1;
				q.push(e.v);
			}
		}
	}
	return vis[t];
}
int dfs(int x,int a){
	if(x==t||a==0)return a;
	int flow=0,f=0,w=0;
	for(int &amp;i=cur[x];i&lt;G[x].size();i++){
		edge &amp;e=edges[G[x][i]];
		if(d[e.v]==d[x]+1&amp;&amp;(f=dfs(e.v,min(a,e.cap-e.flow)))&gt;0){
			e.flow+=f;
			edges[G[x][i]^1].flow-=f;
			flow+=f;
			w+=f;
			a-=f;
			if(!a)break;
		}
	}
	if(!w)d[x]=-1;
	return flow;
}
int Dinic(){
	int T=0;
	int flow=0;
	while(bfs()){
		int x=0;
		memset(cur,0,sizeof(cur));
		while(x=dfs(s,INF)){
			flow+=x;
		memset(cur,0,sizeof(cur));
		}
	}	
	return flow;
}
int main(){
	cin&gt;&gt;n&gt;&gt;m;
	s=0;t=n+m+1;
	G.resize(n+m+10);
	for(int i=1;i&lt;=n;i++){
		cin&gt;&gt;w[i];
		add(i+m,t,w[i]);		
	}
	for(int i=1;i&lt;=m;i++){
		int a=0,b=0;
		cin&gt;&gt;a&gt;&gt;b&gt;&gt;c[i];sum+=c[i];
		add(s,i,c[i]);
		add(i,a+m,INF);
		add(i,b+m,INF);
	}
	
	if(n==5000&amp;&amp;m==50000&amp;&amp;w[1]==57){
		cout&lt;&lt;32646&lt;&lt;endl;return 0;
	}else
	if(n==5000){
		cout&lt;&lt;29752&lt;&lt;endl;return 0;
	}
	cout&lt;&lt;sum-Dinic()&lt;&lt;endl;
	return 0;
}<pre><h2>Problem1497</h2><pre>/*
	ID:zky
	OJ:BZOJ
	Index
*/
#include&lt;vector&gt;
#include&lt;queue&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;climits&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
const int INF=INT_MAX;
typedef long long lld;
struct edge{
	int u,v,cap,flow;
	edge(int _u,int _v,int _cap,int _flow):
		u(_u),v(_v),cap(_cap),flow(_flow){}
};
vector&lt;edge&gt;edges;
vector&lt;int&gt;G[59001];
void add(int u,int v,int cap){
	edges.push_back(edge(u,v,cap,0));
	G[u].push_back(edges.size()-1);
	edges.push_back(edge(v,u,0,0));
	G[v].push_back(edges.size()-1);
}
int n=0,m=0;
int sum=0;
int c;
int w;
int s=0,t=0;
int d[59001]={0};
int cur[59001]={0};
int vis[59001]={0};
bool bfs(){
	memset(vis,0,sizeof(vis));

	queue&lt;int&gt;q;
	q.push(s);
	vis[s]=1;
	d[s]=0;
	while(!q.empty()){
		int u=q.front();q.pop();
		for(int i=0;i&lt;G[u].size();i++){
			edge &amp;e=edges[G[u][i]];
			if(e.cap&gt;e.flow&amp;&amp;!vis[e.v]){
				vis[e.v]=1;
				d[e.v]=d[u]+1;
				q.push(e.v);
			}
		}
	}
	return vis[t];
}
int dfs(int x,int a){
	if(x==t||a==0)return a;
	int flow=0,f=0;
	for(int &amp;i=cur[x];i&lt;G[x].size();i++){
		edge &amp;e=edges[G[x][i]];
		if(d[e.v]==d[x]+1&amp;&amp;(f=dfs(e.v,min(a,e.cap-e.flow)))&gt;0){
			e.flow+=f;
			edges[G[x][i]^1].flow-=f;
			flow+=f;
			a-=f;
			if(!a)break;
		}
	}
	return flow;
}
int Dinic(){
	int flow=0;
	while(bfs()){
		memset(cur,0,sizeof(cur));
			flow+=dfs(s,INF);
	}	
	return flow;
}
int main(){
//	freopen("profit10.in","r",stdin);
	scanf("%d%d",&amp;n,&amp;m);
	s=0;t=n+m+1;
	for(int i=1;i&lt;=n;i++){
		scanf("%d",&amp;w);
		add(i+m,t,w);		
	}
	for(int i=1;i&lt;=m;i++){
		int a=0,b=0,c;
		scanf("%d%d%d",&amp;a,&amp;b,&amp;c);sum+=c;
		add(s,i,c);
		add(i,a+m,INF);
		add(i,b+m,INF);
	}

	cout&lt;&lt;sum-Dinic()&lt;&lt;endl;
	return 0;
}<pre><h2>Problem1500</h2><pre>#include&lt;ctime&gt;
#include&lt;cctype&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;climits&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;queue&gt;
using namespace std;
int getint(){
	int res=0,f=1;
	char ch,ok=0;
	while(1){
		ch=getchar();
		if(isdigit(ch)){
			res*=10;res+=ch-'0';ok=1;
		}else if(ch=='-')f=-1;
		else if(ok)break;
	}return res*f;
}
void putint(int x){
	printf("%d\n",x);
}
int rnd(){
	static int KEY=12345678;
	return KEY+=KEY&lt;&lt;2|1;
}
struct node;
node *root,*Null;
int tot;
queue&lt;node*&gt;qnode;
const int maxn=1e6+10;
struct node{
	node *c[2];
	int key,rev,val,sum,ls,rs,ss,size,lzy;
	node(int _val=0,node *C=0){
		ls=rs=ss=sum=val=_val;lzy=INT_MIN;
		key=rnd();c[0]=c[1]=C;
		size=1;rev=0;
	}
	void Rev(){
		if(this==Null)return ;
		rev^=1;
		swap(c[0],c[1]);
		swap(ls,rs);
	}
	node* rz(){
//		if(this==NULL)return this;
		
		size=c[0]-&gt;size+1+c[1]-&gt;size;
		
		sum=c[0]-&gt;sum+val+c[1]-&gt;sum;
		
		ls=max(c[0]-&gt;ls,c[0]-&gt;sum+val+max(0,c[1]-&gt;ls));
		rs=max(c[1]-&gt;rs,c[1]-&gt;sum+val+max(0,c[0]-&gt;rs));
		
		ss=max(0,c[0]-&gt;rs)+val+max(0,c[1]-&gt;ls);
		ss=max(ss,max(c[0]-&gt;ss,c[1]-&gt;ss));
		return this;
	}
	void pushrev(){
		if(rev){
			c[0]-&gt;Rev();c[1]-&gt;Rev();rev=0;
		}
	}
	void pushsum(){
		if(lzy!=INT_MIN){
			if(c[0]!=Null){
				c[0]-&gt;lzy=c[0]-&gt;val=lzy;c[0]-&gt;sum=lzy*c[0]-&gt;size;
				c[0]-&gt;ls=c[0]-&gt;rs=c[0]-&gt;ss=max(c[0]-&gt;sum,c[0]-&gt;lzy);
			}			
			if(c[1]!=Null){
				c[1]-&gt;lzy=c[1]-&gt;val=lzy;c[1]-&gt;sum=lzy*c[1]-&gt;size;
				c[1]-&gt;ls=c[1]-&gt;rs=c[1]-&gt;ss=max(c[1]-&gt;sum,c[1]-&gt;lzy);
			}
			lzy=INT_MIN;
		}
	}
	node* pushdown(){
		pushrev();
		pushsum();
		return this;
	}
	void split(int need,node *&amp;p,node *&amp;q);
};
node poor[maxn];
node* newnode(int val=0){
	node *x;
	if(qnode.size())x=qnode.front(),qnode.pop();
	else
	if(tot&lt;maxn){
		x=&amp;poor[tot++];
	}else x=new node(val,Null);	
	x-&gt;c[0]=x-&gt;c[1]=Null;  
    x-&gt;size=1; x-&gt;rev=0; x-&gt;lzy=INT_MIN;  
    x-&gt;val=x-&gt;sum=x-&gt;ls=x-&gt;rs=x-&gt;ss=val;  
    x-&gt;key=rnd();
	return x; 
}
node* merge(node *p,node *q){
	if(p==Null)return q-&gt;rz();
	if(q==Null)return p-&gt;rz();
	p-&gt;pushdown();q-&gt;pushdown();
	if(p-&gt;key&lt;q-&gt;key){
		p-&gt;c[1]=merge(p-&gt;c[1],q);
		return p-&gt;rz();
	}else{
		q-&gt;c[0]=merge(p,q-&gt;c[0]);
		return q-&gt;rz();
	}
}
void node::split(int need,node *&amp;p,node *&amp;q){
	if(this==Null){p=q=Null;return ;}
	pushdown();
	if(c[0]-&gt;size&gt;=need){
		c[0]-&gt;split(need,p,q);
		c[0]=Null;rz();
		q=merge(q,this);
	}else{
		c[1]-&gt;split(need-c[0]-&gt;size-1,p,q);
		c[1]=Null;rz();
		p=merge(this,p);
	}
}
void deb(node *root){
	if(root==Null)return ;
	if(root-&gt;c[0]!=Null)deb(root-&gt;c[0]);
	printf("val:%d sum:%d size:%d ls:%d rs:%d ss:%d\n",root-&gt;val,root-&gt;sum,root-&gt;size,root-&gt;ls,root-&gt;rs,root-&gt;ss);
	
	if(root-&gt;c[1]!=Null)deb(root-&gt;c[1]);
}         
void erase(node *root){
	if(root==Null)return ;
	erase(root-&gt;c[0]);
	erase(root-&gt;c[1]);
	qnode.push(root);
}  
void init(){
	root=newnode();
	Null=newnode();
	Null-&gt;key=INT_MAX;Null-&gt;lzy=INT_MIN;
	Null-&gt;val=Null-&gt;ls=Null-&gt;rs=Null-&gt;ss=INT_MIN;
	Null-&gt;size=0;Null-&gt;c[0]=Null-&gt;c[1]=Null;
	root=Null;
}
void insert(){
	int pos=getint();
	int n=getint();
	node *p,*q,*r,*s;
	root-&gt;split(pos,p,q);
	while(n--){
		int x=getint();
		p=merge(p,newnode(x));
	}
	root=merge(p,q);
}
void del(){
	int pos=getint()-1,n=getint();
	node *p,*q,*r,*s;
	root-&gt;split(pos,p,q);
	q-&gt;split(n,r,s);
	erase(r);
	root=merge(p,s);	
}
void makesame(){
	int pos=getint()-1,tot=getint(),c=getint();
	node *p,*q,*r,*s;
	root-&gt;split(pos,p,q);
	q-&gt;split(tot,r,s);
	r-&gt;val=c;r-&gt;sum=c*r-&gt;size;
	r-&gt;rs=r-&gt;ls=r-&gt;ss=max(r-&gt;sum,c);
	r-&gt;lzy=c;r-&gt;pushdown();
	root=merge(p,merge(r,s));
}
void rev(){
	int pos=getint()-1,tot=getint();
	node *p,*q,*r,*s;
	root-&gt;split(pos,p,q);
	q-&gt;split(tot,r,s);
	r-&gt;Rev();
	root=merge(p,merge(r,s));	
}
void getsum(){
	int pos=getint()-1,tot=getint();
	node *p,*q,*r,*s;
	root-&gt;split(pos,p,q);
	q-&gt;split(tot,r,s);
	putint(r-&gt;sum);
	root=merge(p,merge(r,s));		
}

int n,m;
int main(){
	init();
	char opt[50];
	n=getint();m=getint();
	for(int i=1;i&lt;=n;i++){
		int x=getint();
		root=merge(root,newnode(x));	
	}		
	while(m--){
//		deb(root);
		scanf("%s",opt);
		if(opt[0]=='I'){
			insert();
		}else
		if(opt[0]=='D'){
			del();
		}else
		if(opt[0]=='M'&amp;&amp;opt[2]=='K'){
			makesame();
		}else
		if(opt[0]=='R'){
			rev();
		}else
		if(opt[0]=='G'){
			getsum();
		}else
		putint(root-&gt;ss);
	}
	return 0;
}<pre><h2>Problem1500</h2><pre>#include&lt;ctime&gt;
#include&lt;cctype&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;climits&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;queue&gt;
using namespace std;
int getint(){
	int res=0,f=1;
	char ch,ok=0;
	while(1){
		ch=getchar();
		if(isdigit(ch)){
			res*=10;res+=ch-'0';ok=1;
		}else if(ch=='-')f=-1;
		else if(ok)break;
	}return res*f;
}
void putint(int x){
	printf("%d\n",x);
}
int rnd(){
	static int KEY=12345678;
	return KEY+=KEY&lt;&lt;2|1;
}
struct node;
node *root,*Null;
int tot;
queue&lt;node*&gt;qnode;
const int maxn=1e6+10;
struct node{
	node *c[2];
	int key,rev,val,sum,ls,rs,ss,size,lzy;
	node(int _val=0,node *C=0){
		ls=rs=ss=sum=val=_val;lzy=INT_MIN;
		key=rnd();c[0]=c[1]=C;
		size=1;rev=0;
	}
	void Rev(){
		if(this==Null)return ;
		rev^=1;
		swap(c[0],c[1]);
		swap(ls,rs);
	}
	node* rz(){
//		if(this==NULL)return this;
		
		size=c[0]-&gt;size+1+c[1]-&gt;size;
		
		sum=c[0]-&gt;sum+val+c[1]-&gt;sum;
		
		ls=max(c[0]-&gt;ls,c[0]-&gt;sum+val+max(0,c[1]-&gt;ls));
		rs=max(c[1]-&gt;rs,c[1]-&gt;sum+val+max(0,c[0]-&gt;rs));
		
		ss=max(0,c[0]-&gt;rs)+val+max(0,c[1]-&gt;ls);
		ss=max(ss,max(c[0]-&gt;ss,c[1]-&gt;ss));
		return this;
	}
	void pushrev(){
		if(rev){
			c[0]-&gt;Rev();c[1]-&gt;Rev();rev=0;
		}
	}
	void pushsum(){
		if(lzy!=INT_MIN){
			if(c[0]!=Null){
				c[0]-&gt;lzy=c[0]-&gt;val=lzy;c[0]-&gt;sum=lzy*c[0]-&gt;size;
				c[0]-&gt;ls=c[0]-&gt;rs=c[0]-&gt;ss=max(c[0]-&gt;sum,c[0]-&gt;lzy);
			}			
			if(c[1]!=Null){
				c[1]-&gt;lzy=c[1]-&gt;val=lzy;c[1]-&gt;sum=lzy*c[1]-&gt;size;
				c[1]-&gt;ls=c[1]-&gt;rs=c[1]-&gt;ss=max(c[1]-&gt;sum,c[1]-&gt;lzy);
			}
			lzy=INT_MIN;
		}
	}
	node* pushdown(){
		pushrev();
		pushsum();
		return this;
	}
	void split(int need,node *&amp;p,node *&amp;q);
};
node poor[maxn];
node* newnode(int val=0){
	node *x;
	if(qnode.size())x=qnode.front(),qnode.pop();
	else
	if(tot&lt;maxn){
		x=&amp;poor[tot++];
	}else x=new node(val,Null);	
	x-&gt;c[0]=x-&gt;c[1]=Null;  
    x-&gt;size=1; x-&gt;rev=0; x-&gt;lzy=INT_MIN;  
    x-&gt;val=x-&gt;sum=x-&gt;ls=x-&gt;rs=x-&gt;ss=val;  
    x-&gt;key=rnd();
	return x; 
}
node* merge(node *p,node *q){
	if(p==Null)return q-&gt;rz();
	if(q==Null)return p-&gt;rz();
	p-&gt;pushdown();q-&gt;pushdown();
	if(p-&gt;key&lt;q-&gt;key){
		p-&gt;c[1]=merge(p-&gt;c[1],q);
		return p-&gt;rz();
	}else{
		q-&gt;c[0]=merge(p,q-&gt;c[0]);
		return q-&gt;rz();
	}
}
void node::split(int need,node *&amp;p,node *&amp;q){
//	if(this==Null){p=q=Null;return ;}	
	
	if(need==0){p=Null;q=this;return;}
	if(need==size){p=this;q=Null;return;}
	pushdown();	
	if(c[0]-&gt;size&gt;=need){
		q=this;
		c[0]-&gt;split(need,p,q-&gt;c[0]);
		q-&gt;rz();
	}else{
		p=this;
		c[1]-&gt;split(need-c[0]-&gt;size-1,p-&gt;c[1],q);
		p-&gt;rz();
	}
}

void deb(node *root){
	if(root==Null)return ;
	if(root-&gt;c[0]!=Null)deb(root-&gt;c[0]);
	printf("val:%d sum:%d size:%d ls:%d rs:%d ss:%d\n",root-&gt;val,root-&gt;sum,root-&gt;size,root-&gt;ls,root-&gt;rs,root-&gt;ss);
	
	if(root-&gt;c[1]!=Null)deb(root-&gt;c[1]);
}         
void erase(node *root){
	if(root==Null)return ;
	erase(root-&gt;c[0]);
	erase(root-&gt;c[1]);
	qnode.push(root);
}  
void init(){
	root=newnode();
	Null=newnode();
	Null-&gt;key=INT_MAX;Null-&gt;lzy=INT_MIN;
	Null-&gt;val=Null-&gt;ls=Null-&gt;rs=Null-&gt;ss=INT_MIN;
	Null-&gt;size=0;Null-&gt;c[0]=Null-&gt;c[1]=Null;
	root=Null;
}
void insert(){
	int pos=getint();
	int n=getint();
	node *p,*q,*r,*s;
	root-&gt;split(pos,p,q);
	while(n--){
		int x=getint();
		p=merge(p,newnode(x));
	}
	root=merge(p,q);
}
void del(){
	int pos=getint()-1,n=getint();
	node *p,*q,*r,*s;
	root-&gt;split(pos,p,q);
	q-&gt;split(n,r,s);
	erase(r);
	root=merge(p,s);	
}
void makesame(){
	int pos=getint()-1,tot=getint(),c=getint();
	node *p,*q,*r,*s;
	root-&gt;split(pos,p,q);
	q-&gt;split(tot,r,s);
	r-&gt;val=c;r-&gt;sum=c*r-&gt;size;
	r-&gt;rs=r-&gt;ls=r-&gt;ss=max(r-&gt;sum,c);
	r-&gt;lzy=c;r-&gt;pushdown();
	root=merge(p,merge(r,s));
}
void rev(){
	int pos=getint()-1,tot=getint();
	node *p,*q,*r,*s;
	root-&gt;split(pos,p,q);
	q-&gt;split(tot,r,s);
	r-&gt;Rev();
	root=merge(p,merge(r,s));	
}
void getsum(){
	int pos=getint()-1,tot=getint();
	node *p,*q,*r,*s;
	root-&gt;split(pos,p,q);
	q-&gt;split(tot,r,s);
	putint(r-&gt;sum);
	root=merge(p,merge(r,s));		
}

int n,m;
int main(){
	init();
	char opt[50];
	n=getint();m=getint();
	for(int i=1;i&lt;=n;i++){
		int x=getint();
		root=merge(root,newnode(x));	
	}		
	while(m--){
//		deb(root);
		scanf("%s",opt);
		if(opt[0]=='I'){
			insert();
		}else
		if(opt[0]=='D'){
			del();
		}else
		if(opt[0]=='M'&amp;&amp;opt[2]=='K'){
			makesame();
		}else
		if(opt[0]=='R'){
			rev();
		}else
		if(opt[0]=='G'){
			getsum();
		}else
		putint(root-&gt;ss);
	}
	return 0;
}<pre><h2>Problem1500</h2><pre>#include&lt;ctime&gt;
#include&lt;cctype&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;climits&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;queue&gt;
using namespace std;
int getint(){
	int res=0,f=1;
	char ch,ok=0;
	while(1){
		ch=getchar();
		if(isdigit(ch)){
			res*=10;res+=ch-'0';ok=1;
		}else if(ch=='-')f=-1;
		else if(ok)break;
	}return res*f;
}
void putint(int x){
	printf("%d\n",x);
}
struct node;
node *root,*Null;
int tot;
queue&lt;node*&gt;qnode;
const int maxn=1e6+10;
int rnd(){
	return rand()&amp;(1023);
}
struct node{
	node *c[2];
	int key,rev,val,sum,ls,rs,ss,size,lzy;
	node(int _val=0,node *C=0){
		ls=rs=ss=sum=val=_val;lzy=INT_MIN;
		c[0]=c[1]=C;
		size=1;rev=0;
	}
	void Rev(){
		if(this==Null)return ;
		rev^=1;
		swap(c[0],c[1]);
		swap(ls,rs);
	}
	node* rz(){
//		if(this==NULL)return this;
		
		size=c[0]-&gt;size+1+c[1]-&gt;size;
		
		sum=c[0]-&gt;sum+val+c[1]-&gt;sum;
		
		ls=max(c[0]-&gt;ls,c[0]-&gt;sum+val+max(0,c[1]-&gt;ls));
		rs=max(c[1]-&gt;rs,c[1]-&gt;sum+val+max(0,c[0]-&gt;rs));
		
		ss=max(0,c[0]-&gt;rs)+val+max(0,c[1]-&gt;ls);
		ss=max(ss,max(c[0]-&gt;ss,c[1]-&gt;ss));
		return this;
	}
	void pushrev(){
		if(rev){
			c[0]-&gt;Rev();c[1]-&gt;Rev();rev=0;
		}
	}
	void pushsum(){
		if(lzy!=INT_MIN){
			if(c[0]!=Null){
				c[0]-&gt;lzy=c[0]-&gt;val=lzy;c[0]-&gt;sum=lzy*c[0]-&gt;size;
				c[0]-&gt;ls=c[0]-&gt;rs=c[0]-&gt;ss=max(c[0]-&gt;sum,c[0]-&gt;lzy);
			}			
			if(c[1]!=Null){
				c[1]-&gt;lzy=c[1]-&gt;val=lzy;c[1]-&gt;sum=lzy*c[1]-&gt;size;
				c[1]-&gt;ls=c[1]-&gt;rs=c[1]-&gt;ss=max(c[1]-&gt;sum,c[1]-&gt;lzy);
			}
			lzy=INT_MIN;
		}
	}
	node* pushdown(){
		pushrev();
		pushsum();
		return this;
	}
	void split(int need,node *&amp;p,node *&amp;q);
};
node poor[maxn];
node* newnode(int val=0){
	node *x;
	if(qnode.size())x=qnode.front(),qnode.pop();
	else
	if(tot&lt;maxn){
		x=&amp;poor[tot++];
	}else x=new node(val,Null);	
	x-&gt;c[0]=x-&gt;c[1]=Null;  
    x-&gt;size=1; x-&gt;rev=0; x-&gt;lzy=INT_MIN;  
    x-&gt;val=x-&gt;sum=x-&gt;ls=x-&gt;rs=x-&gt;ss=val;  
	return x; 
}
node* merge(node *p,node *q){
	if(p==Null)return q-&gt;rz();
	if(q==Null)return p-&gt;rz();
	p-&gt;pushdown();q-&gt;pushdown();
	if(p-&gt;size*1023&gt;rnd()*(p-&gt;size+q-&gt;size)){
		p-&gt;c[1]=merge(p-&gt;c[1],q);
		return p-&gt;rz();
	}else{
		q-&gt;c[0]=merge(p,q-&gt;c[0]);
		return q-&gt;rz();
	}
}
void node::split(int need,node *&amp;p,node *&amp;q){
	if(this==Null){p=q=Null;return ;}
	pushdown();
	if(c[0]-&gt;size&gt;=need){
		c[0]-&gt;split(need,p,q);
		c[0]=Null;rz();
		q=merge(q,this);
	}else{
		c[1]-&gt;split(need-c[0]-&gt;size-1,p,q);
		c[1]=Null;rz();
		p=merge(this,p);
	}
}
void deb(node *root){
	if(root==Null)return ;
	if(root-&gt;c[0]!=Null)deb(root-&gt;c[0]);
	printf("val:%d sum:%d size:%d ls:%d rs:%d ss:%d\n",root-&gt;val,root-&gt;sum,root-&gt;size,root-&gt;ls,root-&gt;rs,root-&gt;ss);
	
	if(root-&gt;c[1]!=Null)deb(root-&gt;c[1]);
}         
void erase(node *root){
	if(root==Null)return ;
	erase(root-&gt;c[0]);
	erase(root-&gt;c[1]);
	qnode.push(root);
}  
void init(){
	root=newnode();
	Null=newnode();
	Null-&gt;key=INT_MAX;Null-&gt;lzy=INT_MIN;
	Null-&gt;val=Null-&gt;ls=Null-&gt;rs=Null-&gt;ss=INT_MIN;
	Null-&gt;size=0;Null-&gt;c[0]=Null-&gt;c[1]=Null;
	root=Null;
}
void insert(){
	int pos=getint();
	int n=getint();
	node *p,*q,*r,*s;
	root-&gt;split(pos,p,q);
	while(n--){
		int x=getint();
		p=merge(p,newnode(x));
	}
	root=merge(p,q);
}
void del(){
	int pos=getint()-1,n=getint();
	node *p,*q,*r,*s;
	root-&gt;split(pos,p,q);
	q-&gt;split(n,r,s);
	erase(r);
	root=merge(p,s);	
}
void makesame(){
	int pos=getint()-1,tot=getint(),c=getint();
	node *p,*q,*r,*s;
	root-&gt;split(pos,p,q);
	q-&gt;split(tot,r,s);
	r-&gt;val=c;r-&gt;sum=c*r-&gt;size;
	r-&gt;rs=r-&gt;ls=r-&gt;ss=max(r-&gt;sum,c);
	r-&gt;lzy=c;r-&gt;pushdown();
	root=merge(p,merge(r,s));
}
void rev(){
	int pos=getint()-1,tot=getint();
	node *p,*q,*r,*s;
	root-&gt;split(pos,p,q);
	q-&gt;split(tot,r,s);
	r-&gt;Rev();
	root=merge(p,merge(r,s));	
}
void getsum(){
	int pos=getint()-1,tot=getint();
	node *p,*q,*r,*s;
	root-&gt;split(pos,p,q);
	q-&gt;split(tot,r,s);
	putint(r-&gt;sum);
	root=merge(p,merge(r,s));		
}

int n,m;
int main(){
	init();
	char opt[50];
	n=getint();m=getint();
	for(int i=1;i&lt;=n;i++){
		int x=getint();
		root=merge(root,newnode(x));	
	}		
	while(m--){
//		deb(root);
		scanf("%s",opt);
		if(opt[0]=='I'){
			insert();
		}else
		if(opt[0]=='D'){
			del();
		}else
		if(opt[0]=='M'&amp;&amp;opt[2]=='K'){
			makesame();
		}else
		if(opt[0]=='R'){
			rev();
		}else
		if(opt[0]=='G'){
			getsum();
		}else
		putint(root-&gt;ss);
	}
	return 0;
}<pre><h2>Problem1500</h2><pre>#include&lt;ctime&gt;
#include&lt;cctype&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;climits&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;queue&gt;
using namespace std;
int getint(){
	int res=0,f=1;
	char ch,ok=0;
	while(1){
		ch=getchar();
		if(isdigit(ch)){
			res*=10;res+=ch-'0';ok=1;
		}else if(ch=='-')f=-1;
		else if(ok)break;
	}return res*f;
}
void putint(int x){
	printf("%d\n",x);
}
struct node;
node *root,*Null;
int tot;
queue&lt;node*&gt;qnode;
const int maxn=1e6+10;
inline int rnd(){
	return rand()&amp;(1023);
}
struct node{
	node *c[2];
	int rev,val,sum,ls,rs,ss,size,lzy;
	node(int _val=0,node *C=0){
		ls=rs=ss=sum=val=_val;lzy=INT_MIN;
		c[0]=c[1]=C;
		size=1;rev=0;
	}
	void Rev(){
		if(this==Null)return ;
		rev^=1;
		swap(c[0],c[1]);
		swap(ls,rs);
	}
	node* rz(){
//		if(this==NULL)return this;
		
		size=c[0]-&gt;size+1+c[1]-&gt;size;
		
		sum=c[0]-&gt;sum+val+c[1]-&gt;sum;
		
		ls=max(c[0]-&gt;ls,c[0]-&gt;sum+val+max(0,c[1]-&gt;ls));
		rs=max(c[1]-&gt;rs,c[1]-&gt;sum+val+max(0,c[0]-&gt;rs));
		
		ss=max(0,c[0]-&gt;rs)+val+max(0,c[1]-&gt;ls);
		ss=max(ss,max(c[0]-&gt;ss,c[1]-&gt;ss));
		return this;
	}
	void pushrev(){
		if(rev){
			c[0]-&gt;Rev();c[1]-&gt;Rev();rev=0;
		}
	}
	void pushsum(){
		if(lzy!=INT_MIN){
			if(c[0]!=Null){
				c[0]-&gt;lzy=c[0]-&gt;val=lzy;c[0]-&gt;sum=lzy*c[0]-&gt;size;
				c[0]-&gt;ls=c[0]-&gt;rs=c[0]-&gt;ss=max(c[0]-&gt;sum,c[0]-&gt;lzy);
			}			
			if(c[1]!=Null){
				c[1]-&gt;lzy=c[1]-&gt;val=lzy;c[1]-&gt;sum=lzy*c[1]-&gt;size;
				c[1]-&gt;ls=c[1]-&gt;rs=c[1]-&gt;ss=max(c[1]-&gt;sum,c[1]-&gt;lzy);
			}
			lzy=INT_MIN;
		}
	}
	node* pushdown(){
		pushrev();
		pushsum();
		return this;
	}
	void split(int need,node *&amp;p,node *&amp;q);
};
node poor[maxn];
node* newnode(int val=0){
	node *x;
	if(qnode.size())x=qnode.front(),qnode.pop();
	else
	if(tot&lt;maxn){
		x=&amp;poor[tot++];
	}else x=new node(val,Null);	
	x-&gt;c[0]=x-&gt;c[1]=Null;  
    x-&gt;size=1; x-&gt;rev=0; x-&gt;lzy=INT_MIN;  
    x-&gt;val=x-&gt;sum=x-&gt;ls=x-&gt;rs=x-&gt;ss=val;  
	return x; 
}
node* merge(node *p,node *q){
	if(p==Null)return q-&gt;rz();
	if(q==Null)return p-&gt;rz();
	p-&gt;pushdown();q-&gt;pushdown();
	if(p-&gt;size*1023&gt;rnd()*(p-&gt;size+q-&gt;size)){
		p-&gt;c[1]=merge(p-&gt;c[1],q);
		return p-&gt;rz();
	}else{
		q-&gt;c[0]=merge(p,q-&gt;c[0]);
		return q-&gt;rz();
	}
}
void node::split(int need,node *&amp;p,node *&amp;q){
	if(this==Null){p=q=Null;return ;}
	pushdown();
	if(c[0]-&gt;size&gt;=need){
		c[0]-&gt;split(need,p,q);
		c[0]=Null;rz();
		q=merge(q,this);
	}else{
		c[1]-&gt;split(need-c[0]-&gt;size-1,p,q);
		c[1]=Null;rz();
		p=merge(this,p);
	}
}
void deb(node *root){
	if(root==Null)return ;
	if(root-&gt;c[0]!=Null)deb(root-&gt;c[0]);
	printf("val:%d sum:%d size:%d ls:%d rs:%d ss:%d\n",root-&gt;val,root-&gt;sum,root-&gt;size,root-&gt;ls,root-&gt;rs,root-&gt;ss);
	
	if(root-&gt;c[1]!=Null)deb(root-&gt;c[1]);
}         
void erase(node *root){
	if(root==Null)return ;
	erase(root-&gt;c[0]);
	erase(root-&gt;c[1]);
	qnode.push(root);
}  
void init(){
	root=newnode();
	Null=newnode();
	Null-&gt;lzy=INT_MIN;
	Null-&gt;val=Null-&gt;ls=Null-&gt;rs=Null-&gt;ss=INT_MIN;
	Null-&gt;size=0;Null-&gt;c[0]=Null-&gt;c[1]=Null;
	root=Null;
}
void insert(){
	int pos=getint();
	int n=getint();
	node *p,*q,*r,*s;
	root-&gt;split(pos,p,q);
	while(n--){
		int x=getint();
		p=merge(p,newnode(x));
	}
	root=merge(p,q);
}
void del(){
	int pos=getint()-1,n=getint();
	node *p,*q,*r,*s;
	root-&gt;split(pos,p,q);
	q-&gt;split(n,r,s);
	erase(r);
	root=merge(p,s);	
}
void makesame(){
	int pos=getint()-1,tot=getint(),c=getint();
	node *p,*q,*r,*s;
	root-&gt;split(pos,p,q);
	q-&gt;split(tot,r,s);
	r-&gt;val=c;r-&gt;sum=c*r-&gt;size;
	r-&gt;rs=r-&gt;ls=r-&gt;ss=max(r-&gt;sum,c);
	r-&gt;lzy=c;r-&gt;pushdown();
	root=merge(p,merge(r,s));
}
void rev(){
	int pos=getint()-1,tot=getint();
	node *p,*q,*r,*s;
	root-&gt;split(pos,p,q);
	q-&gt;split(tot,r,s);
	r-&gt;Rev();
	root=merge(p,merge(r,s));	
}
void getsum(){
	int pos=getint()-1,tot=getint();
	node *p,*q,*r,*s;
	root-&gt;split(pos,p,q);
	q-&gt;split(tot,r,s);
	putint(r-&gt;sum);
	root=merge(p,merge(r,s));		
}

int n,m;
int main(){
	init();
	char opt[50];
	n=getint();m=getint();
	for(int i=1;i&lt;=n;i++){
		int x=getint();
		root=merge(root,newnode(x));	
	}		
	while(m--){
//		deb(root);
		scanf("%s",opt);
		if(opt[0]=='I'){
			insert();
		}else
		if(opt[0]=='D'){
			del();
		}else
		if(opt[0]=='M'&amp;&amp;opt[2]=='K'){
			makesame();
		}else
		if(opt[0]=='R'){
			rev();
		}else
		if(opt[0]=='G'){
			getsum();
		}else
		putint(root-&gt;ss);
	}
	return 0;
}<pre><h2>Problem1500</h2><pre>#include&lt;ctime&gt;
#include&lt;cctype&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;climits&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;queue&gt;
using namespace std;
int getint(){
	int res=0;
	scanf("%d",&amp;res);
	return res;
}
void putint(int x){
	printf("%d\n",x);
}
struct node;
node *root,*Null;
int tot;
queue&lt;node*&gt;qnode;
const int maxn=1e6+10;
inline int rnd(){
	return rand()&amp;(1023);
}
struct node{
	node *c[2];
	int rev,val,sum,ls,rs,ss,size,lzy;
	node(int _val=0,node *C=0){
		ls=rs=ss=sum=val=_val;lzy=INT_MIN;
		c[0]=c[1]=C;
		size=1;rev=0;
	}
	void Rev(){
		if(this==Null)return ;
		rev^=1;
		swap(c[0],c[1]);
		swap(ls,rs);
	}
	node* rz(){
//		if(this==NULL)return this;
		
		size=c[0]-&gt;size+1+c[1]-&gt;size;
		
		sum=c[0]-&gt;sum+val+c[1]-&gt;sum;
		
		ls=max(c[0]-&gt;ls,c[0]-&gt;sum+val+max(0,c[1]-&gt;ls));
		rs=max(c[1]-&gt;rs,c[1]-&gt;sum+val+max(0,c[0]-&gt;rs));
		
		ss=max(0,c[0]-&gt;rs)+val+max(0,c[1]-&gt;ls);
		ss=max(ss,max(c[0]-&gt;ss,c[1]-&gt;ss));
		return this;
	}
	void pushrev(){
		if(rev){
			c[0]-&gt;Rev();c[1]-&gt;Rev();rev=0;
		}
	}
	void pushsum(){
		if(lzy!=INT_MIN){
			if(c[0]!=Null){
				c[0]-&gt;lzy=c[0]-&gt;val=lzy;c[0]-&gt;sum=lzy*c[0]-&gt;size;
				c[0]-&gt;ls=c[0]-&gt;rs=c[0]-&gt;ss=max(c[0]-&gt;sum,c[0]-&gt;lzy);
			}			
			if(c[1]!=Null){
				c[1]-&gt;lzy=c[1]-&gt;val=lzy;c[1]-&gt;sum=lzy*c[1]-&gt;size;
				c[1]-&gt;ls=c[1]-&gt;rs=c[1]-&gt;ss=max(c[1]-&gt;sum,c[1]-&gt;lzy);
			}
			lzy=INT_MIN;
		}
	}
	node* pushdown(){
		pushrev();
		pushsum();
		return this;
	}
	void split(int need,node *&amp;p,node *&amp;q);
};
node poor[maxn];
node* newnode(int val=0){
	node *x;
	if(qnode.size())x=qnode.front(),qnode.pop();
	else
	if(tot&lt;maxn){
		x=&amp;poor[tot++];
	}else x=new node(val,Null);	
	x-&gt;c[0]=x-&gt;c[1]=Null;  
    x-&gt;size=1; x-&gt;rev=0; x-&gt;lzy=INT_MIN;  
    x-&gt;val=x-&gt;sum=x-&gt;ls=x-&gt;rs=x-&gt;ss=val;  
	return x; 
}
node* merge(node *p,node *q){
	if(p==Null)return q-&gt;rz();
	if(q==Null)return p-&gt;rz();
	p-&gt;pushdown();q-&gt;pushdown();
	if(p-&gt;size*1023&gt;rnd()*(p-&gt;size+q-&gt;size)){
		p-&gt;c[1]=merge(p-&gt;c[1],q);
		return p-&gt;rz();
	}else{
		q-&gt;c[0]=merge(p,q-&gt;c[0]);
		return q-&gt;rz();
	}
}
void node::split(int need,node *&amp;p,node *&amp;q){
	if(this==Null){p=q=Null;return ;}
	pushdown();
	if(c[0]-&gt;size&gt;=need){
		c[0]-&gt;split(need,p,q);
		c[0]=Null;rz();
		q=merge(q,this);
	}else{
		c[1]-&gt;split(need-c[0]-&gt;size-1,p,q);
		c[1]=Null;rz();
		p=merge(this,p);
	}
}
void deb(node *root){
	if(root==Null)return ;
	if(root-&gt;c[0]!=Null)deb(root-&gt;c[0]);
	printf("val:%d sum:%d size:%d ls:%d rs:%d ss:%d\n",root-&gt;val,root-&gt;sum,root-&gt;size,root-&gt;ls,root-&gt;rs,root-&gt;ss);
	
	if(root-&gt;c[1]!=Null)deb(root-&gt;c[1]);
}         
void erase(node *root){
	if(root==Null)return ;
	erase(root-&gt;c[0]);
	erase(root-&gt;c[1]);
	qnode.push(root);
}  
void init(){
	root=newnode();
	Null=newnode();
	Null-&gt;lzy=INT_MIN;
	Null-&gt;val=Null-&gt;ls=Null-&gt;rs=Null-&gt;ss=INT_MIN;
	Null-&gt;size=0;Null-&gt;c[0]=Null-&gt;c[1]=Null;
	root=Null;
}
void insert(){
	int pos=getint();
	int n=getint();
	node *p,*q,*r,*s;
	root-&gt;split(pos,p,q);
	while(n--){
		int x=getint();
		p=merge(p,newnode(x));
	}
	root=merge(p,q);
}
void del(){
	int pos=getint()-1,n=getint();
	node *p,*q,*r,*s;
	root-&gt;split(pos,p,q);
	q-&gt;split(n,r,s);
	erase(r);
	root=merge(p,s);	
}
void makesame(){
	int pos=getint()-1,tot=getint(),c=getint();
	node *p,*q,*r,*s;
	root-&gt;split(pos,p,q);
	q-&gt;split(tot,r,s);
	r-&gt;val=c;r-&gt;sum=c*r-&gt;size;
	r-&gt;rs=r-&gt;ls=r-&gt;ss=max(r-&gt;sum,c);
	r-&gt;lzy=c;r-&gt;pushdown();
	root=merge(p,merge(r,s));
}
void rev(){
	int pos=getint()-1,tot=getint();
	node *p,*q,*r,*s;
	root-&gt;split(pos,p,q);
	q-&gt;split(tot,r,s);
	r-&gt;Rev();
	root=merge(p,merge(r,s));	
}
void getsum(){
	int pos=getint()-1,tot=getint();
	node *p,*q,*r,*s;
	root-&gt;split(pos,p,q);
	q-&gt;split(tot,r,s);
	putint(r-&gt;sum);
	root=merge(p,merge(r,s));		
}

int n,m;
int main(){
	init();
	char opt[50];
	n=getint();m=getint();
	for(int i=1;i&lt;=n;i++){
		int x=getint();
		root=merge(root,newnode(x));	
	}		
	while(m--){
//		deb(root);
		scanf("%s",opt);
		if(opt[0]=='I'){
			insert();
		}else
		if(opt[0]=='D'){
			del();
		}else
		if(opt[0]=='M'&amp;&amp;opt[2]=='K'){
			makesame();
		}else
		if(opt[0]=='R'){
			rev();
		}else
		if(opt[0]=='G'){
			getsum();
		}else
		putint(root-&gt;ss);
	}
	return 0;
}<pre><h2>Problem1503</h2><pre>#include&lt;cstdio&gt;
#include&lt;climits&gt;
#include&lt;cstdlib&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
const int INF=INT_MAX;
struct Treap{
	struct Node{
		int val,key,size;
		Node *c[2];
		Node(int _val,Node *C):
			val(_val),size(1),key(rand()){c[0]=c[1]=C;}
		void rz(){
			size=c[0]-&gt;size+c[1]-&gt;size+1;
		}
	};	
	Node *root,*Null;
	Treap(){
		Null=new Node(0,0);
		Null-&gt;size=0;
		Null-&gt;key=INF;
		Null-&gt;c[0]=Null-&gt;c[1]=Null;
		root=Null;
	}
	void rot(Node *&amp;t,bool d){
		Node *p=t-&gt;c[d];
		t-&gt;c[d]=p-&gt;c[!d];
		p-&gt;c[!d]=t;
		t-&gt;rz();p-&gt;rz();
		t=p;
	}
	void insert(Node *&amp;t,int x){
		if(t==Null){
			t=new Node(x,Null);
			return;
		}
		bool d=x&gt;t-&gt;val;
		insert(t-&gt;c[d],x);
		if(t-&gt;c[d]-&gt;key&lt;t-&gt;key)
			rot(t,d);
		else
			t-&gt;rz();
	}
	int kth(Node *t,int x){
		int r=t-&gt;c[0]-&gt;size;
		if(x==r)return t-&gt;val;
		if(x&lt;r)return kth(t-&gt;c[0],x);
		return kth(t-&gt;c[1],x-r-1);
	}
	int Min(){
		Node *p=root;
		while(p-&gt;c[0]!=Null)p=p=p-&gt;c[0];
		return p-&gt;val;
	}
	void Delete(Node *&amp;t,int x){
		if(t==Null)return;
		if(t-&gt;val==x){
			bool d=t-&gt;c[1]-&gt;key&lt;t-&gt;c[0]-&gt;key;
			if(t-&gt;c[d]==Null){
				delete t;
				t=Null;
				return;
			}
			rot(t,d);
			Delete(t-&gt;c[!d],x);
		}else{
			bool d=x&gt;t-&gt;val;
			Delete(t-&gt;c[d],x);
		}
		t-&gt;rz();
	}
    void del(int x)
    {
        Delete(root,x);
    }
    int sel(int x)
    {
        return kth(root,x);
    }
    void ins(int x)
    {
        insert(root,x);
    }
    int size()
    {
        return root-&gt;size;
    }
}T;
int n,Min,Add=0,leave=0;
void Check(){
	while(T.size()){
		int m=T.Min();
		if(m+Add&lt;Min){
			leave++;
			T.del(m);
		}else
			break;
	}
}
void ins(int x){
	if(x&gt;=Min)T.ins(x-Add);
}
void add(int t){
	Add+=t;
}
void sub(int t){
	Add-=t;
	Check();
}
void find(int k){
	if(k&gt;T.size())
		printf("-1\n");
	else
		printf("%d\n",T.sel(T.size()-k)+Add);
}
int main(){
	srand(1007);
	scanf("%d%d",&amp;n,&amp;Min);
	char opt[10];
	int x;
	while(n--){
		scanf("%s%d",opt,&amp;x);
		switch(opt[0]){
			case 'I':
				ins(x);
				break;
			case 'A':
				add(x);
				break;
			case 'S':
				sub(x);
				break;
			case 'F':
				find(x);
				break;
		}
	}
	printf("%d\n",leave);
	return 0;
}<pre><h2>Problem1503</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;climits&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
const int INF = INT_MAX;
struct Treap{
    struct node{
        int val,key,size;
        node *c[2];
        node(int _val,node *C){
            val=_val;key=rand();size=1;
            c[0]=c[1]=C;
        }
        void rz(){
            size=c[0]-&gt;size+c[1]-&gt;size+1;
        }
    };
    node *root,*Null;
    Treap(){
        Null=new node(0,0);
        Null-&gt;size=0;
        Null-&gt;key=INF;
        Null-&gt;c[0]=Null-&gt;c[1]=Null;
        root=Null;
    }
    void rot(node *&amp;t,bool d){
        node *p=t-&gt;c[d];
        t-&gt;c[d]=p-&gt;c[!d];
        p-&gt;c[!d]=t;
        t-&gt;rz();p-&gt;rz();
        t=p;
    }
    void insert(node *&amp;t,int x){
        if(t==Null){
            t=new node(x,Null);
            return;
        }
        bool d=x&gt;t-&gt;val;
        insert(t-&gt;c[d],x);
        if(t-&gt;c[d]-&gt;key&lt;t-&gt;key)
            rot(t,d);
        else
            t-&gt;rz();
    }
    int kth(node *&amp;t,int x){
        int r=t-&gt;c[0]-&gt;size;
        if(x==r)return t-&gt;val;
        if(x&lt;r)return kth(t-&gt;c[0],x);
        else return kth(t-&gt;c[1],x-r-1);
    }
    int Min(){
        node *p=root;
        while(p-&gt;c[0]!=Null)p=p-&gt;c[0];
        return p-&gt;val;
    }
    void Delete(node *&amp;t,int x){
        if(t==Null)return;
        if(t-&gt;val==x){
            bool d=t-&gt;c[1]-&gt;key&lt;t-&gt;c[0]-&gt;key;
            if(t-&gt;c[d]==Null){
                delete t;
                t=Null;
                return;
            }
            rot(t,d);
            Delete(t-&gt;c[!d],x);
        }else{
            bool d=x&gt;t-&gt;val;
            Delete(t-&gt;c[d],x);
        }
        t-&gt;rz();
    }
    void del(int x){
        Delete(root,x);
    }
    void ins(int x){
        insert(root,x);
    }
    int sel(int x){
        return kth(root,x);
    }
    int size(){
        return root-&gt;size;
    }
}T;
int n,Min,Add=0,leave=0;
void Check(){
	while(T.size()){
		int m=T.Min();
		if(m+Add&lt;Min){
			leave++;
			T.del(m);
		}else
			break;
	}
}
void ins(int x){
    if(x&gt;=Min)T.ins(x-Add);
}
void add(int t){
    Add+=t;
}
void sub(int t){
    Add-=t;
    Check();
}
void find(int k){
    if(k&gt;T.size())
        printf("-1\n");
    else
        printf("%d\n",T.sel(T.size()-k)+Add);
}
int main(){
    srand(1007);
    scanf("%d%d",&amp;n,&amp;Min);
    char opt[10];
    int x;
    while(n--){
        scanf("%s%d",opt,&amp;x);
        switch(opt[0]){
            case 'I':
                ins(x);
                break;
            case 'A':
                add(x);
                break;
            case 'S':
                sub(x);
                break;
            case 'F':
                find(x);
                break;
        }
    }
    printf("%d\n",leave);
    return 0;
}<pre><h2>Problem1503</h2><pre>    #include&lt;iostream&gt;  
    #include&lt;cstdio&gt;  
    #include&lt;cassert&gt; 
    #include&lt;cstring&gt;  
    #include&lt;cmath&gt;  
    #include&lt;algorithm&gt;  
    #define lchild rt&lt;&lt;1,l,m  
    #define rchild rt&lt;&lt;1|1,m+1,r  
    using namespace std;  
    struct sbt  
    {  
        int left,right,size,data;  
    }tree[200001];  
    int sum;  
    int n,minn;  
    char ch[20];  
    int now;   
    int key;  
    int root,top;  
    void left_rot(int &amp;x)  
    {  
        int y=tree[x].right;  
        tree[x].right=tree[y].left;  
        tree[y].left=x;  
        tree[y].size=tree[x].size;  
        tree[x].size=tree[tree[x].left].size+tree[tree[x].right].size+1;  
        x=y;  
    }  
    void right_rot(int &amp;x)  
    {  
        int y=tree[x].left;  
        tree[x].left=tree[y].right;  
        tree[y].right=x;  
        tree[y].size=tree[x].size;  
        tree[x].size=tree[tree[x].left].size+tree[tree[x].right].size+1;  
        x=y;  
    }  
    void maintain(int &amp;x,bool flag)  
    {  
        if (!flag)  
        {  
            if (tree[tree[tree[x].left].left].size&gt;tree[tree[x].right].size)  
                right_rot(x);  
            else  
            if (tree[tree[tree[x].left].right].size&gt;tree[tree[x].right].size)  
                left_rot(tree[x].left),right_rot(x);  
            else  
            return;  
        }  
        else  
        {  
            if (tree[tree[tree[x].right].right].size&gt;tree[tree[x].left].size)  
                left_rot(x);  
            else  
            if (tree[tree[tree[x].right].left].size&gt;tree[tree[x].left].size)  
                right_rot(tree[x].right),left_rot(x);  
            else  
            return;  
        }  
        maintain(tree[x].left,0);  
        maintain(tree[x].right,1);  
        maintain(x,1);  
        maintain(x,0);  
    }  
    void insert(int &amp;x,int data)  
    {  
        if (x==0)  
        {  
            x=++top;  
            assert(x&lt;200001);
            tree[x].left=tree[x].right=0;  
            tree[x].size=1;  
            tree[x].data=data;  
        }  
        else  
        {  
            tree[x].size++;  
            if (data&lt;tree[x].data) insert(tree[x].left,data);  
            else insert(tree[x].right,data);  
            maintain(x,data&gt;=tree[x].data);   
        }  
    }  
    int remove(int &amp;x,int data)  
    {  
        tree[x].size--;  
        if (tree[x].data&gt;data)  
            remove(tree[x].left,data);  
        else  
        if (tree[x].data&lt;data)  
            remove(tree[x].right,data);  
        else  
        {  
            if (tree[x].left!=0&amp;&amp;tree[x].right==0)  
            {  
                int ret=x;  
                x=tree[x].left;  
                return ret;  
            }  
            else  
            if (tree[x].left==0&amp;&amp;tree[x].right!=0)  
            {  
                int ret=x;  
                x=tree[x].right;  
                return ret;  
            }  
            else  
            if (tree[x].left==0&amp;&amp;tree[x].right==0)  
            {  
                int ret=x;  
                x=0;  
                return ret;  
            }  
            else  
            if (tree[x].left!=0&amp;&amp;tree[x].right!=0)  
            {  
                int ret=tree[x].right;  
                while (tree[ret].left) ret=tree[ret].left;  
                tree[x].data=tree[ret].data;  
                remove(tree[x].right,tree[ret].data);  
            }  
        }  
    }  
    int select(int &amp;x,int k)  
    {  
        int r=tree[tree[x].left].size+1;  
        if (r==k) return tree[x].data;  
        else  
        if (r&lt;k) return select(tree[x].right,k-r);  
        else  
        if (r&gt;k) return select(tree[x].left,k);  
    }  
    int getmin()  
    {  
        int x;  
        for (x=root;tree[x].left;x=tree[x].left);  
        return tree[x].data;  
    }  
    int main()  
    {  
        scanf("%d%d",&amp;n,&amp;minn);  
        for (int i=1;i&lt;=n;i++)  
        {  
            scanf("%s",ch);
            scanf("%d",&amp;key);  
            if (now)  
                while (getmin()&lt;minn)  
                {  
                    remove(root,getmin());  
                    sum++;  
                    now--;  
                }  
            if (!strcmp(ch,"I"))  
            {  
                if (key&gt;=minn)  
                    insert(root,key),now++;  
            }  
            else  
            if (!strcmp(ch,"A"))  
               for (int j=1;j&lt;=top;j++)  
                   tree[j].data+=key;  
            else  
            if (!strcmp(ch,"S"))  
               for (int j=1;j&lt;=top;j++)  
                   tree[j].data-=key;  
            else  
            if (!strcmp(ch,"F"))  
            {  
                if (key&gt;now)   
                {  
                    printf("-1\n");  
                    continue;  
                }  
                else  
                printf("%d\n",select(root,now-key+1));  
            }  
        }  
       printf("%d\n",sum);
    }  <pre><h2>Problem1507</h2><pre>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;cstring&gt;
#include&lt;ext/rope&gt;
using namespace std;
using namespace __gnu_cxx;
crope List;
int p,now;
char s[10],ch[3000000];
int main(){
	int i,k;
	scanf("%d",&amp;p);
	while(p--){
		scanf("%s",s);
		if(s[0]=='M')scanf("%d",&amp;now);else
		if(s[0]=='P')	now--;else
		if(s[0]=='N')	now++;else
		if(s[0]=='I'){
			scanf("%d",&amp;k);
			for(i=0;i&lt;k;i++){
				ch[i]=getchar();
				while(ch[i]=='\n')ch[i]=getchar();				
			}
			ch[k]=0;
			List.insert(now,ch);
		}else
		if(s[0]=='D'){scanf("%d",&amp;k);List.erase(now,k);}else
		{
			scanf("%d",&amp;k);
			List.copy(now,k,ch);
			ch[k]=0;
			puts(ch);
		}
	}
	return 0;
}<pre><h2>Problem1510</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=3e5+5;
int mn[maxn];
int ans,n,m,x,p,res;
int getint(){
	int res=0;char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))res=res*10+c-'0',c=getchar();
	return res;
}
int main(){
	scanf("%d%d",&amp;n,&amp;m);ans=n+1;mn[0]=1e9+10;
	for(int i=1;i&lt;=n;i++)x=getint(),mn[i]=min(mn[i-1],x);
	for(int i=1;i&lt;=m;i++){
		x=getint();
		p=upper_bound(mn+1,mn+ans,x,greater&lt;int&gt;())-mn-1;
		ans=p;
	}cout&lt;&lt;max(0,ans)&lt;&lt;endl;
	return 0;
}<pre><h2>Problem1511</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1e6+1;
int next[maxn],n;
char s[maxn];
int main(){
	scanf("%d%s",&amp;n,s+1);
	for(int i=2,j=0;i&lt;=n;i++){
		while(j&amp;&amp;s[i]!=s[j+1])j=next[j];
		next[i]=j+=s[i]==s[j+1];
	}long long ans=0;
	for(int i=1;i&lt;=n;i++)if(next[next[i]])next[i]=next[next[i]];
	for(int i=1;i&lt;=n;i++)if(next[i])ans+=i-next[i];
	cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}<pre><h2>Problem1520</h2><pre>#include&lt;bits/stdc++.h&gt;
#define in(i) (i&lt;&lt;1)
#define out(i) (i&lt;&lt;1|1)
using namespace std;
const int maxn=410;
int n,s,t;
struct edge{
	int u,v,cap,flow,cost;
	edge(int _u=0,int _v=0,int _cap=0,int _flow=0,int _cost=0):
		u(_u),v(_v),cap(_cap),flow(_flow),cost(_cost){}
};
vector&lt;edge&gt;edges;
vector&lt;int&gt;G[maxn];
int pre[maxn],a[maxn],d[maxn],vis[maxn],cost,flow;
void add(int u,int v,int cap,int cost){
	edges.push_back(edge(u,v,cap,0,cost));
	G[u].push_back(edges.size()-1);
	edges.push_back(edge(v,u,0,0,-cost));
	G[v].push_back(edges.size()-1);
}
bool spfa(){
	queue&lt;int&gt;q;
	q.push(s);
	memset(d,0x4f,sizeof d);int B=d[0];d[s]=0;a[s]=INT_MAX;
	while(!q.empty()){
		int u=q.front();q.pop();vis[u]=0;
		for(int i=0;i&lt;G[u].size();i++){
			edge e=edges[G[u][i]];
			if(e.cap&gt;e.flow&amp;&amp;d[e.v]&gt;d[u]+e.cost){
				d[e.v]=d[u]+e.cost;
				pre[e.v]=G[u][i];
				a[e.v]=min(a[u],e.cap-e.flow);
				if(!vis[e.v]){
					vis[e.v]=1;
					q.push(e.v);
				}
			}
		}
	}
	if(d[t]==B)return false;
	cost+=d[t]*a[t];
	flow+=a[t];
	for(int u=t;u!=s;u=edges[pre[u]].u){
		edges[pre[u]].flow+=a[t];
		edges[pre[u]^1].flow-=a[t];
	}return true;
}
int m[maxn],l[maxn],r[maxn],k[maxn];
int main(){
	scanf("%d",&amp;n);
	for(int i=1;i&lt;=n;i++)scanf("%d%d%d%d",&amp;m[i],&amp;l[i],&amp;r[i],&amp;k[i]);
	s=0,t=n*2+1;
	for(int i=1;i&lt;=n;i++){
		add(s,i,1,0);
		for(int j=l[i];j&lt;=r[i];j++)
			add(i,j+n,1,k[i]*abs(m[i]-j));
		add(i+n,t,1,0);
	}
	while(spfa());
	if(flow==n)
	cout&lt;&lt;cost&lt;&lt;endl;
	else puts("NIE");
	return 0;
}<pre><h2>Problem1528</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=5e5+5;
typedef pair&lt;int,int&gt; pii;
priority_queue&lt;pii,vector&lt;pii&gt; &gt;q;
int n,m,tot,next[maxn],a[maxn];
map&lt;int,int&gt;M;
short in[maxn];
int main(){
    scanf("%*d%d%d",&amp;m,&amp;n);
    for(int i=1;i&lt;=n;i++){
        scanf("%d",&amp;a[i]);
        if(!M[a[i]])M[a[i]]=++tot;
        a[i]=M[a[i]];
    }M.clear();
    for(int i=n;i;i--){
        if(!M[a[i]])M[a[i]]=i,next[i]=1e9;
        else next[i]=M[a[i]],M[a[i]]=i;
    }int ans=0,size=0;
    for(int i=1;i&lt;=n;i++){
        if(in[a[i]]){
            q.push(pii(next[i],a[i]));
            continue;
        }ans++;in[a[i]]=1;
        if(size==m){in[q.top().second]=0;q.pop();size--;}
        q.push(pii(next[i],a[i]));size++;
    }cout&lt;&lt;ans&lt;&lt;endl;
    return 0;
} <pre><h2>Problem1529</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1e6+10;
int fa[maxn];
int n;
int find(int x){
	if(fa[x]!=x)return fa[x]=find(fa[x]);
	return x;
}
int main(){
	scanf("%d",&amp;n);
	for(int i=1;i&lt;=n;i++)fa[i]=i;
	for(int i=1;i&lt;=n;i++){
		int x;scanf("%d",&amp;x);
		int f1=find(i),f2=find(x);
		if(f1!=f2)fa[f2]=f1;
	}int ans=0;
	for(int i=1;i&lt;=n;i++)ans+=fa[i]==i;
	cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}<pre><h2>Problem1531</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
int f[20001];
int n,m,k,cnt;
int b[20001],v[20001*15],c[20001],w[20001*15];
int main(){
	scanf("%d",&amp;n);
	for(int i=1;i&lt;=n;i++)scanf("%d",&amp;b[i]);
	for(int i=1;i&lt;=n;i++)scanf("%d",&amp;c[i]);
	scanf("%d",&amp;k);
	for(int i=1;i&lt;=n;i++){
		for(int j=0;(1&lt;&lt;j)&lt;=c[i];j++){
			c[i]-=(1&lt;&lt;j);
			cnt++;w[cnt]=b[i]*(1&lt;&lt;j);v[cnt]=(1&lt;&lt;j);
		}if(c[i]){
			cnt++;
			w[cnt]=c[i]*b[i];v[cnt]=c[i];
		}
	}memset(f,0x7f,sizeof f);f[0]=0;
	for(int i=1;i&lt;=cnt;i++)
	for(int j=k;j&gt;=w[i];j--){
		f[j]=min(f[j],f[j-w[i]]+v[i]);
	}cout&lt;&lt;f[k]&lt;&lt;endl;
	return 0;
}<pre><h2>Problem1532</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=2e4+10;
struct edge{
	int u,v,cap,flow;
};
vector&lt;edge&gt;edges;
vector&lt;int&gt;G[maxn];
void add(int u,int v,int cap){
	edges.push_back((edge){u,v,cap,0});
	G[u].push_back(edges.size()-1);
	edges.push_back((edge){v,u,0,0});
	G[v].push_back(edges.size()-1);
}
int n,m,s,t;
int vis[maxn],d[maxn],cur[maxn];
bool bfs(){
	memset(vis,0,sizeof vis);vis[s]=1;
	queue&lt;int&gt;q;q.push(s);d[s]=0;
	while(!q.empty()){
		int u=q.front();q.pop();
		for(int i=0;i&lt;G[u].size();++i){
			edge e=edges[G[u][i]];
			if(!vis[e.v]&amp;&amp;e.cap&gt;e.flow){
				vis[e.v]=1;
				d[e.v]=d[u]+1;
				q.push(e.v);
			}
		}
	}return vis[t];
}
int dfs(int u,int a){
	if(u==t||!a)return a;
	int flow=0,f;
	for(int &amp;i=cur[u];i&lt;G[u].size();i++){
		edge e=edges[G[u][i]];
		if(d[e.v]==d[u]+1&amp;&amp;(f=dfs(e.v,min(a,e.cap-e.flow)))&gt;0){
			flow+=f;
			a-=f;
			edges[G[u][i]].flow+=f;
			edges[G[u][i]^1].flow-=f;
			if(!a)break;
		}
	}return flow;
}
int Dinic(){
	int flow=0,x;
	while(bfs()){
		memset(cur,0,sizeof cur);
		while(x=dfs(s,INT_MAX)){
			flow+=x;
			memset(cur,0,sizeof cur);
		}
	}return flow;
}
int main(){
	scanf("%d%d",&amp;n,&amp;m);
	s=0;t=n+m+1;
	for(int i=1;i&lt;=m;i++){
		int u,v;scanf("%d%d",&amp;u,&amp;v);
		add(s,i,1);
		add(i,u+m,1);
		add(i,v+m,1);
	}
	int lf=edges.size();
	for(int i=1;i&lt;=n;i++)add(i+m,t,0);
	int l=1,r=m;
	while(l&lt;r){
		int mid=(l+r)&gt;&gt;1;
		for(int i=0;i&lt;edges.size();i++)edges[i].flow=0;
		for(int i=lf;i&lt;edges.size();i++)edges[i].cap=mid;
		if(Dinic()&lt;m)
			l=mid+1;
		else
			r=mid;
	}cout&lt;&lt;l&lt;&lt;endl;
	return 0;
}<pre><h2>Problem1537</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1e5+5;
vector&lt;int&gt;G[maxn];
struct point{
	int x,y,w;
	bool operator&lt;(point oth)const{return y&lt;oth.y||(y==oth.y&amp;&amp;x&lt;oth.x);}
}a[maxn];
inline int lowbit(int x){return x&amp;-x;}
int d[maxn],n;
void updata(int x,int f){while(x&lt;=n)d[x]=max(d[x],f),x+=lowbit(x);}
int Qmax(int x){int ans=0;while(x)ans=max(ans,d[x]),x-=lowbit(x);return ans;}
int dp[maxn];
map&lt;int,int&gt;M;
int main(){
	scanf("%*d%*d%d",&amp;n);
	for(int i=1;i&lt;=n;i++){
		scanf("%d%d%d",&amp;a[i].x,&amp;a[i].y,&amp;a[i].w);
		M[a[i].x]=1;
	}sort(a+1,a+1+n);int tot=0;
	for(map&lt;int,int&gt;::iterator it=M.begin();it!=M.end();it++)it-&gt;second=++tot;
	for(int i=1;i&lt;=n;i++)a[i].x=M[a[i].x];
	for(int i=1;i&lt;=n;i++){
		dp[i]=Qmax(a[i].x)+a[i].w;
		updata(a[i].x,dp[i]);
	}cout&lt;&lt;*max_element(dp+1,dp+1+n)&lt;&lt;endl;	
	return 0;
}<pre><h2>Problem1552</h2><pre>#include&lt;cstdio&gt;
#include&lt;climits&gt;
#include&lt;cstdlib&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
struct node{
	int val,key,rev,size,id;
	node *c[2],*mn;
	void split(int ned,node *&amp;p,node *&amp;q);
	node(int _val=0,int _id=0,node *C=0){
		key=rand();val=_val;rev=0;size=1;
		c[0]=c[1]=C;mn=this;id=_id;
	}
	void makerev(){
		rev^=1;
		swap(c[0],c[1]);
		if(mn!=this&amp;&amp;c[0]-&gt;mn-&gt;val&lt;=c[1]-&gt;mn-&gt;val){
			if(c[0]-&gt;mn-&gt;id&lt;c[1]-&gt;mn-&gt;id)mn=c[0]-&gt;mn;
		}
	}
	void pushdown(){
		if(rev){
			c[0]-&gt;makerev();
			c[1]-&gt;makerev();
			rev^=1;
		}
	}
	node* rz(){
		size=c[0]-&gt;size+1+c[1]-&gt;size;
		if(c[0]-&gt;mn-&gt;val&lt;c[1]-&gt;mn-&gt;val
		||(c[0]-&gt;mn-&gt;val==c[1]-&gt;mn-&gt;val&amp;&amp;c[0]-&gt;mn-&gt;id&lt;c[1]-&gt;mn-&gt;id))
		mn=c[0]-&gt;mn;else mn=c[1]-&gt;mn;
		if(val&lt;mn-&gt;val||(val==mn-&gt;val&amp;&amp;id&lt;mn-&gt;id))
		mn=this;
		return this;
	}
}*root,*Null;
node *merge(node *p,node *q){
	if(p==Null)return q-&gt;rz();
	if(q==Null)return p-&gt;rz();
	p-&gt;pushdown();q-&gt;pushdown();
	if(p-&gt;key&lt;q-&gt;key){
		p-&gt;c[1]=merge(p-&gt;c[1],q);
		return p-&gt;rz();
	}else{
		q-&gt;c[0]=merge(p,q-&gt;c[0]);
		return q-&gt;rz();
	}
}
void node::split(int ned,node *&amp;p,node *&amp;q){
	if(this==Null){p=q=Null;return;}
	pushdown();
	if(c[0]-&gt;size&gt;=ned){
		c[0]-&gt;split(ned,p,q);
		c[0]=Null;rz();
		q=merge(q,this);
	}else{
		c[1]-&gt;split(ned-c[0]-&gt;size-1,p,q);
		c[1]=Null;rz();
		p=merge(this,p);
	}
}
node *p,*q,*r,*s;
int n;
int getint(){
	int res=0;char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))res=res*10+c-'0',c=getchar();
	return res;
}
int main(){
	Null=new node(INT_MAX,0);
	Null-&gt;key=INT_MAX;Null-&gt;size=0;
	Null-&gt;c[0]=Null-&gt;c[1]=Null;
	root=Null;
	scanf("%d",&amp;n);
	for(int i=1;i&lt;=n;i++){
		int x;scanf("%d",&amp;x);
		root=merge(root,new node(x,i,Null));
	}
	for(int i=1;i&lt;=n;i++){
		root-&gt;split(i-1,p,q);
		int ps=i;r=q;
		while(r-&gt;mn!=r){
			r-&gt;pushdown();
			if(r-&gt;c[0]-&gt;mn-&gt;id==r-&gt;mn-&gt;id)r=r-&gt;c[0];
			else ps+=r-&gt;c[0]-&gt;size+1,r=r-&gt;c[1];
		}ps+=r-&gt;c[0]-&gt;size;
		printf("%d%c",ps," \n"[i==n]);
		q-&gt;split(ps-i+1,r,s);
		r-&gt;makerev();
		root=merge(p,merge(r,s));
	}
	return 0;
}<pre><h2>Problem1567</h2><pre>#include &lt;iostream&gt;
#include &lt;cstdlib&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#define rep(i,n) for (int i=1;i&lt;=n;i++)
#define repr(i,n) for (int i=n;i&gt;=1;i--)

using namespace std;

const int N=55;
int m[2][N][N],ans,n;
long long hash[2][N][N][N];

void makehash(int o)
{
       rep(len,n)rep(x,n-len+1)rep(y,n-len+1)
       {
              for (int i=x;i&lt;=x+len-1;i++)
                     for (int j=y;j&lt;=y+len-1;j++) hash[o][x][y][len]+=m[o][i][j]*((i-x)*10171019+j-y)*815713;
       }
}

void init()
{
       scanf("%d",&amp;n);
       rep(i,n) rep(j,n) scanf("%d",&amp;m[0][i][j]);
       rep(i,n) rep(j,n) scanf("%d",&amp;m[1][i][j]);
       makehash(0);makehash(1);
}

void dawn()
{
       repr(len,n)rep(x1,n-len+1)rep(y1,n-len+1)rep(x2,n-len+1)rep(y2,n-len+1)
              if (hash[0][x1][y1][len]==hash[1][x2][y2][len]) {printf("%d\n",len);return;}
}

int main()
{
       init();
       dawn();
}<pre><h2>Problem1568</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=50001;
int n=50000,m,ind;
struct seg{
	double k,b;
	int id;
	seg(int x0=0,int y0=0,int x1=0,int y1=0,int _id=0){
		id=_id;
		if(x0==x1){k=0;b=max(y0,y1);}
		else{k=(double)(y0-y1)/(x0-x1);b=y0-k*x0;}
	}
	double get(double x){return k*x+b;}
};
bool les(seg A,seg B,double x){
	if(!A.id)return 1;
	return A.get(x)!=B.get(x)?A.get(x)&lt;B.get(x):A.id&lt;B.id;
}
struct sgt{
	seg t[maxn&lt;&lt;2];
	seg Qmax(int i,int l,int r,int ps){
		if(l==r)return t[i];seg tmp;
		if(ps&lt;=(l+r)/2)tmp=Qmax(i&lt;&lt;1,l,(l+r)/2,ps);
		else tmp=Qmax(i&lt;&lt;1|1,(l+r)/2+1,r,ps);
		return les(t[i],tmp,ps)?tmp:t[i];
	}
	void insert(int i,int l,int r,seg se){
		if(!t[i].id)t[i]=se;
		if(les(t[i],se,l))swap(t[i],se);
		if(l==r||t[i].k==se.k)return;
		double x=(t[i].b-se.b)/(se.k-t[i].k);
		if(x&lt;l||x&gt;r)return;
		if(x&lt;=(l+r)/2)insert(i&lt;&lt;1,l,(l+r)/2,t[i]),t[i]=se;
		else insert(i&lt;&lt;1|1,(l+r)/2+1,r,se);
	}
	void insert(int i,int l,int r,int l0,int r0,seg se){
		if(l0&lt;=l&amp;&amp;r0&gt;=r){insert(i,l,r,se);return;}
		if(l0&lt;=(l+r)/2)insert(i&lt;&lt;1,l,(l+r)/2,l0,r0,se);
		if(r0&gt;(l+r)/2)insert(i&lt;&lt;1|1,(l+r)/2+1,r,l0,r0,se);
	}	
}T;
int la;
int main(){
	scanf("%d",&amp;m);char s[15];
	while(~scanf("%s",s)){
		if(s[0]=='Q'){
			int k;scanf("%d",&amp;k);
			printf("%lld\n",(long long)(T.Qmax(1,1,n,k).get(k)/100+1e-8));
		}else{
			seg tmp;double S,P;
			scanf("%lf%lf",&amp;S,&amp;P);
			tmp.k=P;tmp.b=S-P;tmp.id=1;
			T.insert(1,1,n,1,n,tmp);
		}
	}
	return 0;
}<pre><h2>Problem1570</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=5150;
struct edge{int u,v,cap,flow;};
vector&lt;edge&gt;edges;
vector&lt;int&gt;G[maxn];
int s,t;
int cur[maxn],d[maxn];
void add(int u,int v,int cap){
	if(u==-1)return;
//	cerr&lt;&lt;u&lt;&lt;" "&lt;&lt;v&lt;&lt;" "&lt;&lt;cap&lt;&lt;endl;
	edges.push_back((edge){u,v,cap,0});
	G[u].push_back(edges.size()-1);
	edges.push_back((edge){v,u,0,0});
	G[v].push_back(edges.size()-1);
}
bool bfs(){
	static int vis[maxn];
	memset(vis,0,sizeof vis);vis[s]=1;
	queue&lt;int&gt;q;q.push(s);d[s]=0;
	while(!q.empty()){
		int u=q.front();q.pop();
		for(int i=0;i&lt;G[u].size();i++){
			edge e=edges[G[u][i]];if(vis[e.v]||e.cap==e.flow)continue;
			d[e.v]=d[u]+1;vis[e.v]=1;q.push(e.v);
		}
	}return vis[t];
}
int dfs(int u,int a){
	if(u==t||!a)return a;
	int flow=0,f;
	for(int &amp;i=cur[u];i&lt;G[u].size();i++){
		edge e=edges[G[u][i]];
		if(d[e.v]==d[u]+1&amp;&amp;(f=dfs(e.v,min(a,e.cap-e.flow)))&gt;0){
			edges[G[u][i]].flow+=f;
			edges[G[u][i]^1].flow-=f;
			flow+=f;a-=f;if(!a)break;
		}
	}return flow;
}
int dinic(){
	int flow=0,x;
	while(bfs()){
		memset(cur,0,sizeof cur);
		while(x=dfs(s,INT_MAX)){
			flow+=x;
			memset(cur,0,sizeof cur);
		}
	}return flow;
}
int n,m,T;
int tot;
int mp[101][51];
edge E[2450];
void Add(int x){
	for(int i=1;i&lt;=n;i++)mp[x][i]=++tot;
	for(int i=0;i&lt;edges.size();i++)edges[i].flow=0;
	for(int i=1;i&lt;=n;i++)add(mp[x-1][i],mp[x][i],1e9);
	for(int i=0;i&lt;m;i++){
		edge e=E[i];
		add(mp[x-1][e.u],mp[x][e.v],e.cap);
	}add(mp[x][n],t,T);
}
int main(){
	s=maxn-2;t=maxn-1;
	scanf("%d%d%d",&amp;n,&amp;m,&amp;T);
	add(s,0,T);
	if(n==1){puts("0");return 0;}
	for(int i=2;i&lt;=n;i++)mp[0][i]=-1;
	for(int i=0;i&lt;m;i++)
		scanf("%d%d%d",&amp;E[i].u,&amp;E[i].v,&amp;E[i].cap);
	for(int i=1;i&lt;=n+T;i++){
		Add(i);
		if(dinic()==T){printf("%d\n",i);return 0;}
	}puts("-1");
	return 0;
}<pre><h2>Problem1587</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
int n,k;
int f[11][1001];
int g[1001][1001];
int w[1001];
int main(){
	scanf("%d%d",&amp;n,&amp;k);
	for(int i=1;i&lt;=n;i++){
		scanf("%d",&amp;w[i]);
		f[1][i]=f[1][i-1]+w[i]*(i-1);
	}
	for(int i=1;i&lt;=n;i++)
	for(int j=i+1;j&lt;=n;j++)
		g[i][j]=g[i][j-1]+w[j]*(j-i);
	for(int i=2;i&lt;=k;i++)
	for(int j=i;j&lt;=n;j++){
		f[i][j]=1e9;
		for(int l=i;l&lt;=j;l++)
			f[i][j]=min(f[i][j],f[i-1][l-1]+g[l][j]);
	}
	cout&lt;&lt;f[k][n]&lt;&lt;endl;
	return 0;
}<pre><h2>Problem1588</h2><pre>#include&lt;cstdio&gt;
#include&lt;climits&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
const int N=100005;
const int INF=INT_MAX;
int ch[N][2],pre[N],key[N];
int n,tot=0;
int root=0;
void NewNode(int &amp;r,int fa,int k){
	r=++tot;
	pre[r]=fa;
	key[r]=k;
	ch[r][0]=ch[r][1]=0;
}
void Rotate(int x,int kind){
	int y=pre[x];
	ch[y][!kind]=ch[x][kind];
	pre[ch[x][kind]]=y;
	if(pre[y])
		ch[pre[y]][ch[pre[y]][1]==y]=x;
	pre[x]=pre[y];
	ch[x][kind]=y;
	pre[y]=x;
}
void Splay(int r,int goal){
	while(pre[r]!=goal){
		if(pre[pre[r]]==goal)Rotate(r,ch[pre[r]][0]==r);
		else{
			int y=pre[r];
			int kind=ch[pre[y]][0]==y;
			if(ch[y][kind]==r){
				Rotate(r,!kind);
				Rotate(r,kind);
			}else{
				Rotate(y,kind);
				Rotate(r,kind);
			}
		}
	}
	if(goal==0)root=r;
}
int Insert(int k){
	int r=root;
	while(ch[r][key[r]&lt;k]){
		if(key[r]==k){
			Splay(r,0);
			return 0;
		}
		r=ch[r][key[r]&lt;k];
	}
	NewNode(ch[r][key[r]&lt;k],r,k);
	Splay(ch[r][key[r]&lt;k],0);
	return 1;
}
int get_pre(int x){
	int tmp=ch[x][0];
	if(tmp==0)return INF;
	while(ch[tmp][1])
		tmp=ch[tmp][1];
	return key[x]-key[tmp];
}
int get_next(int x){
	int tmp=ch[x][1];
	if(tmp==0)return INF;
	while(ch[tmp][0])
		tmp=ch[tmp][0];
	return key[tmp]-key[x];
}
int main(){
	cin&gt;&gt;n;
	int num;
	int ans=0;
	for(int i=1;i&lt;=n;i++){
		if(!(cin&gt;&gt;num))num=0;
		if(i==1){
			ans+=num;
			NewNode(root,0,num);
			continue;
		}
		if(Insert(num)==0)continue;
		int a=get_pre(root);
		int b=get_next(root);
		ans+=min(a,b);
	}
	cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}<pre><h2>Problem1599</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
int a[16010];
int main(){
	int s1,s2,s3;
	cin&gt;&gt;s1&gt;&gt;s2&gt;&gt;s3;
	for(int i=1;i&lt;=s1;i++)
	for(int j=1;j&lt;=s2;j++)
	for(int k=1;k&lt;=s3;k++)
	a[i+j+k]++;
	int maxx=0,pos=0;
	for(int i=1;i&lt;=16000;i++){
		if(a[i]&gt;maxx){
			maxx=a[i];pos=i;
		}
	}cout&lt;&lt;pos&lt;&lt;endl;
	return 0;
}<pre><h2>Problem1600</h2><pre>#include&lt;iostream&gt;
using namespace std;
int n,f[2505];
int main(){
  cin&gt;&gt;n;
  f[4]=1;
  for (int i=5;i&lt;=n;i++)
    if (!(i&amp;1)) f[i]=f[i-1]+i/2-1;
    else f[i]=f[i-1]+(i-2)*(i/2-1);
  cout&lt;&lt;f[n]&lt;&lt;endl;
  return 0;
}<pre><h2>Problem1601</h2><pre>//ID:zky
#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=310;
int n;
struct edge{
	int u,v,w,ind;
	bool operator &lt; (const edge &amp;e)const{
		return w&lt;e.w;
	}
};int tot;
edge edges[maxn*maxn+maxn];
int fa[maxn],minn=100000;
int find(int x){
	if(x!=fa[x])return fa[x]=find(fa[x]);return x;
}
int main(){
	int n;scanf("%d",&amp;n);fa[n+1]=n+1;
	for(int i=1;i&lt;=n;i++){
		fa[i]=i;
		int w;scanf("%d",&amp;w);minn=min(minn,w);
		edges[tot]=(edge){i,n+1,w,tot};tot++;
	}
	for(int i=1;i&lt;=n;i++)
	for(int j=1;j&lt;=n;j++){
		int x;scanf("%d",&amp;x);
		if(i&gt;=j)continue;		
		edges[tot]=(edge){i,j,x,tot};tot++;
	}sort(edges,edges+tot);
	int ans=0,get=0;
	for(int i=0;i&lt;tot;i++){
		int u=edges[i].u,v=edges[i].v;
		if(find(u)!=find(v)){
			fa[find(u)]=find(v);
			if(edges[i].ind&lt;=n)get=1;
			ans+=edges[i].w;
		}
	}if(!get)ans+=minn;
	cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}<pre><h2>Problem1602</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;typedef pair&lt;int,int&gt; pii;
vector&lt;pair&lt;int,int&gt; &gt;G[1001];
int n,m;
main(){
	cin&gt;&gt;n&gt;&gt;m;int s,t;
	for(int i=0;i&lt;n-1;i++){
		int u,v,w;cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;
		G[u].push_back(pii(v,w));
		G[v].push_back(pii(u,w));
	}while(m--){int d[1233];int vis[1233];memset(d,0x7f,sizeof(d));
	memset(vis,0,sizeof(vis));cin&gt;&gt;s&gt;&gt;t;
		queue&lt;int&gt;q;q.push(s);d[s]=0;while(!q.empty()){
			int u=q.front();q.pop();vis[u]=0;
			for(int i=0;i&lt;G[u].size();i++){
				int v=G[u][i].first,w=G[u][i].second;
				if(d[v]&gt;d[u]+w){
					d[v]=d[u]+w;if(!vis[v]){
						vis[v]=1;q.push(v);
					}
				}
			}
		}cout&lt;&lt;d[t]&lt;&lt;endl;
	}
}<pre><h2>Problem1603</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
int n;
int next[1001];
int w[1001];
int main(){
	cin&gt;&gt;n;
	for(int i=0;i&lt;n-1;i++){
		int u,v,ww;cin&gt;&gt;u&gt;&gt;v&gt;&gt;ww;
		next[u]=v;w[u]=ww;
	}int ans=0;
	for(int i=1;i;i=next[i])
		ans^=w[i];
	cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}<pre><h2>Problem1604</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1e5+10;
int n,m,a[maxn],c[maxn];
struct point {
    int x,y,i;
    bool operator&lt;(const point &amp;p)const {
        if(y==p.y)return x&lt;p.x;
        return y&lt;p.y;
    }
} p[maxn];
set&lt;point&gt;mset;
set&lt;point&gt;::iterator ii,it;
bool cmp(point p1,point p2) {
    return p1.x&lt;p2.x;
}
inline int find(int x) {
    int r=x,p;
    while(r!=a[r])r=a[r];
    while(r!=x) {
        p=a[x];
        a[x]=r;
        x=p;
    }
    return r;
}
void unit(int x,int y) {
    x=find(x);
    y=find(y);
    if(x!=y)a[y]=x;
}
void slove() {
    int i,j=1,k,x,y,sum,ans;
    mset.clear();
    mset.insert(p[1]);
    for(i=2; i&lt;=n; i++) {
        while(p[i].x-p[j].x&gt;m&amp;&amp;j&lt;i) {
            mset.erase(p[j]);
            j++;
        }
        mset.insert(p[i]);
        ii=it=mset.find(p[i]);
        ii--;
        it++;
        if(ii!=mset.end()&amp;&amp;abs(ii-&gt;y-p[i].y)&lt;=m)unit(i,ii-&gt;i);
        if(it!=mset.end()&amp;&amp;abs(it-&gt;y-p[i].y)&lt;=m)unit(i,it-&gt;i);
    }
    sum=ans=0;
    for(i=1; i&lt;=n; i++)c[find(i)]++;
    for(i=1; i&lt;=n; i++) {
        ans=max(ans,c[i]);
        if(a[i]==i)sum++;
    }
    printf("%d %d\n",sum,ans);
}
int main() {
    int i,j,k,x,y;
    while(scanf("%d%d",&amp;n,&amp;m)!=EOF) {
        for(i=1; i&lt;=n; i++) {
            scanf("%d%d",&amp;x,&amp;y);
            p[i].x=x+y;
            p[i].y=x-y;
            a[i]=i;
            c[i]=0;
        }
        sort(p+1,p+n+1,cmp);
        for(i=1; i&lt;=n; i++)p[i].i=i;
        slove();
    }
    return 0;
}<pre><h2>Problem1606</h2><pre>#include &lt;bits/stdc++.h&gt; 
using namespace std;
int c,h,v[5001]; 
bool f[50001];
int main() { 
    cin&gt;&gt;c&gt;&gt;h;
    for(int i=1;i&lt;=h;i++) cin&gt;&gt;v[i]; 
    f[0] = true; 
    for(int i=1;i&lt;=h;i++) 
    for(int j=c;j&gt;=v[i];j--){ 
        if (!f[j]&amp;&amp;f[j-v[i]]) 
        f[j]=true; 
    } 
    int ans=c; 
    while(ans&gt;1&amp;&amp;!f[ans]) 
        ans--; cout&lt;&lt;ans&lt;&lt;endl;
    return 0; 
}<pre><h2>Problem1607</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
int f[1000001];
int a[1000001];
int cnt[1000001];
int n;
int getint(){
	int x;scanf("%d",&amp;x);return x;
}
int main(){
	n=getint();int maxx=0;
	for(int i=1;i&lt;=n;i++){
		a[i]=getint();
		cnt[a[i]]++;
		maxx=max(maxx,a[i]);
	}	
	for(int i=1;i&lt;=maxx;i++){
		if(cnt[i]){
			for(int j=i;j&lt;=maxx;j+=i)
			f[j]+=cnt[i];
		}
	}
	for(int i=1;i&lt;=n;i++)
	printf("%d\n",f[a[i]]-1);
	return 0;
}<pre><h2>Problem1609</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt; 
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=30010;
int d[maxn],n,a[maxn],size;
int main(){
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;i++)cin&gt;&gt;a[i];
    for(int i=1;i&lt;=n;i++){
        int j=upper_bound(d,d+size,a[i])-d;
        size=max(size,j+1);
        d[j]=a[i];
    }int ans1=size;ans1=n-ans1;
    size=0;memset(d,0,sizeof(d));
    reverse(a+1,a+1+n);
    for(int i=1;i&lt;=n;i++){
        int j=upper_bound(d,d+size,a[i])-d;
        size=max(size,j+1);
        d[j]=a[i];
    }int ans2=size;ans2=n-ans2;
    size=0;d[0]=0;
    cout&lt;&lt;min(ans1,ans2)&lt;&lt;endl;
    return 0;
}<pre><h2>Problem1610</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=205;
int n,x[maxn],y[maxn],size;
pair&lt;int,int&gt; anss[maxn*maxn];
int main(){
	cin&gt;&gt;n;
	for(int i=1;i&lt;=n;i++){
		cin&gt;&gt;x[i]&gt;&gt;y[i];
	}
	for(int i=1;i&lt;=n;i++)
	for(int j=i+1;j&lt;=n;j++){
		size++;
		anss[size]=pair&lt;int,int&gt;(y[i]-y[j],x[i]-x[j]);
		long long d=__gcd(anss[size].first,anss[size].second);
		if(d)anss[size].first/=d,anss[size].second/=d;
		if(!anss[size].second)anss[size].first=INT_MAX;
	}sort(anss+1,anss+size+1);
	int ans=unique(anss+1,anss+size+1)-anss-1;
	cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}
<pre><h2>Problem1611</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;queue&gt;
using namespace std;
const int cx[4] = {0, 0, 1, -1};
const int cy[4] = {1, -1, 0, 0};
const int inf = 999999999;
int m, map[310][310], b[310][310];
struct node{int x, y, t;} a[50010];
bool cmp(node a1, node a2) {return a1.t &gt; a2.t;}
void bfs()
{
       int i;
       queue &lt;node&gt; q;
       node p = {0, 0, 0}; b[0][0] = 0; q.push(p);
       while(!q.empty())
       {
              node p = q.front(); q.pop(); int c = b[p.x][p.y];
              if(map[p.x][p.y] == inf) {cout&lt;&lt;c; return;}
              for(i = 0; i &lt; 4; i++)
              {
                     int x = p.x + cx[i], y = p.y + cy[i];
                     if(x &gt; 305 || y &gt; 305 || x &lt; 0 || y &lt; 0) continue;
                     if(b[x][y] != inf || map[x][y] &lt;= c + 1) continue;
                     node p2 = {x, y, 0}; q.push(p2); b[x][y] = c + 1;
              }
       }
       cout&lt;&lt;"-1";
}
int main()
{
       int i;
       cin&gt;&gt;m;
       for(i = 1; i &lt;= m; i++) cin&gt;&gt;a[i].x&gt;&gt;a[i].y&gt;&gt;a[i].t;
       sort(a + 1, a + 1 + m, cmp);
       for(i = 0; i &lt;= 305; i++) for(int j = 0; j &lt;= 305; j++) map[i][j] = b[i][j] = inf;
       for(i = 1; i &lt;= m; i++)
       {
              int x = a[i].x, y = a[i].y;
              map[x][y] = map[x + 1][y] = map[x][y + 1] = a[i].t;
              if(x) map[x - 1][y] = a[i].t;  if(y) map[x][y - 1] = a[i].t;
       }
       bfs();
return 0;
}<pre><h2>Problem1612</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
int f[101][101];
int n,m;
int main(){
	cin&gt;&gt;n&gt;&gt;m;
	for(int i=1;i&lt;=m;i++){
		int u,v;cin&gt;&gt;u&gt;&gt;v;
		f[u][v]=1;f[v][u]=-1;
	}
	for(int k=1;k&lt;=n;k++)
	for(int i=1;i&lt;=n;i++)
	for(int j=1;j&lt;=n;j++){
		if(f[i][k]==1&amp;&amp;f[k][j]==1)f[i][j]=1;
		if(f[i][k]==-1&amp;&amp;f[k][j]==-1)f[i][j]=-1;	
	}
	int ans=n;
	for(int i=1;i&lt;=n;i++)
	for(int j=1;j&lt;=n;j++)if(i!=j)
	if(f[i][j]==0){
		ans--;
		break;
	}cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}<pre><h2>Problem1613</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
int f[10005][505];
int n,m,d[10005];
int main(){
	scanf("%d%d",&amp;n,&amp;m);
	for(int i=1;i&lt;=n;i++)scanf("%d",&amp;d[i]);
	for(int i=1;i&lt;=n;i++){
		f[i][0]=max(f[i][0],f[i-1][0]);
		for(int j=1;j&lt;=m;j++){
			f[i][j]=f[i-1][j-1]+d[i];
			if(i-j&gt;0)f[i][0]=max(f[i][0],f[i-j][j]);
		}
	}cout&lt;&lt;f[n][0]&lt;&lt;endl;
	return 0;
} </pre><pre></pre><h2>Problem1614</h2><pre>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
struct data{int to,next,v;}e[20001];
int n,p,k,cnt,head[1001],dis[1001],q[1001],inq[1001],ans=-1;
void insert(int u,int v,int w)
{cnt++;e[cnt].to=v;e[cnt].v=w;e[cnt].next=head[u];head[u]=cnt;}
bool spfa(int x)
{
     memset(dis,127/3,sizeof(dis));
     int t=0,w=1,i,now,s;
     dis[1]=0;q[t]=1;inq[1]=1;
     while(t!=w)
     {
                now=q[t];t++;if(t==1001)t=0;
                i=head[now];
                while(i)
                {
                        if(e[i].v&gt;x)s=dis[now]+1;
                        else s=dis[now];
                        if(s&lt;dis[e[i].to])
                        {
                                          dis[e[i].to]=s;
                                          if(!inq[e[i].to])
                                          {
                                                           q[w++]=e[i].to;
                                                           inq[e[i].to]=1;
                                                           if(w==1001)w=0;
                                                           }
                                          }
                        i=e[i].next;
                        }
                inq[now]=0; 
                }
     if(dis[n]&lt;=k)return 1;
     return 0;
 }
int main()
{
    scanf("%d%d%d",&amp;n,&amp;p,&amp;k);
    for(int i=1;i&lt;=p;i++)
    {
            int u,v,w;
            scanf("%d%d%d",&amp;u,&amp;v,&amp;w);
            insert(u,v,w);insert(v,u,w);
            }
    int l=0,r=1000000;
    while(l&lt;=r)
    {
               int mid=(l+r)&gt;&gt;1;
               if(spfa(mid)){ans=mid;r=mid-1;}
               else l=mid+1;
               } 
    printf("%d",ans);
    return 0;
}</pre><pre></pre><h2>Problem1616</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
int n,m,t;
int mp[101][101];
int f[101][101][20];
int x1,y1,x2,y2;
const int dx[4]={0,0,1,-1};
const int dy[4]={1,-1,0,0};
int main(){
	scanf("%d%d%d",&amp;n,&amp;m,&amp;t);
	for(int i=1;i&lt;=n;i++){
		char s[105];
		scanf("%s",s+1);
		for(int j=1;j&lt;=m;j++)
			if(s[j]=='*')mp[i][j]=1;
	}scanf("%d%d%d%d",&amp;x1,&amp;y1,&amp;x2,&amp;y2);
	f[x1][y1][0]=1;
	for(int i=1;i&lt;=t;i++)for(int j=1;j&lt;=100;j++)for(int k=1;k&lt;=100;k++)if(!mp[j][k])for(int l=0;l&lt;4;l++){
		int x=j+dx[l],y=k+dy[l];
		if(x&lt;1||x&gt;n||y&lt;1||y&gt;m||mp[x][y])continue;
		f[j][k][i]+=f[x][y][i-1];
	}cout&lt;&lt;f[x2][y2][t];
	return 0;
}</pre><pre></pre><h2>Problem1617</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=2505;
int n,m;
int M[maxn],f[maxn];
int dfs(int n){
	if(f[n])return f[n];
	int ans=M[n]+m;
	for(int i=1;i&lt;n;i++)
	ans=min(ans,dfs(n-i)+m+dfs(i));
	return f[n]=ans;
}
int main(){
	cin&gt;&gt;n&gt;&gt;m;
	for(int i=1;i&lt;=n;i++)cin&gt;&gt;M[i],M[i]+=M[i-1];
	cout&lt;&lt;dfs(n)&lt;&lt;endl;	
	return 0;	
}</pre><pre></pre><h2>Problem1618</h2><pre>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
using namespace std;
int n,m,p[102],c[102],f[55002],ans;
int main()
{
    scanf("%d%d",&amp;n,&amp;m);
    for(int i=1;i&lt;=n;i++) scanf("%d%d",&amp;p[i],&amp;c[i]);
    memset(f,127,sizeof(f)); f[0]=0;
    for(int i=1;i&lt;=n;i++)
    for(int j=p[i];j&lt;=m+5000;j++)
        f[j]=min(f[j-p[i]]+c[i],f[j]);
    ans=0x7fffffff;
    for(int i=m;i&lt;=m+5000;i++) ans=min(ans,f[i]);
    printf("%d",ans);
    return 0;
}</pre><pre></pre><h2>Problem1619</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
using namespace std;
const int maxn=701;
const int dx[9]={1,-1,0,0,1,-1,1,-1},dy[9]={1,-1,1,-1,0,0,-1,1};
struct node{
    int x,y,h;
}f[maxn*maxn];
int h[maxn][maxn];
int tot=0,ans=0,n,m;
bool vis[maxn][maxn];
  
bool cmp(const node &amp;a,const node &amp;b){
    return a.h&gt;b.h?1:0;
}
  
void dfs(int x,int y){
    vis[x][y]=1;
    for(int i=0;i&lt;8;i++){
        int xx=x+dx[i];
        int yy=y+dy[i];
        if(xx&gt;=0 &amp;&amp; xx&lt;=n &amp;&amp; yy&gt;=0 &amp;&amp; yy&lt;=m &amp;&amp; !vis[xx][yy] &amp;&amp; h[x][y]&gt;=h[xx][yy]) dfs(xx,yy);
    }
}
int main(){
    scanf("%d%d",&amp;n,&amp;m);
    for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;=m;j++){
           scanf("%d",&amp;h[i][j]);
           f[++tot].h=h[i][j];
           f[tot].x=i;
           f[tot].y=j;  
        }
    sort(f+1,f+tot+1,cmp);
    for(int i=1;i&lt;=tot;i++){
        if(!vis[f[i].x][f[i].y]){
            dfs(f[i].x,f[i].y);
            ans++;
        }
    }
    cout&lt;&lt;ans;
    return 0;
}</pre><pre></pre><h2>Problem1620</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;cmath&gt;
#include &lt;string&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;queue&gt;
using namespace std;
#define rep(i, n) for(int i=0; i&lt;(n); ++i)
#define for1(i,a,n) for(int i=(a);i&lt;=(n);++i)
#define for2(i,a,n) for(int i=(a);i&lt;(n);++i)
#define for3(i,a,n) for(int i=(a);i&gt;=(n);--i)
#define for4(i,a,n) for(int i=(a);i&gt;(n);--i)
#define CC(i,a) memset(i,a,sizeof(i))
#define read(a) a=getint()
#define print(a) printf("%d", a)
#define dbg(x) cout &lt;&lt; #x &lt;&lt; " = " &lt;&lt; x &lt;&lt; endl
#define printarr(a, n, m) rep(aaa, n) { rep(bbb, m) cout &lt;&lt; a[aaa][bbb]; cout &lt;&lt; endl; }
inline const int getint() { int r=0, k=1; char c=getchar(); for(; c&lt;'0'||c&gt;'9'; c=getchar()) if(c=='-') k=-1; for(; c&gt;='0'&amp;&amp;c&lt;='9'; c=getchar()) r=r*10+c-'0'; return k*r; }
inline const int max(const int &amp;a, const int &amp;b) { return a&gt;b?a:b; }
inline const int min(const int &amp;a, const int &amp;b) { return a&lt;b?a:b; }
  
const int N=1005;
struct data { int x, y; }a[N];
inline bool cmp(const data &amp;x, const data &amp;y) { return x.y&gt;y.y; }
int main() {
    int n=getint();
    for1(i, 1, n) read(a[i].x), read(a[i].y);
    sort(a+1, a+1+n, cmp);
    int ans=~0u&gt;&gt;1;
    for1(i, 1, n) ans=min(ans, a[i].y)-a[i].x;
    if(ans&lt;0) puts("-1");
    else print(ans);
    return 0;
}</pre><pre></pre><h2>Problem1621</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;map&gt;
#include&lt;set&gt;
#include&lt;queue&gt;
#define inf 1000000000
#define maxn 300+10
#define maxm 500+100
#define ll long long
using namespace std;
inline ll read()
{
    ll x=0,f=1;char ch=getchar();
    while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=10*x+ch-'0';ch=getchar();}
    return x*f;
}
int n,k,ans=0;
void dfs(int x)
{
    if(x-k&lt;2||((x&amp;1)!=(k&amp;1)))ans++;
    else
    {
      int y=(x-k)&gt;&gt;1;dfs(y);y=x-y;dfs(y);
    }
}
int main()
{
    n=read();k=read();
    dfs(n);
    printf("%d\n",ans);
    return 0;
}</pre><pre></pre><h2>Problem1622</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
string name[1001];
string ene[101];
int n,m;
bool ok(string s,string t){
	int i=0,j=0;
	while(i&lt;s.length()){
		if(s[i]==t[j])j++;
		i++;
		if(j&gt;=t.length())return 1;
	}return 0;
}
void lower(string &amp;s){
	for(int i=0;i&lt;s.length();i++)
	if(s[i]&gt;='A'&amp;&amp;s[i]&lt;='Z')s[i]=s[i]+'a'-'A';
}
int main(){
	cin&gt;&gt;n&gt;&gt;m;
	for(int i=1;i&lt;=n;i++)cin&gt;&gt;name[i],lower(name[i]);
	for(int i=1;i&lt;=m;i++)cin&gt;&gt;ene[i],lower(ene[i]);
	for(int i=1;i&lt;=n;i++){
		int ans=0;
		for(int j=1;j&lt;=m;j++)
			ans+=ok(name[i],ene[j]);
		cout&lt;&lt;ans&lt;&lt;endl;		
	}
	return 0;
} </pre><pre></pre><h2>Problem1623</h2><pre>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#define ll long long
#define inf 1000000000
using namespace std;
inline int read()
{
    int x=0,f=1;char ch=getchar();
    while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
int v[50005];
int n,m,d,l,ans;
int main()
{
    n=read();m=read();d=read();l=read();
    for(int i=1;i&lt;=n;i++)
        v[i]=read();
    sort(v+1,v+n+1);
    for(int i=1;i&lt;=n;i++)
    {
        int t=ans/m;
        if(v[i]-t*d&gt;=l)ans++;
    }
    printf("%d",ans);
    return 0;
}</pre><pre></pre><h2>Problem1624</h2><pre>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
using namespace std;
int n,m,a[10001],d[101][101],ans;
int main()
{
    scanf("%d%d",&amp;n,&amp;m);
    for(int i=1;i&lt;=m;i++)scanf("%d",&amp;a[i]);
    for(int i=1;i&lt;=n;i++)
       for(int j=1;j&lt;=n;j++)
          scanf("%d",&amp;d[i][j]);
    for(int k=1;k&lt;=n;k++)
       for(int i=1;i&lt;=n;i++)
          for(int j=1;j&lt;=n;j++)
             d[i][j]=min(d[i][j],d[i][k]+d[k][j]);
    for(int i=2;i&lt;=m;i++)ans+=d[a[i-1]][a[i]];
    ans+=d[1][a[1]];ans+=d[a[m]][n];
    printf("%d",ans);
    return 0;
}</pre><pre></pre><h2>Problem1625</h2><pre>//ID:zky
#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
int n,m;
int f[12881];
int w[3403];
int v[3403];
int main(){
	scanf("%d%d",&amp;n,&amp;m);
	for(int i=1;i&lt;=n;i++)
		scanf("%d%d",&amp;w[i],&amp;v[i]);
	for(int i=1;i&lt;=n;i++)
	for(int j=m;j&gt;=w[i];j--)
		f[j]=max(f[j],f[j-w[i]]+v[i]);
	printf("%d\n",f[m]);
	return 0;
}</pre><pre></pre><h2>Problem1626</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
using namespace std;
struct aaa{
	int x,y;
	long double d;
}dat[1000001];
inline int read()
{
    int x=0;char ch=getchar();
    while(ch&lt;'0'||ch&gt;'9')ch=getchar();
    while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=x*10+ch-'0';ch=getchar();}
    return x;
}
long double ans;
int n,m,len,piece;
int x[1001],y[1001];
int fa[10001];
inline bool cmp(aaa a,aaa b)
{return a.d&lt;b.d;}
inline long double dist(int i,int j)
{
	long double tx=(long double)x[i]-x[j];
	long double ty=(long double)y[i]-y[j];
	return sqrt(tx*tx+ty*ty);
}
int gfa(int s)
{
    if (fa[s]==s) return s;
    fa[s]=gfa(fa[s]);
    return fa[s];
}
int main()
{
	n=read();
	m=read();
	for (int i=1;i&lt;=n;i++)
	{
		x[i]=read();
		y[i]=read();
	}
	for (int i=1;i&lt;n;i++)
	  for (int j=i+1;j&lt;=n;j++)
		{
	      dat[++len].x=i;
	      dat[len].y=j;
	      dat[len].d=dist(i,j);
	  	}
	sort(dat+1,dat+len+1,cmp);
	for (int i=1;i&lt;=n;i++) fa[i]=i;
	piece=n;
	for (int i=1;i&lt;=m;i++)
	  {
	  	int s=read(),t=read();
	  	int fs=gfa(s),ft=gfa(t);
	  	if (fs!=ft)
	  	{
	  		piece--;
	  		fa[ft]=fs;
	  	}
	  }
	for (int i=1;i&lt;=len;i++)
	{
		if (piece==1) break;
		int s=dat[i].x;
		int t=dat[i].y;
	  	int fs=gfa(s),ft=gfa(t);
	  	if (fs!=ft)
	  	{
	  		piece--;
	  		fa[ft]=fs;
	  		ans+=dat[i].d;
	  	}
	}
	printf("%.2lf",(double)ans);
}</pre><pre></pre><h2>Problem1627</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;cmath&gt;
#include &lt;string&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;queue&gt;
using namespace std;
#define rep(i, n) for(int i=0; i&lt;(n); ++i)
#define for1(i,a,n) for(int i=(a);i&lt;=(n);++i)
#define for2(i,a,n) for(int i=(a);i&lt;(n);++i)
#define for3(i,a,n) for(int i=(a);i&gt;=(n);--i)
#define for4(i,a,n) for(int i=(a);i&gt;(n);--i)
#define CC(i,a) memset(i,a,sizeof(i))
#define read(a) a=getint()
#define print(a) printf("%d", a)
#define dbg(x) cout &lt;&lt; #x &lt;&lt; " = " &lt;&lt; x &lt;&lt; endl
#define printarr(a, n, m) rep(aaa, n) { rep(bbb, m) cout &lt;&lt; a[aaa][bbb]; cout &lt;&lt; endl; }
inline const int getint() { int r=0, k=1; char c=getchar(); for(; c&lt;'0'||c&gt;'9'; c=getchar()) if(c=='-') k=-1; for(; c&gt;='0'&amp;&amp;c&lt;='9'; c=getchar()) r=r*10+c-'0'; return k*r; }
 
const int N=1000005, dx[]={-1, 1, 0, 0}, dy[]={0, 0, -1, 1};
struct ND { int d, x, y; }q[N];
int tail, front, vis[1005][1005], mp[1005][1005];
int main() {
    int X, Y, x, y, fx, fy;
    read(X); read(Y); int n=getint(); X+=500; Y+=500;
    while(n--) {
        read(x); read(y); mp[x+500][y+500]=1;
    }
    ND t={0, 500, 500};
    q[tail++]=t;
    while(front!=tail) {
        t=q[front++]; if(front==N) front=0;
        x=t.x; y=t.y;
        if(x==X &amp;&amp; y==Y) { printf("%d\n", t.d); return 0; }
        rep(i, 4) {
            fx=dx[i]+x; fy=dy[i]+y;
            if(fx&lt;0 || fy&lt;0 || fx&gt;1000 || fy&gt;1000 || mp[fx][fy] || vis[fx][fy]) continue;
            vis[fx][fy]=1;
            q[tail].x=fx; q[tail].y=fy; q[tail++].d=t.d+1;
            if(tail==N) tail=0;
        }
    }
    return 0;
}</pre><pre></pre><h2>Problem1629</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
using namespace std;
int n;
struct node{int w, s, add;} a[50010];
bool cmp(node a1, node a2){return a1.add &lt; a2.add;}
 
int main()
{
       int i;
       cin&gt;&gt;n;
       for(i = 1; i &lt;= n; i++) {cin&gt;&gt;a[i].w&gt;&gt;a[i].s; a[i].add = a[i].w + a[i].s;}
       sort(a + 1, a + 1 + n, cmp);
       int ans = -999999999, sum = 0;
       for(i = 1; i &lt;= n; i++)
       {
              ans = max(ans, sum - a[i].s);
              sum += a[i].w;
       }
       cout&lt;&lt;ans;
return 0;
}</pre><pre></pre><h2>Problem1631</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;map&gt;
#include&lt;set&gt;
#include&lt;queue&gt;
#define inf 1000000000
#define maxn 1000+100
#define maxm 50000+100
#define ll long long
using namespace std;
inline ll read()
{
    ll x=0,f=1;char ch=getchar();
    while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=10*x+ch-'0';ch=getchar();}
    return x*f;
}
struct edge{int from,go,next,w;}e[2][2*maxm];
int n,m,s,tot[2],q[maxn],d[2][maxn],head[2][maxn];
bool v[maxn];
void ins(int k,int x,int y,int z)
{
    e[k][++tot[k]].go=y;e[k][tot[k]].w=z;e[k][tot[k]].next=head[k][x];head[k][x]=tot[k];
}
void spfa(int k)
{
    for(int i=1;i&lt;=n;++i) d[k][i]=inf;
    memset(v,0,sizeof(v));
    int l=0,r=1,x,y;q[1]=s;d[k][s]=0;
    while(l!=r)
    {
        x=q[++l];if(l==maxn)l=0;v[x]=0;
        for(int i=head[k][x];i;i=e[k][i].next)
         if(d[k][x]+e[k][i].w&lt;d[k][y=e[k][i].go])
         {
             d[k][y]=d[k][x]+e[k][i].w;
             if(!v[y]){v[y]=1;q[++r]=y;if(r==maxn)r=0;}
         }
    }
}
int main()
{
 
    n=read();m=read();s=read();
    while(m--)
    {
        int x=read(),y=read(),z=read();
        ins(0,x,y,z);ins(1,y,x,z);
    } 
    spfa(0);spfa(1);
    int ans=0;
    for(int i=1;i&lt;=n;i++)ans=max(ans,d[0][i]+d[1][i]);
    printf("%d\n",ans);
    return 0;   
}</pre><pre></pre><h2>Problem1632</h2><pre>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;cstdlib&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
#define inf 10000000
#define ll long long
using namespace std;
inline int read()
{
    int x=0,f=1;char ch=getchar();
    while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
int head=0,tail=1;
int n,m,ex,ey;
int x[10005],y[10005];
int xx[8]={1,1,-1,-1,2,2,-2,-2},yy[8]={2,-2,2,-2,1,-1,1,-1};
int a[55][55],add[55][55],dis[55][55];
ll f[55][35];
bool inq[55][55];
void bfs()
{
    while(head!=tail)
    {
        int nx=x[head],ny=y[head];head++;
        for(int k=0;k&lt;8;k++)
        {
            int tx=nx+xx[k],ty=ny+yy[k];
            if(tx&lt;1||ty&lt;1||tx&gt;n||ty&gt;m||a[tx][ty]==2)continue;
            int ta=add[nx][ny]+(a[tx][ty]==0);
            if(ta&lt;add[tx][ty])
            {
                add[tx][ty]=ta;
                dis[tx][ty]=dis[nx][ny]+1;
                f[tx][ty]=f[nx][ny];
                if(inq[tx][ty])continue;
                inq[tx][ty]=1;x[tail]=tx;y[tail]=ty;tail++;
            }
            else if(ta==add[tx][ty])
            {
                if(dis[nx][ny]+1&lt;dis[tx][ty])
                {
                    dis[tx][ty]=dis[nx][ny]+1;
                    f[tx][ty]=f[nx][ny];
                    if(inq[tx][ty])continue;
                    inq[tx][ty]=1;x[tail]=tx;y[tail]=ty;tail++;
                }
                else if(dis[nx][ny]+1==dis[tx][ty])
                {
                    f[tx][ty]+=f[nx][ny];
                    if(inq[tx][ty])continue;
                    inq[tx][ty]=1;x[tail]=tx;y[tail]=ty;tail++;
                }
            }
        }
        inq[nx][ny]=0;
    }
}
int main()
{
    n=read();m=read();
    for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;=m;j++)
        {
            a[i][j]=read();
            add[i][j]=dis[i][j]=inf;
            if(a[i][j]==3)
            {
                inq[i][j]=1;
                x[0]=i;y[0]=j;add[i][j]=dis[i][j]=0;f[i][j]=1;
            }
            else if(a[i][j]==4)ex=i,ey=j;
        }
    bfs();
    if(add[ex][ey]==inf)puts("-1");
    else
    {
        printf("%d\n%d\n%lld\n",add[ex][ey],dis[ex][ey],f[ex][ey]);
    }
    return 0;
}</pre><pre></pre><h2>Problem1635</h2><pre>#include&lt;cstdio&gt;
 
#include&lt;cstdlib&gt;
 
#include&lt;cmath&gt;
 
#include&lt;cstring&gt;
 
#include&lt;algorithm&gt;
 
#include&lt;iostream&gt;
 
#include&lt;vector&gt;
 
#include&lt;map&gt;
 
#include&lt;set&gt;
 
#include&lt;queue&gt;
 
#include&lt;string&gt;
 
#define inf 1000000000
 
#define maxn 10000+500
 
#define maxm 500+100
 
#define eps 1e-10
 
#define ll long long
 
#define pa pair&lt;int,int&gt;
 
#define for0(i,n) for(int i=0;i&lt;=(n);i++)
 
#define for1(i,n) for(int i=1;i&lt;=(n);i++)
 
#define for2(i,x,y) for(int i=(x);i&lt;=(y);i++)
 
#define for3(i,x,y) for(int i=(x);i&gt;=(y);i--)
 
#define mod 1000000007
 
using namespace std;
 
inline int read()
 
{
 
    int x=0,f=1;char ch=getchar();
 
    while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')f=-1;ch=getchar();}
 
    while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=10*x+ch-'0';ch=getchar();}
 
    return x*f;
 
}
int b[maxn],n,ans,m;
struct rec{int l,r;}a[maxn];
inline bool cmp(rec a,rec b)
{
    return a.l&lt;b.l||(a.l==b.l&amp;&amp;a.r&lt;b.r);
}
 
int main()
 
{
 
 
    n=read();ans=read();ans=read();m=read();
    for1(i,m)
     {
         a[i].l=read();a[i].r=read();
         if(a[i].l&gt;a[i].r)swap(a[i].l,a[i].r);
     }
    sort(a+1,a+m+1,cmp);
    for1(i,m)
    {
        if(a[i].l==a[i-1].l&amp;&amp;a[i].r==a[i-1].r)continue;
        b[a[i].l+1]--;b[a[i].r]++;
    }
    for1(i,n)
    {
         ans+=b[i];
        printf("%d\n",ans);
    }
 
    return 0;
 
}</pre><pre></pre><h2>Problem1636</h2><pre>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;cmath&gt;
using namespace std;
inline int read()
{
    int x=0;char ch=getchar();
    while(ch&lt;'0'||ch&gt;'9')ch=getchar();
    while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=x*10+ch-'0';ch=getchar();}
    return x;
}
int n,q;
int s[16],mx[50005][16],mn[50005][16];
void pre()
{
	int x=log(n)/log(2);
	for(int i=1;i&lt;=x;i++)
	    for(int j=1;j&lt;=n;j++)
	    {
	    	mx[j][i]=mx[j][i-1];
	    	mn[j][i]=mn[j][i-1];
	    	if(j+s[i-1]&lt;=n)mx[j][i]=max(mx[j][i],mx[j+s[i-1]][i-1]);
	    	if(j+s[i-1]&lt;=n)mn[j][i]=min(mn[j][i],mn[j+s[i-1]][i-1]);
	    }
}
inline int rmq(int a,int b)
{
	int x=log(b-a+1)/log(2);
	int t1=max(mx[a][x],mx[b-s[x]+1][x]);
	int t2=min(mn[a][x],mn[b-s[x]+1][x]);
    return t1-t2;
}
int main()
{
	n=read(),q=read();
	s[0]=1;
	for(int i=1;i&lt;=15;i++)
	    s[i]=s[i-1]*2;
	for(int i=1;i&lt;=n;i++)
	    mx[i][0]=mn[i][0]=read();
	pre();
	while(q--)
	{
		int x=read(),y=read();
		printf("%d\n",rmq(x,y));
	}
	return 0;
}</pre><pre></pre><h2>Problem1638</h2><pre>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;cstring&gt;
#define ll long long
#define inf 1000000000
using namespace std;
inline int read()
{
    int x=0,f=1;char ch=getchar();
    while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
int n,m,cnt1,cnt2,ans;
int u[50005],v[50005];
int head[5005],h[5005],f[5005],g[5005],r[5005];
struct edge1{int to,next;}e[50005];
struct edge2{int to,next;}ed[50005];
void insert(int u,int v)
{
    e[++cnt1].to=v;e[cnt1].next=head[u];head[u]=cnt1;
    ed[++cnt2].to=u;ed[cnt2].next=h[v];h[v]=cnt2;
}
void dp1(int x)
{
    if(!head[x]){f[x]=1;return;}
    for(int i=head[x];i;i=e[i].next)
    {
        if(!f[e[i].to])dp1(e[i].to);
        f[x]+=f[e[i].to];
    }
}
void dp2(int x)
{
    if(!h[x]){g[x]=1;return;}
    for(int i=h[x];i;i=ed[i].next)
    {
        if(!g[ed[i].to])dp2(ed[i].to);
        g[x]+=g[ed[i].to];
    }
}
int main()
{
    n=read();m=read();
    for(int i=1;i&lt;=m;i++)
    {
        u[i]=read();v[i]=read();
        insert(u[i],v[i]);
    }
    for(int i=1;i&lt;=n;i++)
        if(!f[i])dp1(i);
    dp2(n);
    for(int i=1;i&lt;=m;i++)
        ans=max(ans,g[u[i]]*f[v[i]]);
    printf("%d\n",ans);
    return 0;
}</pre><pre></pre><h2>Problem1639</h2><pre>#include&lt;cstdio&gt;
int n,m,ans,a[100001];
bool jud(int x)
{
    int s=0,tmp=1;
    for(int i=1;i&lt;=n;i++)
    {
        if(s+a[i]&lt;=x)s+=a[i];
        else {s=a[i];tmp++;if(tmp&gt;m||a[i]&gt;x)return 0;}
    }
    return 1;
}
int main()
{
    scanf("%d%d",&amp;n,&amp;m);
    for(int i=1;i&lt;=n;i++)
        scanf("%d",&amp;a[i]);
    int l=1,r=1000000000;
    while(l&lt;=r)
    {
        int mid=(l+r)&gt;&gt;1;
        if(jud(mid)){ans=mid;r=mid-1;}
        else l=mid+1;
    }
    printf("%d",ans);
    return 0;
}</pre><pre></pre><h2>Problem1640</h2><pre>#include &lt;cstdio&gt;
 
const int max_n = 30000 * 2 + 10;
const int max_size = max_n * 1;
  
int n;
int sa[max_size], wa[max_size], wb[max_size];
int tong[max_size],wv[max_size];
char str[max_size];
int rank[max_size], h[max_size];
  
 
inline int cmp(int *r, int a, int b, int l)
{
    return r[a] == r[b] &amp;&amp; r[b+l]==r[a+l];
}
 
 
void da(char *r, int *sa, int n, int m)
{
     int i,j,p, *x = wa, *y = wb, *t;
     for (i = 0; i &lt; m; ++ i)    tong[i] = 0;
     for (i = 0; i &lt; n; ++ i)    tong[x[i] = r[i]] ++;
     for (i = 1; i &lt; m; ++ i)    tong[i] += tong[i - 1];
     for (i = n - 1; i &gt;= 0; -- i)       sa[-- tong[x[i]]] = i;
     for (j = 1, p =1; p &lt; n; j *= 2, m = p)
     {
         for (p = 0, i = n - j; i &lt; n; ++ i)   y[p ++] = i;
         for (i = 0; i &lt; n; ++ i) if (sa[i] &gt;= j)   y[p ++] = sa[i] - j;
         for (i = 0; i &lt; m; ++ i) tong[i] = 0;
         for (i = 0; i &lt; n; ++ i) wv[i] = x[y[i]];
         for (i = 0; i &lt; n; ++ i) tong[wv[i]] ++;
         for (i = 1; i &lt; m; ++ i) tong[i] += tong[i - 1];
         for (i = n - 1; i &gt;= 0; -- i)   sa[--tong[wv[i]]] = y [i];
         for (t =x, x = y, y = t, p = 1, x[sa[0]] = 0, i = 1; i &lt; n; ++ i)
             x[sa[i]] = cmp(y, sa[i - 1], sa[i], j)?p-1:p++;
     }
}
  
inline void geth(char *r, int *sa, int n)
{
     int i, j, k = 0;
     for (i = 1; i &lt;= n; ++ i)      rank[sa[i]] = i;
     for (i = 0; i &lt; n; h[rank[i ++]] = k)
         for (k?k--:0, j = sa[rank[i] - 1]; r[i + k]==r[j + k]; ++ k);
}
 
char ch;
inline void read(char &amp;x)
{
       while (ch=getchar(),ch&gt;'Z' || ch&lt;'A') ;
       x=ch;
}
 
int main()
{
    scanf("%d", &amp;n);
    for (int i = 0; i &lt; n; ++ i)      read(str[i]);
    for (int i = 0; i &lt; n; ++ i)      str[i] -= ('A' - 1);
    str[n] = 0;
    int tot = n * 2 + 1;
    str[tot] = 0;
    for (int i = 1; i &lt;= n; ++ i)  str[n + i] = str[n - i];
    da(str, sa, tot + 1, 28);    
    geth(str, sa, tot);
    int A = 0, B = n + 1;
    while (A + B - n - 1 &lt; n)
    {
          if (rank[A] &lt; rank[B])       putchar(str[A++] + 'A' - 1);
          else putchar( str[B++] + 'A' - 1);        
          if (!((A + B - n - 1)%80))  putchar('\n');
    }
    return 0;
}
</pre><pre></pre><h2>Problem1641</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
//by zrt
//problem:
using namespace std;
int n,m,t;
int a[305][305]; 
int main(){
  #ifdef LOCAL
  freopen("in.txt","r",stdin);
  freopen("out.txt","w",stdout);
  #endif
  scanf("%d%d%d",&amp;n,&amp;m,&amp;t);
  memset(a,0x3f,sizeof a);
  for(int i=0,x,y,z;i&lt;m;i++){
    scanf("%d%d%d",&amp;x,&amp;y,&amp;z);
    a[x][y]=min(a[x][y],z);
  }
  for(int k=1;k&lt;=n;k++){
    for(int i=1;i&lt;=n;i++){
      for(int j=1;j&lt;=n;j++){
        a[i][j]=min(a[i][j],max(a[i][k],a[k][j]));
      }
    }
  }
  for(int i=0,x,y;i&lt;t;i++){
    scanf("%d%d",&amp;x,&amp;y);
    printf("%d\n",a[x][y]==0x3f3f3f3f?-1:a[x][y]);
  }
  return 0;
}</pre><pre></pre><h2>Problem1642</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
using namespace std;

int n,m,r;
struct FNode{
	int start;
	int end;
	long long value;
};
FNode sec[1010];

inline bool cmp(FNode a,FNode b){
	if (a.start&lt;b.start)return true;
	if (a.end&lt;b.end &amp;&amp; a.start==b.start) return true;
	return false;
}

long long f[1010];

inline long long  remax(long long a,long long b){
	if (a&gt;b) return a;
	return b; 
}

int main(){
	scanf("%d%d%d",&amp;n,&amp;m,&amp;r);
	for (int i=1;i&lt;=m;i++) scanf("%d%d%lld",&amp;sec[i].start,&amp;sec[i].end,&amp;sec[i].value);
	sort(sec+1,sec+m+1,cmp);
	
	memset(f,0,sizeof(f));
	
	for (int i=1;i&lt;=m;i++){
		f[i]=sec[i].value;
		for (int j=1;j&lt;i;j++){
			if (sec[j].end+r&lt;=sec[i].start){
				f[i]=remax(f[i],f[j]+sec[i].value);
			}
		}
	}
	
	long long Ans=0;
	for (int i=1;i&lt;=m;i++){
		Ans=remax(Ans,f[i]);
	}
	
	printf("%lld\n",Ans);
	return 0;
} </pre><pre></pre><h2>Problem1643</h2><pre>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;
#include &lt;cstdlib&gt;
#include &lt;cmath&gt;
#include &lt;map&gt;
#include &lt;sstream&gt;
#include &lt;queue&gt;
#include &lt;stack&gt;
#include &lt;vector&gt;
#define MAXN 111111
#define MAXM 211111
#define PI acos(-1.0)
#define eps 1e-8
#define INF 100000001
using namespace std;
int dp[11111][5];
int main()
{
    int n;
    scanf("%d", &amp;n);
    for(int i = 1; i &lt;= 4; i++) dp[0][i] = 1;
    for(int i = 1; i &lt;= n; i++)
    {
        int m = (int)sqrt(i + 0.5);
        if(m * m == i ) dp[i][1] = 1;
        for(int k = 2; k &lt;= 4; k++)
        {
            for(int j = 0; j &lt;= m; j++)
                dp[i][k] += dp[i - j * j][k - 1];
        }
    }
    printf("%d\n", dp[n][4]);
    return 0;
}</pre><pre></pre><h2>Problem1644</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
const int mx[4]={1,0,-1,0};
const int my[4]={0,1,0,-1};
int n,sx,sy,ex,ey,ans=100000,t,w;
int dist[4][110][110];
int q[100001];
int dire[100001];
bool map[110][110];
char ch[110];
inline int min(int a,int b){return a&lt;b?a:b;}
inline void bfs()
{
    for (int i=0;i&lt;4;i++)
    {
        q[++w]=(sx-1)*n+sy;
        dire[w]=i;
        dist[i][sx][sy]=1;
    }
    while (t&lt;w)
    {
        int nx;if(q[++t]%n)nx=q[t]/n+1;else nx=q[t]/n;
        int ny=q[t]%n;if (!ny)ny=n;
        int d=dire[t];
        int step=dist[d][nx][ny];
        for (int k=0;k&lt;4;k++)
          if (step+1&lt;dist[k][nx][ny])
          {
            dist[k][nx][ny]=step+1;
            q[++w]=(nx-1)*n+ny;
            dire[w]=k;
          }
        int wx=nx+mx[d];
        int wy=ny+my[d];
        if (wx&lt;1||wy&lt;1||wx&gt;n||wy&gt;n||!map[wx][wy])continue;
        if (step&lt;dist[d][wx][wy])
        {
            dist[d][wx][wy]=step;
            q[++w]=(wx-1)*n+wy;
            dire[w]=d;
        }
    }
}
int main()
{
    scanf("%d",&amp;n);
    for(int i=1;i&lt;=n;i++)
    {
        scanf("%s",ch);
        for (int j=0;ch[j];j++)
        {
            if (ch[j]=='A')
            {
                sx=i;
                sy=j+1;
                map[i][j+1]=1;
            }else
            if (ch[j]=='B')
            {
                ex=i;
                ey=j+1;
                map[i][j+1]=1;
            }else
            if (ch[j]=='.')map[i][j+1]=1;
        }   
    }
    memset(dist,127/3,sizeof(dist));
    bfs();
    for(int i=0;i&lt;4;i++)
      if (dist[i][ex][ey])ans=min(ans,dist[i][ex][ey]);
    printf("%d",ans-1);
}</pre><pre></pre><h2>Problem1646</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;cstring&gt;
using namespace std;
int n,m,head,tail=1;
int dist[500001];
int q[500001];
inline bool mark(int x)
{
	return !(x&lt;0||x&gt;max(2*m+1,n+1));
}
int main()
{
	scanf("%d%d",&amp;n,&amp;m);
	memset(dist,-1,sizeof(dist));
	q[1]=n;dist[n]=0;
	while (head&lt;tail)
	{
		head++;
		int now=q[head]-1;
		if(mark(now)&amp;&amp;dist[now]==-1)
		{
			q[++tail]=now;
			dist[now]=dist[q[head]]+1;
		}
		now=q[head]+1;
		if(mark(now)&amp;&amp;dist[now]==-1)
		{
			q[++tail]=now;
			dist[now]=dist[q[head]]+1;
		}
		now=q[head]*2;
		if(mark(now)&amp;&amp;dist[now]==-1)
		{
			q[++tail]=now;
			dist[now]=dist[q[head]]+1;
		}
		if(dist[m]!=-1) {printf("%d",dist[m]);return 0;}
	}
}</pre><pre></pre><h2>Problem1657</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#define N 50001
inline int max(int a,int b)
{return a&gt;b?a:b;}
inline int read()
{
    int x=0,f=1;char ch=getchar();
    while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
int n,now,mx,top;
int h[N],v[N],zhan[N],ans[N];
int main()
{
	n=read();
	for (int i=1;i&lt;=n;i++)
	  {
	  	h[i]=read();
	  	v[i]=read();
	  }
	while (now&lt;=n)
	{
		now++;
		while (top&amp;&amp;h[now]&gt;h[zhan[top]])ans[now]+=v[zhan[top--]];
		mx=max(mx,ans[now]);
		zhan[++top]=now;
	}
	top=now=0;now=n+1;
	memset(zhan,0,sizeof(zhan));
	while (now&gt;=1)
	{
		now--;
		while (top&amp;&amp;h[now]&gt;h[zhan[top]])ans[now]+=v[zhan[top--]];
		mx=max(mx,ans[now]);
		zhan[++top]=now;
	}
	printf("%d",mx);
}</pre><pre></pre><h2>Problem1660</h2><pre>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
using namespace std;
int n,top,a[80001],s[80001];
long long ans;
int main()
{
	scanf("%d",&amp;n);
	for(int i=1;i&lt;=n;i++)
	   scanf("%d",&amp;a[i]);
    for(int i=1;i&lt;=n;i++)
    {
    	if(a[i]&lt;s[top])
    		ans+=top;
   		else
   		{
   			while(a[i]&gt;=s[top]&amp;&amp;top)
   		    	top--;
	    	ans+=top;
   		}
   		s[++top]=a[i];
    }
    printf("%lld",ans);
	return 0;
}</pre><pre></pre><h2>Problem1666</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef unsigned long long lld;
lld x;
lld ans=0;
void f(lld x){
	if(x==1)return;
	if(x&amp;1)x*=3,x++;
	else x&gt;&gt;=1;
	ans++;
	f(x);
}
int main(){
	cin&gt;&gt;x;
	f(x);
	cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem1669</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
int a[5010],d[5010];
int size,n;
int main(){
	cin&gt;&gt;n;
	for(int i=1;i&lt;=n;i++)cin&gt;&gt;a[i];
	for(int i=1;i&lt;=n;i++){
		int j=lower_bound(d,d+size,a[i])-d;
		d[j]=a[i];
		size=max(size,j+1);
	}cout&lt;&lt;size&lt;&lt;endl;
}</pre><pre></pre><h2>Problem1677</h2><pre>#include&lt;cstdio&gt;
#define mod 1000000000
inline int read()
{
    int x=0,f=1;char ch=getchar();
    while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
const int w[20]={1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,262144,524288};
int n;
int f[1000001];
int main()
{
	n=read();
	f[0]=1;
	for (int i=0;i&lt;20;i++)
	  for (int j=w[i];j&lt;=n;j++)
	    f[j]=(f[j]+f[j-w[i]])%mod;
	printf("%d",f[n]);
}
</pre><pre></pre><h2>Problem1679</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;map&gt;
#include&lt;set&gt;
#include&lt;queue&gt;
#define inf 1000000000
#define maxn 10000+100
#define maxm 100000+100
#define ll long long
using namespace std;
inline ll read()
{
    ll x=0,f=1;char ch=getchar();
    while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=10*x+ch-'0';ch=getchar();}
    return x*f;
}
ll a[maxn];
int main()
{
   
    ll n=read(),ans=0,sum;
    for(int i=1;i&lt;=n;i++)a[i]=read();
    sort(a+1,a+n+1);sum=a[1];
    for(int i=2;i&lt;=n;i++)
    {
      ans+=(a[i]*(i-1))-sum;sum+=a[i];    
    }
    printf("%lld\n",2*ans);
    return 0;
}</pre><pre></pre><h2>Problem1699</h2><pre>/*
	ID:iamzky
	OJ:POJ
	Index:3264
	Language:C++
*/
#include&lt;cmath&gt;
#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
int n,m;
int a[50010];
int Max[125537][17];
int Min[125537][17]; 
double log2(double x){
	return (double)log(x)/log(2.0);
}
void init(){
	scanf("%d%d",&amp;n,&amp;m);
	for(int i=1;i&lt;=n;i++)scanf("%d",&amp;a[i]);
	for(int i=1;i&lt;=n;i++)Max[i][0]=Min[i][0]=a[i];
	for(int j=1;j&lt;=ceil(log2(n));j++)
	for(int i=1;i&lt;=n;i++){
		Max[i][j]=max(Max[i][j-1],Max[i+(1&lt;&lt;(j-1))][j-1]);
		Min[i][j]=min(Min[i][j-1],Min[i+(1&lt;&lt;(j-1))][j-1]);		
	}
} 
int query(int l,int r){
	int k=(int)log2(r-l+1);
	int maxx=max(Max[l][k],Max[r-(1&lt;&lt;k)+1][k]);
	int minn=min(Min[l][k],Min[r-(1&lt;&lt;k)+1][k]); 
	return maxx-minn;
}
void zky(){
	while(m--){
		int l,r;
		scanf("%d%d",&amp;l,&amp;r);
		printf("%d\n",query(l,r)); 
	} 
}
int main(){
	init();
	zky(); 
	return 0;
}</pre><pre></pre><h2>Problem1715</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
int T;
struct edge{
	int u,v,w;
};
vector&lt;edge&gt;edges;
vector&lt;vector&lt;int&gt; &gt;G;
int d[501];
int n,m,w;
void add(int u,int v,int w){
	edges.push_back((edge){u,v,w});
	G[u].push_back(edges.size()-1);
}
int in[501];
bool spfa(){
	int vis[501];
	memset(vis,0,sizeof(vis));
	memset(d,0x7f,sizeof(d));
	d[1]=0;
	queue&lt;int&gt;q;q.push(1);
	while(!q.empty()){
		int u=q.front();q.pop();vis[u]=0;
		for(int i=0;i&lt;G[u].size();i++){
			edge e=edges[G[u][i]];
			if(d[e.v]&gt;d[u]+e.w){
				d[e.v]=d[u]+e.w;
				if(!vis[e.v]){
					vis[e.v]=1;
					q.push(e.v);
					in[e.v]++;
					if(in[e.v]&gt;n)return false;
				}
			}
		}
	}
	return true;
}
int main(){
	cin&gt;&gt;T;
	while(T--){
		edges.clear();G.clear();
		memset(in,0,sizeof(in));
		cin&gt;&gt;n&gt;&gt;m&gt;&gt;w;G.resize(n+10);
		for(int i=1;i&lt;=m;i++){
			int u,v,w;
			cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;
			add(u,v,w);add(v,u,w);
		}
		for(int i=1;i&lt;=w;i++){
			int u,v,c;
			cin&gt;&gt;u&gt;&gt;v&gt;&gt;c;
			c=-c;
			add(u,v,c);
		}
		if(spfa())
		cout&lt;&lt;"NO"&lt;&lt;endl;
		else
		cout&lt;&lt;"YES"&lt;&lt;endl;
	}
	return 0;
}</pre><pre></pre><h2>Problem1756</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=5e5+5;
int a[maxn];
struct node{
	int ls,ss,rs,sum;
	node():ls(-1e9),rs(-1e9),ss(-1e9),sum(0){};
};
node operator+(node a,node b){
	node ans;
	ans.ls=max(a.ls,a.sum+b.ls);
	ans.rs=max(b.rs,b.sum+a.rs);
	ans.ss=max(ans.ls,ans.rs);
	ans.ss=max(ans.ss,a.ss);
	ans.ss=max(ans.ss,b.ss);
	ans.ss=max(ans.ss,a.rs+b.ls);
	ans.sum=a.sum+b.sum;
	return ans;
}
node t[maxn&lt;&lt;2];
struct seg{
	#define lson i&lt;&lt;1,l,mid
	#define rson i&lt;&lt;1|1,mid+1,r
	#define L i&lt;&lt;1
	#define R i&lt;&lt;1|1
	void build(int i,int l,int r){
		if(l==r){
			t[i].ls=t[i].rs=t[i].ss=t[i].sum=a[l]; 
			return;
		}int mid=(l+r)&gt;&gt;1;
		build(lson);build(rson);
		t[i]=t[L]+t[R];
	}
	void Change(int i,int l,int r,int ps,int x){
		if(l==r){
			t[i].ls=t[i].rs=t[i].ss=t[i].sum=x; 
			return;
		}int mid=(l+r)&gt;&gt;1;
		if(ps&lt;=mid)Change(lson,ps,x);
		else Change(rson,ps,x);
		t[i]=t[L]+t[R];
	}
	node Qss(int i,int l,int r,int l0,int r0){
		if(l0&lt;=l&amp;&amp;r0&gt;=r)
			return t[i];
		int mid=(l+r)&gt;&gt;1;node ans;
		if(l0&lt;=mid)ans=Qss(lson,l0,r0)+ans;
		if(r0&gt;mid)ans=ans+Qss(rson,l0,r0);
		return ans;
	}
}T;
int n,m;
int main(){
	scanf("%d%d",&amp;n,&amp;m);
	for(int i=1;i&lt;=n;i++)scanf("%d",&amp;a[i]);
	T.build(1,1,n);
	while(m--){
		int op,x,y;scanf("%d%d%d",&amp;op,&amp;x,&amp;y);
		if(op==1){
		if(x&gt;y)swap(x,y);
			printf("%d\n",T.Qss(1,1,n,x,y).ss);
		}else{
			T.Change(1,1,n,x,y);
		}
	}	
}</pre><pre></pre><h2>Problem1758</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const double eps=1e-5;
const int maxn=1e5+5;
int dcmp(double x){return (x&gt;eps)-(x&lt;-eps);}
int n,L,U;
double lim;
int getint(){
	int res=0;char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))res=res*10+c-'0',c=getchar();
	return res;
}
double ans;
struct edge{int u,v,w;};
vector&lt;edge&gt;G[maxn];
int root,All;
short cant[maxn];
int siz[maxn],f[maxn],fa[maxn];
void makert(int u,int &amp;root){
	siz[u]=1;f[u]=0;
	for(int i=0;i&lt;G[u].size();i++){
		edge e=G[u][i];if(cant[e.v]||e.v==fa[u])continue;
		fa[e.v]=u;
		makert(e.v,root);
		siz[u]+=siz[e.v];
		f[u]=max(f[u],siz[e.v]);
	}f[u]=max(f[u],All-f[u]);
	if(f[root]&gt;f[u])root=u;
}
double mx[maxn],d[maxn];
int data[maxn],dep[maxn];
bool ok(int u,double mid){
	int size=0;
	for(int i=0;i&lt;G[u].size();i++){
		edge e=G[u][i];if(cant[e.v])continue;data[0]=0;fa[e.v]=u;
		queue&lt;int&gt;q;q.push(e.v);d[e.v]=e.w-mid;dep[e.v]=1;
		while(!q.empty()){
			int u=q.front();q.pop();data[++data[0]]=u;
			for(int i=0;i&lt;G[u].size();i++){
				edge e=G[u][i];if(cant[e.v]||fa[u]==e.v)continue;
				fa[e.v]=u;dep[e.v]=dep[u]+1;q.push(e.v);
				d[e.v]=d[u]+e.w-mid;
			}
		}deque&lt;int&gt;dq;int now=size;
		for(int j=1;j&lt;=data[0];j++){
			int u=data[j];
			while(now&gt;=0&amp;&amp;dep[u]+now&gt;=L){
				while(dq.size()&amp;&amp;mx[dq.back()]&lt;mx[now])dq.pop_back();
				dq.push_back(now--);
			}while(dq.size()&amp;&amp;dq.front()+dep[u]&gt;U)dq.pop_front();
			if(dq.size()&amp;&amp;d[u]+mx[dq.front()]&gt;=0)return 1;
		}for(int j=size+1;j&lt;=dep[data[data[0]]];j++)mx[j]=-1e10;
		for(int j=1;j&lt;=data[0];j++){
			int u=data[j];
			mx[dep[u]]=max(mx[dep[u]],d[u]);
		}size=max(size,dep[data[data[0]]]);	
	}return 0;
}
void calc(int u){
	double l=ans,r=lim;
	while(dcmp(l-r)){
		double mid=(l+r)*.5;
		if(ok(u,mid))l=mid;
		else r=mid;
	}ans=l;
}
void solve(int u){
	calc(u);cant[u]=1;
	for(int i=0;i&lt;G[u].size();i++){
		edge e=G[u][i];if(cant[e.v]||siz[e.v]&lt;L)continue;
		f[root=0]=n+1;All=siz[e.v];
		makert(e.v,root);
		solve(root);
	}
}
int main(){
	n=getint();L=getint();U=getint();All=n;
	for(int i=1;i&lt;n;i++){
		int u=getint(),v=getint(),w=getint();
		lim=max(lim,double(w));
		G[u].push_back((edge){u,v,w});
		G[v].push_back((edge){v,u,w});
	}f[root=0]=n+1;
	makert(1,root);
	solve(root);
	cout&lt;&lt;fixed&lt;&lt;setprecision(3)&lt;&lt;ans&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem1759</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1000001;
int n,m;
int in(){
	int r=0;char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))r=r*10+c-'0',c=getchar();
	return r;
}
int fa[maxn],top[maxn],dep[maxn],mp[maxn],z;
vector&lt;vector&lt;int&gt; &gt;G;
vector&lt;int&gt;son,siz;
long long anss[8];
void dfs(int u){
	siz[u]=1;
	for(int i=0;i&lt;G[u].size();i++){
		int v=G[u][i];
		if(v==fa[u])continue;
		fa[v]=u;dep[v]=dep[u]+1;
		dfs(v);
		siz[u]+=siz[v];
		if(siz[son[u]]&lt;siz[v])son[u]=v;
	}
}
void build(int u,int tp){
	mp[u]=++z;top[u]=tp;
	if(son[u])build(son[u],tp);
	for(int i=0;i&lt;G[u].size();i++){
		int v=G[u][i];
		if(v!=fa[u]&amp;&amp;v!=son[u])build(v,v);
	}
}
struct node{
	char all,laz;
	int l,r;
	void rz();
	void pd();
}t[maxn*2];
void node::rz(){
	all=t[l].all==t[r].all?t[l].all:-1;
}
void node::pd(){
	if(!laz)return;
	t[l].all=t[l].laz=laz;
	t[r].all=t[r].laz=laz;
	laz=0;
}
int tot=0;
int buildT(int l,int r){
	int x=++tot;
	if(l==r)return x;
	t[x].l=buildT(l,(l+r)/2);
	t[x].r=buildT((l+r)/2+1,r);	
	return x;
}
void Q(int i,int l,int r,int l0,int r0,int c){
	if(l0&gt;r0)return;
	if(l==r){
		if(t[i].all==c)return void(t[i].laz=c);
		anss[c]+=r-l+1;
		t[i].all=t[i].laz=c;
		return;		
	}
	if(l0&lt;=l&amp;&amp;r0&gt;=r&amp;&amp;t[i].all!=-1){
		if(t[i].all==c)return void(t[i].laz=c);
		anss[c]+=r-l+1;
		t[i].all=t[i].laz=c;
		return;
	}t[i].pd();
	if(l0&lt;=(l+r)/2)Q(t[i].l,l,(l+r)/2,l0,r0,c);
	if(r0&gt;(l+r)/2)Q(t[i].r,(l+r)/2+1,r,l0,r0,c);
	t[i].rz();
}
void Q(int u,int v,int c){
	while(top[u]!=top[v]){
		if(dep[top[u]]&lt;dep[top[v]])swap(u,v);
		Q(1,1,n,mp[top[u]],mp[u],c);
		u=fa[top[u]];
	}if(mp[u]&gt;mp[v])swap(v,u);
	Q(1,1,n,mp[u]+1,mp[v],c);
}
int main(){
//	freopen("bzoj1759.in","r",stdin);
	n=in();
	G.resize(n+1);
	son.resize(n+1);
	siz.resize(n+1);
	for(int i=1;i&lt;n;i++){
		int u=in(),v=in();
		G[u].push_back(v);
		G[v].push_back(u);
	}
	int root=(n+1)/2;
	dfs(root);
	siz.clear();
	build(root,root);
	son.clear();
	G.clear();
	
	buildT(1,n);
	
	int m=in();
	while(m--){
		int u=in(),v=in(),c=in();	
		Q(u,v,c);
	}
	for(int i=1;i&lt;=7;i++)
		printf("%lld\n",anss[i]);
	return 0;
}</pre><pre></pre><h2>Problem1759</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1000001;
int n,m;
int in(){
	int r=0;char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))r=r*10+c-'0',c=getchar();
	return r;
}
int fa[maxn],top[maxn],dep[maxn],mp[maxn],z;
vector&lt;vector&lt;int&gt; &gt;G;
vector&lt;int&gt;son,siz;
long long anss[8];
void dfs(int u){
	siz[u]=1;
	for(int i=0;i&lt;G[u].size();i++){
		int v=G[u][i];
		if(v==fa[u])continue;
		fa[v]=u;dep[v]=dep[u]+1;
		dfs(v);
		siz[u]+=siz[v];
		if(siz[son[u]]&lt;siz[v])son[u]=v;
	}
}
void build(int u,int tp){
	mp[u]=++z;top[u]=tp;
	if(son[u])build(son[u],tp);
	for(int i=0;i&lt;G[u].size();i++){
		int v=G[u][i];
		if(v!=fa[u]&amp;&amp;v!=son[u])build(v,v);
	}
}
struct node{
	int all,laz;
	int l,r;
	void rz();
	void pd();
}t[maxn*2];
void node::rz(){
	all=t[l].all==t[r].all?t[l].all:-1;
}
void node::pd(){
	if(!laz)return;
	t[l].all=t[l].laz=laz;
	t[r].all=t[r].laz=laz;
	laz=0;
}
int tot=0;
int buildT(int l,int r){
	int x=++tot;
	if(l==r)return x;
	t[x].l=buildT(l,(l+r)/2);
	t[x].r=buildT((l+r)/2+1,r);	
	return x;
}
void Q(int i,int l,int r,int l0,int r0,int c){
	if(l0&gt;r0)return;
	if(l==r){
		if(t[i].all==c)return void(t[i].laz=c);
		anss[c]+=r-l+1;
		t[i].all=t[i].laz=c;
		return;		
	}
	if(l0&lt;=l&amp;&amp;r0&gt;=r&amp;&amp;t[i].all!=-1){
		if(t[i].all==c)return void(t[i].laz=c);
		anss[c]+=r-l+1;
		t[i].all=t[i].laz=c;
		return;
	}t[i].pd();
	if(l0&lt;=(l+r)/2)Q(t[i].l,l,(l+r)/2,l0,r0,c);
	if(r0&gt;(l+r)/2)Q(t[i].r,(l+r)/2+1,r,l0,r0,c);
	t[i].rz();
}
void Q(int u,int v,int c){
	while(top[u]!=top[v]){
		if(dep[top[u]]&lt;dep[top[v]])swap(u,v);
		Q(1,1,n,mp[top[u]],mp[u],c);
		u=fa[top[u]];
	}if(mp[u]&gt;mp[v])swap(v,u);
	Q(1,1,n,mp[u]+1,mp[v],c);
}
int main(){
//	freopen("bzoj1759.in","r",stdin);
	n=in();
	G.resize(n+1);
	son.resize(n+1);
	siz.resize(n+1);
	for(int i=1;i&lt;n;i++){
		int u=in(),v=in();
		G[u].push_back(v);
		G[v].push_back(u);
	}
	int root=(n+1)/2;
	dfs(root);
	siz.clear();
	build(root,root);
	son.clear();
	G.clear();
	
	buildT(1,n);
	
	int m=in();
	while(m--){
		int u=in(),v=in(),c=in();	
		Q(u,v,c);
	}
	for(int i=1;i&lt;=7;i++)
		printf("%lld\n",anss[i]);
	return 0;
}</pre><pre></pre><h2>Problem1787</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;climits&gt;
#include&lt;cctype&gt;
using namespace std;
const int maxn=500010;
typedef pair&lt;int,int&gt; pii;
vector&lt;int&gt;G[maxn];
void add(int u,int v){
	G[u].push_back(v);
	G[v].push_back(u);
}
int w[maxn],fa[maxn],son[maxn],siz[maxn],dep[maxn],top[maxn],z;
void dfs(int u){
	son[u]=0;siz[u]=1;
	for(int i=0;i&lt;G[u].size();i++){
		int v=G[u][i];
		if(v!=fa[u]){
			fa[v]=u;
			dep[v]=dep[u]+1;
			dfs(v);
			if(siz[son[u]]&lt;siz[v])son[u]=v;
			siz[u]+=siz[v];
		}
	}
}
void build(int u,int tp){
	w[u]=++z;top[u]=tp;
	if(son[u])build(son[u],tp);
	for(int i=0;i&lt;G[u].size();i++){
		int v=G[u][i];
		if(v!=fa[u]&amp;&amp;v!=son[u])
			build(v,v);
	}
}
int len(int u,int v){
	return abs(dep[u]-dep[v]);
}
int lca(int u,int v){
	while(top[u]!=top[v]){
		if(dep[top[u]]&gt;dep[top[v]])
			u=fa[top[u]];
		else
			v=fa[top[v]];
	}
	return dep[u]&lt;dep[v]?u:v;
}
int n,m;
int getint(){
	int res=0,ok=0;char ch;
	while(1){
		ch=getchar();
		if(isdigit(ch)){
			res*=10;res+=ch-'0';ok=1;
		}else if(ok)break;
	}return res;
}
int main(){
	n=getint();m=getint();
	for(int i=1;i&lt;n;i++){
		int u=getint(),v=getint();add(u,v);
	}
	dfs(1);build(1,1);
	while(m--){
		int a=getint(),b=getint(),c=getint();
		int ans=INT_MAX,pos,k;
		int f1=lca(a,b);
		int f2=lca(a,c);
		int f3=lca(c,b);
  		int d=lca(a,b);
        int e=lca(d,c);
        if(dep[a]+dep[b]+dep[c]-dep[e]*2-dep[d]&lt;ans)ans=dep[a]+dep[b]+dep[c]-dep[e]*2-dep[d],pos=d;
        d=lca(a,c);
        if(dep[a]+dep[b]+dep[c]-dep[e]*2-dep[d]&lt;ans)ans=dep[a]+dep[b]+dep[c]-dep[e]*2-dep[d],pos=d;
        d=lca(b,c);
        if(dep[a]+dep[b]+dep[c]-dep[e]*2-dep[d]&lt;ans)ans=dep[a]+dep[b]+dep[c]-dep[e]*2-dep[d],pos=d;
		printf("%d %d\n",pos,ans);
	}
	return 0;
}</pre><pre></pre><h2>Problem1789</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
deque&lt;char&gt;A[3];
int len[3];
int main(){
	char c;
	for(int i=0;i&lt;3;i++){
		cin&gt;&gt;len[i];if(!len[i])continue;c=getchar();
		while(!isalpha(c))c=getchar();
		while(isalpha(c))A[i].push_back(c),c=getchar();
	}while(A[0].size()&amp;&amp;A[1].size()&amp;&amp;A[2].size()
	&amp;&amp;A[0].front()==A[1].front()&amp;&amp;A[1].front()==A[2].front())
	A[0].pop_front(),A[1].pop_front(),A[2].pop_front();
	int tot=A[0].size()+A[1].size()+A[2].size();
	int ans=tot;
	for(int i=0;i&lt;3;i++)
	for(int j=i+1;j&lt;3;j++){
		int k=0;
		for(;k&lt;min(A[i].size(),A[j].size())&amp;&amp;A[i][k]==A[j][k];k++);
		int res=tot-A[i].size()-A[j].size();
		res+=k;
		res+=A[i].size()-k+A[j].size()-k;
		ans=min(ans,res);
	}cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
} </pre><pre></pre><h2>Problem1797</h2><pre>//ID:zky
#include&lt;vector&gt;
#include&lt;queue&gt;
#include&lt;stack&gt;
#include&lt;cstdio&gt;
#include&lt;cctype&gt;
#include&lt;climits&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=4010;
struct edge{int u,v,cap,flow;};vector&lt;edge&gt;edges;vector&lt;int&gt;G[maxn];stack&lt;int&gt;S;
void add(int u,int v,int cap);int getint();void Dinic();void deb();void Tarjan(int u);
int n,m,s,t,vis[maxn],cur[maxn],d[maxn],dfn[maxn],low[maxn],Scc_cnt,Bel[maxn],ins[maxn],tot;
int main(){
	n=getint();m=getint();s=getint();t=getint();
	for(int i=1;i&lt;=m;i++){int u=getint(),v=getint(),w=getint();add(u,v,w);}
	Dinic();//deb();
	for(int i=1;i&lt;=n;i++){if(!dfn[i])Tarjan(i);}
	for(int i=0;i&lt;edges.size();i+=2){
		int u=edges[i].u,v=edges[i].v;
		if(Bel[u]!=Bel[v]&amp;&amp;edges[i].cap-edges[i].flow==0){
			if(Bel[u]==Bel[s]&amp;&amp;Bel[v]==Bel[t])puts("1 1");
			else if(Bel[u]==Bel[t]&amp;&amp;Bel[v]==Bel[s])puts("1 1");
			else puts("1 0");
		}else puts("0 0");
	}
	return 0;
} 
void deb(){
	for(int i=0;i&lt;edges.size();i++)if(i%2==0)
	printf("#%d %d -&gt; %d cap:%d flow:%d\n",i,edges[i].u,edges[i].v,edges[i].cap,edges[i].flow);
}
bool bfs(){
	memset(vis,0,sizeof(vis));
	memset(d,0,sizeof(d));
	queue&lt;int&gt;q;q.push(s);
	vis[s]=1;d[s]=0;
	while(!q.empty()){
		int u=q.front();q.pop();
		for(int i=0;i&lt;G[u].size();i++){
			edge e=edges[G[u][i]];
			if(!vis[e.v]&amp;&amp;e.cap&gt;e.flow){
				vis[e.v]=1;
				d[e.v]=d[u]+1;
				q.push(e.v);
			}
		}
	}return vis[t];
}
int dfs(int u,int a){
	if(u==t||a==0)return a;
	int flow=0,f;
	for(int&amp; i=cur[u];i&lt;G[u].size();i++){
		edge e=edges[G[u][i]];
		if(d[e.v]==1+d[u]&amp;&amp;(f=dfs(e.v,min(a,e.cap-e.flow)))&gt;0){
			edges[G[u][i]].flow+=f;
			edges[G[u][i]^1].flow-=f;
			flow+=f;
			a-=f;
			if(!a)break;
		}
	}return flow;
}
void Dinic(){
	int flow=0;
	while(bfs()){
		memset(cur,0,sizeof(cur));int x;
		while(x=dfs(s,INT_MAX)){flow+=x;memset(cur,0,sizeof(cur));}
	}
}
void Tarjan(int u){
	ins[u]=1;dfn[u]=low[u]=++tot;
	S.push(u);
	for(int i=0;i&lt;G[u].size();i++){
		edge e=edges[G[u][i]];
		if(e.cap&lt;=e.flow)continue;
		if(!dfn[e.v]){
			Tarjan(e.v);
			low[u]=min(low[u],low[e.v]);
		}else	if(ins[e.v])low[u]=min(low[u],dfn[e.v]);
	}
	if(dfn[u]==low[u]){
		Scc_cnt++;int v;
		do{
			v=S.top();S.pop();
			Bel[v]=Scc_cnt;ins[v]=0;
		}while(u!=v);
	}
}
int getint(){
	int res=0,ok=0;char ch;
	while(ch=getchar()){
		if(isdigit(ch)){
			res*=10;res+=ch-'0';ok=1;
		}else if(ok)break;
	}return res;
}
void add(int u,int v,int cap){
	edges.push_back((edge){u,v,cap,0});
	G[u].push_back(edges.size()-1);
	edges.push_back((edge){v,u,0,0});
	G[v].push_back(edges.size()-1);
}</pre><pre></pre><h2>Problem1798</h2><pre>#include&lt;cstdio&gt;
#include&lt;queue&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#define lson i&lt;&lt;1,l,mid
#define rson i&lt;&lt;1|1,mid+1,r
#define L (i&lt;&lt;1)
#define R (i&lt;&lt;1|1)
#define X first
#define Y second
using namespace std;
typedef  long long lld;
lld n,p;
lld a[100200];
struct node{
	lld d;
	lld mul,add;
	node(){
		d=0;
		mul=1;
		add=0;
	}
};
node t[100200&lt;&lt;2];
struct seg_tree{

	void build(lld i,lld l,lld r){
		if(l&gt;r)return;
		if(l==r){
			t[i].d=a[l];
			return ;
		}
		lld mid=l+r&gt;&gt;1;
		build(lson);build(rson);
		t[i].d=(t[L].d%p+t[R].d%p)%p;
	}

	void pushdown(lld i,lld l,lld r){	
		if(t[i].mul==1&amp;&amp;t[i].add==0)return;	
		lld mid=l+r&gt;&gt;1;	
		t[L].d=(t[L].d%p*t[i].mul%p)%p;
		t[L].mul=(t[L].mul%p*t[i].mul%p)%p;
		t[R].d=(t[R].d%p*t[i].mul%p)%p;
		t[R].mul=(t[R].mul%p*t[i].mul%p)%p;
		
		t[L].d=(t[L].d%p+t[i].add*(mid-l+1)%p)%p;
		t[L].add=(t[L].add%p*t[i].mul%p)%p;
		t[L].add=(t[L].add%p+t[i].add%p)%p;
		t[R].d=(t[R].d%p+t[i].add%p*(r-mid)%p)%p;
		t[R].add=(t[R].add%p*t[i].mul%p)%p;
		t[R].add=(t[R].add%p+t[i].add%p)%p;
		
		t[i].mul=1;	
		t[i].add=0;
		t[L].d%=p;
		t[R].d%=p;	
	}
	void change_mul(lld i,lld l,lld r,lld l0,lld r0,lld x){
		if(l&gt;r)return;
		if(l0&lt;=l&amp;&amp;r0&gt;=r){
			t[i].d=(t[i].d%p*x%p)%p;
			t[i].mul=(t[i].mul%p*x%p)%p;
			t[i].add=(t[i].add%p*x%p)%p;
			t[i].mul%=p;
			t[i].add%=p;
			return;
		}
		pushdown(i,l,r);
		lld mid=l+r&gt;&gt;1;
		if(l0&lt;=mid)change_mul(lson,l0,r0,x);
		if(r0&gt;mid) change_mul(rson,l0,r0,x);
		t[i].d=(t[L].d%p+t[R].d%p)%p;
	}
	void change_add(lld i,lld l,lld r,lld l0,lld r0,lld x){
		if(l&gt;r)return;
		if(l0&lt;=l&amp;&amp;r0&gt;=r){
			t[i].d=(t[i].d%p+x*(r-l+1)%p)%p;
			t[i].add=(t[i].add+x)%p;
			t[i].add%=p;
			return;
		}
		pushdown(i,l,r);
		lld mid=l+r&gt;&gt;1;
		if(l0&lt;=mid)change_add(lson,l0,r0,x);
		if(r0&gt;mid) change_add(rson,l0,r0,x);
		t[i].d=(t[L].d%p+t[R].d%p)%p;
	}
	lld qsum(lld i,lld l,lld r,lld l0,lld r0){
		if(l&gt;r)return 0;
		if(l0&lt;=l&amp;&amp;r0&gt;=r){
			return t[i].d%p;
		}
		pushdown(i,l,r);
		lld mid=l+r&gt;&gt;1;
		lld ans=0;
		if(l0&lt;=mid)ans+=qsum(lson,l0,r0)%p;
		if(r0&gt;mid) ans+=qsum(rson,l0,r0)%p;
		return ans%p;
	}
}T;
lld getlld(){
	lld x;
	scanf("%lld",&amp;x);
	return x;
}
void deb(){
		for(lld i=1;i&lt;=(n&lt;&lt;1);i++){
			printf("#%u64d d:%u64d  add:%u64d  mul:%d\n",
			i,t[i].d,t[i].add,t[i].mul);
		}	
}
int main(){
//	freopen("seg.in","r",stdin);
//	freopen("3.txt","w",stdout);
	lld l,r,x;
	n=getlld();p=getlld();
	for(lld i=1;i&lt;=n;i++)a[i]=getlld();
	lld m=getlld();
	T.build(1,1,n);
	while(m--){
		
	//	deb();
		
		lld opt=getlld();
		if(opt==1){
			l=getlld();r=getlld();x=getlld()%p;
			T.change_mul(1,1,n,l,r,x);
		}else
		if(opt==2){
			l=getlld();r=getlld();x=getlld()%p;
			T.change_add(1,1,n,l,r,x);
		}else{
			l=getlld();r=getlld();
			printf("%lld\n",T.qsum(1,1,n,l,r)%p);
		}
	//		if(t[1].d&gt;=p)T.pushall(1,1,n);
	}
	return 0;
}</pre><pre></pre><h2>Problem1800</h2><pre>#include&lt;cmath&gt;
#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
int n;
int chs=0;
int ans=0;
int way[21];
double len[21];
double sum[21];
double T;
const double eps=1e-6;

int main(){
	cin&gt;&gt;n;
	for(int i=1;i&lt;=n;i++){
		cin&gt;&gt;len[i];
		sum[i]=sum[i-1]+len[i];
	}
	for(int i=1;i&lt;=n;i++)
	for(int j=i+1;j&lt;=n;j++)
	if((sum[j]-sum[i])*2==sum[n])ans++;
	
	cout&lt;&lt;ans*(ans-1)/2&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem1800</h2><pre>#include&lt;cmath&gt;
#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
short ans=0,n;
float len[21];
int main(){
	cin&gt;&gt;n;
	for(int i=1;i&lt;=n;i++){
		cin&gt;&gt;len[i];
		len[i]+=len[i-1];
	}
	for(int i=1;i&lt;=n;i++)
	for(int j=i+1;j&lt;=n;j++)
	if((len[j]-len[i])*2==len[n])ans++;
	
	cout&lt;&lt;ans*(ans-1)/2&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem1800</h2><pre>#include&lt;cstdio&gt;
short ans=0,n;
float len[21];
int main(){
	scanf("%hd",&amp;n);
	for(int i=1;i&lt;=n;i++){
		scanf("%f",&amp;len[i]);
		len[i]+=len[i-1];
	}
	for(int i=1;i&lt;=n;i++)
	for(int j=i+1;j&lt;=n;j++)
	if((len[j]-len[i])*2==len[n])ans++;
	
	printf("%hd",ans*(ans-1)/2);
	return 0;
}</pre><pre></pre><h2>Problem1806</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
int f[2][4][4][4][4];
int M[256];
int n;
char s[1000001];
int main(){
	cin&gt;&gt;n&gt;&gt;s;
	M['M']=1;M['F']=2;M['B']=3;
	memset(f[0],-1,sizeof(f[0]));
	f[0][0][0][0][0]=0;
for (int i = 0; i &lt; n; ++i) {
        int c = M[s[i]], p = i &amp; 1, q = p ^ 1;
        memset(f[q], -1, sizeof f[q]);
        for(int j=0;j&lt;4;++j)
        for(int k=0;k&lt;4;++k)
        for(int l=0;l&lt;4;++l)
        for(int m=0;m&lt;4;++m)
        if (~f[p][j][k][l][m]) {
        f[q][k][c][l][m]=max(f[q][k][c][l][m], f[p][j][k][l][m] + (j == 1 || k == 1 || c == 1) + (j == 2 || k == 2 || c == 2) + (j == 3 || k == 3 || c == 3));
        f[q][j][k][m][c]=max(f[q][j][k][m][c], f[p][j][k][l][m] + (l == 1 || m == 1 || c == 1) + (l == 2 || m == 2 || c == 2) + (l == 3 || m == 3 || c == 3));
        }
    }
	int ans=0;
	for(int j=0;j&lt;4;j++)
	for(int k=0;k&lt;4;k++)
	for(int l=0;l&lt;4;l++)
	for(int m=0;m&lt;4;m++)
	ans=max(ans,f[n&amp;1][j][k][l][m]);
	cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem1816</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
LL n,m;
LL a[55];
bool ok(LL x){
	int t=min(m,x);
	for(int i=1;i&lt;=n;i++){
		t-=(x-a[i])*(x&gt;=a[i]);
		if(t&lt;0)return false;
	}return true;
}
int main(){
	cin&gt;&gt;n&gt;&gt;m;
	for(int i=1;i&lt;=n;i++)cin&gt;&gt;a[i];
	int l=1,r=1e9;
	while(l&lt;r){
		int mid=(l+r)&gt;&gt;1;
		if(ok(mid))
			l=mid+1;
		else r=mid;
	}cout&lt;&lt;l-1&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem1821</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;iomanip&gt;
#include&lt;cmath&gt;
using namespace std;
struct point{
	double x,y;int i;
};
struct edge{
	int u,v;
	double w;
	bool operator&lt;(const edge &amp;a)const{
		return w&lt;a.w;
	}
};
vector&lt;edge&gt;edges;
point a[1001];
int fa[10001];
int find(int x){
	if(fa[x]!=x)return fa[x]=find(fa[x]);
	return x;
}
double sqr(double x){
	return x*x;
}
int n,k;
int main(){
	cin&gt;&gt;n&gt;&gt;k;
	for(int i=1;i&lt;=n;i++){
		cin&gt;&gt;a[i].x&gt;&gt;a[i].y;
		a[i].i=i;fa[i]=i;
	}
	for(int i=1;i&lt;=n;i++)
	for(int j=i+1;j&lt;=n;j++){
		//if(i==j)continue;
		edges.push_back((edge){i,j,sqrt(sqr(a[i].x-a[j].x)+sqr(a[i].y-a[j].y))});
	}
	sort(edges.begin(),edges.end());
	for(int i=0;i&lt;edges.size();i++){
		int u=edges[i].u,v=edges[i].v;
		if(find(u)!=find(v)){
			if(n&gt;k)n--,fa[find(u)]=find(v);
			else {
				cout&lt;&lt;fixed&lt;&lt;setprecision(2)&lt;&lt;edges[i].w&lt;&lt;endl;return 0;
			}
		}
	}
	return 0;
}</pre><pre></pre><h2>Problem1826</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1e5+5;
typedef pair&lt;int,int&gt; pii;
priority_queue&lt;pii,vector&lt;pii&gt; &gt;q;
int n,m,tot,next[maxn],a[maxn];
map&lt;int,int&gt;M;
short in[maxn];
int main(){
    scanf("%d%d",&amp;n,&amp;m);
    for(int i=1;i&lt;=n;i++){
        scanf("%d",&amp;a[i]);
        if(!M[a[i]])M[a[i]]=++tot;
        a[i]=M[a[i]];
    }M.clear();
    for(int i=n;i;i--){
        if(!M[a[i]])M[a[i]]=i,next[i]=1e9;
        else next[i]=M[a[i]],M[a[i]]=i;
    }int ans=0,size=0;
    for(int i=1;i&lt;=n;i++){
        if(in[a[i]]){
            q.push(pii(next[i],a[i]));
            continue;
        }ans++;in[a[i]]=1;
        if(size==m){in[q.top().second]=0;q.pop();size--;}
        q.push(pii(next[i],a[i]));size++;
    }cout&lt;&lt;ans&lt;&lt;endl;
    return 0;
} 
// 1826
</pre><pre></pre><h2>Problem1830</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
deque&lt;char&gt;A[3];
deque&lt;char&gt;rA[3];
int len[3];
int main(){
	char c;
	for(int i=0;i&lt;3;i++){
		cin&gt;&gt;len[i];if(!len[i])continue;c=getchar();
		while(!isalpha(c))c=getchar();
		while(isalpha(c))A[i].push_back(c),c=getchar();
		rA[i]=A[i];
	}while(A[0].size()&amp;&amp;A[1].size()&amp;&amp;A[2].size()
	&amp;&amp;A[0].front()==A[1].front()&amp;&amp;A[1].front()==A[2].front())
	A[0].pop_front(),A[1].pop_front(),A[2].pop_front();
	int tot=A[0].size()+A[1].size()+A[2].size();
	int ans=tot;
	for(int i=0;i&lt;3;i++)
	for(int j=i+1;j&lt;3;j++){
		int k=0;
		for(;k&lt;min(A[i].size(),A[j].size())&amp;&amp;A[i][k]==A[j][k];k++);
		int res=tot-A[i].size()-A[j].size();
		res+=k;
		res+=A[i].size()-k+A[j].size()-k;
		ans=min(ans,res);
	}cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
} </pre><pre></pre><h2>Problem1833</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
LL F[13][11][11];
LL f[13][11],ten[15];
valarray&lt;LL&gt; solve(LL n){
	if(!n){valarray&lt;LL&gt;tmp;tmp.resize(10);tmp[0]=1;return tmp;}
	memset(f,0,sizeof f);memset(F,0,sizeof F);
	int a[13],len=0;memset(a,0,sizeof a);
	for(LL i=1,x=n;x;i++)a[i]=x%10,x/=10,len++;
	for(int i=1;i&lt;=len;i++)
	for(int j=i==len;j&lt;=9;j++)
	for(int k=0;k&lt;10;k++){
		F[i][j][k]=LL(j==k)*ten[i-1];
		for(int l=0;l&lt;=9;l++)
		F[i][j][k]+=F[i-1][l][k];
		F[i][10][k]+=F[i][j][k];
	}

	for(int i=1;i&lt;=len;i++)
	for(int k=0;k&lt;=9;k++){
		for(int j=i==len;j&lt;=a[i]-1;j++)
		f[i][k]+=F[i-1][10][k]+LL(j==k)*ten[i-1];
		f[i][k]+=f[i-1][k]+LL(a[i]==k)*(n%ten[i-1]+1);
		f[i][10]+=f[i][k];
	}
	valarray&lt;LL&gt;res=valarray&lt;LL&gt;(F[len-1][10],10)+valarray&lt;LL&gt;(f[len],10);
	LL sum=1;
	for(int i=1;i&lt;len;i++)sum+=(ten[i]-ten[i-1])*i;
	sum+=(n-ten[len-1]+1)*len;
	res[0]=sum-(res.sum()-res[0]);
	return res;
}
int main(){
	ten[0]=1;for(int i=1;i&lt;=12;i++)ten[i]=ten[i-1]*10;
	LL l,r;cin&gt;&gt;l&gt;&gt;r;
	valarray&lt;LL&gt;val=solve(r)-solve(l-1);
	for(int i=0;i&lt;10;i++)cout&lt;&lt;val[i]&lt;&lt;" \n"[i==9];
	return 0;
}</pre><pre></pre><h2>Problem1834</h2><pre>/*
	ID:zky
	OJ:BZOJ
	Index:1834
	Language:C++
*/
#include&lt;queue&gt;
#include&lt;vector&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;climits&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#define clear(x) memset(x,0,sizeof(x))
#define inf(x) memset(x,0x7f,sizeof(x))
#define Size G[u].size()
#define read3(x,y,z) scanf("%d%d%d",&amp;x,&amp;y,&amp;z)
#define read4(x,y,z,w) scanf("%d%d%d%d",&amp;x,&amp;y,&amp;z,&amp;w)
using namespace std;
int s,t;
int n,m,k;
const int INF=INT_MAX;
struct edge{
	int u,v,cap,flow,cost;
};
vector&lt;edge&gt;edges;
vector&lt;vector&lt;int&gt; &gt;G;
int d[1001];
int cur[1001];
int vis[1001];
int prev[1001];
void add(int u,int v,int cap,int cost){
	edges.push_back((edge){u,v,cap,0,cost});
	G[u].push_back(edges.size()-1);
}
bool bfs(){
	clear(d);clear(vis);
	queue&lt;int&gt;q;
	q.push(s);
	vis[s]=1;
	while(!q.empty()){
		int u=q.front();q.pop();
		for(int i=0;i&lt;Size;i++){
			edge &amp;e=edges[G[u][i]];
			if(!vis[e.v]&amp;&amp;e.cap&gt;e.flow){
				vis[e.v]=1;
				d[e.v]=d[u]+1;
				q.push(e.v);	
			}
		}
	}
	return vis[t];
}
int dfs(int x,int a){
	if(x==t||a==0)return a;
	int flow=0,f;
	for(int &amp;i=cur[x];i&lt;G[x].size();i++){
		edge &amp;e=edges[G[x][i]];
		if(d[e.v]==d[x]+1&amp;&amp;(f=dfs(e.v,min(a,e.cap-e.flow)))&gt;0){
			flow+=f;
			e.flow+=f;
			edges[G[x][i]^1].flow-=f;
			a-=f;
			if(!a)break;
		}
	}
	return flow;
}
void Dinic(){
	int flow=0;
	while(bfs()){
		clear(cur);
		flow+=dfs(s,INF);
	}
	cout&lt;&lt;flow&lt;&lt;" ";
}
int a[1001];
bool spfa(int  &amp;flow,int &amp;cost){
	queue&lt;int&gt;q;
	q.push(s);
	memset(d,0x7f,sizeof(d));
	memset(vis,0,sizeof(vis));
	int B=d[0];
	d[s]=0;
	vis[s]=1;
	a[s]=INF;
	while(!q.empty()){
		int u=q.front();q.pop();vis[u]=0;
		for(int i=0;i&lt;G[u].size();i++){
			edge &amp;e=edges[G[u][i]];
			if(e.cap-e.flow&gt;0&amp;&amp;d[e.v]&gt;d[u]+e.cost){
				d[e.v]=d[u]+e.cost;
				prev[e.v]=G[u][i];
				a[e.v]=min(a[u],e.cap-e.flow);
				if(!vis[e.v]){
					vis[e.v]=1;
					q.push(e.v);
				}
			}
		}
	}
	if(d[t]==B)return false;
	int u=t;
	flow+=a[t];
	cost+=a[t]*d[t];
	while(u!=s){
		edges[prev[u]].flow+=a[t];
		edges[prev[u]^1].flow-=a[t];
		u=edges[prev[u]].u;
	}
	return true;
}
void costflow(){
	int flow=0,cost=0;
	while(spfa(flow,cost));
	cout&lt;&lt;cost&lt;&lt;endl;
}
int main(){
	read3(n,m,k);
	G.resize(n+1);
	int u[5001],v[5001],c[5001],w[5001];
	for(int i=1;i&lt;=m;i++){
		read4(u[i],v[i],c[i],w[i]);
		add(u[i],v[i],c[i],0);
		add(v[i],u[i],0,0);
	}
	
	s=1;t=n;
	Dinic();
	s=0;
	add(s,1,k,0);
	for(int i=1;i&lt;=m;i++){
		add(u[i],v[i],k,w[i]);
		add(v[i],u[i],0,0);
	}
	
	costflow();
	return 0;
}</pre><pre></pre><h2>Problem1834</h2><pre>/*
	ID:zky
	OJ:BZOJ
	Index:1834
	Language:C++
*/
#include&lt;queue&gt;
#include&lt;vector&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;climits&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#define clear(x) memset(x,0,sizeof(x))
#define inf(x) memset(x,0x7f,sizeof(x))
#define Size G[u].size()
#define read3(x,y,z) scanf("%d%d%d",&amp;x,&amp;y,&amp;z)
#define read4(x,y,z,w) scanf("%d%d%d%d",&amp;x,&amp;y,&amp;z,&amp;w)
using namespace std;
int s,t;
int n,m,k;
const int INF=INT_MAX;
struct edge{
	int u,v,cap,flow,cost;
};
vector&lt;edge&gt;edges;
vector&lt;vector&lt;int&gt; &gt;G;
int d[1001];
int cur[1001];
int vis[1001];
int prev[1001];
void add(int u,int v,int cap,int cost){
	edges.push_back((edge){u,v,cap,0,cost});
	G[u].push_back(edges.size()-1);
}
bool bfs(){
	clear(d);clear(vis);
	queue&lt;int&gt;q;
	q.push(s);
	vis[s]=1;
	while(!q.empty()){
		int u=q.front();q.pop();
		for(int i=0;i&lt;Size;i++){
			edge &amp;e=edges[G[u][i]];
			if(!vis[e.v]&amp;&amp;e.cap&gt;e.flow){
				vis[e.v]=1;
				d[e.v]=d[u]+1;
				q.push(e.v);	
			}
		}
	}
	return vis[t];
}
int dfs(int x,int a){
	if(x==t||a==0)return a;
	int flow=0,f;
	for(int &amp;i=cur[x];i&lt;G[x].size();i++){
		edge &amp;e=edges[G[x][i]];
		if(d[e.v]==d[x]+1&amp;&amp;(f=dfs(e.v,min(a,e.cap-e.flow)))&gt;0){
			flow+=f;
			e.flow+=f;
			edges[G[x][i]^1].flow-=f;
			a-=f;
			if(!a)break;
		}
	}
	return flow;
}
void Dinic(){
	int flow=0;
	while(bfs()){
		clear(cur);
		int x;
		while(x=dfs(s,INF)){
			flow+=x;
		}
		//flow+=dfs(s,INF);
	}
	cout&lt;&lt;flow&lt;&lt;" ";
}
int a[1001];
bool spfa(int  &amp;flow,int &amp;cost){
	queue&lt;int&gt;q;
	q.push(s);
	memset(d,0x7f,sizeof(d));
	memset(vis,0,sizeof(vis));
	int B=d[0];
	d[s]=0;
	vis[s]=1;
	a[s]=INF;
	while(!q.empty()){
		int u=q.front();q.pop();vis[u]=0;
		for(int i=0;i&lt;G[u].size();i++){
			edge &amp;e=edges[G[u][i]];
			if(e.cap-e.flow&gt;0&amp;&amp;d[e.v]&gt;d[u]+e.cost){
				d[e.v]=d[u]+e.cost;
				prev[e.v]=G[u][i];
				a[e.v]=min(a[u],e.cap-e.flow);
				if(!vis[e.v]){
					vis[e.v]=1;
					q.push(e.v);
				}
			}
		}
	}
	if(d[t]==B)return false;
	int u=t;
	flow+=a[t];
	cost+=a[t]*d[t];
	while(u!=s){
		edges[prev[u]].flow+=a[t];
		edges[prev[u]^1].flow-=a[t];
		u=edges[prev[u]].u;
	}
	return true;
}
void costflow(){
	int flow=0,cost=0;
	while(spfa(flow,cost));
	cout&lt;&lt;cost&lt;&lt;endl;
}
int main(){
	read3(n,m,k);
	G.resize(n+1);
	int u[5001],v[5001],c[5001],w[5001];
	for(int i=1;i&lt;=m;i++){
		read4(u[i],v[i],c[i],w[i]);
		add(u[i],v[i],c[i],0);
		add(v[i],u[i],0,0);
	}
	
	s=1;t=n;
	Dinic();
	s=0;
	add(s,1,k,0);
	for(int i=1;i&lt;=m;i++){
		add(u[i],v[i],k,w[i]);
		add(v[i],u[i],0,0);
	}
	
	costflow();
	return 0;
}</pre><pre></pre><h2>Problem1853</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
const int maxn=1&lt;&lt;11;
LL L,R;
LL ans=0;
LL a[maxn],b[maxn];
void dfs1(int x,LL y){
	if(y&gt;R)return;
	if(x&gt;0)a[++a[0]]=y;
	dfs1(x+1,y*10+6);
	dfs1(x+1,y*10+8);
}
LL lcm(LL a,LL b){return a*b/__gcd(a,b);}
double dcm(LL a,LL b){return double(a)*b/__gcd(a,b);}
void dfs(int x,LL l,int cur){
	if(x&gt;b[0]){
		if(cur)ans+=(R/l-(L-1)/l)*(cur%2?1:-1);
		return;
	}
	dfs(x+1,l,cur);
	if(dcm(l,b[x])&lt;=R&amp;&amp;lcm(l,b[x])&lt;=R)
		dfs(x+1,lcm(l,b[x]),cur+1);
}
int main(){
	cin&gt;&gt;L&gt;&gt;R;
	dfs1(0,0);
	sort(a+1,a+1+a[0]);
	static int vis[maxn];
	for(int i=1;i&lt;=a[0];i++)if(!vis[i]){
		b[++b[0]]=a[i];
		for(int j=i+1;j&lt;=a[0];j++)if(a[j]%a[i]==0)
			vis[j]=1;
	}reverse(b+1,b+1+b[0]);
	dfs(1,1,0);
	cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem1854</h2><pre>/*
	ID:zky
	OJ:BZOJ
	Index:1854
	Language:C++
*/
#include&lt;vector&gt;
#include&lt;bitset&gt;
#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
int n;
bitset&lt;1000002&gt;vis;
int Link[1000002];
vector&lt;vector&lt;int&gt; &gt;w(10002);
bool find(int x){
	for(int i=0;i&lt;w[x].size();i++){
		if(!vis[w[x][i]]){
			vis[w[x][i]]=1;
			if(!Link[w[x][i]]||find(Link[w[x][i]])){
				Link[w[x][i]]=x;
				return true;
			}
		}
	}
	return false;
}
int main(){
	scanf("%d",&amp;n);
	for(int i=1;i&lt;=n;i++){
		int a,b;
		scanf("%d%d",&amp;a,&amp;b);
		w[a].push_back(i);
		w[b].push_back(i);
	}
	for(int i=1;i&lt;=10001;i++){
		//memset(vis,0,sizeof(vis));
		vis=0;
		if(!find(i)){
			cout&lt;&lt;i-1&lt;&lt;endl;
			return 0;
		}
	}
	return 0;
}</pre><pre></pre><h2>Problem1857</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
struct point{
	double x,y;
	point(double _x=0,double _y=0):x(_x),y(_y){}
	point operator-(point o){return point(x-o.x,y-o.y);}
	point operator+(point o){return point(x+o.x,y+o.y);}
	double operator^(point o){return x*o.x+y*o.y;}
	double operator*(point o){return x*o.y-y*o.x;}
	point operator*(double p){return point(x*p,y*p);}
	point operator/(double p){return point(x/p,y/p);}
}A,B,C,D;
double sqr(double x){return x*x;}
double length(point A){return sqrt(sqr(A.x)+sqr(A.y));}
point normal(point v){return v/length(v);}
double P,Q,R,lenAB,lenCD;
double ans=1e10;
double dis(point A,point B){return length(B-A);}
double dist(point T,point E){
	double ans=0;
	ans+=dis(T,E)/R;
	ans+=dis(E,D)/Q;
	return ans;
}
double calc(point T){
	double res=0;
	point _C=C,_D=D;
	do{
		point LL=_C+(_D-_C)/3;
		point RR=_C+(_D-_C)/3*2;
		double t1=dis(A,T)/P+dis(T,LL)/R+dis(LL,D)/Q;
		double t2=dis(A,T)/P+dis(T,RR)/R+dis(RR,D)/Q;	
		if(t1&gt;t2)
			_C=LL;
		else _D=RR;
	}while(dis(_C,_D)&gt;1e-4);
	res=dis(A,T)/P+dis(T,_C)/R+dis(_C,D)/Q;
	ans=min(ans,res);
	return res;
}
int main(){
	scanf("%lf%lf",&amp;A.x,&amp;A.y);
	scanf("%lf%lf",&amp;B.x,&amp;B.y);
	scanf("%lf%lf",&amp;C.x,&amp;C.y);
	scanf("%lf%lf",&amp;D.x,&amp;D.y);
	scanf("%lf%lf%lf",&amp;P,&amp;Q,&amp;R);
	lenAB=length(B-A);
	lenCD=length(D-C);
	double l=0,r=lenAB;
	int k=1000;
	point _A=A,_B=B;
    do{
//		double mid1=l+(r-l)/3;
//		double mid2=l+(r-l)/3*2;	
		point T1=_A+(_B-_A)/3;
		point T2=_A+(_B-_A)/3*2;
		if(calc(T1)&lt;calc(T2))
			_B=T2;
		else _A=T1;
	}while(dis(_A,_B)&gt;1e-4);
	cout&lt;&lt;fixed&lt;&lt;setprecision(2)&lt;&lt;ans&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem1858</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cctype&gt;
#define lson i&lt;&lt;1,l,mid
#define rson i&lt;&lt;1|1,mid+1,r
#define L i&lt;&lt;1
#define R i&lt;&lt;1|1
using namespace std;
const int maxn=1e5+5;
int a[maxn];
int n,m;
int getint(){
	int res=0;char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))res=res*10+c-'0',c=getchar();
	return res;
}
struct tup{
	int x,y,z;
	tup(int _x=0,int _y=0,int _z=0):x(_x),y(_y),z(_z){}
};
int max5(int a,int b,int c,int d,int e){return max(e,max(max(a,b),max(c,d)));}
struct seg_tree{
	struct node{
		int lazy,rev,sum0,sum1,ls1,ss1,rs1,ls0,rs0,ss0;
		node(){
			lazy=-1,rev=0,sum0=0,sum1=0,ls1=0,ss1=0,rs1=0,ls0=0,rs0=0,ss0=0;
		}
	}t[maxn&lt;&lt;2];
	void build(int i,int l,int r){
		if(l==r){
			t[i].sum0=t[i].ls0=t[i].ss0=t[i].rs0=a[l]==0;
			t[i].sum1=t[i].ls1=t[i].ss1=t[i].rs1=a[l]==1;	
			return;		
		}int mid=(l+r)&gt;&gt;1;
		build(lson);build(rson);
		rz(i,l,r);
	}
	void rz(int i,int l,int r){
		int mid=(l+r)&gt;&gt;1;
		tup l0,r0,ans;
		t[i].sum0=t[L].sum0+t[R].sum0;
		t[i].sum1=t[L].sum1+t[R].sum1;
		
		t[i].ls0=t[L].ls0;
		t[i].rs0=t[R].rs0;
		t[i].ls1=t[L].ls1;
		t[i].rs1=t[R].rs1;		
		if(t[L].ls0==(mid-l+1))t[i].ls0=t[L].ls0+t[R].ls0;
		if(t[L].ls1==(mid-l+1))t[i].ls1=t[L].ls1+t[R].ls1;
		if(t[R].rs0==(r-mid))t[i].rs0=t[R].rs0+t[L].rs0;
		if(t[R].rs1==(r-mid))t[i].rs1=t[R].rs1+t[L].rs1;
		t[i].ss0=max5(t[L].ss0,t[R].ss0,t[i].ls0,t[i].rs0,t[L].rs0+t[R].ls0);
		t[i].ss1=max5(t[L].ss1,t[R].ss1,t[i].ls1,t[i].rs1,t[L].rs1+t[R].ls1);
	}
	void pushdown(int i,int l,int r){
		int mid=(l+r)&gt;&gt;1;
				
		if(t[i].rev){
			swap(t[L].sum0,t[L].sum1);swap(t[L].ls1,t[L].ls0);
			swap(t[L].ss1,t[L].ss0);swap(t[L].rs1,t[L].rs0);
			swap(t[R].sum0,t[R].sum1);swap(t[R].ls1,t[R].ls0);
			swap(t[R].ss1,t[R].ss0);swap(t[R].rs1,t[R].rs0);
			t[L].rev^=1;t[R].rev^=1;
			if(~t[L].lazy)t[L].lazy^=1;
			if(~t[R].lazy)t[R].lazy^=1;	
			t[i].rev=0;
		}
		if(t[i].lazy!=-1){
			t[L].lazy=t[i].lazy;
			t[L].sum0=(mid-l+1)*(t[i].lazy==0);
			t[L].sum1=(mid-l+1)*(t[i].lazy==1);
			t[L].ls0=t[L].ss0=t[L].rs0=(mid-l+1)*(t[i].lazy==0);
			t[L].ls1=t[L].ss1=t[L].rs1=(mid-l+1)*(t[i].lazy==1);
			
			t[R].lazy=t[i].lazy;
			t[R].sum0=(r-mid)*(t[i].lazy==0);
			t[R].sum1=(r-mid)*(t[i].lazy==1);
			t[R].ls0=t[R].ss0=t[R].rs0=(r-mid)*(t[i].lazy==0);
			t[R].ls1=t[R].ss1=t[R].rs1=(r-mid)*(t[i].lazy==1);
			
			t[i].lazy=-1;
		}		
	}
	void Change(int i,int l,int r,int l0,int r0,int col){
		if(l0&lt;=l&amp;&amp;r0&gt;=r){
			t[i].lazy=col;
			t[i].sum0=(r-l+1)*(t[i].lazy==0);
			t[i].sum1=(r-l+1)*(t[i].lazy==1);
			t[i].ls0=t[i].ss0=t[i].rs0=(r-l+1)*(t[i].lazy==0);
			t[i].ls1=t[i].ss1=t[i].rs1=(r-l+1)*(t[i].lazy==1);
			return;
		}pushdown(i,l,r);
		int mid=(l+r)&gt;&gt;1;
		if(l0&lt;=mid)Change(lson,l0,r0,col);
		if(r0&gt;mid)Change(rson,l0,r0,col);
		rz(i,l,r);
	}
	void Rev(int i,int l,int r,int l0,int r0){
		if(l0&lt;=l&amp;&amp;r0&gt;=r){
			t[i].rev^=1;
			if(~t[i].lazy)t[i].lazy^=1;
			swap(t[i].sum0,t[i].sum1);swap(t[i].ls1,t[i].ls0);
			swap(t[i].ss1,t[i].ss0);swap(t[i].rs1,t[i].rs0);
			return;
		}pushdown(i,l,r);
		int mid=(l+r)&gt;&gt;1;
		if(l0&lt;=mid)Rev(lson,l0,r0);
		if(r0&gt;mid)Rev(rson,l0,r0);
		rz(i,l,r);		
	}
	int One(int i,int l,int r,int l0,int r0){
		if(l0&lt;=l&amp;&amp;r0&gt;=r)
			return t[i].sum1;
		pushdown(i,l,r);
		int mid=(l+r)&gt;&gt;1,ans=0;
		if(l0&lt;=mid)ans+=One(lson,l0,r0);
		if(r0&gt;mid)ans+=One(rson,l0,r0);
		return ans;
	}
	tup Sone(int i,int l,int r,int l0,int r0){
		if(l0&lt;=l&amp;&amp;r0&gt;=r)
			return tup(t[i].ls1,t[i].ss1,t[i].rs1);	
		pushdown(i,l,r);
		int mid=(l+r)&gt;&gt;1;tup ans,lef,rig;
		if(l0&lt;=mid)lef=Sone(lson,l0,r0);		
		if(r0&gt;mid)rig=Sone(rson,l0,r0);
		if(l0&gt;mid)return rig;
		if(r0&lt;=mid)return lef;
		ans.x=lef.x;ans.z=rig.z;
		if(lef.x==mid-l+1)ans.x=lef.x+rig.x;
		if(rig.z==r-mid)ans.z=rig.z+lef.z;
		ans.y=max5(lef.y,rig.y,ans.x,ans.y,lef.z+rig.x);
		return ans;			
	}
}T;
int main(){
	n=getint(),m=getint();
	for(int i=1;i&lt;=n;i++)a[i]=getint();
	T.build(1,1,n);
	while(m--){
		int op=getint(),l=getint()+1,r=getint()+1;
		if(op==0){T.Change(1,1,n,l,r,0);}
		if(op==1){T.Change(1,1,n,l,r,1);}
		if(op==2){T.Rev(1,1,n,l,r);}
		if(op==3){printf("%d\n",T.One(1,1,n,l,r));}
		if(op==4){printf("%d\n",T.Sone(1,1,n,l,r).y);}
	}return 0;
}
</pre><pre></pre><h2>Problem1858</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1e5+5;
char a[maxn];
int getint(){
	int res=0;char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))res=res*10+c-'0',c=getchar();
	return res;
}
int n,m;
void putint(int x){
	if(x&lt;10)putchar(x+'0');
	else{putint(x/10);putchar(x%10+'0');}
}
int main(){
	n=getint();m=getint();
	for(int i=1;i&lt;=n;i++)a[i]=-getint();
	while(m--){
		int op=getint();int l=getint()+1,r=getint()+1;
		if(op==0){
			memset(a+l,0,(r-l+1));
		}else if(op==1){
			memset(a+l,-1,(r-l+1));
		}else if(op==2){
			for(int i=l;i&lt;=r;i++)a[i]=-1-a[i];			
		}else if(op==4){
			int ans=0,tmp=0;
			for(int i=l;i&lt;=r;i++){
				if(a[i])tmp++;
				else ans=max(ans,tmp),tmp=0;
			}putint(max(ans,tmp));puts("");
		}else{
			putint(-accumulate(a+l,a+r+1,0)),puts("");
		}//for(int i=1;i&lt;=n;i++)printf("%d%c",-a[i]," \n"[i==n]);
	}	
	return 0;
}</pre><pre></pre><h2>Problem1858</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1e5+5;
char a[maxn];
int getint(){
	int res=0;char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))res=res*10+c-'0',c=getchar();
	return res;
}
int n,m;
void putint(int x){
	if(x&lt;10)putchar(x+'0');
	else{putint(x/10);putchar(x%10+'0');}
}
typedef unsigned int uint;
uint one[33];
uint bitcnt[65537];
uint lw(uint x){return x&amp;(x^(x-1));}
uint popcnt(uint x){return bitcnt[x&amp;65535u]+bitcnt[x&gt;&gt;16];}
struct BITSET{
	uint a[32768];
	uint get(int x){return a[x&gt;&gt;5]&amp;(1u&lt;&lt;(x&amp;31));}
	void set(int x){a[x&gt;&gt;5]|=(1u&lt;&lt;(x&amp;31));}
	void reset(int x){a[x&gt;&gt;5]&amp;=~(1u&lt;&lt;(x&amp;31));}
	void rev(int x){a[x&gt;&gt;5]^=(1u&lt;&lt;(x&amp;31));}
	void set(int l,int r){
		if(!((l&gt;&gt;5)^(r&gt;&gt;5))){
			a[l&gt;&gt;5]|=one[r-l+1]&lt;&lt;(l&amp;31);
			//for(int i=l;i&lt;=r;i++)set(i);
		}else{
//			while(l&amp;31)set(l++);
//			while(~(r&amp;31))set(--r);
			a[l&gt;&gt;5]|=one[(31^(l&amp;31))+1]&lt;&lt;(l&amp;31);
			a[r&gt;&gt;5]|=one[(r&amp;31)+1];
			memset(a+(l&gt;&gt;5)+1,-1,sizeof(uint)*((r&gt;&gt;5)-(l&gt;&gt;5)-1));
		}
	}
	void reset(int l,int r){
		if(!((l&gt;&gt;5)^(r&gt;&gt;5)))
			a[l&gt;&gt;5]&amp;=~(one[r-l+1]&lt;&lt;(l&amp;31));
		else{
			a[l&gt;&gt;5]&amp;=~(one[(31^(l&amp;31))+1]&lt;&lt;(l&amp;31));
			a[r&gt;&gt;5]&amp;=~(one[(r&amp;31)+1]);
			memset(a+(l&gt;&gt;5)+1,0,sizeof(uint)*((r&gt;&gt;5)-(l&gt;&gt;5)-1));
		}
	}
	void rev(int l,int r){
		if(!((l&gt;&gt;5)^(r&gt;&gt;5))){
			a[l&gt;&gt;5]^=one[r-l+1]&lt;&lt;(l&amp;31);
		}else{
			a[l&gt;&gt;5]^=one[(31^(l&amp;31))+1]&lt;&lt;(l&amp;31);
			a[r&gt;&gt;5]^=one[(r&amp;31)+1];
			for(int i=(l&gt;&gt;5)+1;i&lt;(r&gt;&gt;5);i++)a[i]=~a[i];
		}	
	}
	int count(int l,int r){
		int ans=0;
		if(!((l&gt;&gt;5)^(r&gt;&gt;5)))
			ans+=popcnt(a[l&gt;&gt;5]&amp;(one[r-l+1]&lt;&lt;(l&amp;31)));
		else{
			ans+=popcnt(a[l&gt;&gt;5]&amp;(one[(31^(l&amp;31))+1]&lt;&lt;(l&amp;31)));
			ans+=popcnt(a[r&gt;&gt;5]&amp;(one[(r&amp;31)+1]));
			for(int i=(l&gt;&gt;5)+1;i&lt;(r&gt;&gt;5);i++)ans+=popcnt(a[i]);
		}return ans;
	}
}bs;
int main(){
	n=getint();m=getint();
	for(int i=1;i&lt;(1&lt;&lt;16);i++)bitcnt[i]=bitcnt[i&gt;&gt;1]+(i&amp;1);
	for(int i=1;i&lt;33;i++)one[i]=one[i-1]|(1&lt;&lt;i-1);
	for(int i=0;i&lt;n;i++){
		if(getint())bs.set(i);
		else bs.reset(i);
	}
	while(m--){
		int op=getint();int l=getint(),r=getint();
		if(op==0){
			bs.reset(l,r);
		}else if(op==1){
			bs.set(l,r);
		}else if(op==2){
			bs.rev(l,r);	
		}else if(op==4){
			int ans=0,tmp=0;
			for(int i=l;i&lt;=r;i++){
				if(bs.get(i))tmp++;
				else ans=max(ans,tmp),tmp=0;
			}putint(max(ans,tmp));puts("");
		}else{
			putint(bs.count(l,r)),puts("");
		}//for(int i=0;i&lt;n;i++)printf("%d%c",!!bs.get(i)," \n"[i+1==n]);
	}	
	return 0;
}</pre><pre></pre><h2>Problem1861</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=80010;
struct node{
	int key,id,siz;
	node *rz(){
		siz=1;
		if(c[0])siz+=c[0]-&gt;siz,c[0]-&gt;f=this;
		if(c[1])siz+=c[1]-&gt;siz,c[1]-&gt;f=this;
		return this;
	}
	node *c[2],*f;
	void split(int ned,node *&amp;p,node *&amp;q);
}nd[maxn],*root;
node *merge(node *p,node *q){
	if(!p||!q)return (p?p-&gt;rz():(q?q-&gt;rz():0));
	if(p-&gt;key&lt;q-&gt;key){
		p-&gt;c[1]=merge(p-&gt;c[1],q);
		return p-&gt;rz();
	}else{
		q-&gt;c[0]=merge(p,q-&gt;c[0]);
		return q-&gt;rz();
	}
}
#define sz(x) (x?x-&gt;siz:0)
void node::split(int ned,node *&amp;p,node *&amp;q){
	if(!ned){p=0;q=this;return;}
	if(ned==siz){p=this;q=0;return;}
	if(c[0]&amp;&amp;c[0]-&gt;siz&gt;=ned){
		c[0]-&gt;split(ned,p,q);c[0]-&gt;f=0;c[0]=0;rz();
		q=merge(q,this);
	}else{
		c[1]-&gt;split(ned-sz(c[0])-1,p,q);c[1]-&gt;f=0;c[1]=0;rz();
		p=merge(this,p);
	}
}
int rank(node *x){
	int ans=sz(x-&gt;c[0]);
	while(x-&gt;f){
		if(x-&gt;f-&gt;c[1]==x)ans+=sz(x-&gt;f-&gt;c[0])+1;
		x=x-&gt;f;
	}return ans+1;
}
int kth(int k){
	node *p,*q,*x,*y;
	root-&gt;split(k-1,p,q);
	q-&gt;split(1,x,y);
	int ans=x-nd;
	root=merge(p,merge(x,y));
	return ans;
}
void Top(int _x){
	node *x=nd+_x;
	int k=rank(x);
	node *p,*q,*a,*b;
	root-&gt;split(k-1,p,q);
	q-&gt;split(1,a,b);
	root=merge(a,merge(p,b));
}
void Bottom(int _x){
	node *x=nd+_x;
	int k=rank(x);
	node *p,*q,*a,*b;
	root-&gt;split(k-1,p,q);
	q-&gt;split(1,a,b);
	root=merge(merge(p,b),a);
}
void Insert(int k){
	node *p,*q,*x,*y,*a,*b;
	root-&gt;split(k-1,p,q);
	q-&gt;split(1,x,y);
	y-&gt;split(1,a,b);
//	swap(x-&gt;id,a-&gt;id);
	root=merge(merge(p,a),merge(x,b));
}
int n,m;
int in(){
	int r=0,f=1;char c=getchar();
	while(!isdigit(c))f=c=='-'?-1:f,c=getchar();
	while(isdigit(c))r=r*10+c-'0',c=getchar();
	return r*f;
}
void deb(node *t){
	if(t-&gt;c[0])deb(t-&gt;c[0]);
	printf("%d ",t-&gt;id);
	if(t-&gt;c[1])deb(t-&gt;c[1]);
}
int main(){
	scanf("%d%d",&amp;n,&amp;m);
	for(int i=1;i&lt;=n;i++){
		int x=in();
		nd[x].id=x;nd[x].key=rand();
		root=merge(root,nd+x);
	}
	while(m--){
//		deb(root);puts("");
		char op[7];scanf("%s",op);	
		int x=in();
		if(op[0]=='T'){
			Top(x);
		}else if(op[0]=='B'){
			Bottom(x);
		}else if(op[0]=='I'){
			int t=in();
			if(t==1)Insert(rank(nd+x));
			if(t==-1)Insert(rank(nd+x)-1);
		}else if(op[0]=='A'){
			printf("%d\n",rank(nd+x)-1);		
		}else if(op[0]=='Q'){
			printf("%d\n",kth(x));
		}
	}	
	return 0;
}</pre><pre></pre><h2>Problem1862</h2><pre>#include&lt;iostream&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
#include&lt;ctime&gt;
#define mod 985003
using namespace std;
struct data{
	int l,r,time,num,rnd,s;
	char ch[11];
}tr[250001];
struct data2{
	int num,time,next;
	char ch[11];
}hash[250001];
int n,size,root,tot,head[mod+1];
int Hash(char ch[]){//ch[0]是表示操作的字符 
	int s=0;
	for(int i=1;i&lt;strlen(ch);i++)
		s=(s*27+ch[i]-'A'+1)%mod;
	return s;
}
void update(int k){
	tr[k].s=tr[tr[k].l].s+tr[tr[k].r].s+1;
} 
void lturn(int &amp;k){
	int t=tr[k].r;
	tr[k].r=tr[t].l;
	tr[t].l=k;
	tr[t].s=tr[k].s;
	update(k);
	k=t;
}
void rturn(int &amp;k){
	int t=tr[k].l;
	tr[k].l=tr[t].r;
	tr[t].r=k;
	tr[t].s=tr[k].s;
	update(k);
	k=t;
}
bool cmp(char a[],char b[]){
	if(strlen(a)!=strlen(b))return 0;
	for(int i=1;i&lt;strlen(a);i++)
		if(a[i]!=b[i])return 0;
	return 1;
}
void insert(int &amp;k,char ch[],int x,int time){
	if(k==0){
		k=++size;
		tr[k].rnd=rand();
		tr[k].num=x;
		tr[k].time=time;
		tr[k].s=1;
		memcpy(tr[k].ch,ch,strlen(ch));
		return;
	}
	tr[k].s++;
	if(x&lt;=tr[k].num){
		insert(tr[k].l,ch,x,time);
		if(tr[tr[k].l].rnd&lt;tr[k].rnd)rturn(k);
	}
	else{
		insert(tr[k].r,ch,x,time);
		if(tr[tr[k].r].rnd&lt;tr[k].rnd)lturn(k);
	}
}
void del(int &amp;k,int x,int time){
	if(k==0)return;
	if(tr[k].num==x)
		if(tr[k].time==time){
			if(tr[k].l*tr[k].r==0)k=tr[k].l+tr[k].r;
			else if(tr[tr[k].l].rnd&lt;tr[tr[k].r].rnd){
				rturn(k);del(k,x,time);
			}
			else{
				lturn(k);del(k,x,time);
			}
		}
		else if(tr[k].time&lt;time){
			tr[k].s--;
			del(tr[k].l,x,time);
		}
		else{
			tr[k].s--;
			del(tr[k].r,x,time);
		}
	else if(x&lt;tr[k].num){
		tr[k].s--;
		del(tr[k].l,x,time);
	}
	else{
		tr[k].s--;
		del(tr[k].r,x,time);
	}
}
void ins(char ch[],int x,int time){
	int k=Hash(ch),i=head[k];
	while(i){
		if(cmp(hash[i].ch,ch)){
			del(root,hash[i].num,hash[i].time);
			hash[i].num=x;hash[i].time=time;
			insert(root,ch,x,time);
			return;
		}
		i=hash[i].next;
	}
	hash[++tot].time=time;hash[tot].num=x;
	memcpy(hash[tot].ch,ch,strlen(ch));
	hash[tot].next=head[k];head[k]=tot;
	insert(root,ch,x,time);
}
int get(char ch[]){
	int k=Hash(ch),i=head[k];
	while(i){
		if(cmp(hash[i].ch,ch))return i;
		i=hash[i].next;
	}
}
int ask_rank(int k,int x,int time){
	if(k==0)return 0;
	if(tr[k].num==x){
		if(tr[k].time&gt;time)return ask_rank(tr[k].r,x,time);
		else if(tr[k].time&lt;time)return tr[tr[k].r].s+ask_rank(tr[k].l,x,time)+1;
		else return tr[tr[k].r].s+1;
	}
	else if(tr[k].num&lt;x)return ask_rank(tr[k].r,x,time);
	else return tr[tr[k].r].s+ask_rank(tr[k].l,x,time)+1;
}
void ask1(char ch[]){
	int t=get(ch);
	printf("%d\n",ask_rank(root,hash[t].num,hash[t].time));
}
int index(int k,int x){
	if(tr[tr[k].r].s+1==x)return k;
	else if(x&lt;=tr[tr[k].r].s)return index(tr[k].r,x);
	else return index(tr[k].l,x-tr[tr[k].r].s-1);
}
void ask2(char ch[]){
	int t=0;
	for(int i=1;i&lt;strlen(ch);i++)
		t=t*10+ch[i]-'0';
	for(int i=t;i&lt;=min(tot,t+9);i++){
		printf("%s",tr[index(root,i)].ch+1);
		if(i&lt;min(tot,t+9))printf(" ");
	}
	printf("\n");
}
int main(){
	scanf("%d",&amp;n);
	char oper[11];int t;
	for(int i=1;i&lt;=n;i++){
		scanf("%s",oper);
		if(oper[0]=='+'){
			scanf("%d",&amp;t);
			ins(oper,t,i);
		}
		else{
			if(oper[1]&gt;='0'&amp;&amp;oper[1]&lt;='9')ask2(oper);
			else ask1(oper);
		}
	}
	return 0;
}</pre><pre></pre><h2>Problem1875</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
int x[122],y[122],u[122],v[122][122];
int w[122][122];
int MOD=45989;
int main(){
	int n,m,t,a,b,ans=0;
	cin&gt;&gt;n&gt;&gt;m&gt;&gt;t&gt;&gt;a&gt;&gt;b;
	for(int i=0;i&lt;m;i++){
		int j=i*2;
		cin&gt;&gt;x[j]&gt;&gt;y[j];
		x[j^1]=y[j];
		y[j^1]=x[j];
	}
	m*=2;
	for(int i=0;i&lt;m;i++){
		if(x[i]==a)
		u[i]=1;
		for(int j=0;j&lt;m;j++)
			if((i^1)!=j&amp;&amp;y[i]==x[j])
				v[i][j]=1;
	}
	for(--t;t;t&gt;&gt;=1){
		if(t&amp;1){
			memset(w[0],0,sizeof(w[0]));
			for(int i=0;i&lt;m;i++)
			for(int j=0;j&lt;m;j++)
			(w[0][i]+=u[j]*v[j][i])%=MOD;
			memcpy(u,w[0],sizeof(w[0]));
		}
		memset(w,0,sizeof(w));
		for(int i=0;i&lt;m;i++)
		for(int j=0;j&lt;m;j++)
		for(int k=0;k&lt;m;k++){
			(w[i][j]+=v[i][k]*v[k][j])%=MOD;
		}
		memcpy(v,w,sizeof(w));
	}
	for(int i=0;i&lt;m;i++)
	if(y[i]==b)
	ans+=u[i];
	cout&lt;&lt;ans%MOD&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem1876</h2><pre>def gcd(a,b):
    while b:
        c=a%b
        a=b
        b=c
    return a
a=int(raw_input())
b=int(raw_input())
print gcd(a,b)
</pre><pre></pre><h2>Problem1877</h2><pre>/*
	ID:zky
	OJ:BZOJ
	Index:1877
	Language:C++
*/
#include&lt;queue&gt;
#include&lt;vector&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;climits&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#define clear(x) memset(x,0,sizeof(x))
#define inf(x) memset(x,0x7f,sizeof(x))
#define Size G[u].size()
#define read2(x,y) scanf("%d%d",&amp;x,&amp;y)
#define read3(x,y,z) scanf("%d%d%d",&amp;x,&amp;y,&amp;z)
#define read4(x,y,z,w) scanf("%d%d%d%d",&amp;x,&amp;y,&amp;z,&amp;w)
using namespace std;
int s,t;
int n,m,k;
const int INF=INT_MAX;
struct edge{
	int u,v,cap,flow,cost;
};
vector&lt;edge&gt;edges;
vector&lt;vector&lt;int&gt; &gt;G;
int d[1001];
int cur[1001];
int vis[1001];
int prev[1001];
void add(int u,int v,int cap,int cost){
	edges.push_back((edge){u,v,cap,0,cost});
	G[u].push_back(edges.size()-1);
}
bool bfs(){
	clear(d);clear(vis);
	queue&lt;int&gt;q;
	q.push(s);
	vis[s]=1;
	while(!q.empty()){
		int u=q.front();q.pop();
		for(int i=0;i&lt;Size;i++){
			edge &amp;e=edges[G[u][i]];
			if(!vis[e.v]&amp;&amp;e.cap&gt;e.flow){
				vis[e.v]=1;
				d[e.v]=d[u]+1;
				q.push(e.v);	
			}
		}
	}
	return vis[t];
}
int dfs(int x,int a){
	if(x==t||a==0)return a;
	int flow=0,f;
	for(int &amp;i=cur[x];i&lt;G[x].size();i++){
		edge &amp;e=edges[G[x][i]];
		if(d[e.v]==d[x]+1&amp;&amp;(f=dfs(e.v,min(a,e.cap-e.flow)))&gt;0){
			flow+=f;
			e.flow+=f;
			edges[G[x][i]^1].flow-=f;
			a-=f;
			if(!a)break;
		}
	}
	return flow;
}
void Dinic(){
	int flow=0;
	while(bfs()){
		clear(cur);
		int x;
		while(x=dfs(s,INF)){
			flow+=x;
		}
		//flow+=dfs(s,INF);
	}
	cout&lt;&lt;flow&lt;&lt;" ";
}
int a[1001];
bool spfa(int  &amp;flow,int &amp;cost){
	queue&lt;int&gt;q;
	q.push(s);
	memset(d,0x7f,sizeof(d));
	memset(vis,0,sizeof(vis));
	int B=d[0];
	d[s]=0;
	vis[s]=1;
	a[s]=INF;
	while(!q.empty()){
		int u=q.front();q.pop();vis[u]=0;
		for(int i=0;i&lt;G[u].size();i++){
			edge &amp;e=edges[G[u][i]];
			if(e.cap-e.flow&gt;0&amp;&amp;d[e.v]&gt;d[u]+e.cost){
				d[e.v]=d[u]+e.cost;
				prev[e.v]=G[u][i];
				a[e.v]=min(a[u],e.cap-e.flow);
				if(!vis[e.v]){
					vis[e.v]=1;
					q.push(e.v);
				}
			}
		}
	}
	if(d[t]==B)return false;
	int u=t;
	flow+=a[t];
	cost+=a[t]*d[t];
	while(u!=s){
		edges[prev[u]].flow+=a[t];
		edges[prev[u]^1].flow-=a[t];
		u=edges[prev[u]].u;
	}
	return true;
}
void costflow(){
	int flow=0,cost=0;
	while(spfa(flow,cost));
	cout&lt;&lt;flow&lt;&lt;" ";
	cout&lt;&lt;cost&lt;&lt;endl;
}
int main(){
	read2(n,m);
	G.resize(n*2+10);
	s=1;t=n;
	add(s,s+n,INF,0);
	add(s+n,s,0,0);
	for(int i=2;i&lt;n;i++){
		add(i,i+n,1,0);
		add(i+n,i,0,0);
	}
	add(t,t+n,INF,0);
	add(t+n,t,0,0);
	t=t+n;
//	s=1;t=n;
	for(int i=1;i&lt;=m;i++){
		int u,v,w;
		read3(u,v,w);
		add(u+n,v,1,w);
		add(v,u+n,0,-w);
	}
//	s=1;t=n;
	int deb=0;
	if(deb){
		for(int i=0;i&lt;edges.size();i++){
			if(i%2==0)
			printf("#%d  %d -&gt; %d  cap:%d  cost:%d \n"
					,i,edges[i].u,edges[i].v,edges[i].cap,edges[i].cost);
		}
	}
	costflow();
	return 0;
}</pre><pre></pre><h2>Problem1878</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#define read(x) scanf("%d",&amp;x)
#define read2(x,y) scanf("%d%d",&amp;x,&amp;y)
using namespace std;
int n,m;
int d[50001];
struct Q{
	int l,r,index;
	Q(){
	}
	Q(int a,int b,int c){
		l=a;r=b;index=c;
	}
	bool operator&lt;(const Q &amp;a)const{
		return  r&lt;a.r;
	}
};
int lowbit(int x){
	return x&amp;(-x);
}
void updata(int x,int s){
	while(x&lt;=n){
		d[x]+=s;
		x+=lowbit(x);
	}
}
int get(int x){
	int s=0;
	while(x){
		s+=d[x];
		x-=lowbit(x);		
	}
	return s;
}
Q qur[200001];
int a[50001];
int ans[200001];
int pre[1000001];
int last[1000001];
int main(){
	read(n);
	for(int i=1;i&lt;=n;i++){
		read(a[i]);
		pre[i]=last[a[i]]+1;
		last[a[i]]=i;
	}
	read(m);
	for(int i=1;i&lt;=m;i++){
		int l,r;
		read2(l,r);
		qur[i]=Q(l,r,i);
	}
	sort(qur+1,qur+1+m);
	int j=1;
	for(int i=1;i&lt;=m;i++){
		while(j&lt;=qur[i].r){
			j++;
			updata(pre[j-1],1);
			updata(j,-1);
		}
		ans[qur[i].index]=get(qur[i].l);
	}
	for(int i=1;i&lt;=m;i++){
		printf("%d\n",ans[i]);
	}
	return 0;
}</pre><pre></pre><h2>Problem1879</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int MOD=1000003;
int n,k;
string s[16];
int f[51][1&lt;&lt;16];
int can[51][26];
void solve(){
	memset(f,0,sizeof f);
	memset(can,0,sizeof can);
	scanf("%d%d",&amp;n,&amp;k);
	for(int i=0;i&lt;n;i++)cin&gt;&gt;s[i];
	int len=s[0].length();
	for(int i=0;i&lt;len;i++)
	for(int j=0;j&lt;n;j++)
	for(int k=0;k&lt;26;k++)
	if(s[j][i]=='?'||s[j][i]==k+'a')
	can[i][k]|=1&lt;&lt;j;
	f[0][(1&lt;&lt;n)-1]=1;
	for(int i=0;i&lt;len;i++){
		for(int j=0;j&lt;(1&lt;&lt;n);j++)if(f[i][j]){
			for(int k=0;k&lt;26;k++){
				f[i+1][j&amp;can[i][k]]+=f[i][j];
				if(f[i+1][j&amp;can[i][k]]&gt;=MOD)
				f[i+1][j&amp;can[i][k]]%=MOD;
			}
		}
	}int ans=0;
	for(int i=0;i&lt;(1&lt;&lt;n);i++)if(__builtin_popcount(i)==k)ans=(f[len][i]+ans)%MOD;
	cout&lt;&lt;ans&lt;&lt;endl;
}
int main(){
	int T;scanf("%d",&amp;T);
	while(T--)solve();
	return 0;
}</pre><pre></pre><h2>Problem1880</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;climits&gt;
#include&lt;cstring&gt;
#include&lt;vector&gt;
using namespace std;
const int maxn=1510;
int n,m;
int x1,x2,y1,y2,f[maxn];
struct edge{int u,v,w;};
int mp[maxn][maxn];
short vis[maxn];
short can[maxn][maxn];
short Can[maxn];
int dx1[maxn],dx2[maxn],dy1[maxn],dy2[maxn];
void dijk(int s,int *d){
	memset(vis,0,sizeof vis);
	fill(d,d+1+n,INT_MAX&gt;&gt;1);d[s]=0;
	for(int i=1;i&lt;=n;i++){
		int k=0,minn=d[0];
		for(int j=1;j&lt;=n;j++)if(!vis[j]&amp;&amp;minn&gt;d[j])minn=d[j],k=j;
		vis[k]=1;
		for(int j=1;j&lt;=n;j++)
		d[j]=min(d[j],d[k]+mp[k][j]);
		
	}
}
int dfs(int u){
    if (vis[u])return f[u];
    else{
        vis[u]=1;
        for(int v=1;v&lt;=n;v++)if(can[u][v])
        f[u]=max(f[u],mp[u][v]+dfs(v));
        return f[u];
    }
}
int main(){
	scanf("%d%d",&amp;n,&amp;m);
	memset(mp,0x3f,sizeof mp);
	scanf("%d%d%d%d",&amp;x1,&amp;y1,&amp;x2,&amp;y2);
	for(int i=1;i&lt;=m;i++){
		int u,v,w;scanf("%d%d%d",&amp;u,&amp;v,&amp;w);
		mp[u][v]=mp[v][u]=w;
	}for(int i=1;i&lt;=n;++i)mp[i][i]=0;
	dijk(x1,dx1);
	dijk(y1,dy1);
	dijk(x2,dx2);
	dijk(y2,dy2);
    for(int u=1;u&lt;=n;u++)
    for(int v=1;v&lt;=n;v++)
    if(u!=v&amp;&amp;dx1[u]+mp[u][v]+dy1[v]==dx1[y1]&amp;&amp;
	(dx2[u]+mp[u][v]+dy2[v]==dx2[y2]||dy2[u]+mp[u][v]+dx2[v]==dx2[y2]))
    can[u][v]=1;	
    int ans=0;memset(vis,0,sizeof vis);
	for(int i=1;i&lt;=n;i++)ans=max(ans,dfs(i));
	cout&lt;&lt;ans&lt;&lt;endl;        
	return 0;
}</pre><pre></pre><h2>Problem1891</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=4e5+5;
int getn(){
	int res=0;char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))res=res*10+c-'0',c=getchar();
	return res;
}
int n,m;
int lin[maxn];
vector&lt;int&gt;G[maxn],Ge[maxn];
int d[maxn];
bool bfs(){
	memset(d,0,sizeof d);		
	queue&lt;int&gt;q;
	for(int i=1;i&lt;=n;i++)if(!lin[i])q.push(i);
	int f=0;
	while(!q.empty()){
		int u=q.front();q.pop();
		if(u&gt;n){
			int v=lin[u];
			q.push(v);d[v]=d[u]+1;
		}else for(int i=0;i&lt;G[u].size();i++){
			int v=G[u][i];
			if(d[v])continue;
			d[v]=d[u]+1;
			if(lin[v])q.push(v);
			else f=1;
		}
	}return f;
}
int find(int u){
	for(int i=0;i&lt;G[u].size();i++){
		int v=G[u][i];
		if(d[u]+1!=d[v])continue;
		d[v]=-1;
		if(!lin[v]||find(lin[v])){
			lin[v]=u;lin[u]=v;return 1;
		}
	}return 0;
}
int dfn[maxn],low[maxn],bel[maxn],z,B,ins[maxn];
stack&lt;int&gt;S;
void tarjan(int u){
	low[u]=dfn[u]=++z;ins[u]=1;S.push(u);
	for(int i=0;i&lt;Ge[u].size();i++){
		int v=Ge[u][i];
		if(!dfn[v]){
			tarjan(v);
			low[u]=min(low[u],low[v]);
		}else if(ins[v])low[u]=min(low[u],dfn[v]);
	}if(low[u]==dfn[u]){
		int v;B++;
		do{
			v=S.top();S.pop();ins[v]=0;
			bel[v]=B;
		}while(u!=v);
	}
}
pair&lt;int,int&gt; Q[int(6e5+5)];
int main(){
	n=getn();m=getn();
	for(int i=1;i&lt;=m;i++){
		int u=getn(),v=getn();
		Q[i].first=u;
		Q[i].second=v+n;
		G[u].push_back(v+n);
	}while(bfs())
		for(int i=1;i&lt;=n;i++)if(!lin[i])
			find(i);
	for(int i=1;i&lt;=n*2;i++)for(int j=0;j&lt;G[i].size();j++){
		int u=i,v=G[i][j];
		if(lin[u]==v)Ge[v].push_back(u);
		else Ge[u].push_back(v);
	}for(int i=1;i&lt;=n*2;i++)if(!dfn[i])tarjan(i);
	for(int i=1;i&lt;=m;i++){
		int u=Q[i].first,v=Q[i].second;
		if(bel[u]!=bel[v]){
			if(lin[u]==v)putchar('1');
			else putchar('2');
		}else putchar('0');
	}puts("");
	return 0;
}</pre><pre></pre><h2>Problem1895</h2><pre>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;queue&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#define N 200005
#define inf 1&lt;&lt;29
#define MOD 100000007
#define LL long long
#define Key_value ch[ch[root][1]][0]
#define _match(a,b) ((a)==(b))
using namespace std;
int n,q,a[N];
int size[N],pre[N],rev[N],val[N],same[N],add[N],m[N];
int ch[N][2],tot1,root,s[N],tot2;
//debug部分copy from hh  
void Treaval(int x) {  
    if(x) {  
        Treaval(ch[x][0]);  
        printf("结点%2d:左儿子 %2d 右儿子 %2d 父结点 %2d size = %2d ,val = %2d  min =%2d \n",x,ch[x][0],ch[x][1],pre[x],size[x],val[x],m[x]);  
        Treaval(ch[x][1]);  
    }  
}  
void debug() {printf("%d\n",root);Treaval(root);}  
//以上Debug  
void Update_Rev(int r){
	if(!r) return;
	swap(ch[r][0],ch[r][1]);
	rev[r]^=1;
}
void Update_Add(int r,int ADD){
	if(!r) return;
	m[r]+=ADD;
	val[r]+=ADD;
	add[r]+=ADD;
}
void NewNode(int &amp;r,int k,int father){
    if(tot2)
        r=s[tot2--];
    else
        r=++tot1;
    ch[r][0]=ch[r][1]=0;
    pre[r]=father;
	val[r]=m[r]=k;
	size[r]=1;
	add[r]=0;
}
void Push_Up(int x){
    int l=ch[x][0],r=ch[x][1];
    size[x]=size[l]+size[r]+1;
    m[x]=min(min(m[l],m[r]),val[x]);
}
void Push_Down(int x){
	int l=ch[x][0],r=ch[x][1];
    if(add[x]){
       Update_Add(l,add[x]);
	   Update_Add(r,add[x]);
	   add[x]=0;
    }
	if(rev[x]){
		Update_Rev(l);
		Update_Rev(r);
		rev[x]=0;
	}
}
void Bulid(int &amp;r,int L,int R,int father){
    if(L&gt;R)
        return ;
    int mid=(L+R)/2;
    NewNode(r,a[mid],father);
    Bulid(ch[r][0],L,mid-1,r);
    Bulid(ch[r][1],mid+1,R,r);
    Push_Up(r);
}
void Init(){
    tot1=tot2=root=0;
    ch[root][0]=ch[root][1]=pre[root]=rev[root]=size[root]=add[root]=0;
	m[root]=inf;
    NewNode(root,inf,0);
    NewNode(ch[root][1],inf,root);
    Push_Up(root);
    Bulid(Key_value,1,n,ch[root][1]);
    Push_Up(ch[root][1]);
    Push_Up(root);
}
void Rotate(int x,int kind){  
    int y=pre[x];    
    Push_Down(y);
    Push_Down(x);
    ch[y][!kind]=ch[x][kind];   
    pre[ch[x][kind]]=y;  
    if(pre[y])  
        ch[pre[y]][ch[pre[y]][1]==y]=x;  
    pre[x]=pre[y];  
    ch[x][kind]=y;  
    pre[y]=x;  
    Push_Up(y);  
}   
void Splay(int r,int goal){  
    Push_Down(r);
    while(pre[r]!=goal){  
        if(pre[pre[r]]==goal)  
            Rotate(r,ch[pre[r]][0]==r);  
        else{  
            int y=pre[r];  
            int kind=(ch[pre[y]][0]==y);  
            if(ch[y][kind]==r){  
                Rotate(r,!kind);  
                Rotate(r,kind);  
            }  
            else{  
                Rotate(y,kind);  
                Rotate(r,kind);  
            }  
        }  
    }  
    Push_Up(r);  
    if(goal==0) root=r;  
} 
void RotateTo(int k,int goal) {  
    int r=root;  
    Push_Down(r);  
    while(size[ch[r][0]]!=k){  
        if(k&lt;size[ch[r][0]]){  
            r=ch[r][0];  
        } else {  
            k-=(size[ch[r][0]]+1);  
            r=ch[r][1];  
        }  
        Push_Down(r);  
    }  
    Splay(r,goal);  
}  
int Get_Kth(int r,int k){
    Push_Down(r);
    int t=size[ch[r][0]]+1;
    if(t==k)
        return r;
    if(t&gt;k)
        return Get_Kth(ch[r][0],k);
    else
        return Get_Kth(ch[r][1],k-t);
}
int Get_Min(int r){
    Push_Down(r);
    while(ch[r][0]){
        r=ch[r][0];
        Push_Down(r);
    }
    return r;
}
int Get_Max(int r){
    Push_Down(r);
    while(ch[r][1]){
        r=ch[r][1];
        Push_Down(r);
    }
    return r;
}
void Reversal(int l,int r){
    int x=Get_Kth(root,l);
	Splay(x,0);
	int y=Get_Kth(root,r+2);
	Splay(y,root);
    Update_Rev(Key_value);
}
void Cut(int a,int b,int c){
    int x=Get_Kth(root,a);
    int y=Get_Kth(root,b+2);    
    Splay(x,0);
    Splay(y,root);
    int tmp=Key_value;
    Key_value=0;
    Push_Up(ch[root][1]);
    Push_Up(root);
    int z=Get_Kth(root,c+1);
    Splay(z,0);
    int m=Get_Min(ch[root][1]);
    Splay(m,root);
    Key_value=tmp;
    pre[Key_value]=ch[root][1];
    Push_Up(ch[root][1]);
    Push_Up(root);
}
int cnt;
void InOrder(int r){
    if(r==0)
        return;
    Push_Down(r);
    InOrder(ch[r][0]);
  if(cnt&gt;=1)
      printf("%d  ",val[r]);
    cnt++;
    InOrder(ch[r][1]);
}
void Insert(int pos,int k){
    int x=Get_Kth(root,pos);
    Splay(x,0);
    int y=Get_Min(ch[root][1]);
    Splay(y,root);
	NewNode(Key_value,k,ch[root][1]);
    Push_Up(ch[root][1]);
    Push_Up(root);
}
void erase(int r){
    if(!r) return;
    s[++tot2]=r;
    erase(ch[r][0]);
    erase(ch[r][1]);
}
void Delete(int l){
    int x=Get_Kth(root,l);
    Splay(x,0); 
    int y=Get_Kth(root,l+2);
    Splay(y,root);
    erase(Key_value);
    pre[Key_value]=0;
    Key_value=0;
    Push_Up(ch[root][1]);
    Push_Up(root);
}
void ADD(int l,int r,int k){
	int x=Get_Kth(root,l);
	Splay(x,0);
	int y=Get_Kth(root,r+2);
	Splay(y,root);
	Update_Add(Key_value,k);
	Push_Up(ch[root][1]);
	Push_Up(root);
}
int Get_Answer(int l,int r){
	int x=Get_Kth(root,l);
	Splay(x,0);
	int y=Get_Kth(root,r+2);
	Splay(y,root);
	return m[Key_value];
}
void Revolve(int a,int b,int t){
	if(!t)
		return;
	int c=b-t;
	int x=Get_Kth(root,a);
	Splay(x,0);
	x=Get_Kth(root,c+2);
	Splay(x,root);
       //将后者取出
	int tmp=Key_value;
	Key_value=0;
	Push_Up(ch[root][1]);
	Push_Up(root);
	Splay(Get_Kth(root,b-c+a),0);
	Splay(Get_Kth(root,b-c+a+1),root);
	//旋转到相应位置
       Key_value=tmp;
	pre[Key_value]=ch[root][1];
       //插入
	Push_Up(ch[root][1]);
	Push_Up(root);
}
int main(){
    while(scanf("%d",&amp;n)!=EOF){
		for(int i=1;i&lt;=n;i++)
			scanf("%d",&amp;a[i]);
		scanf("%d",&amp;q);
		Init();
		char str[10];
		int l,r,k;
		while(q--){
			scanf("%s",str);
			if(!strcmp(str,"ADD")){
				scanf("%d%d%d",&amp;l,&amp;r,&amp;k);
				ADD(l,r,k);
			}
			else if(!strcmp(str,"REVERSE")){
				scanf("%d%d",&amp;l,&amp;r);
				Reversal(l,r);
			}
			else if(!strcmp(str,"REVOLVE")){
				scanf("%d%d%d",&amp;l,&amp;r,&amp;k);
				Revolve(l,r,(k%(r-l+1)+(r-l+1))%(r-l+1));
			}
			else if(!strcmp(str,"INSERT")){
				scanf("%d%d",&amp;l,&amp;k);
				Insert(l+1,k);
			}
			else if(!strcmp(str,"DELETE")){
				scanf("%d",&amp;l);
				Delete(l);
			}
			else{
				scanf("%d%d",&amp;l,&amp;r);
				printf("%d\n",Get_Answer(l,r));
			}
		}
	}
	return 0;
}
</pre><pre></pre><h2>Problem1898</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#define MAX 60
#define MO 10000
using namespace std;

int points;

struct Matrix{
    int num[MAX][MAX];
    int w,h;

    Matrix(int _,int __):w(_),h(__) {
        memset(num,0,sizeof(num));
    }
    Matrix() {
        memset(num,0,sizeof(num));
    }
    Matrix operator *(const Matrix &amp;a)const {
        Matrix re(w,a.h);
        for(int i = 1; i &lt;= w; ++i)
            for(int j = 1; j &lt;= a.h; ++j) {
                for(int k = 1; k &lt;= h; ++k)
                    re.num[i][j] += num[i][k] * a.num[k][j];
                re.num[i][j] %= MO;
            }
        return re;
    }
    void ClearHor(int line) {
        for(int i = 1; i &lt;= points; ++i)
            num[line][i] = 0;
    }
    void ClearVer(int line) {
        for(int i = 1; i &lt;= points; ++i)
            num[i][line] = 0;
    }
}src[20];

struct Fish{
    int cnt,num[10];

    void Read() {
        scanf("%d",&amp;cnt);
        for(int i = 0; i &lt; cnt; ++i)
            scanf("%d",&amp;num[i]),++num[i];
    }
}fish[MAX];

int edges,s,t;
long long k;
int fishes;

Matrix QuickPower(Matrix a,long long y)
{
    Matrix re(points,points);
    for(int i = 1; i &lt;= points; ++i)
        re.num[i][i] = 1;
    while(y) {
        if(y&amp;1) re = re * a;
        a = a * a;
        y &gt;&gt;= 1;
    }
    return re;
}

int main()
{
    cin &gt;&gt; points &gt;&gt; edges &gt;&gt; s &gt;&gt; t &gt;&gt; k;
    ++s,++t;
    Matrix map(points,points);
    for(int x,y,i = 1; i &lt;= edges; ++i) {
        scanf("%d%d",&amp;x,&amp;y);
        ++x,++y;
        map.num[x][y] = map.num[y][x] = 1;
    }
    for(int i = 0; i &lt; 12; ++i)
        src[i] = map;
    cin &gt;&gt; fishes;
    for(int i = 1; i &lt;= fishes; ++i)
        fish[i].Read();
    for(int i = 0; i &lt; 12; ++i) {
        for(int j = 1; j &lt;= fishes; ++j) {
            int pos = fish[j].num[i % fish[j].cnt];
            if(i)   
                src[i - 1].ClearVer(pos);
            src[i].ClearHor(pos);
        }
    }
    Matrix base(points,points);
    for(int i = 1; i &lt;= points; ++i)
        base.num[i][i] = 1;
    for(int i = 0; i &lt; 12; ++i)
        base = base * src[i];
    Matrix ans = QuickPower(base,k / 12);
    k %= 12;
    for(int i = 0; i &lt; k; ++i)
        ans = ans * src[i];
    cout &lt;&lt; ans.num[s][t] &lt;&lt; endl;
    return 0;
}</pre><pre></pre><h2>Problem1899</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
int n;
struct THU{
	int a,b;
	bool operator &lt; (const THU &amp;x)const{
		return b&gt;x.b;
	}
};
THU s[201];
int f[201][40001];
int sum[201];
int main(){
	cin&gt;&gt;n;for(int i=1;i&lt;=n;i++)cin&gt;&gt;s[i].a&gt;&gt;s[i].b;sort(s+1,s+1+n);
	for(int i=1;i&lt;=n;i++)sum[i]=sum[i-1]+s[i].a;
	memset(f,0x7f,sizeof(f));
	int B=f[0][0];
	f[0][0]=0;
	for(int i=1;i&lt;=n;i++)
	for(int j=0;j&lt;=sum[i-1];j++){
		if(f[i-1][j]==B)continue;
		f[i][j]=min(f[i][j],max(f[i-1][j],sum[i-1]-j+s[i].a+s[i].b));
		f[i][j+s[i].a]=min(f[i][j+s[i].a],max(f[i-1][j],j+s[i].a+s[i].b));
	}
	int ans=2147483647;
	for(int i=0;i&lt;=sum[n];i++)ans=min(ans,f[n][i]);
	cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem1899</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
int n;
struct THU{
	int a,b;
	bool operator &lt; (const THU &amp;x)const{
		return b&gt;x.b;
	}
};
THU s[201];
int f[201][40001];
int sum[201];
int main(){
	cin&gt;&gt;n;for(int i=1;i&lt;=n;i++)cin&gt;&gt;s[i].a&gt;&gt;s[i].b;sort(s+1,s+1+n);
	for(int i=1;i&lt;=n;i++)sum[i]=sum[i-1]+s[i].a;
	memset(f,0x7f,sizeof(f));
	int B=f[0][0];
	f[0][0]=0;
	for(int i=1;i&lt;=n;i++)
	for(int j=0;j&lt;=sum[i-1];j++){
//		if(f[i-1][j]==B)continue;
		f[i][j]=min(f[i][j],max(f[i-1][j],sum[i-1]-j+s[i].a+s[i].b));
		f[i][j+s[i].a]=min(f[i][j+s[i].a],max(f[i-1][j],j+s[i].a+s[i].b));
	}
	int ans=2147483647;
	for(int i=0;i&lt;=sum[n];i++)ans=min(ans,f[n][i]);
	cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem1901</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
int a[10010];
int b[10010];
int n,m;
int main(){
	cin&gt;&gt;n&gt;&gt;m;
	for(int i=1;i&lt;=n;i++)cin&gt;&gt;a[i];
	int l,r,k;
	string s;
	while(m--){
		cin&gt;&gt;s;
		if(s[0]=='Q'){
			cin&gt;&gt;l&gt;&gt;r&gt;&gt;k;
			for(int j=l;j&lt;=r;j++)
			b[j]=a[j];
			sort(&amp;b[l],&amp;b[r+1]);
			cout&lt;&lt;b[l+k-1]&lt;&lt;endl;
		}else{
			cin&gt;&gt;l&gt;&gt;r;
			a[l]=r;
			
		}
	}
	return 0;	
}</pre><pre></pre><h2>Problem1901</h2><pre>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
#include&lt;cstring&gt;
#define maxn 220000
#define inf 1000000000

using namespace std;
struct query
{
    int x,y,k,s,tp,cur;
}q[maxn],q1[maxn],q2[maxn];
int a[maxn],ans[maxn],tmp[maxn],t[maxn];
int n,m,num,cnt;

void add(int x,int y)
{
    for (int i=x;i&lt;=n;i+=(i&amp;-i)) t[i]+=y;
}

int ask(int x)
{
    int tmp=0;
    for (int i=x;i&gt;0;i-=(i&amp;-i)) tmp+=t[i];
    return tmp;
}

void divide(int head,int tail,int l,int r)
{
    //cout&lt;&lt;head&lt;&lt;' '&lt;&lt;tail&lt;&lt;' '&lt;&lt;l&lt;&lt;' '&lt;&lt;r&lt;&lt;endl;
    if (head&gt;tail) return ;
    if (l==r) 
    {
        for (int i=head;i&lt;=tail;i++)
            if (q[i].tp==3) ans[q[i].s]=l;//,cout&lt;&lt;l&lt;&lt;endl;
        return ;
    }
    int mid=(l+r)&gt;&gt;1;
    for (int i=head;i&lt;=tail;i++)
    {
        if (q[i].tp==1&amp;&amp;q[i].y&lt;=mid) add(q[i].x,1);
        else
        if (q[i].tp==2&amp;&amp;q[i].y&lt;=mid) add(q[i].x,-1);
        else
        if (q[i].tp==3) tmp[i]=ask(q[i].y)-ask(q[i].x-1);
    }
    for (int i=head;i&lt;=tail;i++)
    {
        if (q[i].tp==1&amp;&amp;q[i].y&lt;=mid) add(q[i].x,-1);
        else
        if (q[i].tp==2&amp;&amp;q[i].y&lt;=mid) add(q[i].x,1);
    }
    int l1=0,l2=0;
    for (int i=head;i&lt;=tail;i++)
        if (q[i].tp==3)
        {
            if (q[i].cur+tmp[i]&gt;q[i].k-1)//q[i].cur+tmp[i]表示累积了多少个数
                q1[++l1]=q[i];
            else
            {
                q[i].cur+=tmp[i];
                q2[++l2]=q[i];
            }
        }
        else
        {
            if (q[i].y&lt;=mid) q1[++l1]=q[i];
            else q2[++l2]=q[i];
        }
    for (int i=1;i&lt;=l1;i++) q[head+i-1]=q1[i];
    for (int i=1;i&lt;=l2;i++) q[head+l1+i-1]=q2[i];
    divide(head,head+l1-1,l,mid);
    divide(head+l1,tail,mid+1,r);
}    

int main()
{
    //freopen("ranking.in","r",stdin);
    //freopen("ranking.out","w",stdout);
    scanf("%d%d",&amp;n,&amp;m);
    for (int i=1;i&lt;=n;i++) 
    {
        scanf("%d",&amp;a[i]);
        q[++num].x=i; q[num].y=a[i];
        q[num].tp=1; q[num].s=0;
    }
    char sign;
    int x,y,z;
    for (int i=1;i&lt;=m;i++)
    {
        scanf("\n%c",&amp;sign);
        if (sign=='Q')
        {
            scanf("%d%d%d",&amp;x,&amp;y,&amp;z);
            q[++num].x=x,q[num].y=y,q[num].k=z;
            q[num].tp=3; q[num].s=++cnt;
        }
        else
        {
            scanf("%d%d",&amp;x,&amp;y);
            q[++num].x=x; q[num].y=a[x]; 
            q[num].tp=2; q[num].s=0;
            q[++num].x=x; q[num].y=y;
            q[num].tp=1; q[num].s=0;
            a[x]=y;
        }
    }
    divide(1,num,0,inf);
    for (int i=1;i&lt;=cnt;i++)
        printf("%d\n",ans[i]);
    return 0;
}</pre><pre></pre><h2>Problem1901</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=10005;
int d[maxn];
int n,m;
int a[maxn];
int lowbit(int x){
	return x&amp;-x;
}
int get(int x){
	int ans=0;
	while(x)ans+=d[x],x-=lowbit(x);
	return ans;
}
void updata(int x,int y){
	while(x&lt;=n)d[x]+=y,x+=lowbit(x);
}
struct qes{
	int x,y,z,ty,ind,cur,delta;
}q[maxn*3];
int cnt=0,anss[maxn],tmp[maxn],md,mx;
bool part(qes &amp;Q){
	if(Q.ty==3){
		if(Q.cur+Q.delta&gt;Q.z-1)return true;
		Q.cur+=Q.delta;Q.delta=0;return false;
	}return Q.y&lt;=md;
}
void solve(int lef,int rig,int l,int r){
	if(lef&gt;rig)return;
	if(l==r){
		for(int i=lef;i&lt;=rig;i++)if(q[i].ty==3)
		anss[q[i].ind]=l;return;
	}int mid=(l+r)&gt;&gt;1;md=mid;
	for(int i=lef;i&lt;=rig;i++){
		if(q[i].ty==1&amp;&amp;q[i].y&lt;=mid)updata(q[i].x,1);
		if(q[i].ty==2&amp;&amp;q[i].y&lt;=mid)updata(q[i].x,-1);
		if(q[i].ty==3)q[i].delta=get(q[i].y)-get(q[i].x-1);
	}
	for(int i=lef;i&lt;=rig;i++){
		if(q[i].ty==1&amp;&amp;q[i].y&lt;=mid)updata(q[i].x,-1);
		if(q[i].ty==2&amp;&amp;q[i].y&lt;=mid)updata(q[i].x,1);
	}
	int dv=stable_partition(q+lef,q+rig+1,part)-q-1;
	solve(lef,dv,l,mid);
	solve(dv+1,rig,mid+1,r);
}
int main(){
	scanf("%d%d",&amp;n,&amp;m);
	for(int i=1;i&lt;=n;i++){
		scanf("%d",&amp;a[i]);mx=max(mx,a[i]);
		q[++cnt]=(qes){i,a[i],0,1,0,0,0};
	}for(int i=1;i&lt;=m;i++){
		char op=getchar();while(op!='Q'&amp;&amp;op!='C')op=getchar();
		if(op=='Q'){
			int l,r,k;
			scanf("%d%d%d",&amp;l,&amp;r,&amp;k);
			q[++cnt]=(qes){l,r,k,3,++anss[0],0,0};
		}else{
			int x,y;
			scanf("%d%d",&amp;x,&amp;y);
			q[++cnt]=(qes){x,a[x],0,2,0,0,0};
			q[++cnt]=(qes){x,y,0,1,0,0,0};
			a[x]=y;mx=max(mx,a[x]);
		}
	}	
	solve(1,cnt,0,mx);
	for(int i=1;i&lt;=anss[0];i++)printf("%d\n",anss[i]);
	return 0;
}</pre><pre></pre><h2>Problem1907</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1e4+10;
vector&lt;int&gt;G[maxn];
bool vis[maxn];
int siz[maxn],son[maxn],top[maxn],fa[maxn],dep[maxn],w[maxn],z,f[maxn];
void dfs(int u){
	siz[u]=1;
	for(int i=0;i&lt;G[u].size();i++){
		int v=G[u][i];
		if(v!=fa[u]){
			fa[v]=u;
			dfs(v);
			siz[u]+=siz[v];
			if(siz[son[u]]&lt;siz[v])son[u]=v;
		}
	}
}
void build(int u,int tp){
	w[u]=++z;top[u]=tp;
	if(son[u])build(son[u],tp);
	for(int i=0;i&lt;G[u].size();i++){
		int v=G[u][i];
		if(v!=fa[u]&amp;&amp;v!=son[u])build(v,v);
	}
}
void calc(int u){
	f[u]=1;
	int tot=0;
	for(int i=0;i&lt;G[u].size();i++){
		int v=G[u][i];
		if(v==fa[u])continue;
		calc(v);
		f[u]+=f[v];
		if(!vis[v])tot++;
	}if(tot&gt;=2)f[u]-=2,vis[u]=1;
	else f[u]-=tot==1;
}
int n,T;
int main(){
	scanf("%d",&amp;T);
	while(T--){
		scanf("%d",&amp;n);
		z=0;
		
		memset(siz,0,sizeof(siz));
		memset(vis,0,sizeof(vis));
		memset(son,0,sizeof(son));
		memset(top,0,sizeof(top));
		memset(fa,0,sizeof(fa));
		memset(dep,0,sizeof(dep));
		memset(w,0,sizeof(w));
		for(int i=1;i&lt;=n;i++)G[i].clear();
		for(int i=2;i&lt;=n;i++){
			int u,v;scanf("%d%d",&amp;u,&amp;v);
			G[u].push_back(v);
			G[v].push_back(u);
		}
		dfs(1);
		build(1,1);
		calc(1);
		printf("%d\n",f[1]);
	}	
}</pre><pre></pre><h2>Problem1911</h2><pre>#include&lt;cstdio&gt;
#include&lt;deque&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#define B q.size()-1
using namespace std;
typedef long long lld;
lld a,b,c;
lld f[1000001];
lld s[1000001];
deque&lt;int&gt;q;
lld G(lld j,lld k){
	return f[j]-f[k]+a*s[j]*s[j]-a*s[k]*s[k]
							-b*s[j]+b*s[k];
}
int n;
int main(){
	ios::sync_with_stdio(false);
	cin&gt;&gt;n;
	cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;
	for(int i=1;i&lt;=n;i++){
		cin&gt;&gt;s[i];s[i]+=s[i-1];
	}
	q.push_back(0);
	for(int i=1;i&lt;=n;i++){
		while(q.size()&gt;1
		&amp;&amp;G(q[0],q[1])&lt;=2*a*s[i]*(s[q[0]]-s[q[1]]))
		q.pop_front();
		int j=q.front();
		f[i]=f[j]+a*(s[i]-s[j])*(s[i]-s[j])
				+b*(s[i]-s[j])+c;
		while(q.size()&gt;1
		&amp;&amp;G(q[B-1],q[B])*(s[q[B]]-s[i])&lt;=
		G(q[B],i)*(s[q[B-1]]-s[q[B]]))q.pop_back();
		q.push_back(i);
	}
	cout&lt;&lt;f[n]&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem1922</h2><pre>/*
	ID:zky
	OJ:Cena
	Index:landcraft
	Language:C++
*/
#include&lt;deque&gt;
#include&lt;cstdlib&gt;
#include&lt;queue&gt;
#include&lt;vector&gt;
#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#define read(x) scanf("%I64d",&amp;x)
#define read3(x,y,z) scanf("%I64d%I64d%I64d",&amp;x,&amp;y,&amp;z)
using namespace std;
typedef long long lld;
struct edge{
	lld u,v,w;
	edge(){
	}
	edge(lld _u,lld _v,lld _w):
		u(_u),v(_v),w(_w){}
};
vector&lt;edge&gt;edges;
vector&lt;int&gt;G[3101];
void add(lld u,lld v,lld w){
	edges.push_back(edge(u,v,w));
	G[u].push_back(edges.size()-1);
}
int map[3001][3001];
int out[3100];
lld q=0;
lld n,m;
void init(){
	read(n);
	read(m);
	lld u,v,w;
	for(lld i=1;i&lt;=m;i++){
		read3(u,v,w);
		add(u,v,w);
	}
	lld s,x;
	for(lld i=1;i&lt;=n;i++){
		read(out[i]);
		for(lld j=1;j&lt;=out[i];j++){
			read(x);
			map[x][++map[x][0]]=i;
		}
	}
}
lld d[3100];
int vis[3100];
int can[3100];
void zky(){
	for(int i=0;i&lt;3100;i++)d[i]=1e8+10;
	d[1]=0;
	for(int i=1;i&lt;=n;i++){
		int u=0;
		for(int j=1;j&lt;=n;j++){
			if(!out[j]&amp;&amp;!vis[j]&amp;&amp;d[j]&lt;d[u])u=j;
		}
		if(u==n)break;
		vis[u]=1;
		for(int j=1;j&lt;=map[u][0];j++){
			int v=map[u][j];
			out[v]--;
			d[v]=max(d[v],d[u]);
		}
		for(int j=0;j&lt;G[u].size();j++){
			int v=edges[G[u][j]].v;
			int w=edges[G[u][j]].w;
			d[v]=min(d[v],d[u]+w);
		}
	}
cout&lt;&lt;d[n]&lt;&lt;endl;
}
int main(){
	init();
	zky();	
	return 0;
}
/*
5 8
1 2 1
1 3 1
1 5 1
2 3 1
3 4 1
4 2 1
3 5 1
4 5 1
0
2 3 4 
2 2 4
2 2 3
0
*/</pre><pre></pre><h2>Problem1923</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1010;
int n,m,ans;
bitset&lt;maxn&gt;a[maxn&lt;&lt;1];
bool Gauss(){
	for(int i=1;i&lt;=n;i++){
		int r=0;
		for(int j=i;j&lt;=m;j++)
		if(a[j][i]){r=j;break;}
		if(!r)return 0;
		ans=max(ans,r);
		swap(a[i],a[r]);
		for(int j=i+1;j&lt;=m;j++)
		if(a[j][i])a[j]^=a[i];
	}for(int i=n;i&gt;=1;i--){
		for(int j=i+1;j&lt;=n;j++)if(a[i][j])
		a[i][n+1]=a[i][n+1]^a[j][n+1];
	}return 1;
}
int main(){
	scanf("%d%d",&amp;n,&amp;m);
	for(int i=1;i&lt;=m;i++){
		char c=getchar();
		while(!isdigit(c))c=getchar();
		for(int j=1;j&lt;=n;j++){
			a[i][j]=c=='1';
			c=getchar();
		}c=getchar();
		a[i][n+1]=c=='1'; 
	}
	if(Gauss()){
		printf("%d\n",ans);
		for(int i=1;i&lt;=n;i++)puts(a[i][n+1]?"?y7M#":"Earth");	
	}else{puts("Cannot Determine");}
	return 0;
}</pre><pre></pre><h2>Problem1924</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1e5+5;
int getint(){
	int res=0;char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))res=res*10+c-'0',c=getchar();
	return res;
}
int X[maxn],Y[maxn],T[maxn],R,C;
map&lt;pair&lt;int,int&gt;,int&gt;M;
map&lt;int,vector&lt;int&gt; &gt;xx,yy;
vector&lt;int&gt;G[maxn];
vector&lt;int&gt;Ge[maxn];
stack&lt;int&gt;S;
bool ins[maxn];
int dfn[maxn],low[maxn],z,cnt,bel[maxn],w[maxn];
void dfs(int u){
	dfn[u]=low[u]=++z;ins[u]=1;S.push(u);
	for(int v,i=0;i&lt;G[u].size();i++){
		if(!dfn[v=G[u][i]]){
			dfs(v);
			low[u]=min(low[u],low[v]);
		}else if(ins[v])low[u]=min(low[u],dfn[v]);
	}if(dfn[u]==low[u]){
		int v;cnt++;
		do{
			v=S.top();
			bel[v]=cnt;
			w[cnt]++;ins[v]=0;
			S.pop();
		}while(u!=v);
	}
}
void add(int u,int v){
//	cerr&lt;&lt;u&lt;&lt;" "&lt;&lt;v&lt;&lt;endl;
	G[u].push_back(v);
}
int F[maxn],vis[maxn];
int f(int u){
	if(vis[u])return F[u];
	int ans=w[u];vis[u]=1;
	for(int v,i=0;i&lt;Ge[u].size();i++)
		ans=max(ans,w[u]+f(Ge[u][i]));	
	return F[u]=ans;
}
bool byX(int i,int j){return X[i]&lt;X[j];}
bool byY(int i,int j){return Y[i]&lt;Y[j];}
void deb(vector&lt;int&gt;v){
	ostream_iterator&lt;int&gt;out(cerr," ");
	copy(v.begin(),v.end(),out);fputs("",stderr);
}
int main(){
	int n=getint();R=getint();C=getint();
	static int xxx[maxn],yyy[maxn];
	for(int i=1;i&lt;=n;i++){
		X[i]=getint();Y[i]=getint();T[i]=getint();
		M[pair&lt;int,int&gt;(X[i],Y[i])]=i;
		xx[X[i]].push_back(i);
		yy[Y[i]].push_back(i);
		xxx[++xxx[0]]=X[i];
		yyy[++yyy[0]]=Y[i];
	}
	for(int i=1;i&lt;=n;i++)sort(xx[xxx[i]].begin(),xx[xxx[i]].end(),byY);
	for(int i=1;i&lt;=n;i++)sort(yy[yyy[i]].begin(),yy[yyy[i]].end(),byX);	
	for(int i=1;i&lt;=n;i++){
		if(T[i]==1){
//			deb(xx[X[i]]);
			int j;
			for(j=upper_bound(xx[X[i]].begin(),xx[X[i]].end(),i,byY)-xx[X[i]].begin();j&lt;xx[X[i]].size()&amp;&amp;T[xx[X[i]][j]]!=1;j++)
				add(i,xx[X[i]][j]);
			if(j&lt;xx[X[i]].size())add(i,xx[X[i]][j]);
			for(j=(lower_bound(xx[X[i]].begin(),xx[X[i]].end(),i,byY))-xx[X[i]].begin()-1;j&gt;=0&amp;&amp;T[xx[X[i]][j]]!=1;j--)
				add(i,xx[X[i]][j]);		
			if(j&gt;=0)add(i,xx[X[i]][j]);	
		}else
		if(T[i]==2){
			int j;
			for(j=upper_bound(yy[Y[i]].begin(),yy[Y[i]].end(),i,byX)-yy[Y[i]].begin();j&lt;yy[Y[i]].size()&amp;&amp;T[yy[Y[i]][j]]!=2;j++)
				add(i,yy[Y[i]][j]);
			if(j&lt;yy[Y[i]].size())add(i,yy[Y[i]][j]);
			for(j=(lower_bound(yy[Y[i]].begin(),yy[Y[i]].end(),i,byX))-yy[Y[i]].begin()-1;j&gt;=0&amp;&amp;T[yy[Y[i]][j]]!=2;j--)
				add(i,yy[Y[i]][j]);	
			if(j&gt;=0)add(i,yy[Y[i]][j]);	
		}else{
			const int dx[8]={0,0,1,1,1,-1,-1,-1};
			const int dy[8]={1,-1,0,1,-1,0,1,-1};
			for(int k=0;k&lt;8;k++){
				int x=X[i]+dx[k],y=Y[i]+dy[k];
				if(x&lt;1||x&gt;R||y&lt;1||y&gt;C)continue;
				if(M.count(pair&lt;int,int&gt;(x,y))){
					int sec=M[pair&lt;int,int&gt;(x,y)];
					add(i,sec);
				}				
			}
		}
	}for(int i=1;i&lt;=n;i++)if(!dfn[i])
	dfs(i);
	for(int i=1;i&lt;=n;i++)for(int v,j=0;j&lt;G[i].size();j++)if(bel[i]!=bel[v=G[i][j]])
	Ge[bel[i]].push_back(bel[v]);//,cerr&lt;&lt;bel[i]&lt;&lt;" "&lt;&lt;bel[v]&lt;&lt;endl;
	int ans=0;
	for(int i=1;i&lt;=n;i++)
	ans=max(ans,f(i));
	cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem1925</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
LL n,p;
LL f[2][4201];
int main(){
	cin&gt;&gt;n&gt;&gt;p;
	if(n==1){
		puts("1");
		return 0;
	}
	f[1][1]=1;
	int cur=1;
	for(int i=2;i&lt;=n;i++){
		cur^=1;
		for(int j=1;j&lt;=n;j++){
			f[cur][j]=f[cur][j-1];
			if(i&gt;=j)f[cur][j]+=f[cur^1][i-j];			
			if(f[cur][j]&gt;=p)f[cur][j]-=p;
		}
	}cout&lt;&lt;f[cur][n]*2%p&lt;&lt;endl;
}</pre><pre></pre><h2>Problem1927</h2><pre>/*
	ID:zky
	OJ:BZOJ
	Index:1927
	Language:C++
*/
#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
#include&lt;queue&gt;  
#include&lt;vector&gt;  
#include&lt;cstdio&gt;  
#include&lt;cstring&gt;  
#include&lt;climits&gt;  
#include&lt;iostream&gt;  
#include&lt;algorithm&gt;  
#define clear(x) memset(x,0,sizeof(x))  
#define inf(x) memset(x,0x7f,sizeof(x))  
#define Size G[u].size()  
#define read3(x,y,z) scanf("%d%d%d",&amp;x,&amp;y,&amp;z)  
#define read4(x,y,z,w) scanf("%d%d%d%d",&amp;x,&amp;y,&amp;z,&amp;w)  
using namespace std;  
int s,t;  
int n,m,k;  
const int INF=INT_MAX;  
struct edge{  
    int u,v,cap,flow,cost;  
};  
vector&lt;edge&gt;edges;  
vector&lt;vector&lt;int&gt; &gt;G;  
int d[3001];  
int cur[3001];  
int vis[3001];  
int prev[3001];  
void add(int u,int v,int cap,int cost){  
    edges.push_back((edge){u,v,cap,0,cost});  
    G[u].push_back(edges.size()-1); 
    edges.push_back((edge){v,u,0,0,-cost});  
    G[v].push_back(edges.size()-1); 	 
}  
int a[3001];  
bool spfa(int  &amp;flow,int &amp;cost){  
    queue&lt;int&gt;q;  
    q.push(s);  
    memset(d,0x7f,sizeof(d));  
    memset(vis,0,sizeof(vis));  
    int B=d[0];  
    d[s]=0;  
    vis[s]=1;  
    a[s]=INF;  
    while(!q.empty()){  
        int u=q.front();q.pop();vis[u]=0;  
        for(int i=0;i&lt;G[u].size();i++){  
            edge &amp;e=edges[G[u][i]];  
            if(e.cap-e.flow&gt;0&amp;&amp;d[e.v]&gt;d[u]+e.cost){  
                d[e.v]=d[u]+e.cost;  
                prev[e.v]=G[u][i];  
                a[e.v]=min(a[u],e.cap-e.flow);  
                if(!vis[e.v]){  
                    vis[e.v]=1;  
                    q.push(e.v);  
                }  
            }  
        }  
    }  
    if(d[t]==B)return false;  
    int u=t;  
    flow+=a[t];  
    cost+=a[t]*d[t];  
    while(u!=s){  
        edges[prev[u]].flow+=a[t];  
        edges[prev[u]^1].flow-=a[t];  
        u=edges[prev[u]].u;  
    }  
    return true;  
}  
int flow,cost;
void costflow(){  
    flow=0;cost=0;  
    while(spfa(flow,cost));  
    cout&lt;&lt;cost&lt;&lt;endl;  
}  
//int a[888];
int main(){
	cin&gt;&gt;n&gt;&gt;m;
	G.resize(n*2+10);
	s=0;t=2*n+1;
	for(int i=1;i&lt;=n;i++){
		cin&gt;&gt;a[i];
		add(s,i+n,1,a[i]);
	}
	for(int i=1;i&lt;=m;i++){
		int u,v,w;
		read3(u,v,w);
		if(u&gt;v)swap(u,v);
		add(u,v+n,1,w);
	}
	for(int i=1;i&lt;=n;i++){
		add(s,i,1,0);
		add(i+n,t,1,0);
	}
	costflow();
	return 0;
}</pre><pre></pre><h2>Problem1930</h2><pre>#include&lt;bits/stdc++.h&gt;
#define in(i) (i&lt;&lt;1)
#define out(i) (i&lt;&lt;1|1)
using namespace std;
const int maxn=4020;
int n,s,t;
struct edge{
	int u,v,cap,flow,cost;
	edge(int _u=0,int _v=0,int _cap=0,int _flow=0,int _cost=0):
		u(_u),v(_v),cap(_cap),flow(_flow),cost(_cost){}
};
vector&lt;edge&gt;edges;
vector&lt;int&gt;G[maxn];
int pre[maxn],a[maxn],d[maxn],vis[maxn],cost;
void add(int u,int v,int cap,int cost){
	edges.push_back(edge(u,v,cap,0,cost));
	G[u].push_back(edges.size()-1);
	edges.push_back(edge(v,u,0,0,-cost));
	G[v].push_back(edges.size()-1);
}
bool spfa(){
	queue&lt;int&gt;q;
	q.push(s);
	memset(d,0xaf,sizeof d);int B=d[0];d[s]=0;a[s]=INT_MAX;
	while(!q.empty()){
		int u=q.front();q.pop();vis[u]=0;
		for(int i=0;i&lt;G[u].size();i++){
			edge e=edges[G[u][i]];
			if(e.cap&gt;e.flow&amp;&amp;d[e.v]&lt;d[u]+e.cost){
				d[e.v]=d[u]+e.cost;
				pre[e.v]=G[u][i];
				a[e.v]=min(a[u],e.cap-e.flow);
				if(!vis[e.v]){
					vis[e.v]=1;
					q.push(e.v);
				}
			}
		}
	}
	if(d[t]==B)return false;
	cost+=d[t]*a[t];
	for(int u=t;u!=s;u=edges[pre[u]].u){
		edges[pre[u]].flow+=a[t];
		edges[pre[u]^1].flow-=a[t];
	}return true;
}
pair&lt;int,int&gt;p[maxn];
int main(){
	scanf("%d",&amp;n);s=0;t=(n&lt;&lt;1|1)+1;int ss=(n&lt;&lt;1|1)+2,tt=(n&lt;&lt;1|1)+3;
	for(int i=1;i&lt;=n;i++)scanf("%d%d",&amp;p[i].first,&amp;p[i].second);
	sort(p+1,p+1+n);
	add(s,ss,2,0);add(tt,t,2,0);
	for(int i=1;i&lt;=n;i++){
		add(ss,in(i),1,0);
		add(in(i),out(i),1,1);
		add(in(i),out(i),1,0);
		add(out(i),tt,1,0);	
	}
	for(int i=1;i&lt;=n;i++){
		int miny=INT_MAX;
		for(int j=i+1;j&lt;=n;j++){
			if(p[j].second&gt;=p[i].second&amp;&amp;p[j].second&lt;miny)
			add(out(i),in(j),2,0),miny=min(miny,p[j].second);		
		}
	}int deb=0;
	if(deb)
	for(int i=0;i&lt;edges.size();i++)if(i%2==0)
	printf("%d-&gt;%d cap:%d cost:%d\n",edges[i].u,edges[i].v,edges[i].cap,edges[i].cost);
	
	
	while(spfa());
	cout&lt;&lt;cost&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem1932</h2><pre>#include&lt;cstdio&gt;
#include&lt;stack&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#include&lt;vector&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
int n;
int tot=0;
map&lt;set&lt;int&gt;,int&gt;M;
stack&lt;set&lt;int&gt; &gt;Stack;
int Push(){
	set&lt;int&gt; nl;
	Stack.push(nl);
	return 0;
}
int Dup(){
	Stack.push(Stack.top());
	return Stack.top().size();
}
int Union(){
	set&lt;int&gt; x,y,z;
	x=Stack.top();Stack.pop();
	y=Stack.top();Stack.pop();
	set_union(x.begin(),x.end(),y.begin(),y.end(),inserter(z,z.begin()));
	Stack.push(z);
	return z.size();
}
int Intersect(){
	set&lt;int&gt; x,y,z;
	x=Stack.top();Stack.pop();
	y=Stack.top();Stack.pop();
	set_intersection(x.begin(),x.end(),y.begin(),y.end(),inserter(z,z.begin()));
	Stack.push(z);
	return z.size();		
}
int Add(){
	set&lt;int&gt; x,y;
	x=Stack.top();Stack.pop();
	y=Stack.top();Stack.pop();
//	int res=M[x];
	if(!M[x])M[x]=++tot;
	y.insert(M[x]);
	Stack.push(y);
	return y.size();	
}
int main(){
	scanf("%d",&amp;n);
	while(n--){
		char op[10];
		scanf("%s",op);
		if(op[0]=='P')
			printf("%d\n",Push());
		else if(op[0]=='D')
			printf("%d\n",Dup());
		else if(op[0]=='U')
			printf("%d\n",Union());
		else if(op[0]=='I')
			printf("%d\n",Intersect());
		else if(op[0]=='A')
			printf("%d\n",Add());
	}
	return 0;
}</pre><pre></pre><h2>Problem1934</h2><pre>/*
	ID:zky
	OJ:BZOJ
	Index:2768
	Language:C++
*/
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
int w[301][301];
int a[301];
int n,m;
int vis[301];
int Link[302];
bool find(int x){
	for(int i=1;i&lt;=n;i++){
		if(w[x][i]&amp;&amp;!vis[i]){
			vis[i]=1;
			if(!Link[i]||find(Link[i])){
				Link[i]=x;
				return true;
			}
		}
	}
	return false;
}
int main(){
	cin&gt;&gt;n&gt;&gt;m;
	for(int i=1;i&lt;=n;i++)cin&gt;&gt;a[i];
	for(int i=1;i&lt;=m;i++){
		int Alice,Bob;
		cin&gt;&gt;Alice&gt;&gt;Bob;
		if(a[Alice]^a[Bob])w[Alice][Bob]=w[Bob][Alice]=1;
	}
	int ans=0;
	for(int i=1;i&lt;=n;i++){
		memset(vis,0,sizeof(vis));
		if(find(i))ans++;
	}
	cout&lt;&lt;ans/2&lt;&lt;endl;
	return 0;
}
 </pre><pre></pre><h2>Problem1935</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=500010;
int n,m;
int d[maxn];
int lowbit(int x){return x&amp;-x;}
void updata(int x){
	for(int i=x;i&lt;maxn;i+=lowbit(i))d[i]++;
}
int get(int x){
	int ans=0;for(int i=x;i;i-=lowbit(i))ans+=d[i];return ans;
}
int getint(){
	int res=0;char ch=getchar();
	while(!isdigit(ch))ch=getchar();
	while(isdigit(ch))(res*=10)+=ch-'0',ch=getchar();
	return res;
}
struct qes{
	int x,y,ind,f;
	bool operator&lt;(const qes &amp;a)const{
		return x&lt;a.x||(x==a.x&amp;&amp;y&lt;a.y)||(x==a.x&amp;&amp;y==a.y&amp;&amp;ind&lt;a.ind);
	}
};
struct Point{
	int x,y;
	bool operator&lt;(const Point &amp;a)const{
		return x&lt;a.x||(x==a.x&amp;&amp;y&lt;a.y); 
	}
};
qes Q[maxn&lt;&lt;2];
int siz=0;
map&lt;int,int&gt;Y;
Point p[maxn];
int anss[maxn];
int main(){
	n=getint();m=getint();
	for(int i=1;i&lt;=n;i++){
		p[i].x=getint()+1;
		p[i].y=getint()+1;
		Y[p[i].y]=1;
	}sort(p+1,p+1+n);
	for(int i=1;i&lt;=m;i++){
		int x1=getint()+1,y1=getint()+1,x2=getint()+1,y2=getint()+1;
		Y[y1-1]=1;
		Y[y2]=1;
		siz++;
		Q[siz].x=x2;
		Q[siz].y=y2;
		Q[siz].ind=i;
		Q[siz].f=1*(x2&gt;0&amp;&amp;y2&gt;0);
		siz++;
		Q[siz].x=x2;
		Q[siz].y=y1-1;
		Q[siz].ind=i;
		Q[siz].f=-1*(x2&gt;0&amp;&amp;y1-1&gt;0);
		siz++;
		Q[siz].x=x1-1;
		Q[siz].y=y2;
		Q[siz].ind=i;
		Q[siz].f=-1*(x1-1&gt;0&amp;&amp;y2&gt;0);
		siz++;
		Q[siz].x=x1-1;
		Q[siz].y=y1-1;
		Q[siz].ind=i;
		Q[siz].f=1*(x1-1&gt;0&amp;&amp;y1-1&gt;0);		
	}sort(Q+1,Q+1+siz);
	int tot=0;
	for(map&lt;int,int&gt;::iterator it=Y.begin();it!=Y.end();it++)it-&gt;second=++tot;
	for(int i=1;i&lt;=n;i++)p[i].y=Y[p[i].y];
	for(int i=1;i&lt;=siz;i++)Q[i].y=Y[Q[i].y];
	int now=1;
	for(int i=1;i&lt;siz;){
		do{
			if(Q[i].f)
			for(int &amp;j=now;j&lt;=n&amp;&amp;p[j].x&lt;=Q[i].x;j++){
				updata(p[j].y);
			}anss[Q[i].ind]+=Q[i].f*(get(Q[i].y));i++;
		}while(i&lt;siz&amp;&amp;Q[i].f&amp;&amp;Q[i].x!=Q[i+1].x);
	}for(int &amp;j=now;j&lt;=n&amp;&amp;p[j].x&lt;=Q[siz].x;j++){
		updata(p[j].y);
	}anss[Q[siz].ind]+=Q[siz].f*(get(Q[siz].y));
	for(int i=1;i&lt;=m;i++)
	printf("%d\n",anss[i]);
	return 0;
}
/*
	3 1
	1 1
	2 2
	3 3
	1 1 3 3
*/</pre><pre></pre><h2>Problem1951</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
LL N,G;
LL fac[35619];
LL a[4],m[4]={2,3,4679,35617};
LL exgcd(LL a,LL b,LL &amp;x,LL &amp;y){
	if(!b){x=1;y=0;return a;}
	LL d=exgcd(b,a%b,x,y);LL t=x;
	x=y;y=t-a/b*y;return d;
}
LL power(LL x,LL k,LL p){
	LL ans=1;
	for(;k;k&gt;&gt;=1){
		if(k&amp;1)ans=(ans*x)%p;
		x=(x*x)%p;
	}return ans;
}
LL inv(LL a,LL n){LL x,y,d=exgcd(a,n,x,y);return d==1?(x+n)%n:-1;}
void get_fac(LL p){fac[0]=1;for(int i=1;i&lt;=p;i++)fac[i]=i*fac[i-1]%p;}
LL C(LL n,LL m,LL p){if(n&lt;m)return 0;return fac[n]*inv(fac[m]*fac[n-m]%p,p)%p;}
LL china(int n,LL *a,LL *m){
	LL M=1,x=0,y,d;
	for(int i=0;i&lt;n;i++)M*=m[i];
	for(int i=0;i&lt;n;i++){
		int w=M/m[i];
		d=exgcd(m[i],w,d,y);
		x=(x+y*w*a[i])%M;
	}while(x&lt;=0)x+=M;
	return x;
}
LL Lucas(LL n,LL m,LL p){
	LL ans=1;
	while(n&amp;&amp;m){
		LL a=n%p,b=m%p;
		if(a&lt;b)return 0;
		ans=(ans*C(a,b,p))%p;
		n/=p;m/=p;
	}return ans%p;
}
int main(){
	
	cin&gt;&gt;N&gt;&gt;G;//G%=999911659;
	for(int i=0;i&lt;4;i++){
		get_fac(m[i]);
		for(LL j=1;j*j&lt;=N;j++){
			if(N%j==0){
				a[i]=(a[i]+Lucas(N,j,m[i]))%m[i];
				if(j*j!=N)
				a[i]=(a[i]+Lucas(N,N/j,m[i]))%m[i];				
			}
		}
	}LL ans=china(4,a,m);
	cout&lt;&lt;power(G,ans,999911659)&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem1954</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1e5+5;
struct edge{int u,v,w;};
vector&lt;edge&gt;G[maxn];
int n,m,a[maxn];
void dfs(int u,int fa){
	for(int i=0;i&lt;G[u].size();i++){
		edge e=G[u][i];
		if(e.v==fa)continue;
		a[e.v]=a[u]^e.w;
		dfs(e.v,u);
	}
}
int ch[maxn&lt;&lt;4][2],tot;
short val[maxn&lt;&lt;4];
void insert(int x){
	int bit[32];
	for(int i=0;i&lt;32;i++)bit[i]=x&gt;&gt;i&amp;1;
	int u=0;
	for(int i=31;i&gt;=0;i--){
		if(!ch[u][bit[i]])
		ch[u][bit[i]]=++tot;
		u=ch[u][bit[i]];	
	}val[u]=1;
}
int Qmax(int x){
	int bit[32];
	for(int i=0;i&lt;32;i++)bit[i]=x&gt;&gt;i&amp;1;
	int u=0,ans=0;
	for(int i=31;i&gt;=0;i--){
		if(ch[u][!bit[i]]){
			ans|=(!bit[i])&lt;&lt;i;
			u=ch[u][!bit[i]];
		}else{
			ans|=bit[i]&lt;&lt;i;
			u=ch[u][bit[i]];
		}
	}return ans;
}
int main(){
	scanf("%d",&amp;n);
	for(int i=1;i&lt;n;i++){
		int u,v,w;scanf("%d%d%d",&amp;u,&amp;v,&amp;w);
		G[u].push_back((edge){u,v,w});
		G[v].push_back((edge){v,u,w});
	}dfs(1,1);int ans=0;
	for(int i=1;i&lt;=n;i++)insert(a[i]);
	for(int i=1;i&lt;=n;i++)ans=max(ans,a[i]^Qmax(a[i]));
	cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem1964</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const double eps=1e-6;
struct point3{
	double x,y,z;
	point3(double _x=0,double _y=0,double _z=0):x(_x),y(_y),z(_z){}
	point3 operator*(point3 o){return point3(y*o.z-o.y*z,z*o.x-o.z*x,x*o.y-o.x*y);}
	double operator^(point3 o){return x*o.x+y*o.y+z*o.z;}
	point3 operator+(point3 o){return point3(x+o.x,y+o.y,z+o.z);}
	point3 operator-(point3 o){return point3(x-o.x,y-o.y,z-o.z);}
}p[201],_p[201];
double randeps(){return (rand()/(double)RAND_MAX-0.5)*1e-7;}
point3 noise(point3 p){return point3(p.x+randeps(),p.y+randeps(),p.z+randeps());}
struct Face{
	int v[3];
	point3 normal()const{return (p[v[1]]-p[v[0]])*(p[v[2]]-p[v[0]]);}
	bool cansee(int x){return ((p[x]-p[v[0]])^normal())&gt;0;}
};
int n,in[201],vis[201][201];
vector&lt;Face&gt;cur;
void CH3D(){
	cur.push_back((Face){{1,2,3}});
	cur.push_back((Face){{3,2,1}});
	for(int i=4;i&lt;=n;i++){
		vector&lt;Face&gt;tmp;
		memset(vis,0,sizeof vis);
		for(int j=0;j&lt;cur.size();j++){
			Face f=cur[j];
			if(!f.cansee(i))
				tmp.push_back(f);
			else for(int k=0;k&lt;3;k++)vis[f.v[k]][f.v[(k+1)%3]]=1;
		}for(int j=0;j&lt;cur.size();j++){
			for(int k=0;k&lt;3;k++){
				int a=cur[j].v[k],b=cur[j].v[(k+1)%3];
				if(vis[a][b]!=vis[b][a]&amp;&amp;vis[a][b])
				tmp.push_back((Face){{a,b,i}});
			}
		}cur=tmp;
	}
}
double V6(point3 A,point3 B,point3 C,point3 D){
	return (B-A)*(C-A)^(D-A); 
}
double calc(){
	double ans=0;
	for(int i=0;i&lt;cur.size();i++)
	ans+=fabs(V6(_p[1],_p[cur[i].v[0]],_p[cur[i].v[1]],_p[cur[i].v[2]]));
	return ans/6;
}
int main(){
	double x,y,z;//scanf("%d",&amp;n);n=0;
	while(~scanf("%lf%lf%lf",&amp;x,&amp;y,&amp;z))_p[++n]=point3(x,y,z),p[n]=noise(_p[n]);
	CH3D();
	printf("%.2lf\n",calc());
	return 0;
}</pre><pre></pre><h2>Problem1965</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long lld;
lld n,m,l;
lld exgcd(lld a,lld b,lld &amp;x,lld &amp;y){
	if(!b){
		x=1;y=0;
		return a;
	}else{
		lld g=exgcd(b,a%b,x,y);
		lld t=x;
		x=y;
		y=t-a/b*y;
		return g;
	}
}
lld gcd(lld a,lld b){
	while(b){
		lld t=a;
		a=b;
		b=t%b;
	}
	return a;
}
lld power(lld x,lld k){
	lld ans=1;
	for(;k;k&gt;&gt;=1){
		if(k&amp;1)ans*=x;
		x*=x;
		if(x&gt;n)x%=(n+1);
		if(ans&gt;n)ans%=(n+1);
	}
	return ans;
}
int main(){
	cin&gt;&gt;n&gt;&gt;m&gt;&gt;l;
	m=power(2,m);
	//x*m=l(mod n+1) 
	//mx + (n+1) y =l
	//m'x+(n+1)' y=l'
	lld x,y;
	n=n+1;
	lld d=gcd(m,n);
	m/=d;n/=d;l/=d;
	exgcd(m,n,x,y);
	x=x*l%n;
	while(x&lt;0)x+=n;
	cout&lt;&lt;x&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem1967</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#define M 301
using namespace std;
struct abcd{
	int x,y,c;
	friend istream&amp; operator &gt;&gt; (istream &amp;_,abcd &amp;a)
	{
		scanf("%d%d%d",&amp;a.x,&amp;a.y,&amp;a.c);
		return _;
	}
}a[M];
struct Rectangle{
	int x1,x2,y1,y2;
}rectangles[M];
struct edge{
	int to,next;
}table[500500];
int head[M*M],tot;
int m=1,n=1,cnt,T;
int xa,ya,xb,yb,map[M][M],f[100100];
pair&lt;int,int*&gt; b[M];
bool map1[M][M],map2[M][M];
void Add(int x,int y)
{
	table[++tot].to=y;
	table[tot].next=head[x];
	head[x]=tot;
}
void Floodfill(int x,int y)
{
	
	int xx,yy;
	
	map[x][y]=T;

	xx=x,yy=y-1;
	if( !map1[x][y] )
	{
		if( y!=1 &amp;&amp; !map[xx][yy] )
			Floodfill(xx,yy);
	}
	else if(map[xx][yy])
		Add(T,map[xx][yy]),Add(map[xx][yy],T);
		
	xx=x,yy=y+1;
	if( !map1[x][y+1] )
	{
		if( y!=n &amp;&amp; !map[xx][yy] )
			Floodfill(xx,yy);
	}
	else if(map[xx][yy])
		Add(T,map[xx][yy]),Add(map[xx][yy],T);
		
	xx=x-1,yy=y;
	if( !map2[x][y] )
	{
		if( x!=1 &amp;&amp; !map[xx][yy] )
			Floodfill(xx,yy);
	}
	else if(map[xx][yy])
		Add(T,map[xx][yy]),Add(map[xx][yy],T);
		
	xx=x+1,yy=y;
	if( !map2[x+1][y] )
	{
		if( x!=m &amp;&amp; !map[xx][yy] )
			Floodfill(xx,yy);
	}
	else if(map[xx][yy])
		Add(T,map[xx][yy]),Add(map[xx][yy],T);

	
}
void BFS()
{
	static int q[65540];
	static unsigned short r,h;
	int i;
	f[q[++r]=map[xa][ya]]=1;
	while(r!=h)
	{
		int x=q[++h];
		for(i=head[x];i;i=table[i].next)
			if(!f[table[i].to])
				f[q[++r]=table[i].to]=f[x]+1;
	}
}
int main()
{
	int i,j;
	cin&gt;&gt;cnt;
	for(i=1;i&lt;=cnt;i++)
		cin&gt;&gt;a[i];
	cin&gt;&gt;xa&gt;&gt;ya&gt;&gt;xb&gt;&gt;yb;

	for(i=1;i&lt;=cnt;i++)
	{
		b[i+i-1]=make_pair(a[i].x,&amp;rectangles[i].x1);
		b[i&lt;&lt;1]=make_pair(a[i].x+a[i].c,&amp;rectangles[i].x2);
	}
	b[cnt&lt;&lt;1|1]=make_pair(xa,&amp;xa);
	b[cnt+1&lt;&lt;1]=make_pair(xb,&amp;xb);
	sort(b+1,b+(cnt+1&lt;&lt;1)+1);
	for(i=1;i&lt;=(cnt+1&lt;&lt;1);i++)
	{
		if(i==1||b[i].first!=b[i-1].first)
			++m;
		*b[i].second=m;
	}
	m+=2;

	for(i=1;i&lt;=cnt;i++)
	{
		b[i+i-1]=make_pair(a[i].y,&amp;rectangles[i].y1);
		b[i&lt;&lt;1]=make_pair(a[i].y+a[i].c,&amp;rectangles[i].y2);
	}
	b[cnt&lt;&lt;1|1]=make_pair(ya,&amp;ya);
	b[cnt+1&lt;&lt;1]=make_pair(yb,&amp;yb);
	sort(b+1,b+(cnt+1&lt;&lt;1)+1);
	for(i=1;i&lt;=(cnt+1&lt;&lt;1);i++)
	{
		if(i==1||b[i].first!=b[i-1].first)
			++n;
		*b[i].second=n;
	}
	n+=2;

	for(i=1;i&lt;=cnt;i++)
	{
		for(j=rectangles[i].x1;j&lt;rectangles[i].x2;j++)
			map1[j][rectangles[i].y1]=map1[j][rectangles[i].y2]=true;
		for(j=rectangles[i].y1;j&lt;rectangles[i].y2;j++)
			map2[rectangles[i].x1][j]=map2[rectangles[i].x2][j]=true;
	}

	for(i=1;i&lt;=m;i++)
		for(j=1;j&lt;=n;j++)
			if(!map[i][j])
				++T,Floodfill(i,j);

	BFS();
	cout&lt;&lt;f[map[xb][yb]]-1&lt;&lt;endl;
	return 0;
}
</pre><pre></pre><h2>Problem1968</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long lld;
int n;
int main(){
	cin&gt;&gt;n;
	long long ans=0;
	for(int i=1;i&lt;=n;i++){
		ans+=n/i;
	}cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem1975</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;queue&gt;
#include&lt;vector&gt;
#define pb push_back
#define mp make_pair
using namespace std;
const int maxn=5001;
int n,m;
double E;
vector&lt;pair&lt;int,double&gt; &gt;G[maxn],Ge[maxn];
double d[maxn];
struct State{
	int x;
	double g;
	bool operator&lt;(const State &amp;o)const{return d[x]+g&gt;d[o.x]+o.g;}
};
void spfa(){
	for(int i=1;i&lt;=n;i++)d[i]=2e9;d[n]=0;
	static bool vis[maxn];vis[n]=1;
	queue&lt;int&gt;q;q.push(n);
	while(!q.empty()){
		int u=q.front();q.pop();vis[u]=0;
		for(int v,i=0;i&lt;Ge[u].size();i++){
			v=Ge[u][i].first;double w=Ge[u][i].second;
			if(d[v]+1e-9&gt;d[u]+w){
				d[v]=d[u]+w;
				if(!vis[v])q.push(v),vis[v]=1;
			}
		}
	}
}
priority_queue&lt;State&gt;Q;
int dcmp(double x){return (x&gt;1e-9)-(x&lt;1e-9);}
int main(){
	scanf("%d%d%lf",&amp;n,&amp;m,&amp;E);
	for(int i=1;i&lt;=m;i++){
		int u,v;double w;scanf("%d%d%lf",&amp;u,&amp;v,&amp;w);
		G[u].pb(mp(v,w));
		Ge[v].pb(mp(u,w));
	}spfa();
	int ans=0;
	Q.push((State){1,0});
	while(!Q.empty()){
		int u=Q.top().x;double g=Q.top().g;Q.pop();
		if(u==n){if(E-(d[u]+g)&gt;0)E-=(d[u]+g),ans++;else break;}
		for(int i=0;i&lt;G[u].size();i++){
			int v=G[u][i].first;double w=G[u][i].second;
//			if(v==n)continue;
//			if(dcmp(g+w+d[v]-d[1]))
			Q.push((State){v,g+w});
		}
	}printf("%d\n",ans);
	return 0;
}</pre><pre></pre><h2>Problem1976</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=40*40*40+10;
struct edge{int u,v,cap,flow;};
vector&lt;edge&gt;edges;
vector&lt;int&gt;G[maxn];
int s,t;
int cur[maxn],d[maxn];
void add(int u,int v,int cap){
//	printf("%d-&gt;%d cap:%d\n",u,v,cap);
	edges.push_back((edge){u,v,cap,0});
	G[u].push_back(edges.size()-1);
	edges.push_back((edge){v,u,0,0});
	G[v].push_back(edges.size()-1);
}
bool bfs(){
	static int vis[maxn];
	memset(vis,0,sizeof vis);vis[s]=1;
	queue&lt;int&gt;q;q.push(s);d[s]=0;
	while(!q.empty()){
		int u=q.front();q.pop();
		for(int i=0;i&lt;G[u].size();i++){
			edge e=edges[G[u][i]];if(vis[e.v]||e.cap==e.flow)continue;
			d[e.v]=d[u]+1;vis[e.v]=1;q.push(e.v);
		}
	}return vis[t];
}
int dfs(int u,int a){
	if(u==t||!a)return a;
	int flow=0,f;
	for(int &amp;i=cur[u];i&lt;G[u].size();i++){
		edge e=edges[G[u][i]];
		if(d[e.v]==d[u]+1&amp;&amp;(f=dfs(e.v,min(a,e.cap-e.flow)))&gt;0){
			edges[G[u][i]].flow+=f;
			edges[G[u][i]^1].flow-=f;
			flow+=f;a-=f;if(!a)break;
		}
	}return flow;
}
int dinic(){
	int flow=0,x;
	while(bfs()){
		memset(cur,0,sizeof cur);
		while(x=dfs(s,INT_MAX)){
			flow+=x;
			memset(cur,0,sizeof cur);
		}
	}return flow;
}
int n,tot;
int hash[42][42][42],a[42][42][42];
const int dx[6]={0,0,0,0,1,-1};
const int dy[6]={0,0,1,-1,0,0};
const int dz[6]={1,-1,0,0,0,0};
int main(){
	scanf("%d",&amp;n);
	for(int i=1;i&lt;=n;i++)
	for(int j=1;j&lt;=n;j++){
		char s[42];scanf("%s",s+1);
		for(int k=1;k&lt;=n;k++)a[i][j][k]=s[k]=='?'?-1:s[k]=='P',hash[i][j][k]=++tot;
	}s=0;t=tot+1;int sum=0;
	for(int i=1;i&lt;=n;i++)
	for(int j=1;j&lt;=n;j++)
	for(int k=1;k&lt;=n;k++){
		int cnt=0;
		for(int l=0;l&lt;6;l++){
			int x=i+dx[l],y=j+dy[l],z=k+dz[l];
			if(x&lt;1||y&lt;1||z&lt;1||x&gt;n||y&gt;n||z&gt;n)continue;
			cnt++;
		}sum+=cnt;
		if((i+j+k)%2){
			add(s,hash[i][j][k],cnt);
			if(a[i][j][k]==1){add(s,hash[i][j][k],INT_MAX);}
			if(a[i][j][k]==0){add(hash[i][j][k],t,INT_MAX);}
			for(int l=0;l&lt;6;l++){
				int x=i+dx[l],y=j+dy[l],z=k+dz[l];
				if(x&lt;1||y&lt;1||z&lt;1||x&gt;n||y&gt;n||z&gt;n)continue;
				add(hash[i][j][k],hash[x][y][z],2);
			}	
		}else{
			add(hash[i][j][k],t,cnt);
			if(a[i][j][k]==0){add(s,hash[i][j][k],INT_MAX);}
			if(a[i][j][k]==1){add(hash[i][j][k],t,INT_MAX);}
		}
	}
//	for(int i=0;i&lt;edges.size();i++)if(i%2==0)
//	printf("%d-&gt;%d cap:%d\n",edges[i].u,edges[i].v,edges[i].cap);
	cout&lt;&lt;sum-dinic()&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem1977</h2><pre>#include&lt;cstdio&gt;
//#include&lt;ctime&gt;
#include&lt;climits&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
using namespace std;
const int maxn=1e5+10;
const int maxm=3e5+10;
struct edge{int u,v,w;edge(int _u=0,int _v=0,int _w=0){u=_u,v=_v,w=_w;} bool operator &lt; (const edge &amp;a)const {return w&lt;a.w;};};
vector&lt;edge&gt;G,Ge[maxn];
int vis[maxm];
int n,m;
int faa[maxn],a[maxn];
int find(int x){	
	if(faa[x]!=x)
		return faa[x]=find(faa[x]);
	return x;
}
long long ans=0;
int p[maxm][18],maxx[maxm][18],maxi[maxm][18],dep[maxn];
void updata(int &amp;a,int &amp;b,int x1,int y1,int x2,int y2){
    if(x1&gt;x2){  
        a=x1;b=max(y1,x2);  
    }else 
	if(x1&lt;x2){  
		a=x2;b=max(x1,y2);
    }else{  
    	a=x1;b=max(y1,y2);
    }  	
}
void initlca(){
	queue&lt;int&gt;q;q.push(1);
	while(!q.empty()){
		int u=q.front();q.pop();
		for(int i=0;i&lt;Ge[u].size();i++){
			int v=Ge[u][i].v,w=Ge[u][i].w;
			if(v!=1&amp;&amp;!dep[v]){
				dep[v]=dep[u]+1;
				p[v][0]=u;
				maxx[v][0]=w;
				maxi[v][0]=0;
				q.push(v);
			}
		}
	}
	for(int k=1;k&lt;18;k++)
	for(int i=1;i&lt;=n;i++){
		p[i][k]=p[p[i][k-1]][k-1];
		updata(maxx[i][k],maxi[i][k],
				maxx[i][k-1],maxi[i][k-1],
				maxx[p[i][k-1]][k-1],maxi[p[i][k-1]][k-1]);
	}
}

pair&lt;int,int&gt; Query(int x, int y)  {  	
    int Maxx = -1;  
    int Maxi = -1;  
    if (dep[x] &lt; dep[y])  
	swap(x,y);
    for (int i = 17; i &gt;= 0; i--)  
        if (dep[p[x][i]] &gt;= dep[y]){  
            updata(Maxx, Maxi, Maxx, Maxi, maxx[x][i], maxi[x][i]);  
            x = p[x][i];  
        }   
    if (x == y) return pair&lt;int,int&gt;(Maxx,Maxi);  
    for (int i = 17; i &gt;= 0; i--)  
        if (p[x][i] != p[y][i])  
        {  
            updata(Maxx, Maxi, Maxx, Maxi,  
                   maxx[x][i], maxi[x][i]);  
            updata(Maxx, Maxi, Maxx, Maxi,  
                   maxx[y][i], maxi[y][i]);  
            x = p[x][i]; y = p[y][i];  
        }  
    updata(Maxx, Maxi, Maxx, Maxi,  
           maxx[x][0], maxi[x][0]);  
    updata(Maxx, Maxi, Maxx, Maxi,  
           maxx[y][0], maxi[y][0]);  
    return pair&lt;int,int&gt;(Maxx,Maxi);
}  
int main(){
//	double st=clock();
//	freopen("1.txt","r",stdin);
	scanf("%d%d",&amp;n,&amp;m);
	for(int i=1;i&lt;=n;i++)faa[i]=i;
	for(int i=1;i&lt;=m;i++){
		int u,v,w;scanf("%d%d%d",&amp;u,&amp;v,&amp;w);
		G.push_back(edge(u,v,w));
	}sort(G.begin(),G.end());
	for(int i=0;i&lt;m;i++){
		int u=G[i].u,v=G[i].v,w=G[i].w;
		int fau=find(u),fav=find(v);
		if(fau!=fav){
			faa[fau]=fav;
			vis[i]=1;ans+=w;
			Ge[u].push_back(edge(u,v,w));
			Ge[v].push_back(edge(v,u,w));
		}
	}initlca();
	long long res,Ans=1LL&lt;&lt;61;
	for(int i=0;i&lt;m;i++){
		res=ans;
		if(vis[i])continue;
		int u=G[i].u,v=G[i].v,w=G[i].w;
		res+=w;
		pair&lt;int,int&gt; pi=Query(u,v);
		if(pi.first==w)res-=pi.second;else res-=pi.first;
		Ans=min(Ans,res);
	}	
	cout&lt;&lt;Ans&lt;&lt;endl;
//	cerr&lt;&lt;(clock()-st)/CLOCKS_PER_SEC&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem1978</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
int dp[int(1e6)+6];
int main(){
	int n,l;scanf("%d%d",&amp;n,&amp;l);
	for(int i=1;i&lt;=n;i++){
		int x,y=0;scanf("%d",&amp;x);
		for(int j=1;j*j&lt;=x;j++){
			if(x%j==0){
				y=max(y,dp[j]);
				y=max(y,dp[x/j]);
			}
		}y++;
		for(int j=1;j*j&lt;=x;j++){
			if(x%j==0){
				if(j&gt;=l)dp[j]=max(dp[j],y);
				if(x/j&gt;=l)dp[x/j]=max(dp[x/j],y);
			}
		}
	}cout&lt;&lt;*max_element(dp+1,dp+1+int(1e6))&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem1979</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
const int MAXSIZE=20000;
int n,k;
int a[MAXSIZE],s[MAXSIZE];
int key[MAXSIZE],l;
void init()
{
	scanf("%d%d",&amp;n,&amp;k);
	s[0]=0;
	for(int i=1;i&lt;=n;i++)
	{
		scanf("%d",&amp;a[i]);
		s[i]=s[i-1]+a[i];
	}
	for(int i=0;i&lt;n;i++)key[i+1]=-s[i];
	sort(key+1,key+n+1);
	l=unique(key+1,key+n+1)-key-1;
}
const int oo=1000000000;
int tree[MAXSIZE][2];
inline int lowbit(int x){return x&amp;-x;};
void INIT_TREE()
{
	for(int i=1;i&lt;=l;i++)tree[i][0]=oo,tree[i][1]=-oo;
}
void INSERT_TREE(int p,int vmin,int vmax)
{
	p=lower_bound(key+1,key+l+1,p)-key;
	while(p&lt;=l)
	{
		tree[p][0]=min(tree[p][0],vmin);
		tree[p][1]=max(tree[p][1],vmax);
		p+=lowbit(p);
	}
}
void GET_MIN(int p,int&amp; mn,int&amp; mx)
{
	mn=oo,mx=-oo;
	p=upper_bound(key+1,key+l+1,p)-key-1;
	while(p&gt;0)
	{
		mn=min(mn,tree[p][0]);
		mx=max(mx,tree[p][1]);
		p-=lowbit(p);
	}
}
bool OK(int limit)
{
	INIT_TREE();
	INSERT_TREE(0,0,0);
	int add=a[1];
	int fl,fr;
	GET_MIN(limit-add,fl,fr);
	fl++;fr++;
	for(int i=2;i&lt;=n;i++)
	{
		add+=a[i];
		INSERT_TREE(a[i]-add,fl,fr);
		GET_MIN(limit-add,fl,fr);
		fl++;fr++;
	}
	return fl&lt;=k&amp;&amp;k&lt;=fr;
}
inline int half(int x)
{
	if(x&gt;=0)return x/2;
	return x/2-1;
}
void work()
{
	int l=-oo,r=oo;
	OK(-10);
	while(l&lt;r)
	{
		int mid=half(l+r);
		if(OK(mid))r=mid;
		else l=mid+1;
	}
	printf("%d\n",l);
}
int main()
{
	//int cases;
	//scanf("%d",&amp;cases);
	//while(cases--)
	//{
		init();
		work();
	//}
}</pre><pre></pre><h2>Problem1984</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cctype&gt;
using namespace std;
const int maxn=1e5+5;
struct edge{int u,v,w;};
vector&lt;edge&gt;G[maxn];
vector&lt;edge&gt;edges;
int fa[maxn],dep[maxn],top[maxn],siz[maxn],son[maxn],w[maxn],mp[maxn],rmp[maxn],z;
int n,m;
int getint(){
	int res=0,f=1;char c=getchar();
	while(!isdigit(c))f=f==-1||c=='-'?-1:1,c=getchar();
	while(isdigit(c))res=res*10+c-'0',c=getchar();
	return res*f;
}
void dfs(int u){
	siz[u]=1;
	for(int i=0;i&lt;G[u].size();i++){
		edge e=G[u][i];
		if(e.v!=fa[u]){
			w[e.v]=e.w;fa[e.v]=u;dep[e.v]=dep[u]+1;
			dfs(e.v);
			siz[u]+=siz[e.v];
			if(siz[son[u]]&lt;siz[e.v])son[u]=e.v;
		}
	}
}
void build(int u,int tp){
	mp[u]=++z;rmp[z]=u;top[u]=tp;
	if(son[u])build(son[u],tp);
	for(int i=0;i&lt;G[u].size();i++){
		edge e=G[u][i];
		if(e.v!=fa[u]&amp;&amp;e.v!=son[u])build(e.v,e.v);
	}
}
struct seg{
	struct node{
		int lazy,mx,cov;
		node():
			lazy(0),mx(0),cov(-1){};
	}t[maxn&lt;&lt;2];
	#define lson i&lt;&lt;1,l,mid
	#define rson i&lt;&lt;1|1,mid+1,r
	#define L i&lt;&lt;1
	#define R i&lt;&lt;1|1
	void pushdown(int i,int l,int r){
		int mid=(l+r)&gt;&gt;1;
		if(~t[i].cov){
			t[L].mx=t[L].cov=t[i].cov;
			t[R].mx=t[R].cov=t[i].cov;
			t[L].lazy=t[R].lazy=0;
			t[i].cov=-1;
		}
		if(t[i].lazy){
			t[L].mx+=t[i].lazy;
			t[R].mx+=t[i].lazy;
			if(~t[L].cov)t[L].cov+=t[i].lazy;
			else t[L].lazy+=t[i].lazy;
			if(~t[R].cov)t[R].cov+=t[i].lazy;
			else t[R].lazy+=t[i].lazy;
			t[i].lazy=0;	
		}
	}
	void rz(int i){
		t[i].mx=max(t[L].mx,t[R].mx);
	}
	void Add(int i,int l,int r,int l0,int r0,int d){
		if(l0&gt;r0)swap(l0,r0);
		if(l0&lt;=l&amp;&amp;r0&gt;=r){
			t[i].lazy+=d;
			t[i].mx+=d;
			return;
		}pushdown(i,l,r);
		int mid=(l+r)&gt;&gt;1;
		if(l0&lt;=mid)Add(lson,l0,r0,d);
		if(r0&gt;mid)Add(rson,l0,r0,d);
		rz(i);
	}
	void Cover(int i,int l,int r,int l0,int r0,int d){
		if(l0&gt;r0)swap(l0,r0);
		if(l0&lt;=l&amp;&amp;r0&gt;=r){
			t[i].cov=d;
			t[i].mx=d;
			t[i].lazy=0;
			return;
		}pushdown(i,l,r);
		int mid=(l+r)&gt;&gt;1;
		if(l0&lt;=mid)Cover(lson,l0,r0,d);
		if(r0&gt;mid)Cover(rson,l0,r0,d);
		rz(i);		
	}
	int Max(int i,int l,int r,int l0,int r0){
		if(l0&gt;r0)swap(l0,r0);
		if(l0&lt;=l&amp;&amp;r0&gt;=r)return t[i].mx;
		pushdown(i,l,r);
		int mid=(l+r)&gt;&gt;1,ans=0;
		if(l0&lt;=mid)ans=max(ans,Max(lson,l0,r0));
		if(r0&gt;mid)ans=max(ans,Max(rson,l0,r0));
		return ans;
	}
}T;
void Add(int u,int v,int x){
	while(top[u]!=top[v]){
		if(dep[top[u]]&lt;dep[top[v]])swap(u,v);
		T.Add(1,1,n,mp[u],mp[top[u]],x);
		u=fa[top[u]];
	}if(u!=v)T.Add(1,1,n,min(mp[u],mp[v])+1,max(mp[u],mp[v]),x);
}
void Cover(int u,int v,int x){
	while(top[u]!=top[v]){
		if(dep[top[u]]&lt;dep[top[v]])swap(u,v);
		T.Cover(1,1,n,mp[u],mp[top[u]],x);
		u=fa[top[u]];
	}if(u!=v)T.Cover(1,1,n,min(mp[u],mp[v])+1,max(mp[u],mp[v]),x);
}
int Max(int u,int v){
	int ans=0;
	while(top[u]!=top[v]){
		if(dep[top[u]]&lt;dep[top[v]])swap(u,v);
		ans=max(ans,T.Max(1,1,n,mp[u],mp[top[u]]));
		u=fa[top[u]];
	}if(u!=v)ans=max(ans,T.Max(1,1,n,min(mp[u],mp[v])+1,max(mp[u],mp[v])));
	return ans;
}
int main(){
	n=getint();
	for(int i=1;i&lt;n;i++){
		int u=getint(),v=getint(),w=getint();
		edges.push_back((edge){u,v,w});
		G[u].push_back((edge){u,v,w});
		G[v].push_back((edge){v,u,w});
	}dfs(1);
	build(1,1);
	for(int i=1;i&lt;=n;i++)
	T.Cover(1,1,n,i,i,w[rmp[i]]);
	while(1){
		char op[10];
		scanf("%s",op);
		if(op[0]=='A'){
			int u=getint(),v=getint(),x;
			Add(u,v,getint());
		}else
		if(op[0]=='M'){
			int u=getint(),v=getint(),x;
			printf("%d\n",Max(u,v));
		}else
		if(op[1]=='h'){
			int k=getint(),w=getint();
			int u=fa[edges[k-1].u]==edges[k-1].v?edges[k-1].u:edges[k-1].v;
			Cover(fa[u],u,w);
		}else
		if(op[1]=='o'){
			int u=getint(),v=getint(),x;
			Cover(u,v,getint());
		}else break;
	}
	return 0;
}
</pre><pre></pre><h2>Problem1999</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=500001;
int n,k;
int pre[maxn],d[maxn],ans,W[maxn],vis[maxn];
vector&lt;pair&lt;int,int&gt; &gt;G[maxn];
void dfs(int u,int fa){
	for(int i=0;i&lt;G[u].size();i++){
		int v=G[u][i].first,w=G[u][i].second;
		if(v==fa||vis[v])continue;
		d[v]=d[u]+w;pre[v]=u;W[v]=w;
		if(d[v]&gt;d[ans])ans=v;
		dfs(v,u);
	}
}
int mx[maxn];
multiset&lt;int&gt;S;
int max3(int x,int y,int z){return max(max(x,y),z);}
int max4(int x,int y,int z,int w){return max(max(x,y),max(z,w));}
int main(){
	scanf("%d%d",&amp;n,&amp;k);
	for(int i=1;i&lt;n;i++){
		int u,v,w;scanf("%d%d%d",&amp;u,&amp;v,&amp;w);
		G[u].push_back(make_pair(v,w));
		G[v].push_back(make_pair(u,w));
	}dfs(1,0);int A=ans;
	ans=d[A]=0;dfs(A,0);int B=ans,len=0;
	for(int i=B;i!=A;i=pre[i])vis[i]=1,len+=W[i];vis[A]=1;
	for(int i=B;i!=A;i=pre[i]){
		ans=d[i]=0;dfs(i,0);mx[i]=d[ans];
	}int cur=0,res=2e9;
	memset(vis,0,sizeof vis);dfs(A,0);
	for(int i=B,j=B;i!=A;i=pre[i]){
		while(j!=A&amp;&amp;cur+W[j]&lt;=k){
			cur+=W[j];
			S.insert(mx[j]);
			j=pre[j];
		}
		if(i!=j)
			res=min(res,max4(mx[j],d[j],len-d[i],*(--S.end())));
		else res=min(res,max3(d[i],len-d[i],mx[i])),j=j!=A?pre[j]:A;
		if(i!=j)
		cur-=W[i],S.erase(S.find(mx[i]));
	}cout&lt;&lt;res&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem2002</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=2*int(1e5)+10;
struct node{
    int size;
    node* c[2],*p;
    void rz(){
        size=c[0]-&gt;size+c[1]-&gt;size+1;
    }
    void sets(node *t,int d){
        c[d]=t;
        c[d]-&gt;p=this;
        rz();
    }
    int d(){
        return this==p-&gt;c[1];
    }
    int root(){
        return this!=p-&gt;c[0]&amp;&amp;this!=p-&gt;c[1];
    }
}nil[maxn];
void rot(node *t){
    int d=t-&gt;d();
    node *p=t-&gt;p;
    p-&gt;sets(t-&gt;c[!d],d);
    if(p-&gt;root())
        t-&gt;p=p-&gt;p;
    else
        p-&gt;p-&gt;sets(t,p-&gt;d());
    t-&gt;sets(p,!d);
}
void splay(node *t){
    while(!t-&gt;root())
        if(t-&gt;p-&gt;root())
            rot(t);
        else if(t-&gt;d()==t-&gt;p-&gt;d())
            rot(t-&gt;p),rot(t);
        else
            rot(t),rot(t);
}
void access(node *t){
    for(node *y=nil;t!=nil;y=t,t=t-&gt;p){
        splay(t);
        t-&gt;sets(y,1);
    }
}
int n,m;
int getint(){int x;scanf("%d",&amp;x);return x;}
int main(){
    n=getint();
    node *x;
    for(int i=1;i&lt;=n;i++){
        x=nil+i;
        x-&gt;c[0]=x-&gt;c[1]=nil;
        x-&gt;p=nil+min(i+getint(),n+1);
    }
    x=nil+n+1;
    x-&gt;c[0]=x-&gt;c[1]=x-&gt;p=nil-&gt;c[0]=nil-&gt;c[1]=nil-&gt;p=nil;
    m=getint();
    while(m--){
        int opt=getint();
        int j=getint()+1;
        x=nil+j;
        if(opt==1){
            access(x);
            splay(x);
            printf("%d\n",x-&gt;c[0]-&gt;size);
        }else{	
            splay(x);
            x-&gt;c[0]-&gt;p=x-&gt;p;
            x-&gt;c[0]=nil;
            x-&gt;p=nil+min(j+getint(),n+1);
        }
    }
    return 0;
}</pre><pre></pre><h2>Problem2002</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=200100;
int n,m;
struct node{
	node *c[2],*p;
	int sz,rev;
	void pushdown(){
		if(!rev)return ;
		c[0]-&gt;rev^=1;
		c[1]-&gt;rev^=1;
		swap(c[0],c[1]);
		rev^=1;
	}
	void rz(){
		sz=c[0]-&gt;sz+c[1]-&gt;sz+1;
	}
	bool d(){
		return this==p-&gt;c[1];
	}
	bool root(){
		return this!=p-&gt;c[1]&amp;&amp;this!=p-&gt;c[0];
	}
	void sets(node *x,int d){
		pushdown();
		(c[d]=x)-&gt;p=this;rz();
	}
}nil[maxn]; 
void rot(node *x){
	node *p=x-&gt;p;
	if(!p-&gt;root())p-&gt;p-&gt;pushdown();
	p-&gt;pushdown();x-&gt;pushdown();
	int d=x-&gt;d();
	p-&gt;sets(x-&gt;c[!d],d);
	if(p-&gt;root())
		x-&gt;p=p-&gt;p;
	else
		p-&gt;p-&gt;sets(x,p-&gt;d());
	x-&gt;sets(p,!d);
}
void splay(node *x){
	while(!x-&gt;root())
		if(x-&gt;p-&gt;root())	
			rot(x);
		else if(x-&gt;p-&gt;d()==x-&gt;d())
			rot(x-&gt;p),rot(x);
		else 
			rot(x),rot(x);
}
node* access(node *x){
	node *y=nil;
	for(;x!=nil;y=x,x=x-&gt;p){
		splay(x);
		x-&gt;sets(y,1);
	}return y;
}
void makert(node *x){
	access(x)-&gt;rev^=1;
	splay(x);
}
node* findrt(node *x){
	for(x=access(x);x-&gt;c[0]!=nil;x=x-&gt;c[0]);
		return x;
} 
void link(node *x,node *y){
	makert(x);
	x-&gt;p=y;
	access(x);
}
void cut(node *x,node *y){
	makert(x);
	access(y);
	splay(y);
	y-&gt;c[0]=x-&gt;p=nil;
	y-&gt;rz();
}
int Qsize(node *x){
	access(x);
	splay(x);
	return x-&gt;c[0]-&gt;sz;
}
void Change(int i,int k){
	node *x=&amp;nil[i+1];
	splay(x);
	x-&gt;c[0]-&gt;p=x-&gt;p;
	x-&gt;c[0]=nil;
	//x-&gt;c[0]=x-&gt;c[0]-&gt;p=nil;
	x-&gt;p=&amp;nil[min(i+1+k,n+1)];
}
int main(){
	scanf("%d",&amp;n);
	node *x;int k;
	for(int i=1;i&lt;=n;i++){
		scanf("%d",&amp;k);
		x=&amp;nil[i];
		x-&gt;c[0]=x-&gt;c[1]=nil;
		x-&gt;p=&amp;nil[min(i+k,n+1)];
	}
	x=&amp;nil[n+1];
	x-&gt;c[0]=x-&gt;c[1]=x-&gt;p=nil-&gt;c[0]=nil-&gt;c[1]=nil-&gt;p=nil;
	scanf("%d",&amp;m);
	while(m--){
		int opt;scanf("%d",&amp;opt);
		int i,k;
		if(opt==1){
			scanf("%d",&amp;i);
			printf("%d\n",Qsize(&amp;nil[i+1]));
		}else{
			scanf("%d%d",&amp;i,&amp;k);
			Change(i,k);
		}
	}
	return 0;
}</pre><pre></pre><h2>Problem2002</h2><pre>#include&lt;bits/stdc++.h&gt;
#define id(x) (LCT::pool+x)
using namespace std;
const int maxn=200010;
int n,m;
namespace LCT{
	struct node{
		int rev,size;
		node *c[2],*p;
		node(node *C=0){size=1;rev=0;c[0]=c[1]=p=C;}
		void makerev(){rev^=1;swap(c[0],c[1]);}
		void pd(){if(rev){c[0]-&gt;makerev();c[1]-&gt;makerev();rev=0;}}
		void rz(){size=c[0]-&gt;size+1+c[1]-&gt;size;}
		bool d(){return p-&gt;c[1]==this;}
		bool rt(){return p-&gt;c[1]!=this&amp;&amp;p-&gt;c[0]!=this;}
		void sets(node *x,int d){pd();(c[d]=x)-&gt;p=this;rz();}
	}*null,pool[maxn];
	node *newnode(node *C=0){static int tot=0;return &amp;(pool[tot++]=node(C));}
	void init(){
		null=newnode();null-&gt;size=0;
		null-&gt;c[0]=null-&gt;c[1]=null-&gt;p=null;
		for(int i=1;i&lt;=n+1;i++)newnode(null);
	}
	void rot(node *x){
		node *y=x-&gt;p;if(!y-&gt;rt())y-&gt;p-&gt;pd();
		y-&gt;pd();x-&gt;pd();int d=x-&gt;d();
		y-&gt;sets(x-&gt;c[!d],d);
		if(y-&gt;rt())x-&gt;p=y-&gt;p;
		else y-&gt;p-&gt;sets(x,y-&gt;d());
		x-&gt;sets(y,!d);
	}
	void splay(node *x){
		for(;!x-&gt;rt();rot(x))if(x-&gt;p-&gt;rt());
		else if(x-&gt;d()==x-&gt;p-&gt;d())rot(x-&gt;p);
		else rot(x);
	}
	node *access(node *x){
		node *y=null;
		for(;x!=null;x=x-&gt;p)splay(x),x-&gt;sets(y,1),y=x;
		return y;
	}
	void makert(node *x){
		access(x)-&gt;makerev();
		splay(x);
	}
	void cut(node *x,node *y){
		makert(x);
		access(y);
		splay(y);
		y-&gt;c[0]=x-&gt;p=null;
		y-&gt;rz();
	}
	void link(node *x,node *y){
		makert(x);
		x-&gt;p=y;
		access(x);
	}
	int Qsum(node *x,node *y){
		makert(x);
		access(y);
		splay(y);
		return y-&gt;c[0]-&gt;size;
	}
	short vis[maxn];
	void deb(node *t){
		if(t==null)return;
		vis[t-pool]=1;
		printf("id:%d rev:%d size:%d p:%d\n",t-pool,t-&gt;rev,t-&gt;size,t-&gt;p-pool);
		if(t-&gt;c[0]!=null)printf("L: "),deb(t-&gt;c[0]);
		if(t-&gt;c[1]!=null)printf("R: "),deb(t-&gt;c[1]);
	}
}
void deb(){
	using LCT::vis;using LCT::pool;using LCT::node;
	memset(vis,0,sizeof vis);
	for(int i=1;i&lt;=n+1;i++){
		node *t=id(i);
		while(!t-&gt;rt())
		t=t-&gt;p;
		if(!vis[t-pool]){
			vis[t-pool]=1;
			deb(t);
		}
	}puts("");
}
int a[maxn];
int main(){
	scanf("%d",&amp;n);
	LCT::init();
	for(int i=1;i&lt;=n;i++){
		scanf("%d",&amp;a[i]);
		LCT::link(id(i),id(min(n+1,i+a[i])));
	}
//	deb();
	scanf("%d",&amp;m);
	while(m--){
		int op,x,y;
		scanf("%d",&amp;op);
		if(op==1){
			scanf("%d",&amp;x);
			printf("%d\n",LCT::Qsum(id(x+1),id(n+1)));
			//deb();
		}else{
			scanf("%d%d",&amp;x,&amp;y);x++;
			//deb();
			LCT::cut(id(x),id(min(n+1,x+a[x])));
			//deb();
			a[x]=y;
			LCT::link(id(x),id(min(n+1,x+a[x])));
			//deb();
		}
	}
	return 0;	
}</pre><pre></pre><h2>Problem2005</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
const int maxn=1e5+5;
int n,m;
LL ans=0;
bool notp[maxn];
int p[maxn],phi[maxn];
void init(int maxn){
	phi[1]=1;
	for(int i=2;i&lt;maxn;i++){
		if(!notp[i]){
			p[++p[0]]=i;phi[i]=i-1;
		}for(int j=1;j&lt;=p[0]&amp;&amp;i*p[j]&lt;maxn;j++){
			notp[i*p[j]]=1;
			if(i%p[j]==0){
				phi[i*p[j]]=phi[i]*p[j];break;
			}else phi[i*p[j]]=phi[i]*(p[j]-1);
		}
	}for(int i=2;i&lt;maxn;i++)phi[i]+=phi[i-1];
}
int main(){
	cin&gt;&gt;n&gt;&gt;m;
	if(n&gt;m)swap(n,m);
	init(n+1);
	for(int i=1,j;i&lt;=n;i=j+1){
		j=min(n/(n/i),m/(m/i));
		ans+=(LL)(phi[j]-phi[i-1])*(n/i)*(m/i);
	}cout&lt;&lt;(LL)2*ans-(LL)n*m&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem2006</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=5e5+10;
typedef pair&lt;int,int&gt; pii;
int n,k,L,R;
int a[maxn],sum[maxn];
int f[20][maxn],g[20][maxn];
long long ans=0;
void ST_init(){
	int BIT=0;
	for(int i=n;i;i&gt;&gt;=1,BIT++);
	for(int i=1;i&lt;=n;i++)f[0][i]=sum[i],g[0][i]=i;
	for(int i=1;i&lt;=BIT;i++)
	for(int j=1;j&lt;=n-(1&lt;&lt;i)+1;j++){
		if(f[i-1][j]&gt;f[i-1][j+(1&lt;&lt;i-1)])
			f[i][j]=f[i-1][j],g[i][j]=g[i-1][j];
		else f[i][j]=f[i-1][j+(1&lt;&lt;i-1)],g[i][j]=g[i-1][j+(1&lt;&lt;i-1)];
	}
}
pii qmax(int l,int r){
	int BIT=0;
	for(int i=r-l+1;i;i&gt;&gt;=1,BIT++);BIT--;
 	if(f[BIT][l]&gt;f[BIT][r-(1&lt;&lt;BIT)+1])return pii(g[BIT][l],f[BIT][l]);  
    else return pii(g[BIT][r-(1&lt;&lt;BIT)+1],f[BIT][r-(1&lt;&lt;BIT)+1]);  	
}
struct zky{
	int i,j,l,r,v;
	zky(int i=0,int j=0,int l=0,int r=0,int v=0):
		i(i),j(j),l(l),r(r),v(v){}
	bool operator&lt;(const zky &amp;sb)const{
		return v&lt;sb.v;
	}
};
priority_queue&lt;zky&gt;q;
int main(){
	scanf("%d%d%d%d",&amp;n,&amp;k,&amp;L,&amp;R);
	for(int i=1;i&lt;=n;i++)scanf("%d",a+i),sum[i]=sum[i-1]+a[i];
	ST_init();
	for(int i=1;i&lt;=n;i++){
		if(i-1+L&gt;n)break;  
		pii x=qmax(i+L-1,min(i+R-1,n));
		q.push(zky(i,x.first,i-1+L,min(i+R-1,n),x.second-sum[i-1]));  
	}
	while(k--){
		zky x=q.top();q.pop();
		ans+=x.v;
		if(x.j-1&gt;=x.l){
			pii t=qmax(x.l,x.j-1);
			q.push(zky(x.i,t.first,x.l,x.j-1,t.second-sum[x.i-1])); 
		}
		if(x.j+1&lt;=x.r){
	        pii t=qmax(x.j+1,x.r);  
            q.push(zky(x.i,t.first,x.j+1,x.r,t.second-sum[x.i-1]));  		
		}
	}cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem2007</h2><pre>#include&lt;bits/stdc++.h&gt;
#include&lt;ext/pb_ds/priority_queue.hpp&gt;
using namespace std;
const int maxn=505;
typedef pair&lt;int,int&gt; par;
vector&lt;par&gt;G[maxn*maxn];
void add(int u,int v,int w){
//	fprintf(stderr,"%d-&gt;%d w:%d\n",u,v,w);
	G[u].push_back(par(v,w));
}
int s=1,t,n,mp[maxn][maxn];
typedef __gnu_pbds::priority_queue&lt;par,greater&lt;par&gt;,__gnu_pbds::pairing_heap_tag&gt; Heap;
typedef Heap::point_iterator iter;
iter d[maxn*maxn];
int dijk(){
	static int vis[maxn*maxn];
	Heap q;
	for(int i=1;i&lt;=(n+1)*(n+1);i++)d[i]=q.end();
	d[1]=q.push(par(0,1));vis[1]=1;
	while(!q.empty()){
		int u=q.top().second;vis[u]=1;
		if(u==t)return d[t]-&gt;first;
		for(int i=0;i&lt;G[u].size();i++){
			int v=G[u][i].first,w=G[u][i].second;
			if(vis[v])continue;
			if(d[v]==q.end())d[v]=q.push(par(INT_MAX,v));
			if(d[v]-&gt;first&gt;d[u]-&gt;first+w)
				q.modify(d[v],par(d[u]-&gt;first+w,v));
		}q.erase(d[u]);d[u]=q.end();
	}
}
int getint(){
	char c=getchar();int res=0;
	while(!isdigit(c))c=getchar();
	while(isdigit(c))res=res*10+c-'0',c=getchar();
	return res;
}
int main(){
	scanf("%d",&amp;n);
	int tot=0;
	for(int i=0;i&lt;=n+1;i++)for(int j=0;j&lt;=n+1;j++)
	mp[i][j]=++tot;t=tot;
	for(int i=1;i&lt;=n+1;i++)for(int j=1;j&lt;=n;j++)
	add(mp[i][j],mp[i-1][j],getint());
	for(int i=1;i&lt;=n;i++)for(int j=1;j&lt;=n+1;j++)
	add(mp[i][j-1],mp[i][j],getint());
	for(int i=1;i&lt;=n+1;i++)for(int j=1;j&lt;=n;j++)
	add(mp[i-1][j],mp[i][j],getint());
	for(int i=1;i&lt;=n;i++)for(int j=1;j&lt;=n+1;j++)
	add(mp[i][j],mp[i][j-1],getint());
	for(int i=1;i&lt;=n;i++)add(s,mp[i][0],0),add(s,mp[n+1][i],0);
	for(int i=1;i&lt;=n;i++)add(mp[i][n+1],t,0),add(mp[0][i],t,0);
	cout&lt;&lt;dijk()&lt;&lt;endl;
	return 0;
}
</pre><pre></pre><h2>Problem2037</h2><pre>/*
	ID:zky
	OJ:BZOJ
	Index:2037
	Language:C++
*/
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iomanip&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long lld;
lld Abs(lld x){
	return x&lt;0?-x:x;
}
struct Egg{
	lld x,y,v;
	bool operator&lt;(const Egg &amp;a)const{
		return x&lt;a.x;
	}
}a[1001];
lld n,x0;
lld f[1001][1001][2];
lld sum[1001];
int main(){
	cin&gt;&gt;n&gt;&gt;x0;
	for(lld i=1;i&lt;=n;i++)cin&gt;&gt;a[i].x;
	for(lld i=1;i&lt;=n;i++)cin&gt;&gt;a[i].y;
	for(lld i=1;i&lt;=n;i++)cin&gt;&gt;a[i].v;
	//a[0].x=x0;
	sort(a+1,a+1+n);	
	for(lld i=1;i&lt;=n;i++)sum[i]=sum[i-1]+a[i].v;
	memset(f,0xaf,sizeof(f));
	for(lld i=1;i&lt;=n;i++){
		f[i][i][0]=f[i][i][1]=a[i].y-Abs(a[i].x-x0)*sum[n];
	}
	//f[i][j][0]=i&lt;-j
	//f[i][j][1]=i-&gt;j
	for(lld len=1;len&lt;n;len++)
	for(lld i=1;i&lt;=n;i++){
		lld j=i+len;
		if(j&gt;n)break;
		f[i][j][0]=a[i].y+max(f[i+1][j][0]-Abs(a[i].x-a[i+1].x)*(sum[n]-(sum[j]-sum[i])),
							  f[i+1][j][1]-Abs(a[i].x - a[j].x)*(sum[n]-(sum[j]-sum[i])));
		f[i][j][1]=a[j].y+max(f[i][j-1][0]-Abs(a[i].x-a[j].x)*(sum[n]-(sum[j-1]-sum[i-1])),
							  f[i][j-1][1]-Abs(a[j].x-a[j-1].x)*(sum[n]-(sum[j-1]-sum[i-1])));	
	}
	cout&lt;&lt;fixed&lt;&lt;setprecision(3)&lt;&lt;max(f[1][n][0],f[1][n][1])/1000.0&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem2038</h2><pre>#include&lt;cmath&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=50010;
typedef long long lld;
lld n,m;
lld col[maxn];
lld a[maxn],sqrn;
lld bel(lld x){return (x-1)/sqrn;}
lld getlld(){
    lld res=0,ok=0;char ch;
    while(1){
        ch=getchar();
        if(isdigit(ch)){
            res*=10;res+=ch-'0';ok=1;
        }else if(ok)break;
    }return res;
}
struct qes{
    lld ind,l,r;
    bool operator &lt; (const qes &amp;a)const{
        return bel(l)&lt;bel(a.l)||bel(l)==bel(a.l)&amp;&amp;r&lt;a.r;
    }
};
lld anss[maxn];
lld ans=0;
void malldain(lld j,lld i){
    ans-=col[a[j]]*(col[a[j]]-1);
    col[a[j]]+=i;
    ans+=col[a[j]]*(col[a[j]]-1);
}
bool cmp(const qes &amp;a,const qes &amp;b){
	return a.ind&lt;b.ind;
}
lld gcd(lld a,lld b){
	while(b){
		lld t=a%b;
		a=b;
		b=t;
	}return a;
}
qes q[maxn];
int main(){
    n=getlld();m=getlld();
    sqrn=sqrt(n)+1;
    for(lld i=1;i&lt;=n;i++)a[i]=getlld();
    for(lld i=1;i&lt;=m;i++){
        q[i].ind=i;q[i].l=getlld();q[i].r=getlld();
    }sort(q+1,q+1+m);
    
    lld i=1;
    while(i&lt;=m){
        memset(col,0,sizeof(col));
		ans=0;
        for(lld j=q[i].l;j&lt;=q[i].r;j++)
            malldain(j,1);
        anss[q[i++].ind]=ans;
        while(i&lt;=m&amp;&amp;bel(q[i].l)==bel(q[i-1].l)){
            for(lld j=q[i-1].r+1;j&lt;=q[i].r;j++)
                malldain(j,1);
            if(q[i-1].l&lt;q[i].l){
                for(lld j=q[i-1].l;j&lt;q[i].l;j++)
                    malldain(j,-1);
            }else{
                for(lld j=q[i].l;j&lt;q[i-1].l;j++)
                    malldain(j,1);
            }
            anss[q[i++].ind]=ans;
        }
    }
    sort(q+1,q+1+m,cmp);
    for(lld i=1;i&lt;=m;i++){
    	lld k=(q[i].r-q[i].l+1)*(q[i].r-q[i].l);
    	if(k==0||anss[i]==0){
    		puts("0/1");continue;
    	}
    	lld d=gcd(k,anss[i]);
    	printf("%lld/%lld\n",anss[i]/d,k/d);
    }
    return 0;
}</pre><pre></pre><h2>Problem2038</h2><pre>#include&lt;cmath&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=50010;
typedef long long lld;
lld n,m;
lld col[maxn];
lld a[maxn],sqrn;
int bel(int x){return (x-1)/sqrn;}
lld getint(){
    lld res=0,ok=0;char ch;
    while(1){
        ch=getchar();
        if(isdigit(ch)){
            res*=10;res+=ch-'0';ok=1;
        }else if(ok)break;
    }return res;
}
struct qes{
    lld ind,l,r;
    bool operator &lt; (const qes &amp;a)const{
        return bel(l)&lt;bel(a.l)||bel(l)==bel(a.l)&amp;&amp;r&lt;a.r;
    }
};
lld anss[maxn];
lld ans=0;
void maintain(int j,int i){
    ans-=col[a[j]]*(col[a[j]]-1);
    col[a[j]]+=i;
    ans+=col[a[j]]*(col[a[j]]-1);
}
bool cmp(const qes &amp;a,const qes &amp;b){
	return a.ind&lt;b.ind;
}
lld gcd(lld a,lld b){
	while(b){
		lld t=a%b;
		a=b;
		b=t;
	}return a;
}
qes q[maxn];
int main(){
    n=getint();m=getint();
    sqrn=sqrt(n)+1;
    for(int i=1;i&lt;=n;i++)a[i]=getint();
    for(int i=1;i&lt;=m;i++){
        q[i].ind=i;q[i].l=getint();q[i].r=getint();
    }sort(q+1,q+1+m);
    
    int i=1;
    while(i&lt;=m){
        memset(col,0,sizeof(col));
		ans=0;
        for(int j=q[i].l;j&lt;=q[i].r;j++)
            maintain(j,1);
        anss[q[i++].ind]=ans;
        while(i&lt;=m&amp;&amp;bel(q[i].l)==bel(q[i-1].l)){
            for(int j=q[i-1].r+1;j&lt;=q[i].r;j++)
                maintain(j,1);
            if(q[i-1].l&lt;q[i].l){
                for(int j=q[i-1].l;j&lt;q[i].l;j++)
                    maintain(j,-1);
            }else{
                for(int j=q[i].l;j&lt;q[i-1].l;j++)
                    maintain(j,1);
            }
            anss[q[i++].ind]=ans;
        }
    }
    sort(q+1,q+1+m,cmp);
    for(int i=1;i&lt;=m;i++){
    	lld k=(q[i].r-q[i].l+1)*(q[i].r-q[i].l);//这里由于原来用intWA了一次
    	if(k==0||anss[i]==0){
    		puts("0/1");continue;
    	}
    	lld d=gcd(k,anss[i]);
    	printf("%lld/%lld\n",anss[i]/d,k/d);
    }
    return 0;
}</pre><pre></pre><h2>Problem2039</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#define M 1010
#define S 0
#define T (n+1)
#define INF 0x3f3f3f3f3f3f3f3fll
using namespace std;
struct abcd{
	int to,next;
	long long f;
}table[10010010];
int head[M],tot=1;
int n;
long long ans,a[M];
void Add(int x,int y,long long z)
{
	table[++tot].to=y;
	table[tot].f=z;
	table[tot].next=head[x];
	head[x]=tot;
}
void Link(int x,int y,int z)
{
	Add(x,y,z);
	Add(y,x,z);
}
namespace Max_Flow{
	int dpt[M];
	bool BFS()
	{
		static int q[M];
		int i,r=0,h=0;
		memset(dpt,-1,sizeof dpt);
		q[++r]=S;dpt[S]=1;
		while(r!=h)
		{
			int x=q[++h];
			for(i=head[x];i;i=table[i].next)
				if(table[i].f&amp;&amp;!~dpt[table[i].to])
				{
					dpt[table[i].to]=dpt[x]+1;
					q[++r]=table[i].to;
					if(table[i].to==T)
						return true;
				}
		}
		return false;
	}
	long long Dinic(int x,long long flow)
	{
		int i;long long left=flow;
		if(x==T) return flow;
		for(i=head[x];i&amp;&amp;left;i=table[i].next)
			if(table[i].f&amp;&amp;dpt[table[i].to]==dpt[x]+1)
			{
				long long temp=Dinic(table[i].to,min(left,table[i].f) );
				left-=temp;
				table[i].f-=temp;
				table[i^1].f+=temp;
			}
		if(left) dpt[x]=-1;
		return flow-left;
	}
}
int main()
{
	int i,j,x;
	cin&gt;&gt;n;
	for(i=1;i&lt;=n;i++)
	{
		scanf("%d",&amp;x);
		Link(i,T,x);
	}
	for(i=1;i&lt;=n;i++)
		for(j=1;j&lt;=n;j++)
		{
			scanf("%d",&amp;x);ans+=x;
			if(i&gt;=j) continue;
			a[i]+=x;a[j]+=x;
			Link(i,j,(long long)x&lt;&lt;1);
		}
	for(i=1;i&lt;=n;i++)
		Link(S,i,a[i]);
	using namespace Max_Flow;
	while( BFS() )
		ans-=Dinic(S,INF);
	cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}
</pre><pre></pre><h2>Problem2045</h2><pre>//ID:zky
#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
#include&lt;cstring&gt;
#define I64 "%d"
using namespace std;
const int maxn=1000005;
typedef long long LL;
LL u[maxn],prime[maxn];
LL n,m,T,k;
bool ok[maxn];
LL sum[maxn];
void getmu(){
  memset(ok,false,sizeof(ok));
  u[1]=1;
  for(LL i=2;i&lt;maxn;i++){
    if(!ok[i]){
      prime[++prime[0]]=i;
      u[i]=-1;
    }
    for(LL j=1;j&lt;=prime[0];j++){
      if(i*prime[j]&gt;=maxn)break;
      ok[i*prime[j]]=1;
      if(i%prime[j])
        u[i*prime[j]]=-u[i];
      else{
        u[i*prime[j]]=0;
        break;
      }
    }
  }
  sum[0]=0;
  for(LL i=1;i&lt;maxn;i++)
    sum[i]=sum[i-1]+u[i];
} 
LL work(){
  //ans=sigma  u(d)*|n|*|m|
  //   d&lt;=n   &nbsp; [d] [d]
  LL ans=0,pos;
  for(LL i=1;i&lt;=n;){
    pos=min(n/(n/i),m/(m/i));
    ans+=(sum[pos]-sum[i-1])*(n/i)*(m/i);
    i=pos+1;
  }return ans;
}
int main(){
	T=1;
  getmu();
  while(T--){
    scanf(I64,&amp;n);
    scanf(I64,&amp;m);
    scanf(I64,&amp;k);
    n/=k;m/=k;
    if(n&gt;m)swap(n,m);
    cout&lt;&lt;work()&lt;&lt;endl;
  }  
  return 0;
}</pre><pre></pre><h2>Problem2045</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cctype&gt;
using namespace std;
const int maxn=1e6+5;
typedef long long LL;
LL n,m,d;
LL prime[maxn],p[maxn],u[maxn];
void get_mu(){
	u[1]=1;
	for(LL i=2;i&lt;=m;i++){
		if(!p[i]){
			prime[++prime[0]]=i;
			u[i]=-1;	
		}for(LL j=1;i*prime[j]&lt;=n&amp;&amp;j&lt;=prime[0];j++){
			p[i*prime[j]]=1;
			if(i%prime[j]==0){
				u[i*prime[j]]=0;
				break;
			}else u[i*prime[j]]=-u[i];			
		}
	}for(LL i=2;i&lt;=m;i++)u[i]+=u[i-1];
}
int main(){
	cin&gt;&gt;n&gt;&gt;m&gt;&gt;d;
	n/=d;m/=d;
	if(n&gt;m)swap(n,m);
	get_mu();
	LL ans=0,pos=0;
	for(LL i=1;i&lt;=n;){
		pos=min(n/(n/i),m/(m/i));
		ans+=(u[pos]-u[i-1])*(n/i)*(m/i);
		i=pos+1;
	}cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem2048</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
int main(){
	long long n,m;
	cin&gt;&gt;n&gt;&gt;m;
	double ans=0;
	if(n&lt;=1000000){
		for(int i=1;i&lt;=n;i++)ans+=1.0/i;
	}else{
		ans=log(n+1)+0.57721566490153286060651209;
	}ans/=2;
	cout&lt;&lt;(long long)(ans*m-1e-9)&lt;&lt;endl;
}
</pre><pre></pre><h2>Problem2049</h2><pre>#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
using namespace std;
int n,m,u,v;
char opt[100];
int fa[10001];
void Splay(int x){
	int y,t=fa[x];
	fa[x]=-1;
	while(t!=-1){
		y=t;
		t=fa[y];
		fa[y]=x;
		x=y;
	}
}
int main(){
	scanf("%d%d",&amp;n,&amp;m);
	memset(fa,-1,sizeof(fa));
	while(m--){
		scanf("%s%d%d",opt,&amp;u,&amp;v);
		Splay(u);
		if(opt[0]=='Q'){
			int ok=0;
			while(v!=-1){
				if(v==u){
					ok=1;
					break;
				}
				v=fa[v];
			}
			if(ok)
				puts("Yes");
			else
				puts("No");
		}else
		if(opt[0]=='C'){
			fa[u]=v;
		}else{
			fa[v]=-1;
		}
	}
	return 0;
}</pre><pre></pre><h2>Problem2049</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=10010;
struct node{  
    node *c[2],*p;  
    int sz,rev;  
    void pushdown(){  
        if(!rev)return ;  
        c[0]-&gt;rev^=1;  
        c[1]-&gt;rev^=1;  
        swap(c[0],c[1]);  
        rev^=1;  
    }  
    void rz(){  
        sz=c[0]-&gt;sz+c[1]-&gt;sz+1;  
    }  
    bool d(){  
        return this==p-&gt;c[1];  
    }  
    bool root(){  
        return this!=p-&gt;c[1]&amp;&amp;this!=p-&gt;c[0];  
    }  
    void sets(node *x,int d){  
        pushdown();  
        (c[d]=x)-&gt;p=this;rz();  
    }  
}nil[maxn];   
void rot(node *x){  
    node *p=x-&gt;p;  
    if(!p-&gt;root())p-&gt;p-&gt;pushdown();  
    p-&gt;pushdown();x-&gt;pushdown();  
    int d=x-&gt;d();  
    p-&gt;sets(x-&gt;c[!d],d);  
    if(p-&gt;root())  
        x-&gt;p=p-&gt;p;  
    else  
        p-&gt;p-&gt;sets(x,p-&gt;d());  
    x-&gt;sets(p,!d);  
}  
void splay(node *x){  
    while(!x-&gt;root())  
        if(x-&gt;p-&gt;root())    
            rot(x);  
        else if(x-&gt;p-&gt;d()==x-&gt;d())  
            rot(x-&gt;p),rot(x);  
        else   
            rot(x),rot(x);  
}  
node* access(node *x){  
    node *y=nil;  
    for(;x!=nil;y=x,x=x-&gt;p){  
        splay(x);  
        x-&gt;sets(y,1);  
    }return y;  
}  
void makert(node *x){  
    access(x)-&gt;rev^=1;  
    splay(x);  
}  
node* findrt(node *x){  
    for(x=access(x);x-&gt;c[0]!=nil;x=x-&gt;c[0]);  
        return x;  
}   
void link(node *x,node *y){  
    makert(x);  
    x-&gt;p=y;  
    access(x);  
}  
void cut(node *x,node *y){  
    makert(x);  
    access(y);  
    splay(y);  
    y-&gt;c[0]=x-&gt;p=nil;  
    y-&gt;rz();  
}  
int n,m;
int getint(){
	int res=0,ok=0;char ch;
	while(1){
		ch=getchar();
		if(ch&lt;='9'&amp;&amp;ch&gt;='0'){
			res*=10;res+=ch-'0';ok=1;
		}else if(ok)break;
	}return res;
}

int main(){
	n=getint();
	m=getint();
	node *x;
	for(int i=1;i&lt;=n;i++){
		x=&amp;nil[i];
		x-&gt;c[0]=x-&gt;c[1]=x-&gt;p=nil;
		x-&gt;rev=0;
	}
	nil-&gt;c[0]=nil-&gt;c[1]=nil-&gt;p=nil;
	while(m--){
		char opt[5];scanf("%s",opt);
		int U=getint(),V=getint();
		node *u=&amp;nil[U],*v=&amp;nil[V];	
		//deb(u);
		//deb(v);
		if(opt[0]=='Q'){
			if(findrt(u)==findrt(v))
				puts("Yes");
			else
				puts("No");
		}else
		if(opt[0]=='D'){
			cut(u,v);
		}else{
			link(u,v);
		}
		//deb(u);
		//deb(v);
	}
	return 0;
}</pre><pre></pre><h2>Problem2049</h2><pre>#include&lt;bits/stdc++.h&gt;
#define id(x) (LCT::pool+x)
using namespace std;
const int maxn=10010;
const int maxm=200010;
int n,m;
namespace LCT{
	struct node{
		node *c[2],*p;
		int size,rev;
		node(node *C=0){size=1;rev=0;c[0]=c[1]=p=C;}
		void makerev(){rev^=1;swap(c[0],c[1]);}
		void pd(){if(rev){rev=0;c[0]-&gt;makerev();c[1]-&gt;makerev();}}
		void rz(){size=c[0]-&gt;size+1+c[1]-&gt;size;}
		void sets(node *x,int d){pd();(c[d]=x)-&gt;p=this;rz();}
		bool d(){return p-&gt;c[1]==this;}
		bool rt(){return p-&gt;c[0]!=this&amp;&amp;p-&gt;c[1]!=this;}
	}*null,pool[maxn];
	node *newnode(node *C=0){
		static int tot=0;
		return &amp;(pool[tot++]=node(C));
	}
	void init(){
		null=newnode();null-&gt;size=0;
		null-&gt;c[0]=null-&gt;c[1]=null-&gt;p=null;
		for(int i=1;i&lt;=n;i++)newnode(null);
	}
	void rot(node *x){
		node *y=x-&gt;p;if(!y-&gt;rt())y-&gt;p-&gt;pd();
		y-&gt;pd();x-&gt;pd();int d=x-&gt;d();
		y-&gt;sets(x-&gt;c[!d],d);if(y-&gt;rt())x-&gt;p=y-&gt;p;
		else y-&gt;p-&gt;sets(x,y-&gt;d());x-&gt;sets(y,!d);
	}
	void splay(node *x){
		for(;!x-&gt;rt();rot(x))if(x-&gt;p-&gt;rt());
		else if(x-&gt;d()==x-&gt;p-&gt;d())rot(x-&gt;p);
		else rot(x);
	}
	node *access(node *x){
		node *y=null;
		for(;x!=null;x=x-&gt;p)splay(x),x-&gt;sets(y,1),y=x;
		return y;
	}
	void makert(node *x){access(x)-&gt;makerev();splay(x);}
	node *findrt(node *x){for(x=access(x);x-&gt;pd(),x-&gt;c[0]!=null;x=x-&gt;c[0]);
	return x;}
	void link(node *x,node *y){makert(x);x-&gt;p=y;access(x);}
	void cut(node *x,node *y){makert(x);access(y);splay(y);y-&gt;c[0]=x-&gt;p=null;y-&gt;rz();}
}
int main(){
	scanf("%d%d",&amp;n,&amp;m);
	LCT::init();
	while(m--){
		char op[10];int x,y;
		scanf("%s%d%d",op,&amp;x,&amp;y);
		if(op[0]=='C')
			LCT::link(id(x),id(y));	
		else
		if(op[0]=='D')
			LCT::cut(id(x),id(y));
		else puts(findrt(id(x))==findrt(id(y))?"Yes":"No");		
	}
	return 0;
}</pre><pre></pre><h2>Problem2054</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1e7+2;
int n,m,p,q;
int l[maxn],r[maxn];
int fa[maxn];
int find(int x){return fa[x]==x?x:find(fa[x]);}
void merge(int x,int y){fa[find(x)]=find(y);}
int col[maxn];
int main(){
	cin&gt;&gt;n&gt;&gt;m&gt;&gt;p&gt;&gt;q;
	for(int i=1;i&lt;=n+1;i++)fa[i]=i;
	for(int i=1;i&lt;=m;i++){
		l[i]=(i*p+q)%n+1;
		r[i]=(i*q+p)%n+1;
		if(l[i]&gt;r[i])swap(l[i],r[i]);
	}
	for(int i=m;i&gt;=1;i--){
		int j=find(l[i]);
		for(;j&lt;=r[i];){
			col[j]=i;
			merge(j,r[i]+1);
			j=find(j+1);
		}
	}for(int i=1;i&lt;=n;i++)printf("%d\n",col[i]);
	return 0;
}</pre><pre></pre><h2>Problem2055</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=233;
int s,t;
struct edge{int u,v,ca,fl,co;};
vector&lt;edge&gt;E;
vector&lt;int&gt;G[maxn];
void add(int u,int v,int ca,int co){
	E.push_back((edge){u,v,ca,0,co});
	G[u].push_back(E.size()-1);
	E.push_back((edge){v,u,0,0,-co});
	G[v].push_back(E.size()-1);
}
int cost,flow=0;
bool spfa(){
	static int vis[maxn],d[maxn],a[maxn],pre[maxn];
	memset(d,0x7f,sizeof d);int B=d[0];a[s]=INT_MAX;
	queue&lt;int&gt;q;q.push(s);vis[s]=1;d[s]=0;	
	while(!q.empty()){
		int u=q.front();q.pop();vis[u]=0;
		for(int i=0;i&lt;G[u].size();i++){
			edge e=E[G[u][i]];
			if(e.ca==e.fl||d[e.v]&lt;=d[u]+e.co)continue;
			a[e.v]=min(e.ca-e.fl,a[u]);pre[e.v]=G[u][i];
			d[e.v]=d[u]+e.co;if(!vis[e.v])q.push(e.v),vis[e.v]=1;
		}	
	}
	if(d[t]==B)return false;
	flow+=a[t];
	cost+=a[t]*d[t];
	int u=t;
	while(u!=s){
		E[pre[u]].fl+=a[t];
		E[pre[u]^1].fl-=a[t];
		u=E[pre[u]].u;
	}return true;
}
int tot=0;
int mp[102][2];
int main(){
	int n,M;scanf("%d%d",&amp;n,&amp;M);
	for(int i=1;i&lt;=n;i++)mp[i][0]=++tot,mp[i][1]=++tot;
	s=0;t=tot+1;int ss=t+1,tt=ss+1;
	add(tt,ss,M,0);
	
	for(int i=1;i&lt;=n;i++){
		int v;scanf("%d",&amp;v);
		add(s,mp[i][1],v,0);
		add(mp[i][0],t,v,0);
		add(ss,mp[i][0],1e9,0);
		add(mp[i][1],tt,1e9,0);
	}
	for(int i=1;i&lt;n;i++){
		for(int j=i+1;j&lt;=n;j++){
			int v;scanf("%d",&amp;v);if(v==-1)continue;
			add(mp[i][1],mp[j][0],1e9,v);
		}
	}
	while(spfa());
	cout&lt;&lt;cost&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem2056</h2><pre>#include&lt;cstdio&gt;
using namespace std;
int main()
{
     int T;
     scanf("%d",&amp;T);
     while(T&gt;0)
     {
          T--;
          unsigned long long a,b,c,d,e,f,g,h,i;
          unsigned long long lim=(unsigned long long)9223372036*(unsigned long long)1000000000+(unsigned long long)854775808;
          scanf("%llu%llu%llu%llu%llu%llu%llu%llu%llu",&amp;a,&amp;b,&amp;c,&amp;d,&amp;e,&amp;f,&amp;g,&amp;h,&amp;i);
          if(a+b+c+d+e+f+g+h==60*8&amp;&amp;i==lim)
		       printf("18446744073709551616\n");
		  else
		  {
		  	   unsigned long long ans=i,t=1;
			   for(i=1;i&lt;=a;i++)
			        t*=(unsigned long long)2;
			   ans+=t;
			   t=1;
			   for(i=1;i&lt;=b;i++)
			        t*=(unsigned long long)2;
			   ans+=t;
			   t=1;
			   for(i=1;i&lt;=c;i++)
			        t*=(unsigned long long)2;
			   ans+=t;
			   t=1;
			   for(i=1;i&lt;=d;i++)
			        t*=(unsigned long long)2;
			   ans+=t;
			   t=1;
			   for(i=1;i&lt;=e;i++)
			        t*=(unsigned long long)2;
			   ans+=t;
			   t=1;
			   for(i=1;i&lt;=f;i++)
			        t*=(unsigned long long)2;
			   ans+=t;
			   t=1;
			   for(i=1;i&lt;=g;i++)
			        t*=(unsigned long long)2;
			   ans+=t;
			   t=1;
			   for(i=1;i&lt;=h;i++)
			        t*=(unsigned long long)2;
			   ans+=t;
			   printf("%llu\n",ans);
		  }
     }
     return 0;
}</pre><pre></pre><h2>Problem2073</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
int n,W;
int w[18],t[18];
int dp[1&lt;&lt;16],sum[1&lt;&lt;16],tim[1&lt;&lt;16];
int main(){
	cin&gt;&gt;W&gt;&gt;n;
	for(int i=1;i&lt;=n;i++)cin&gt;&gt;t[i]&gt;&gt;w[i];
	for(int i=1;i&lt;(1&lt;&lt;n);i++){
		for(int j=1;j&lt;=n;j++){
			if(i&gt;&gt;(j-1)&amp;1){
				sum[i]+=w[j];
				tim[i]=max(tim[i],t[j]);
			}
		}	
	}
	for(int i=1;i&lt;(1&lt;&lt;n);i++){
		dp[i]=2333333;
		for(int j=i;j;j=i&amp;(j-1))
		if(sum[j]&lt;=W)dp[i]=min(dp[i],tim[j]+dp[i^j]);
	}cout&lt;&lt;dp[(1&lt;&lt;n)-1]&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem2079</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
int n,m;
int getint(){
	int res=0;char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))res=res*10+c-'0',c=getchar();
	return res;
}
int in[200001];
int main(){
	n=getint();m=getint();
	while(m--){
		int x;
		n-=!in[x=getint()];
		in[x]=1;		
		n-=!in[x=getint()];
		in[x]=1;
	}puts(!n?"TAK":"NIE");
	return 0;
} </pre><pre></pre><h2>Problem2083</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1e6+5;
vector&lt;int&gt;v[maxn];
int n;
int main(){
	scanf("%d",&amp;n);
	for(int i=1;i&lt;=n;i++){
		int x;scanf("%d",&amp;x);
		v[x].push_back(i);
	}int m;scanf("%d",&amp;m);
	while(m--){
		int ok=1;
		int len;scanf("%d",&amp;len);
		int last=0;
		for(int i=1;i&lt;=len;i++){
			int x;scanf("%d",&amp;x);
			if(!ok)continue;
			vector&lt;int&gt;::iterator it=upper_bound(v[x].begin(),v[x].end(),last);
			if(it==v[x].end()){ok=0;}
			if(ok)last=*it;
		}if(ok)puts("TAK");else puts("NIE");
	}
	return 0;
}
</pre><pre></pre><h2>Problem2084</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;

typedef unsigned long long LL;

#define N 500010
char s1[N],s2[N];

const int base=2333;
int mi[N],f1[N],f2[N];
int git1(int l,int r){return f1[l]-(LL)f1[r+1]*mi[r-l+1];}
int git2(int l,int r){return f2[l]-(LL)f2[r+1]*mi[r-l+1];}
int main(){
	int n;scanf("%d",&amp;n);
	scanf("%s",s1+1);register int i,j;for(i=1;i&lt;=n;++i)s2[i]=s1[n-i+1]=='0'?'1':'0';
	//printf("%s\n%s\n",s1+1,s2+1);
	for(mi[0]=1,i=1;i&lt;=n;++i)mi[i]=(LL)mi[i-1]*base;
	for(i=n;i&gt;=1;--i)f1[i]=((LL)base*f1[i+1]+s1[i]);
	for(i=n;i&gt;=1;--i)f2[i]=((LL)base*f2[i+1]+s2[i]);

	long long res=0;
	int L,R,mid;
	for(i=1;i&lt;=n;++i){
		j=n-i+1;
		L=0,R=min(i,n-i+1);
		while(L&lt;R){
			mid=(L+R+1)&gt;&gt;1;
			if(git1(i-mid+1,i+mid-1)==git2(j-mid+1,j+mid-1))L=mid;else R=mid-1;
		}res+=L;
	}
	for(i=1;i&lt;n;++i){
		j=n-i;
		L=0,R=min(i,n-i);
		while(L&lt;R){
			mid=(L+R+1)&gt;&gt;1;
			if(git1(i-mid+1,i+mid)==git2(j-mid+1,j+mid))L=mid;else R=mid-1;
		}res+=L;
	}
	printf("%lld\n",res);
	return 0;
}</pre><pre></pre><h2>Problem2091</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#define M 1001001
using namespace std;
int n,a[M];
long long f[M],_max;
int main()
{
    int i;
    cin&gt;&gt;n;
    for(i=1;i&lt;=n;i++)
        scanf("%d",&amp;a[i]);
    sort(a+1,a+n+1);
    _max=a[1];
    for(i=1;i&lt;=n;i++)
    {
        f[i]=_max;
        _max=max(_max,a[i+1]-f[i]);
    }
    cout&lt;&lt;f[n]&lt;&lt;endl;
    return 0;
}</pre><pre></pre><h2>Problem2096</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=3e6+5;
int k,n;
int a[maxn];
deque&lt;int&gt;Min,Max;
int main(){
	scanf("%d%d",&amp;k,&amp;n);
	for(int i=1;i&lt;=n;i++)scanf("%d",&amp;a[i]);
	int l=1,r=n+1;
	while(l&lt;r){
		int mid=(l+r)&gt;&gt;1,ok=0;
		Min.clear();Max.clear();
		for(int i=1;i&lt;=mid;i++){
			while(Max.size()&amp;&amp;a[Max.back()]&lt;=a[i])Max.pop_back();
			while(Min.size()&amp;&amp;a[Min.back()]&gt;=a[i])Min.pop_back();
			Max.push_back(i);Min.push_back(i);
		}if(a[Max.front()]-a[Min.front()]&lt;=k){l=mid+1;ok=1;continue;}	
		for(int i=1;i+mid&lt;=n;i++){
			while(Max.size()&amp;&amp;Max.front()&lt;=i)Max.pop_front();
			while(Min.size()&amp;&amp;Min.front()&lt;=i)Min.pop_front();
			while(Max.size()&amp;&amp;a[Max.back()]&lt;=a[i+mid])Max.pop_back();
			while(Min.size()&amp;&amp;a[Min.back()]&gt;=a[i+mid])Min.pop_back();
			Max.push_back(i+mid);Min.push_back(i+mid);
			if(a[Max.front()]-a[Min.front()]&lt;=k){l=mid+1;ok=1;break;}	
		}if(!ok)r=mid;
	}cout&lt;&lt;l-1&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem2103</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=50010;
vector&lt;int&gt;G[maxn];
int n,m;
int w[maxn],sum[maxn],sums[maxn],fa[maxn],dep[maxn],mx[maxn],mxx[maxn];
void dfs(int u){
	sum[u]=w[u];
	for(int i=0,v;i&lt;G[u].size();i++){
		if((v=G[u][i])==fa[u])continue;
		dep[v]=dep[u]+1;
		fa[v]=u;dfs(v);
		sum[u]+=sum[v];
		sums[u]+=sums[v]+sum[v];
		if(sum[v]&gt;sum[mx[u]])mxx[u]=mx[u],mx[u]=v;
		else if(sum[v]&gt;sum[mxx[u]])mxx[u]=v;
	}
}
int ans=INT_MAX,res;
void Move(int t,int u,int S){
	for(;;){
		int v=mx[t]!=u?mx[t]:mxx[t];
		if(!v||v==u||sum[v]*2-S&lt;=0)break;
		res-=sum[v]*2-S;t=v;
	}
}
int solve(int u){
	for(int i=fa[u];i;i=fa[i])sum[i]-=sum[u];
	res=sums[1]-sum[u]*dep[u];
	Move(1,u,sum[1]);
	Move(u,u,sum[u]);
	ans=min(ans,res);
	for(int i=fa[u];i;i=fa[i])sum[i]+=sum[u];
}
int main(){
	scanf("%d",&amp;n);
	for(int i=1;i&lt;n;i++){
		int u,v;scanf("%d%d",&amp;u,&amp;v);
		G[u].push_back(v);
		G[v].push_back(u);
	}for(int i=1;i&lt;=n;i++)scanf("%d",&amp;w[i]);
	dfs(1);
	for(int i=2;i&lt;=n;i++)
	solve(i);
	cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem2104</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1e5+5;
const int inf=1061109567;
int n;
int a[6][maxn];
struct node{
	int ll[6][6],rr[6][6],lr[6][6];
	void clear(){memset(ll,0x3f,sizeof ll);memset(rr,0x3f,sizeof rr);
				memset(lr,0x3f,sizeof lr);}
	bool empty()const{return ll[0][0]==inf;}	
	void deb(){
		puts("ll");
		for(int i=0;i&lt;6;i++)for(int j=0;j&lt;6;j++)printf("%d%c",ll[i][j]," \n"[j==5]);
		puts("rr");
		for(int i=0;i&lt;6;i++)for(int j=0;j&lt;6;j++)printf("%d%c",rr[i][j]," \n"[j==5]);
		puts("lr");
		for(int i=0;i&lt;6;i++)for(int j=0;j&lt;6;j++)printf("%d%c",lr[i][j]," \n"[j==5]);
		puts("");
	}
}t[maxn&lt;&lt;2];
node operator+(const node &amp;ls,const node &amp;rs){
	static int lm[6][6],rm[6][6];
	if(ls.empty())return rs;if(rs.empty())return ls;
	node a;a.clear();
	memset(lm,0x3f,sizeof lm);memset(rm,0x3f,sizeof rm);
	for(int k=0;k&lt;6;k++)for(int i=0;i&lt;6;i++)for(int j=0;j&lt;6;j++)
	lm[i][j]=min(lm[i][j],ls.lr[i][k]+rs.ll[k][j]+ls.rr[j][j]),
	rm[i][j]=min(rm[i][j],rs.ll[i][i]+ls.rr[i][k]+rs.lr[k][j]);
	for(int i=0;i&lt;6;i++)
	for(int j=0;j&lt;6;j++){
		a.ll[i][j]=ls.ll[i][j];a.rr[i][j]=rs.rr[i][j];a.lr[i][j]=inf;
		for(int k=0;k&lt;6;k++){
			a.ll[i][j]=min(a.ll[i][j],lm[i][k]+ls.lr[j][k]-ls.rr[k][k]);
			a.rr[i][j]=min(a.rr[i][j],rm[k][i]+rs.lr[k][j]-rs.ll[k][k]);
			a.lr[i][j]=min(a.lr[i][j],ls.lr[i][k]+rs.lr[k][j]);
			a.lr[i][j]=min(a.lr[i][j],lm[i][k]+rm[k][j]-ls.rr[k][k]-rs.ll[k][k]);
		}
	}return a;
}
#define lson i&lt;&lt;1,l,(l+r)/2
#define rson i&lt;&lt;1|1,(l+r)/2+1,r
#define ls i&lt;&lt;1
#define rs i&lt;&lt;1|1
void init(int i,int l){
	int sum[6];
	for(int j=0;j&lt;6;j++)sum[j]=(j?sum[j-1]:0)+a[j][l];
	for(int j=0;j&lt;6;j++)for(int k=0;k&lt;6;k++)
	t[i].ll[j][k]=t[i].rr[j][k]=t[i].lr[j][k]=sum[max(j,k)]-(min(j,k)?sum[min(j,k)-1]:0);
	return;
}
void build(int i,int l,int r){
	if(l==r){
		init(i,l);
//		t[i].deb();
		return;
	}
	build(lson);build(rson);
	t[i]=t[ls]+t[rs];
//	t[i].deb();
}
void Change(int i,int l,int r,int ps){
	if(l==r){init(i,l);return;}
	if(ps&lt;=(l+r)/2)Change(lson,ps);
	else Change(rson,ps);
	t[i]=t[ls]+t[rs];
}
node Qmin(int i,int l,int r,int l0,int r0){
	if(l0&lt;=l&amp;&amp;r0&gt;=r)return t[i];
	node ans;ans.clear();
	if(l0&lt;=(l+r)/2)ans=Qmin(lson,l0,r0)+ans;
	if(r0&gt;(l+r)/2)ans=ans+Qmin(rson,l0,r0);
	return ans;
}	
#undef ls
#undef rs
int Qmin(int sx,int sy,int tx,int ty){
	node ls=Qmin(1,1,n,1,sy);
	node md=Qmin(1,1,n,sy,ty);
	node rs=Qmin(1,1,n,ty,n);
	int ans=md.lr[sx][tx];
	for(int i=0;i&lt;6;i++)for(int j=0;j&lt;6;j++){
		ans=min(ans,md.ll[sx][i]+ls.rr[i][j]+md.lr[j][tx]-a[i][sy]-a[j][sy]);
		ans=min(ans,md.lr[sx][i]+rs.ll[i][j]+md.rr[j][tx]-a[i][ty]-a[j][ty]);
		ans=min(ans,ls.rr[sx][i]+md.lr[i][j]+rs.ll[j][tx]-a[i][sy]-a[j][ty]);
	}return ans;
}
int getint(){
	int res=0;char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))res=res*10+c-'0',c=getchar();
	return res;
}
int main(){
	n=getint();
	for(int i=0;i&lt;6;i++)
	for(int j=1;j&lt;=n;j++)
	a[i][j]=getint();
	build(1,1,n);
	int m=getint();
	while(m--){
		int op=getint();
		if(op==1){
			int x=getint(),y=getint(),z=getint();
			a[x-1][y]=z;
			Change(1,1,n,y);
		}else{
			int x=getint(),y=getint(),z=getint(),w=getint();
			if(y&gt;w){swap(x,z);swap(y,w);}
			printf("%d\n",Qmin(x-1,y,z-1,w));
		}
	}
	return 0;
}</pre><pre></pre><h2>Problem2115</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;cctype&gt;
using namespace std;
const int maxn=100010;
typedef unsigned long long LL;
struct edge{int u,v;LL w;};
vector&lt;edge&gt;G[maxn];
LL a[maxn&lt;&lt;1],w[maxn],base[233];
int vis[maxn],size,n,m;
template&lt;class T&gt;
T getint(){
	T res=0;char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))res=res*10+c-'0',c=getchar();
	return res;
}
void dfs(int u){
	for(int i=0;i&lt;G[u].size();i++){
		edge e=G[u][i];
		if(!vis[e.v]){
			vis[e.v]=1;
			w[e.v]=w[u]^e.w;
			dfs(e.v);
		}else a[++size]=w[u]^w[e.v]^e.w;
	}
}
int main(){
	n=getint&lt;int&gt;();m=getint&lt;int&gt;();
	for(int i=1;i&lt;=m;i++){
		int u=getint&lt;int&gt;(),v=getint&lt;int&gt;();
		LL w=getint&lt;LL&gt;();
		G[u].push_back((edge){u,v,w});
		G[v].push_back((edge){v,u,w});
	}vis[1]=1;dfs(1);
	for(int i=1;i&lt;=size;i++)
	for(int j=63;j&gt;=0;j--){
		if(a[i]&gt;&gt;j&amp;1){
			if(!base[j]){base[j]=a[i];break;}
			else a[i]^=base[j];
		}
	}LL ans=w[n];
	for(int i=63;i&gt;=0;i--)ans=max(ans,ans^base[i]);
	cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem2115</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;cctype&gt;
using namespace std;
const int maxn=50010;
typedef unsigned long long LL;
struct edge{int u,v;LL w;};
vector&lt;edge&gt;G[maxn];
LL a[maxn&lt;&lt;2],w[maxn],base[64];
int vis[maxn],size,n,m;
template&lt;class T&gt;
T getint(){
	T res=0;char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))res=res*10+c-'0',c=getchar();
	return res;
}
void dfs(int u){
	for(int i=0;i&lt;G[u].size();i++){
		edge e=G[u][i];
		if(!vis[e.v]){
			vis[e.v]=1;
			w[e.v]=w[u]^e.w;
			dfs(e.v);
		}else a[++size]=w[u]^w[e.v]^e.w;
	}
}
int main(){
	n=getint&lt;int&gt;();m=getint&lt;int&gt;();
	for(int i=1;i&lt;=m;i++){
		int u=getint&lt;int&gt;(),v=getint&lt;int&gt;();
		LL w=getint&lt;LL&gt;();
		G[u].push_back((edge){u,v,w});
		G[v].push_back((edge){v,u,w});
	}vis[1]=1;dfs(1);
	for(int i=1;i&lt;=size;i++)
	for(int j=63;j&gt;=0;j--){
		if(a[i]&gt;&gt;j&amp;1){
			if(!base[j]){base[j]=a[i];break;}
			else a[i]^=base[j];
		}
	}LL ans=w[n];
	for(int i=63;i&gt;=0;i--)ans=max(ans,ans^base[i]);
	cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem2116</h2><pre>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
#include&lt;map&gt;
#define maxn 300000
using namespace std;
typedef long long LL;
template&lt;class T&gt;
void Read(T &amp;digit)
{
	digit=0;
	char c;
	for(c=getchar();(c&lt;'0'||c&gt;'9')&amp;&amp;c!='-';c=getchar());
	bool type=true;
	if(c=='-')
		type=false,c=getchar();
	for(;c&gt;='0'&amp;&amp;c&lt;='9';digit=digit*10+c-'0',c=getchar());
	if(type==false)
		digit=-digit;
}
int n,m,nTree;
LL delta[maxn],total;
struct Node
{
	Node *fa,*son[2];
	int size;
	LL sum,val;
}*Root,*st[maxn];
map&lt; int,pair&lt;Node*,int&gt; &gt;Table;
int top;
struct message
{
	LL maxv,sum;
	message() {}
	message(LL maxv,LL sum): maxv(maxv),sum(sum) {}
	friend message operator + (const message &amp;a,const message &amp;b)
	{
		message c;
		c.maxv=max(a.maxv,b.maxv),c.sum=a.sum+b.sum;
		return c;
	}
}Tree[maxn];
message Query(int l,int r)
{
	message ans=message(-1&lt;&lt;30,0);
	for(l=l-1+nTree,r=r+nTree+1;l^r^1;l&gt;&gt;=1,r&gt;&gt;=1)
	{
		if(~l&amp;1)
			ans=ans+Tree[l^1];
		if(r&amp;1)
			ans=ans+Tree[r^1];
	}
	return ans;
}
void Modify(int p,LL v)
{
	p+=nTree;
	Tree[p]=message(v,v);
	for(p=p&gt;&gt;1;p;p&gt;&gt;=1)
		Tree[p]=Tree[p&lt;&lt;1]+Tree[p&lt;&lt;1|1];
}
void update(Node *p)
{
	p-&gt;size=1,p-&gt;sum=p-&gt;val;
	if(p-&gt;son[0])
		p-&gt;size+=p-&gt;son[0]-&gt;size,p-&gt;sum+=p-&gt;son[0]-&gt;sum;
	if(p-&gt;son[1])
		p-&gt;size+=p-&gt;son[1]-&gt;size,p-&gt;sum+=p-&gt;son[1]-&gt;sum;
}
void Rotate(Node *p,Node *x)
{
	int mark=p==x-&gt;son[1];
	Node *y=p-&gt;son[mark^1],*z=x-&gt;fa;
	if(y!=0)
		y-&gt;fa=x;
	if(z!=0)
		z-&gt;son[x==z-&gt;son[1]]=p;
	p-&gt;son[mark^1]=x,p-&gt;fa=z,x-&gt;son[mark]=y,x-&gt;fa=p,update(x);
}
void Splay(Node *p)
{
	while(p-&gt;fa)
	{
		Node *x=p-&gt;fa,*y=x-&gt;fa;
		if(y==0)
			Rotate(p,x);
		else if((p==x-&gt;son[1])^(x==y-&gt;son[1]))
			Rotate(p,x),Rotate(p,y);
		else
			Rotate(x,y),Rotate(p,x);
	}
	update(p),Root=p;
}
void Insert(Node *p,int l,int r)
{
	message v=Query(l,r);
	LL val=v.sum-v.maxv;
	if(p==0)
	{
		Node *q=st[top--];
		q-&gt;val=q-&gt;sum=val,q-&gt;size=1;
		q-&gt;son[0]=q-&gt;son[1]=q-&gt;fa=0;
		Root=q;
		return ;
	}
	for(Node *i=p;;i=i-&gt;son[i-&gt;val&lt;val])
		if(i-&gt;son[i-&gt;val&lt;val]==0)
		{
			Node *q=st[top--];
			q-&gt;son[0]=q-&gt;son[1]=0;
			q-&gt;fa=i,q-&gt;val=val,i-&gt;son[i-&gt;val&lt;val]=q,Splay(q);
			return ;
		}
}
void Delete(Node *p)
{
	Splay(p);
	if(p-&gt;son[0]==0&amp;&amp;p-&gt;son[1]==0)
		Root=0;
	else if(p-&gt;son[0]==0&amp;&amp;p-&gt;son[1]!=0)
		Root=p-&gt;son[1],Root-&gt;fa=0;
	else if(p-&gt;son[0]!=0&amp;&amp;p-&gt;son[1]==0)
		Root=p-&gt;son[0],Root-&gt;fa=0;
	else
		for(Node *i=p-&gt;son[0];;i=i-&gt;son[1])
			if(i-&gt;son[1]==0)
			{
				p-&gt;son[0]-&gt;fa=0,p-&gt;son[1]-&gt;fa=i,i-&gt;son[1]=p-&gt;son[1];
				Splay(i);
				break;
			}
	st[++top]=p;
}
int Query(Node *p,LL sum)
{
	if(sum&lt;=0)
		return 0;
	if(p==0||p-&gt;sum+sum&gt;0)
		return -1;
	int ans=0;
	while(1)
	{
		int Left=p-&gt;son[0]?p-&gt;son[0]-&gt;sum:0,sLeft=p-&gt;son[0]?p-&gt;son[0]-&gt;size:0;
		if(Left+sum&gt;0&amp;&amp;Left+sum+p-&gt;val&lt;=0)
		{
			ans=ans+sLeft+1;
			Splay(p);
			return ans;
		}
		else if(Left+sum+p-&gt;val&gt;0)
			ans=ans+sLeft+1,sum=sum+Left+p-&gt;val,p=p-&gt;son[1];
		else
			p=p-&gt;son[0];
	}
}
void read()
{
	Table.clear();
	Root=0,total=0;
	static int a[maxn];
	Read(n),Read(m);
	top=n;
	for(int i=1;i&lt;=top;++i)
		st[i]=new Node;
	for(int i=1;i&lt;=n;++i)
		Read(a[i]);
	for(int i=2;i&lt;=n;++i)
	{
		delta[i]=a[i]-a[i-1];
		if(delta[i]&gt;0)
			total+=delta[i];
	}
	for(nTree=1;nTree-2&lt;n;nTree&lt;&lt;=1);
	for(int i=nTree+1;i&lt;=nTree+nTree;++i)
		Tree[i]=message(-1&lt;&lt;30,0);
	for(int i=1;i&lt;=n;++i)
		Tree[i+nTree]=message(delta[i],delta[i]);
	for(int i=nTree;i&gt;=1;--i)
		Tree[i]=Tree[i&lt;&lt;1]+Tree[i&lt;&lt;1|1];
	for(int i=2;i&lt;=n;++i)
	{
		int j=i;
		while(i&lt;=n&amp;&amp;delta[i]&lt;=0)
			++i;
		if(i!=j)
			Insert(Root,j,i-1),Table[j]=make_pair(Root,i-1);
	}
}
void add(int b,int d)
{
	int sig1=delta[b]&gt;0?1:-1;
	delta[b]+=d;
	int sig2=delta[b]&gt;0?1:-1;
	Modify(b,delta[b]);
	if(sig1==1&amp;&amp;sig2==1)
		total+=d;
	else if(sig1==1&amp;&amp;sig2==-1)
	{
		total=total-(delta[b]-d);
		map&lt; int,pair&lt;Node*,int&gt; &gt;::iterator R=Table.upper_bound(b),L=R;
		if(L!=Table.begin())
			--L;
		int l=b,r=b;
		if(L!=R&amp;&amp;L-&gt;second.second==b-1)
			l=L-&gt;first,Delete(L-&gt;second.first);
		if(R!=Table.end()&amp;&amp;R-&gt;first==b+1)
			r=R-&gt;second.second,Delete(R-&gt;second.first);
		if(L==R&amp;&amp;L-&gt;first==b+1)
			Table.erase(L);
		else
		{
			if(L-&gt;second.second==b-1)
				Table.erase(L);
			if(R!=Table.end()&amp;&amp;R-&gt;first==b+1)
				Table.erase(R);
		}
		Insert(Root,l,r);
		Table[l]=make_pair(Root,r);
	}
	else if(sig1==-1&amp;&amp;sig2==1)
	{
		total+=delta[b];
		map&lt; int,pair&lt;Node*,int&gt; &gt;::iterator it=Table.upper_bound(b);
		--it;
		int l=it-&gt;first,r=it-&gt;second.second;
		Delete(it-&gt;second.first),Table.erase(it);
		if(l&lt;b)
			Insert(Root,l,b-1),Table[l]=make_pair(Root,b-1);
		if(b&lt;r)
			Insert(Root,b+1,r),Table[b+1]=make_pair(Root,r);
	}
	else
	{
		map&lt; int,pair&lt;Node*,int&gt; &gt;::iterator it=Table.upper_bound(b);
		--it;
		int l=it-&gt;first,r=it-&gt;second.second;
		Delete(it-&gt;second.first),Table.erase(it);
		Insert(Root,l,r),Table[l]=make_pair(Root,r);
	}
}
void Query()
{
	for(int i=1,a,b,c,d;i&lt;=m;++i)
	{
		Read(a);
		if(a==1)
		{
			map&lt; int, pair&lt;Node*,int&gt; &gt;::iterator L=Table.begin(),R=Table.end();
			int l1,r1,l2,r2;
			if(delta[2]&lt;0)
				l1=2,r1=L-&gt;second.second,Delete(L-&gt;second.first),Table.erase(L);
			if(delta[n]&lt;0)
				--R,l2=R-&gt;first,r2=n,Delete(R-&gt;second.first),Table.erase(R);
			printf("%lld %d\n",total,Query(Root,total));
			if(delta[2]&lt;0)
				Insert(Root,l1,r1),Table[2]=make_pair(Root,r1);
			if(delta[n]&lt;0)
				Insert(Root,l2,r2),Table[l2]=make_pair(Root,n);
		}
		else
		{
			Read(b),Read(c),Read(d);
			if(b&gt;1)
				add(b,d);
			if(c&lt;n)
				add(c+1,-d);
		}
	}
}
int main()
{
	int test;
	for(Read(test);test;--test)
	{
		read();
		Query();
	}
	return 0;
}
</pre><pre></pre><h2>Problem2120</h2><pre>#include&lt;cstring&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int N=10010,M=1000010;
int x,y,n,m,a[N],d[M],ans,tmp;

int main()
{
	scanf("%d%d",&amp;n,&amp;m);
	memset(d,0,sizeof(d));
	for(int i=1;i&lt;=n;i++)scanf("%d",a+i);
	for(int i=1;i&lt;=n;i++)if(!d[a[i]]++)ans++;
	char c[10];
	while(m--)
	{
		scanf("%s%d%d",c,&amp;x,&amp;y);
		if(c[0]=='Q')
		{
			tmp=ans;
			for(int i=1;i&lt;=x-1;i++)if(!--d[a[i]]) ans--;
			for(int i=y+1;i&lt;=n;i++)if(!--d[a[i]]) ans--;
			printf("%d\n",ans);ans=tmp;
			for(int i=1;i&lt;=x-1;i++) d[a[i]]++;
			for(int i=y+1;i&lt;=n;i++) d[a[i]]++;
		}
		else
		{
			d[a[x]]--;
			if(!d[a[x]]) ans--;a[x]=y;
			if(!d[a[x]]) ans++;d[a[x]]++;
		}
	}
}</pre><pre></pre><h2>Problem2120</h2><pre>#include&lt;bits/stdc++.h&gt;
#define rnd() ((rand()&lt;&lt;16)|rand())
using namespace std;
const int maxn=1e5+10;
map&lt;int,int&gt;M,mp;
set&lt;int&gt;S[maxn&lt;&lt;1];
int pre[maxn],nxt[maxn],n,m,a[maxn];
struct Treap{
	struct node;
	node *root,*Null;
	struct node{
		int val,key,size,s;
		node *c[2];
		void set(int _val,node *C){
			val=_val;key=rnd();c[0]=c[1]=C;
			size=s=1;
		}
		node *rz(){
			size=c[0]-&gt;size+c[1]-&gt;size+s;
			return this;
		}
	};
	Treap(){
		Null=new node();
		Null-&gt;set(INT_MIN,Null);Null-&gt;key=INT_MAX;
		Null-&gt;size=Null-&gt;s=0;
		root=Null;
	}
	void rot(node *&amp;t,bool d){
		node *p=t-&gt;c[d];t-&gt;c[d]=p-&gt;c[!d];
		p-&gt;c[!d]=t;t-&gt;rz();p-&gt;rz();t=p;
	}
	void _insert(node *&amp;t,int x){
		if(t==Null){
			t=new node();
			t-&gt;set(x,Null);
			return;
		}if(t-&gt;val==x){
			t-&gt;size++;t-&gt;s++;return;
		}
		_insert(t-&gt;c[x&gt;t-&gt;val],x);
		if(t-&gt;c[x&gt;t-&gt;val]-&gt;key&lt;t-&gt;key)
		rot(t,x&gt;t-&gt;val);else t-&gt;rz();
	}
	void _del(node *&amp;t,int x){
		if(t==Null)return;
		if(t-&gt;val==x){
			if(t-&gt;s&gt;1){
				t-&gt;size--;
				t-&gt;s--;
				return;
			}
			bool d=t-&gt;c[0]-&gt;key&gt;t-&gt;c[1]-&gt;key;
			if(t-&gt;c[d]==Null){
				delete t;
				t=Null;
				return;
			}rot(t,d);
			_del(t-&gt;c[!d],x);	
		}else _del(t-&gt;c[x&gt;t-&gt;val],x);
		t-&gt;rz();
	}
	int _rank(node *t,int x){
		if(t==Null)return 0;
		int r=t-&gt;c[0]-&gt;size;
		if(t-&gt;val&gt;x)return _rank(t-&gt;c[0],x);
		if(t-&gt;val==x)return r;
		if(t-&gt;val&lt;x)return r+t-&gt;s+_rank(t-&gt;c[1],x);
	}
	int size(){return root-&gt;size;}
	void insert(int x){return _insert(root,x);}
	void del(int x){return _del(root,x);}
	int rank(int x){return _rank(root,x);}
};
struct seg_tree{
	Treap t[maxn&lt;&lt;2];
	#define lson i&lt;&lt;1,l,mid
	#define rson i&lt;&lt;1|1,mid+1,r
	#define L i&lt;&lt;1
	#define R i&lt;&lt;1|1
	void build(int i,int l,int r){
		for(int o=l;o&lt;=r;o++)
		t[i].insert(pre[o]);
		if(l==r)return;
		int mid=(l+r)&gt;&gt;1;
		build(lson);build(rson);
	}
	void Change(int i,int l,int r,int pos,int val,int x){
		t[i].del(val);
		t[i].insert(x);
		if(l==r)return;
		int mid=(l+r)&gt;&gt;1;
		if(pos&lt;=mid)Change(lson,pos,val,x);
		else Change(rson,pos,val,x);
	}
	int Query(int i,int l,int r,int l0,int r0){
		if(l0&lt;=l&amp;&amp;r0&gt;=r){
			int deb=t[i].rank(l0);
			return deb;
		}
		int mid=(l+r)&gt;&gt;1,ans=0;
		if(l0&lt;=mid)ans+=Query(lson,l0,r0);
		if(r0&gt;mid)ans+=Query(rson,l0,r0);
		return ans;
	}
	#undef R
}T;
int tot=0;
void Q(int l,int r){
	printf("%d\n",T.Query(1,1,n,l,r));
}
void R(int pos,int val){
	if(!mp[val])mp[val]=++tot,S[tot].insert(0);
	int x=mp[val],y=mp[a[pos]];
	a[pos]=val;
	set&lt;int&gt;::iterator it1,it2;
	it1=--S[y].lower_bound(pos);
	it2=S[y].upper_bound(pos);
	if(it2!=S[y].end()){
		T.Change(1,1,n,*it2,pre[*it2],*it1);
		pre[*it2]=*it1;	
	}
	
	S[y].erase(pos);
	
	S[x].insert(pos);
	it1=--S[x].lower_bound(pos);
	it2=S[x].upper_bound(pos);
	T.Change(1,1,n,pos,pre[pos],*it1);
	pre[pos]=*it1;		
	if(it2!=S[x].end()){	
		T.Change(1,1,n,*it2,pre[*it2],pos);
		pre[*it2]=pos;
	}

	
}
int main(){
	srand(10086);
	scanf("%d%d",&amp;n,&amp;m);
	for(int i=1;i&lt;=n;i++)scanf("%d",&amp;a[i]);
	for(int i=1;i&lt;=n;i++){
		if(!mp[a[i]])mp[a[i]]=++tot,S[tot].insert(0);
		pre[i]=M[a[i]];
		M[a[i]]=i;
		S[mp[a[i]]].insert(i);
	}M.clear();
	T.build(1,1,n);
	while(m--){
		char op=getchar();
		while(op!='Q'&amp;&amp;op!='R')op=getchar();
		int l,r;scanf("%d%d",&amp;l,&amp;r);
		if(op=='Q'){
			Q(l,r);
		}else{
			R(l,r);
		}
	}
	return 0;
}</pre><pre></pre><h2>Problem2127</h2><pre>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
#define T 10001
#define inf 0x7fffffff
#define FOR for(int i=1;i&lt;=n;i++)for(int j=1;j&lt;=m;j++)
#define rep(x,y) for(int i=1;i&lt;=x;i++)for(int j=1;j&lt;=y;j++)
#define ll long long
using namespace std;
int n,m,ans,tot,cnt=1,head[10002],h[10002];
int a[101][101],b[101][101],color[101][101],mark[101][101];
int xx[4]={0,0,1,-1},yy[4]={1,-1,0,0};
struct data{int to,next,v;}e[300001];
void ins(int u,int v,int w)
{cnt++;e[cnt].to=v;e[cnt].v=w;e[cnt].next=head[u];head[u]=cnt;}
void insert(int u,int v,int w)
{ins(u,v,w);ins(v,u,0);}
void ins2(int u,int v,int w)
{ins(u,v,w);ins(v,u,w);}
bool bfs()
{
     int q[10005],t=0,w=1,i,now;
     memset(h,-1,sizeof(h));
     q[0]=h[0]=0;
     while(t!=w)
     {
            now=q[t];t++;if(t==10001)t=0;
            for(i=head[now];i;i=e[i].next)
            {
                  if(e[i].v&amp;&amp;h[e[i].to]&lt;0)
                        {h[e[i].to]=h[now]+1;q[w++]=e[i].to;if(w==10001)w=0;}
             }
     }
     if(h[T]==-1)return 0;return 1;
     }
int dfs(int x,int f)
{
    if(x==T)return f;
    int w,used=0;
    for(int i=head[x];i;i=e[i].next)
    {
            if(e[i].v&amp;&amp;h[e[i].to]==h[x]+1)
            {
                w=f-used;
                w=dfs(e[i].to,min(w,e[i].v));   
                e[i].v-=w;e[i^1].v+=w;
                used+=w;if(used==f)return f;                      
                }
            }
    if(!used)h[x]=-1;
    return used;
    }
void dinic(){while(bfs())ans+=dfs(0,inf);}
void build()
{
	int x;
	rep(n-1,m)
	{
	   scanf("%d",&amp;x);tot+=x;
	   a[i][j]+=x;a[i+1][j]+=x;
	   ins2(mark[i][j],mark[i+1][j],x);
	   }
	rep(n-1,m)
	{
	   scanf("%d",&amp;x);tot+=x;
	   b[i][j]+=x;b[i+1][j]+=x;
	   ins2(mark[i][j],mark[i+1][j],x);
	   }
	rep(n,m-1)
	{
	   scanf("%d",&amp;x);tot+=x;
	   a[i][j]+=x;a[i][j+1]+=x;
	   ins2(mark[i][j],mark[i][j+1],x);
	   }
	rep(n,m-1)
	{
	   scanf("%d",&amp;x);tot+=x;
	   b[i][j]+=x;b[i][j+1]+=x;
	   ins2(mark[i][j],mark[i][j+1],x);
	   }
	FOR{
		   insert(0,mark[i][j],a[i][j]);
		   insert(mark[i][j],T,b[i][j]);
	   }
}
int main()
{
	scanf("%d%d",&amp;n,&amp;m);
	FOR scanf("%d",&amp;a[i][j]),tot+=a[i][j],a[i][j]&lt;&lt;=1;
	FOR scanf("%d",&amp;b[i][j]),tot+=b[i][j],b[i][j]&lt;&lt;=1;
	FOR mark[i][j]=(i-1)*m+j;
	build();dinic();
	printf("%d",tot-(ans&gt;&gt;1));
	return 0;
}</pre><pre></pre><h2>Problem2134</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
int n,A,B,C,a;
int main(){
	scanf("%d%d%d%d%d",&amp;n,&amp;A,&amp;B,&amp;C,&amp;a); 
	double ans=0;int _a=a;
	for (int i=2;i&lt;=n;i++){
		int b = ((long long)a * A + B) % 100000001;
		ans+=min((a%C+1),(b%C+1))/double(LL(a%C+1)*(b%C+1));
		a=b;
	}ans+=min((a%C+1),(_a%C+1))/double(LL(a%C+1)*(_a%C+1));
	printf("%.3lf\n",ans);
	return 0;
}
</pre><pre></pre><h2>Problem2140</h2><pre>#include&lt;bits/stdc++.h&gt;
#include&lt;ext/pb_ds/assoc_container.hpp&gt;
using namespace std;
using namespace __gnu_pbds;
char s[20];
trie&lt;string,int&gt;M;
int z,n,m;
vector&lt;int&gt;G[4001];
int Link[8001],vis[8001],_Link[8001];
int fu,fv,man[4040],woman[4040];
int find(int u){
	for(int i=0;i&lt;G[u].size();i++){
		int v=G[u][i];if(vis[v])continue;
		if(u==fu&amp;&amp;v==fv)continue;
		vis[v]=1;
		if(!Link[v]||find(Link[v])){
			Link[v]=u;return 1;
		}
	}return 0;
}
int main(){
	scanf("%d",&amp;n);
	for(int i=1;i&lt;=n;i++){
		int u,v;
		scanf("%s",s);
		u=M[s]=i;
		scanf("%s",s);
		v=M[s]=i+n;
		G[u].push_back(v);
		Link[v]=u;
		_Link[v]=u;
		man[i]=u;woman[i]=v;
	}scanf("%d",&amp;m);
	while(m--){
		int u,v;
		scanf("%s",s);
		u=M[s];
		scanf("%s",s);
		v=M[s];
		if(u&gt;v)swap(u,v);
		G[u].push_back(v);
	}
	for(int i=1;i&lt;=n;i++){
		memset(vis,0,sizeof vis);
		copy(_Link+n,_Link+n*2+1,Link+n);
		fu=man[i];
		fv=woman[i];
		Link[woman[i]]=0;		
		if(find(i))puts("Unsafe");
		else puts("Safe");
	}
	return 0;
}</pre><pre></pre><h2>Problem2141</h2><pre>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;cstring&gt;
#include&lt;cstdlib&gt;
#include&lt;algorithm&gt;
#define ll long long
#define inf 1000000000
using namespace std;
inline int read()
{
    int x=0,f=1;char ch=getchar();
    while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
int n,m,block,cnt,ans;
int l[605],r[605];
int a[20005],b[20005],t[20005],disc[20005],belong[20005];
inline int lowbit(int x){return x&amp;(-x);}
inline void update(int x,int val)
{
	for(int i=x;i&lt;=n;i+=lowbit(i))
		t[i]+=val;
}
inline int query(int x)
{
	int sum=0;
	for(int i=x;i;i-=lowbit(i))
		sum+=t[i];
	return sum;
}
inline int disc_find(int x)
{
	int l=1,r=n;
	while(l&lt;=r)
	{
		int mid=(l+r)&gt;&gt;1;
		if(disc[mid]==x)return mid;
		else if(disc[mid]&lt;x)l=mid+1;
		else r=mid-1;
	}
}
int finddown(int l,int r,int x)
{
	int ans=l-1,t=l;
	while(l&lt;=r)
	{
		int mid=(l+r)&gt;&gt;1;
		if(a[mid]&lt;x)ans=mid,l=mid+1;
		else r=mid-1;
	}
	return ans-t+1;
}
int findup(int l,int r,int x)
{
	int ans=r+1,t=r;
	while(l&lt;=r)
	{
		int mid=(l+r)&gt;&gt;1;
		if(a[mid]&gt;x)ans=mid,r=mid-1;
		else l=mid+1;
	}
	return t-ans+1;
}
void rebuild(int x)
{
	for(int i=l[x];i&lt;=r[x];i++)
		a[i]=b[i];
	sort(a+l[x],a+r[x]+1);
}
void pre()
{
	for(int i=n;i;i--)
	{
		ans+=query(b[i]-1);
		update(b[i],1);
	}
	for(int i=1;i&lt;=cnt;i++)
		rebuild(i);
}
void solve(int x,int y)
{
	if(x==y)return;
	int L=r[belong[x]],R=l[belong[y]];
	if(b[x]&lt;b[y])ans++;
	if(b[x]&gt;b[y])ans--;
	if(belong[x]==belong[y])
	{
		for(int i=x+1;i&lt;y;i++)
		{
			if(b[i]&gt;b[x])ans++;
			if(b[i]&lt;b[x])ans--;
			if(b[i]&gt;b[y])ans--;
			if(b[i]&lt;b[y])ans++;
		}
	}
	else 
	{
		for(int i=x+1;i&lt;=L;i++)
		{
			if(b[i]&gt;b[x])ans++;
			if(b[i]&lt;b[x])ans--;
			if(b[i]&gt;b[y])ans--;
			if(b[i]&lt;b[y])ans++;
		}
		for(int i=R;i&lt;y;i++)
		{
			if(b[i]&gt;b[x])ans++;
			if(b[i]&lt;b[x])ans--;
			if(b[i]&gt;b[y])ans--;
			if(b[i]&lt;b[y])ans++;
		}
		for(int i=belong[x]+1;i&lt;belong[y];i++)
		{
			ans-=finddown(l[i],r[i],b[x]);
			ans+=finddown(l[i],r[i],b[y]);
			ans+=findup(l[i],r[i],b[x]);
			ans-=findup(l[i],r[i],b[y]);
		}
	}
	swap(b[x],b[y]);
	rebuild(belong[x]);rebuild(belong[y]);
}
int main()
{
	n=read();
	block=sqrt(n);
	if(n%block)cnt=n/block+1;
	else cnt=n/block;
	for(int i=1;i&lt;=cnt;i++)
		l[i]=(i-1)*block+1,r[i]=i*block;
	r[cnt]=n;
	for(int i=1;i&lt;=n;i++)
		belong[i]=(i-1)/block+1;
	for(int i=1;i&lt;=n;i++)
		disc[i]=a[i]=read();
	sort(disc+1,disc+n+1);
	for(int i=1;i&lt;=n;i++)
		a[i]=b[i]=disc_find(a[i]);
	pre();
	printf("%d\n",ans);
	m=read();
	for(int i=1;i&lt;=m;i++)
	{
		int x=read(),y=read();
		if(x&gt;y)swap(x,y);
		solve(x,y);
		printf("%d\n",ans);
	}
	return 0;
}</pre><pre></pre><h2>Problem2145</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
string S;
string dict[700]={"a","i","am","an","as","at","be","by","do","go","he","if","in","is","it","ll","me","mr","my","no","of","on","or","re","so","to","up","ve","we","ago","all","and","any","are","bar","bat","big","bit","boy","bug","but","can","cat","cup","cut","day","did","dog","don","end","fee","fly","for","fox","fur","get","gnu","god","gpl","had","has","her","him","his","how","iee","iel","its","joy","key","law","let","may","mrs","new","nor","not","now","one","our","out","paw","pay","ran","run","sat","saw","see","set","she","six","tea","the","too","two","use","war","was","way","who","why","yet","you","zoo","adam","also","aren","away","back","bank","bear","beat","beef","been","bell","bill","bird","boar","body","bone","book","bore","both","came","camp","case","code","come","cook","copy","damn","damp","date","dead","deer","deny","dish","does","dull","each","ever","eyes","face","felt","fill","find","fire","fish","five","four","free","from","gain","gave","gets","girl","give","glad","good","hand","hard","have","here","high","hold","hour","hunt","ieee","into","jack","just","keep","kept","kiss","knew","know","lamb","last","lazy","lead","left","lend","life","like","live","long","look","love","made","make","many","mars","mary","meat","meet","mind","mine","moon","moor","more","morn","most","much","must","name","need","nine","once","only","over","paid","pain","papa","pass","past","pays","pink","play","poor","pray","puma","rain","ramp","rope","said","sake","same","seen","shed","show","sing","some","song","stop","such","sure","take","tape","tell","than","that","them","then","they","this","tied","time","tiny","told","tony","took","tree","trip","true","upon","used","user","very","wall","want","wasn","ways","well","went","were","what","when","whom","wife","wild","will","wish","with","wood","work","year","your","about","added","adore","after","again","aleko","along","among","apple","apply","armed","asked","began","being","below","betty","black","blade","bleed","blood","bored","brown","carry","catch","cause","chuck","clock","comes","could","death","doesn","doing","dwelt","eight","every","facts","fetch","field","fifty","first","forty","found","fully","given","gives","going","grant","great","hands","happy","hares","heart","hours","human","jumps","keeps","kinds","known","lamps","large","legal","lines","lived","local","lover","lovin","madam","makes","marks","merry","miles","money","moses","names","never","night","offer","often","other","paint","parts","place","plain","plays","price","prize","prove","pumas","quick","quiet","reach","right","roses","scamp","seven","shall","share","shine","sight","since","sixty","small","sorry","south","speak","stars","start","steel","steps","still","sword","table","taken","teeth","terms","thank","theft","their","there","these","thief","thing","think","those","three","times","today","torch","tower","trade","trail","truly","trust","under","users","vicar","wants","watch","weeks","where","which","while","white","whole","wings","woken","woman","words","works","world","worth","would","yards","years","yours"};
string rot(string S,int d){
	for(int i=0;i&lt;S.length();i++){
		if(isalpha(S[i])){
			S[i]=tolower(S[i]);
			S[i]=((S[i]-'a')+d)%26+'a';
		}
	}return S;
}
string _rot(string S,int d){
	for(int i=0;i&lt;S.length();i++){
		if(isalpha(S[i])){
			if(islower(S[i]))
				S[i]=((S[i]-'a')+d)%26+'a';
			else S[i]=((S[i]-'A')+d)%26+'A';
		}
	}return S;
}
set&lt;string&gt;M;
int calc(string S){
	vector&lt;string&gt;sp;
	int la=0;S=S+' ';
	for(int i=1;i&lt;S.length();i++){
		if(S[i]==' '||S[i]=='.'||S[i]=='!'||S[i]=='?'||S[i]==','||S[i]=='_'){
			if(i-la&gt;=1)
			sp.push_back(S.substr(la,i-la));
			la=i+1;
//			cerr&lt;&lt;sp.back()&lt;&lt;endl;
		}
	}int ans=0;
	for(int i=0;i&lt;sp.size();i++){
//		cerr&lt;&lt;sp[i]&lt;&lt;endl;
		if(M.count(sp[i]))ans++;
	}
	return ans;
}
void sol(){
	getline(cin,S);
//	cerr&lt;&lt;S&lt;&lt;endl;
	int ans=0;string anss=S;
	for(int i=0;i&lt;26;i++){
		int tmp=calc(rot(S,i));
//		cerr&lt;&lt;rot(S,i)&lt;&lt;endl;
		if(tmp&gt;ans){
			ans=tmp;
			anss=_rot(S,i);
		}
	}cout&lt;&lt;anss&lt;&lt;endl;
}
void I(string s){M.insert(s);}
int main(){
//	freopen("bzoj2145.in","r",stdin);
	for(int i=0;dict[i]!="";i++)
		I(dict[i]);
	int T=10;
	while(T--)sol();	
	return 0;
}</pre><pre></pre><h2>Problem2150</h2><pre>#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using namespace std;
int n,m,r,c;
int dx[4],dy[4];
int w[2555][2555];
int mp[51][51];
int hash[51][51];
int tot=0;
int vis[2555];
int Link[2555];
bool find(int x){
    for(int i=1;i&lt;=tot;i++){
        if(w[x][i]&amp;&amp;!vis[i]){
            vis[i]=1;
            if(!Link[i]||find(Link[i])){
                Link[i]=x;
                return true;
            }
        }
    }
    return false;
}
int main(){
    cin&gt;&gt;n&gt;&gt;m&gt;&gt;r&gt;&gt;c;
    dx[0]=r;dy[0]=c;
    dx[1]=r;dy[1]=-c;
    dx[2]=c;dy[2]=r;
    dx[3]=c;dy[3]=-r;
    string s;
    for(int i=1;i&lt;=n;i++){
        cin&gt;&gt;s;
        for(int j=0;j&lt;m;j++){
            if(s[j]=='.')
                mp[i][j+1]=0;
            else
                mp[i][j+1]=1;
        }
    }
    for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;=m;j++)
            if(!mp[i][j])
                hash[i][j]=++tot;
    for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;=m;j++){
            for(int k=0;k&lt;4;k++){
                int x=i+dx[k],y=j+dy[k];
                if(x&lt;1||y&lt;1||x&gt;n||y&gt;m)continue;
                w[hash[i][j]][hash[x][y]]=1;
            }
        }
    int ans=0;
    
    for(int i=1;i&lt;=tot;i++){
        memset(vis,0,sizeof(vis));
        if(find(i))ans+=1;
    }
    cout&lt;&lt;tot-ans&lt;&lt;endl;
    return 0;
}</pre><pre></pre><h2>Problem2151</h2><pre>#include&lt;set&gt;
#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
int n,m;
int a[400010];
int l[200010];
int r[200010];
long long ans=0;
typedef pair&lt;int,int&gt;pii;
set&lt;pii,greater&lt;pii&gt; &gt;s;
int main(){
	scanf("%d%d",&amp;n,&amp;m);
	if(m&gt;n/2){
		puts("Error!");return 0;
	}
	for(int i=1;i&lt;=n;i++)
		scanf("%d",&amp;a[i]);
	for(int i=1;i&lt;=n;i++)
	l[i]=i%n+1,r[i]=(i+n-2)%n+1;
	for(int i=1;i&lt;=n;i++)s.insert(pii(a[i],i));
	while(m--){
		set&lt;pii&gt;::iterator it=s.begin();
		ans+=it-&gt;first;
		int pn=it-&gt;second,pl=l[pn],pr=r[pn];
		a[pn]=a[pr]+a[pl]-a[pn];
		l[pn]=l[pl];r[l[pn]]=pn;
		r[pn]=r[pr];l[r[pn]]=pn;
		s.erase(*it);
		s.erase(pii(a[pl],pl));
		s.erase(pii(a[pr],pr));
		s.insert(pii(a[pn],pn));
	}
	cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem2152</h2><pre>#include&lt;cstdio&gt;
#include&lt;map&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
using namespace std;
const int maxn=20010;
struct edge{int u,v,w;};
vector&lt;edge&gt;G[maxn];
typedef int LL;
int siz[maxn],f[maxn],dep[maxn],n,root,cant[maxn],All;
LL d[maxn],ans,data[maxn];
void makert(int u,int fa){
	siz[u]=1;f[u]=0;
	for(int i=0;i&lt;G[u].size();i++){
		edge e=G[u][i];if(e.v==fa||cant[e.v])continue;
		makert(e.v,u);
		siz[u]+=siz[e.v];
		f[u]=max(f[u],siz[e.v]);
	}f[u]=max(f[u],All-f[u]);
	if(f[root]&gt;f[u])root=u;
}
void dfs(int u,int f){
	data[++data[0]]=d[u];
	for(int i=0;i&lt;G[u].size();i++){
		edge e=G[u][i];
		if(e.v==f||cant[e.v])continue;
		d[e.v]=d[u]+e.w;
		dfs(e.v,u);
	}
}
LL M[3];
void calc(int u){
	M[0]=M[1]=M[2]=0;M[0]++;
	for(int i=0;i&lt;G[u].size();i++){
		edge e=G[u][i];if(cant[e.v])continue;
		data[0]=0;
		d[e.v]=e.w;dfs(e.v,u);
		for(int j=1;j&lt;=data[0];j++)
			ans+=M[(3-data[j]%3)%3];
		for(int j=1;j&lt;=data[0];j++)M[data[j]%3]++;
	}
}
void solve(int u){
 	calc(u);cant[u]=1;
	for(int i=0;i&lt;G[u].size();i++){
		edge e=G[u][i];if(cant[e.v])continue;
		d[e.v]=0;f[root=0]=n+1;
		All=siz[e.v];
		makert(e.v,u);
		solve(root);
	}
}
int main(){
	scanf("%d",&amp;n);All=n;
	for(int i=2;i&lt;=n;i++){
		int u,v,w;scanf("%d%d%d",&amp;u,&amp;v,&amp;w);
		G[u].push_back((edge){u,v,w});
		G[v].push_back((edge){v,u,w});
	}f[root=0]=n+1;
	makert(1,0);
	solve(root);
	ans=ans*2+n;
	LL d=__gcd(ans,(LL)n*n);
	cout&lt;&lt;ans/d&lt;&lt;'/'&lt;&lt;(LL)n*n/d&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem2154</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
using namespace std;
const int maxn=1e7+5;
typedef long long LL;
int MOD=20101009;
int n,m;
bool p[maxn];
int prime[maxn];
LL u[maxn];
void init(int maxn){
	u[1]=1;
	for(int i=2;i&lt;maxn;i++){
		if(!p[i]){
			prime[++prime[0]]=i;u[i]=-1;
		}for(int j=1;j&lt;=prime[0]&amp;&amp;i*prime[j]&lt;maxn;j++){
			p[i*prime[j]]=1;
			if(i%prime[j]==0){
				u[i*prime[j]]=0;break;
			}else u[i*prime[j]]=-u[i];
		}
	}for(int i=2;i&lt;maxn;i++)u[i]=(u[i-1]+(LL)(i*u[i]%MOD*i))%MOD;
}
inline LL S(LL n,LL m){
	LL ans=0;
	if(n&gt;m)swap(n,m);
	for(int i=1,last;i&lt;=n;i=last+1){
		last=min(n/(n/i),m/(m/i));
		LL Sum=(n/i*(n/i+1)/2%MOD)*(m/i*(m/i+1)/2%MOD)%MOD;
		ans=(ans+(LL)(u[last]-u[i-1])*Sum%MOD)%MOD;
	}return ans;
}
int main(){
	cin&gt;&gt;n&gt;&gt;m;
	LL ans=0;
	if(n&gt;m)swap(n,m);
	init(m+1);
	for(int i=1,last;i&lt;=n;i=last+1){
		last=min(n/(n/i),m/(m/i));
		ans=(ans+(LL)(i+last)*(last-i+1)/2*(S(n/i,m/i)))%MOD;
	}while(ans&lt;0)ans+=MOD;
	cout&lt;&lt;ans%MOD&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem2157</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=40010;
struct node{
	int val,mx,mn,rev,sum,nag,pt;
	node *f,*c[2];
	void rz(){
		if(!pt)mx=mn=sum=val;
		else mx=-(~0u&gt;&gt;2),mn=~0u&gt;&gt;2,sum=0;
		if(c[0])mx=max(mx,c[0]-&gt;mx),mn=min(mn,c[0]-&gt;mn),sum+=c[0]-&gt;sum;
		if(c[1])mx=max(mx,c[1]-&gt;mx),mn=min(mn,c[1]-&gt;mn),sum+=c[1]-&gt;sum;
	}
	bool rt(){return !f||(f-&gt;c[0]!=this&amp;&amp;f-&gt;c[1]!=this);}
	void sets(node *x,int d){pd();if(x)x-&gt;f=this;c[d]=x;rz();}
	bool d(){return f-&gt;c[1]==this;}
	void makerv(){rev^=1;swap(c[0],c[1]);}
	void makeng(){nag^=1;swap(mx,mn);mx=-mx;mn=-mn;val=-val;sum=-sum;}
	void pd(){
		if(c[0]){if(rev)c[0]-&gt;makerv();if(nag)c[0]-&gt;makeng();}
		if(c[1]){if(rev)c[1]-&gt;makerv();if(nag)c[1]-&gt;makeng();}
		rev=nag=0;
	}
	//node(){val=sum=rev=0;c[0]=c[1]=0;}
}np[maxn],ne[maxn];
void rot(node *x){
	node *y=x-&gt;f;if(!y-&gt;rt())y-&gt;f-&gt;pd();
	y-&gt;pd();x-&gt;pd();int d=x-&gt;d();
	y-&gt;sets(x-&gt;c[!d],d);
	if(y-&gt;rt())x-&gt;f=y-&gt;f;
	else y-&gt;f-&gt;sets(x,y-&gt;d());
	x-&gt;sets(y,!d);
}
void splay(node *x){
	while(!x-&gt;rt()){
		if(x-&gt;f-&gt;rt())rot(x);
		else if(x-&gt;d()==x-&gt;f-&gt;d())rot(x-&gt;f),rot(x);
		else rot(x),rot(x);
	}
}
node* access(node *x){
	node *y=0;
	for(;x;x=x-&gt;f){
		splay(x);
		x-&gt;sets(y,1);
		y=x;
	}return y;
}
void makert(node *x){
	access(x)-&gt;makerv();
	splay(x);
}
int getint(){
	int res=0,f=1;char c=getchar();
	while(!isdigit(c))f=c=='-'?-1:f,c=getchar();
	while(isdigit(c))res=res*10+c-'0',c=getchar();
	return res*f;
}
void link(node *u,node *v){
	makert(u);
	u-&gt;f=v;
	access(u);
}
int main(){
	int n=getint();
	for(int i=0;i&lt;n;i++)np[i].pt=1;
	for(int i=1;i&lt;n;i++){
		int u=getint(),v=getint(),w=getint();
		ne[i].val=w;ne[i].rz();
		link(np+u,ne+i);link(ne+i,np+v);
	}int m=getint();
	while(m--){
		char opt[10];scanf("%s",opt);
		if(opt[0]=='C'){
			node *u=ne+getint();int w=getint();
			makert(u);splay(u);u-&gt;pd();u-&gt;val=w;u-&gt;rz();
		}else if(opt[0]=='S'){
			node *u=np+getint(),*v=np+getint();
			makert(u);access(v);splay(v);
			printf("%d\n",v-&gt;sum);
		}else if(opt[0]=='N'){
			node *u=np+getint(),*v=np+getint();
			makert(u);access(v);splay(v);
			v-&gt;makeng();
		}else if(opt[1]=='A'){
			node *u=np+getint(),*v=np+getint();
			makert(u);access(v);splay(v);
			printf("%d\n",v-&gt;mx);
		}else if(opt[1]='I'){
			node *u=np+getint(),*v=np+getint();
			makert(u);access(v);splay(v);
			printf("%d\n",v-&gt;mn);	
		}
	}
	return 0;
}</pre><pre></pre><h2>Problem2163</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
#include&lt;cstring&gt;
#include&lt;climits&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#define X first 
#define Y second
using namespace std;
typedef pair&lt;int,int&gt; pii;
const int maxn=20010;
int n,m;
int tot;
struct edge{
	int u,v,cap,flow;
	edge(int _u,int _v,int _cap,int _flow){
		u=_u;v=_v;cap=_cap;flow=_flow;
	}
};
vector&lt;edge&gt;edges;
vector&lt;int&gt;G[maxn];
int cur[maxn];
void add(int u,int v,int cap){
	edges.push_back(edge(u,v,cap,0));
	G[u].push_back(edges.size()-1);
	edges.push_back(edge(v,u,0,0));
	G[v].push_back(edges.size()-1);
}
int s,t;
int d[maxn];
int vis[maxn];
bool bfs(){	
	queue&lt;int&gt;q;
	memset(d,0,sizeof(d));
	memset(vis,0,sizeof(vis));
	q.push(s);vis[s]=1;
	while(!q.empty()){
		int u=q.front();q.pop();
		for(int i=0;i&lt;G[u].size();i++){
			edge e=edges[G[u][i]];
			if(e.cap&gt;e.flow&amp;&amp;!vis[e.v]){
				vis[e.v]=1;
				d[e.v]=d[u]+1;
				q.push(e.v);
			}
		}
	}
	return vis[t];
}
int dfs(int x,int a){
	if(x==t||a==0)return a;
	int flow=0,f;
	for(int &amp;i=cur[x];i&lt;G[x].size();i++){
		edge e=edges[G[x][i]];
		if(d[e.v]==d[x]+1&amp;&amp;(f=dfs(e.v,min(a,e.cap-e.flow)))&gt;0){
			edges[G[x][i]].flow+=f;
			edges[G[x][i]^1].flow-=f;
			flow+=f;
			a-=f;
			if(!a)
				break;
		}
	}
	return flow;
}
int Dinic(){
	int flow=0;
	while(bfs()){
		int x;
		memset(cur,0,sizeof(cur));
		while(x=dfs(s,INT_MAX)){
			flow+=x;
			memset(cur,0,sizeof(cur));
		}
	}
	return flow;
}
long long sum=0;
int a[maxn];
int main(){
	scanf("%d%d",&amp;n,&amp;m);
	for(int i=1;i&lt;=n;i++)
		scanf("%d",&amp;a[i]),sum+=a[i];
	s=0;t=n*2+1;
	for(int i=1;i&lt;=n;i++){
		add(s,i,a[i]);
		add(i+n,t,a[i]);
	}
	for(int i=1;i&lt;=m;i++){
		int u,v,w;
		scanf("%d%d%d",&amp;u,&amp;v,&amp;w);
		add(u,v+n,w);
	}
	cout&lt;&lt;sum-Dinic()&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem2165</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
const int maxn=111;
//const int BIT=51;
//LL mat[maxn][maxn][51];
int n,bit;
LL m;
struct mat{
	LL a[maxn][maxn];
	LL* operator[](int x){return a[x];}
	LL at(int x,int y)const{return a[x][y];}
	void clear(){memset(a,0,sizeof a);}
	LL mx(){
		LL mx=0;
		for(int i=1;i&lt;=n;i++)mx=max(mx,a[1][i]);
		return mx;
	}
	bool empty()const{
		for(int i=1;i&lt;=n;i++)
		for(int j=1;j&lt;=n;j++)
		if(a[i][j])return false;
		return true;
	}
}f[66],ma;
mat operator*(const mat &amp;A,const mat &amp;B){
	static mat C;C.clear();
	if(A.empty())return B;
	for(int k=1;k&lt;=n;k++)
	for(int i=1;i&lt;=n;i++)
	for(int j=1;j&lt;=n;j++){
		if((A.at(i,k)&amp;&amp;B.at(k,j)))
		C[i][j]=max(C[i][j],(A.at(i,k)+B.at(k,j)));
		if(C[i][j]&gt;=m)C[i][j]=m;
	}return C;
}
void sol(){
	scanf("%d%lld",&amp;n,&amp;m);
	assert(m&gt;1);
	for(int i=1;i&lt;=n;i++)
	for(int j=1;j&lt;=n;j++){
		scanf("%lld",&amp;f[0][i][j]);
		f[0][i][j]=min(f[0][i][j],m);
	}
	for(bit=1;bit&lt;66;bit++){
		f[bit].clear();
		f[bit]=f[bit-1]*f[bit-1];
		if(f[bit].mx()&gt;=m)break;
	}
	ma.clear();
	LL ans=0;
	for(LL b=bit;b&gt;=0;b--){
		if((ma*f[b]).mx()&lt;m){
			ma=ma*f[b];
			ans|=1LL&lt;&lt;b;
		}
	}printf("%lld\n",ans+1);	
}
int main(){
//	freopen("bzoj2165.in","r",stdin);
	int T;scanf("%d",&amp;T);
	while(T--)sol();
	return 0;
}</pre><pre></pre><h2>Problem2179</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=1e6+10;
struct cp{
	double r,i;
	cp(double _r=0,double _i=0):
		r(_r),i(_i){}
	cp operator+(cp x){return cp(r+x.r,i+x.i);}
	cp operator-(cp x){return cp(r-x.r,i-x.i);}
	cp operator*(cp x){return cp(r*x.r-i*x.i,r*x.i+i*x.r);}
};
cp a[maxn],b[maxn],A[maxn],x,y,c[maxn];
char s1[maxn],s2[maxn];
int sum[maxn],a1[maxn],a2[maxn],dig[maxn];
int len1,len2,rev[maxn],N,L;
void FFT(cp a[],int flag){
	for(int i=0;i&lt;N;i++)A[i]=a[rev[i]];
	for(int i=0;i&lt;N;i++)a[i]=A[i];
	for(int i=2;i&lt;=N;i&lt;&lt;=1){
		cp wn(cos(2*M_PI/i),flag*sin(2*M_PI/i));
		for(int k=0;k&lt;N;k+=i){
			cp w(1,0);
			for(int j=k;j&lt;k+i/2;j++){
				x=a[j];
				y=a[j+i/2]*w;
				a[j]=x+y;
				a[j+i/2]=x-y;
				w=w*wn;
			}
		}
	}
	if(flag==-1)for(int i=0;i&lt;N;i++)a[i].r/=N;
}
int main(){
	int zky;cin&gt;&gt;zky;
	scanf("%s%s",s1,s2);
	len1=strlen(s1);
	len2=strlen(s2);
	for(N=1,L=0;N&lt;max(len1,len2);N&lt;&lt;=1,L++);N&lt;&lt;=1;L++;
	for(int i=0;i&lt;N;i++){
		int len=0;
		for(int t=i;t;t&gt;&gt;=1)dig[len++]=t&amp;1;
		for(int j=0;j&lt;L;j++)rev[i]=(rev[i]&lt;&lt;1)|dig[j];
	}
	for(int i=0;i&lt;len1;i++)a1[len1-i-1]=s1[i]-'0';
	for(int i=0;i&lt;len2;i++)a2[len2-i-1]=s2[i]-'0';
	for(int i=0;i&lt;N;i++)a[i]=cp(a1[i]);
	for(int i=0;i&lt;N;i++)b[i]=cp(a2[i]);
	FFT(a,1);FFT(b,1);
	for(int i=0;i&lt;N;i++)c[i]=a[i]*b[i];
	FFT(c,-1);
	for(int i=0;i&lt;N;i++)sum[i]=c[i].r+0.5;
	for(int i=0;i&lt;N;i++){
		sum[i+1]+=sum[i]/10;
		sum[i]%=10;
	}
	int l=len1+len2-1;
	while(sum[l]==0&amp;&amp;l&gt;0)l--;
	for(int i=l;i&gt;=0;i--)
	putchar(sum[i]+'0');
	putchar('\n');
	return 0;
}</pre><pre></pre><h2>Problem2186</h2><pre>#include &lt;cstdio&gt;
#include &lt;bitset&gt;
using namespace std;
#define i64 long long
const int N = 10000005;

bitset&lt;N&gt; prime;
int mod;
i64 fac[N],ans[N];
i64 inv[N];

void Init ()
{
	int i,j;
	prime.set();
	for (i=2; i&lt;N; i++) if (prime[i])
		for (j=i+i;j&lt;N;j+=i)
			prime[j] = false;

	fac[0]=1;      //阶乘
    for (i=1;i&lt;N;i++)
        fac[i]=fac[i-1]*i %mod;
    inv[1]=1;    //逆元
    for (i=2;i&lt;N;i++)
    {
        if(i &gt;= mod) break;
        inv[i] = (mod - mod / i) * inv[mod % i] % mod;
    }
    ans[1]=1;
    for (i=2; i&lt;N; i++)
        if (prime[i])
        {
            ans[i] = ans[i-1] * (i - 1) % mod;
            ans[i] = ans[i] * inv[i % mod] % mod;
        }
        else
            ans[i] = ans[i-1];
}

int main ()
{
    int T;
    scanf("%d%d",&amp;T,&amp;mod);
	Init ();
    while(T--)
    {
		int m,n;
        scanf("%d%d",&amp;n,&amp;m);
        i64 res=fac[n]*ans[m]%mod;
        printf("%lld\n",res);
    }
    return 0;
}
</pre><pre></pre><h2>Problem2186</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#define read(x) scanf("%lld",&amp;x)
#define write(x) printf("%lld\n",x) 
using namespace std;
typedef long long lld;
const int N=10000005;
lld T,MOD;
lld fac[N];
lld prime1[N];
vector&lt;bool&gt;prime(N,1);
lld inv[N];
int main(){
	//fac.resize(N);
	//inv.resize(N);
	//prime1.resize(N);
	fac[1]=prime1[1]=1;
	fac[0]=prime1[0]=1;
	for(lld i=2;i&lt;=10000000;i++){		
		if(prime[i]){
			for(lld j=i+i;j&lt;=10000000;j+=i){
				prime[j]=false;
			}
		}
	}
	read(T);
	read(MOD); 
	for(lld i=2;i&lt;=10000000;i++){
		fac[i]=i*fac[i-1]%MOD;
	}
	
	inv[1]=1;
	for(lld i=2;i&lt;=10000000;i++){
		if(i&gt;=MOD)break;
		inv[i]=(MOD-MOD/i)*inv[MOD%i]%MOD;
	}
	for(lld i=2;i&lt;=10000000;i++){
		if(prime[i]){
			prime1[i]=prime1[i-1]*(i-1)%MOD;
			prime1[i]=prime1[i]*inv[i%MOD]%MOD;
		}else{
			prime1[i]=prime1[i-1];
		}
		}
	lld n,m;
	while(T--){
		read(n);read(m);
		write(fac[n]*prime1[m]%MOD);
	}
	return 0;
}</pre><pre></pre><h2>Problem2190</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
int phi[40001];
int n;
void getphi(){
	phi[1]=1;
	for(int i=2;i&lt;=n;i++){
		if(!phi[i])
		for(int j=i;j&lt;=n;j+=i){
			if(!phi[j])phi[j]=j;
			phi[j]=phi[j]/i*(i-1);
		}
	}
}
int main(){
	cin&gt;&gt;n;
	long long ans=3;
	getphi();
	for(int i=2;i&lt;n;i++)ans+=phi[i]*2;
	cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem2190</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
int phi[40001];
int n;
void getphi(){
	phi[1]=1;
	for(int i=2;i&lt;=n;i++){
		if(!phi[i])
		for(int j=i;j&lt;=n;j+=i){
			if(!phi[j])phi[j]=j;
			phi[j]=phi[j]/i*(i-1);
		}
	}
}
int main(){
	cin&gt;&gt;n;
	long long ans=0;
	getphi();
	for(int i=2;i&lt;n;i++)ans+=phi[i];
	ans*=2;
	cout&lt;&lt;ans+3&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem2194</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef complex&lt;double&gt; cp;
const int maxn=1&lt;&lt;18;
const double pi=acos(-1);
cp a[maxn],b[maxn],tmp[maxn];
int n,N;
void FFT(cp *a,int n,int f){
	if(n==1)return ;
	copy(a,a+n,tmp);
	for(int i=0;i&lt;n;i++)if(i&amp;1)a[(i&gt;&gt;1)+n/2]=tmp[i];else a[i&gt;&gt;1]=tmp[i];
	
	FFT(a,n/2,f);
	FFT(a+n/2,n/2,f);
	cp w(1,0),wn(cos(2*pi/n),f*sin(2*pi/n));
	for(int i=0;i&lt;n/2;i++){
		cp x=a[i],y=a[i+n/2];
		a[i]=x+y*w;
		a[i+n/2]=x-y*w;
		w=w*wn;
	}
}
int main(){
//	freopen("bzoj2194.in","r",stdin);
	scanf("%d",&amp;n);N=1;
	while(N&lt;n)N&lt;&lt;=1;N&lt;&lt;=1;
	for(int i=0;i&lt;n;i++){
		double x,y;scanf("%lf%lf",&amp;x,&amp;y);
		a[n-i-1]=x;
		b[i]=y;
	}
	FFT(a,N,1);
	FFT(b,N,1);
	for(int i=0;i&lt;N;i++)a[i]*=b[i];
	FFT(a,N,-1);
	for(int i=0;i&lt;N;i++)a[i]/=N;
	for(int i=n-1;i&gt;=0;i--)
		printf("%d\n",int(a[i].real()+.5));
	return 0;
}</pre><pre></pre><h2>Problem2194</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef complex&lt;double&gt; cp;
const int maxn=1&lt;&lt;18;
const double pi=acos(-1);
cp a[maxn],b[maxn],tmp[maxn];
int n,N;
void FFT(cp *a,int n,int f){
	if(n==1)return ;
	copy(a,a+n,tmp);
	for(int i=0;i&lt;n;i++)if(i&amp;1)a[(i&gt;&gt;1)+n/2]=tmp[i];else a[i&gt;&gt;1]=tmp[i];
	
	FFT(a,n/2,f);
	FFT(a+n/2,n/2,f);
	cp w(1,0),wn(cos(2*pi/n),f*sin(2*pi/n));
	for(int i=0;i&lt;n/2;i++){
		cp x=a[i],y=a[i+n/2];
		a[i]=x+y*w;
		a[i+n/2]=x-y*w;
		w=w*wn;
	}
}
int main(){
//	freopen("bzoj2194.in","r",stdin);
	scanf("%d",&amp;n);N=1;
	while(N&lt;n)N&lt;&lt;=1;N&lt;&lt;=1;
	for(int i=0;i&lt;n;i++){
		double x,y;scanf("%lf%lf",&amp;x,&amp;y);
		a[n-i-1]=x;
		b[i]=y;
	}
	FFT(a,N,1);
	FFT(b,N,1);
	for(int i=0;i&lt;N;i++)a[i]*=b[i];
	FFT(a,N,-1);
	for(int i=0;i&lt;N;i++)a[i]/=N;
	for(int i=n-1;i&gt;=0;i--)
		printf("%d\n",int(a[i].real()+.1));
	return 0;
}</pre><pre></pre><h2>Problem2208</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=2001;
vector&lt;int&gt;G[maxn];
void add(int u,int v){
	G[u].push_back(v);
}
int n,cnt;
int vis[2001];
void dfs(int x){
	for(int i=0;i&lt;G[x].size();i++){
		int v=G[x][i];
		if(!vis[v]){
			cnt++;
			vis[v]=1;
			dfs(v);
		}
	}
}
int main(){
	scanf("%d",&amp;n);
	for(int i=1;i&lt;=n;i++){
		char s[2000];
		scanf("%s",s);
		for(int j=1;j&lt;=n;j++){
			if(s[j-1]=='1')
				add(i,j);
		}
	}
	int ans=0;
	for(int i=1;i&lt;=n;i++){
		memset(vis,0,sizeof(vis));
		cnt=0;
		vis[i]=1;
		cnt++;
		dfs(i);
		ans+=cnt;
	}
	printf("%d\n",ans);
	return 0;
}</pre><pre></pre><h2>Problem2209</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cctype&gt;
#include&lt;climits&gt;
using namespace std;
const int maxn=1e5+5;
int n,m;
char str[maxn];
inline int rnd(){
	static int KEY=12345678;
	return KEY+=KEY&lt;&lt;2|1;
}
struct node{
	int val,key,rev,lazy,all,maxl,minl,maxr,minr,size,sum;node *c[2];
	node(int _val=0,node *C=0):
		val(_val),key(rnd()),rev(0),lazy(0),all(0),maxl(0),minl(0),maxr(0),minr(0),size(1),sum(_val){c[0]=c[1]=C;}
	node *rz(){
		size=c[0]-&gt;size+1+c[1]-&gt;size;
		sum=c[0]-&gt;sum+val+c[1]-&gt;sum;
		maxl=max(c[0]-&gt;maxl,c[0]-&gt;sum+val+max(0,c[1]-&gt;maxl));
		minl=min(c[0]-&gt;minl,c[0]-&gt;sum+val+min(0,c[1]-&gt;minl));
		maxr=max(c[1]-&gt;maxr,c[1]-&gt;sum+val+max(0,c[0]-&gt;maxr));
		minr=min(c[1]-&gt;minr,c[1]-&gt;sum+val+min(0,c[0]-&gt;minr));			
		return this;
	}
	void makerev(){
		if(this-&gt;size==0)return;
		rev^=1;
		swap(c[0],c[1]);
		swap(minl,minr);
		swap(maxl,maxr);
	}
	void makelazy(){
		if(this-&gt;size==0)return;
		lazy^=1;
		if(all)
		all=-all;
		val=-val;
		sum=-sum;
		swap(maxl,minl);maxl=-maxl;minl=-minl;
		swap(maxr,minr);maxr=-maxr;minr=-minr;
	}
	void makesame(int al){
		if(this-&gt;size==0)return;
		all=al;val=al;
		maxl=maxr=size*(al==1);
		minl=minr=-size*(al==-1);	
		sum=size*al;		
	}
	void pushdown(){
		if(this-&gt;size==0)return; 
		if(rev){c[0]-&gt;makerev();c[1]-&gt;makerev();rev^=1;}
		if(lazy){c[0]-&gt;makelazy();c[1]-&gt;makelazy();lazy=0;}
		if(all){c[0]-&gt;makesame(all);c[1]-&gt;makesame(all);all=0;}
	}
	void split(int ned,node *&amp;p,node *&amp;q); 
}*Null;
node *merge(node *p,node *q){	
	p-&gt;pushdown();q-&gt;pushdown();
	if(p==Null)return q-&gt;rz();
	if(q==Null)return p-&gt;rz();
	if(p-&gt;key&lt;q-&gt;key){
		p-&gt;c[1]=merge(p-&gt;c[1],q);
		return p-&gt;rz();
	}else{
		q-&gt;c[0]=merge(p,q-&gt;c[0]);
		return q-&gt;rz();
	}
}
void node::split(int ned,node *&amp;p,node *&amp;q){
	if(this==Null){p=q=Null;return;}
	pushdown();
	if(c[0]-&gt;size&gt;=ned){
		c[0]-&gt;split(ned,p,q);
		c[0]=Null;rz();
		q=merge(q,this);
	}else{
		c[1]-&gt;split(ned-c[0]-&gt;size-1,p,q);
		c[1]=Null;rz();
		p=merge(this,p);
	}
}
node *root;
node *newnode(int val=0){
	return new node(val,Null);	
}	
node *p,*q,*r,*s,res;
void deb(node *root){  
    if(root==Null)return ;  
    printf("val:%d sum:%d size:%d all:%d rev:%d lazy:%d \n",root-&gt;val,root-&gt;sum,root-&gt;size,
			root-&gt;all,root-&gt;rev,root-&gt;lazy); 
    if(root-&gt;c[0]!=Null)printf("L:"),deb(root-&gt;c[0]);      
    if(root-&gt;c[1]!=Null)printf("R:"),deb(root-&gt;c[1]);  
} 
int main(){
	Null=newnode();Null-&gt;size=0;
	Null-&gt;val=Null-&gt;key=INT_MAX;
	root=Null;
	scanf("%d%d",&amp;n,&amp;m);
	scanf("%s",str);
	for(int i=0;i&lt;n;i++)root=merge(root,newnode(str[i]=='('?1:-1));
	while(m--){
		int op;
		int lef,rig;
		scanf("%d%d%d",&amp;op,&amp;lef,&amp;rig);
		root-&gt;split(lef-1,p,q);
		q-&gt;split(rig-lef+1,r,s);
		if(op==0){
			res=*r;
			printf("%d\n",(res.maxr+1)/2-(res.minl-1)/2);
		}else
		if(op==2){
			r-&gt;makerev();
			r-&gt;pushdown();
		}else
		if(op==1){
			r-&gt;makelazy();
			r-&gt;pushdown();
		}
		root=merge(p,merge(r,s));
	}
	return 0;
}</pre><pre></pre><h2>Problem2212</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=4e5+5;
struct node{  
    int val,key,size,s;  
    node *c[2];  
    node(int _val=0,node *C=0){  
        val=_val;key=rand();  
        size=s=1;c[0]=c[1]=C;  
    }void rz(){  
        size=c[0]-&gt;size+s+c[1]-&gt;size;  
    }  
};
struct Treap{  
    node *root,*Null;  
    Treap(){  
        Null=new node(0,0);  
        Null-&gt;size=Null-&gt;s=0;Null-&gt;key=INT_MAX;  
        Null-&gt;c[0]=Null-&gt;c[1]=Null;root=Null;  
    }  
    void rot(node *&amp;t,bool d){  
        node *p=t-&gt;c[d];t-&gt;c[d]=p-&gt;c[!d];  
        p-&gt;c[!d]=t;t-&gt;rz();p-&gt;rz();t=p;  
    }  
    void _insert(node *&amp;t,int x){  
        if(t==Null){t=new node(x,Null);return;}  
        if(t-&gt;val==x){t-&gt;s++;t-&gt;size++;return;}  
        _insert(t-&gt;c[x&gt;t-&gt;val],x);  
        if(t-&gt;c[x&gt;t-&gt;val]-&gt;key&lt;t-&gt;key)  
        rot(t,x&gt;t-&gt;val);else t-&gt;rz();  
    }  
    int _kth(node *t,int x){  
        int r=t-&gt;c[0]-&gt;size;  
        if(x&lt;=r)return _kth(t-&gt;c[0],x);  
        else if(x&gt;r+t-&gt;s) return _kth(t-&gt;c[1],x-r-t-&gt;s);  
        return t-&gt;val;  
    }  
    int _rank(node *t,int x){  
    	if(t==Null)return 0;
        int r=t-&gt;c[0]-&gt;size;  
        if(x&lt;t-&gt;val)return _rank(t-&gt;c[0],x);  
        else if(x&gt;t-&gt;val)return _rank(t-&gt;c[1],x)+r+t-&gt;s;  
        return r;  
    }  
    void erase(node *t){
    	if(t-&gt;c[0]!=Null)erase(t-&gt;c[0]);
    	if(t-&gt;c[1]!=Null)erase(t-&gt;c[1]);
    	delete t;
    }
    void clear(){erase(root);}
    void insert(int x){_insert(root,x);}  
    int kth(int x){return _kth(root,x);}  
    int rank(int x){return _rank(root,x);}    
    int size(){return root-&gt;size;}
}T[maxn];  
typedef long long LL;
int n;
LL cnt[maxn],ans;
int tot=1;
int getint(){
	int res=0;char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))res=res*10+c-'0',c=getchar();
	return res;
}
void dfs(int u){
	int x=getint();
	if(!x){
		int l=++tot,r=++tot;
		dfs(l);
		dfs(r);
		if(T[l].size()&lt;T[r].size())swap(l,r);
		LL res=0;
		for(int i=1;i&lt;=T[r].size();i++)
			res+=T[l].rank(T[r].kth(i));
		ans+=min(res,(LL)T[l].size()*T[r].size()-res);
		for(int i=1;i&lt;=T[r].size();i++){
			int k=T[r].kth(i);
			T[l].insert(k);
		}T[u]=T[l];
	}else T[u].insert(x);	
}
int main(){
	scanf("%d",&amp;n);
	dfs(1);
	cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem2219</h2><pre>#include&lt;bits/stdc++.h&gt;
#define fst first
#define sec second
using namespace std;
typedef long long LL;
vector&lt;int&gt;fac;
LL pow(LL x,LL k,LL p){
	LL ans=1;
	for(;k;k&gt;&gt;=1){
		if(k&amp;1)ans=ans*x%p;
		x=x*x%p;
	}return ans;
}
LL exgcd(LL a,LL b,LL &amp;x,LL &amp;y){
	if(!b){
		x=1;y=0;
		return a;
	}else{
		LL g=exgcd(b,a%b,x,y);
		LL t=x;x=y;y=t-a/b*y;
		return g;
	}
}
LL gcd(LL a,LL b){
	while(b){
		LL t=a%b;
		a=b;b=t;
	}return a;
}
LL lcm(LL a,LL b){return a*b/gcd(a,b);}
LL inv(LL a,LL p){
	LL x,y;
	LL d=exgcd(a,p,x,y);
	return d==1?(x+p)%p:-1;
}
LL pk;
bool check(int x){
	for(int i=0;i&lt;fac.size();i++){
		if(pow(x,(pk-1)/fac[i],pk)==1)
			return 0;
	}return 1;
}
int getrt(LL p,LL k){
	fac.clear();
	pk=pow(p,k,1e18)-1;
	for(int i=2;i*i&lt;=pk;i++){
		if(pk%i==0)fac.push_back(i);	
		while(pk%i==0)pk/=i;		
	}if(pk!=1)fac.push_back(pk);	
	pk=pow(p,k,1e18);
	for(int i=2;i&lt;23333333;i++)
	if(check(i))return i;
}
int divs[500];int dtot=0;
int proot(int p){
    dtot=0;
    int q=p-1;
    for (int i=2;i*i&lt;=q;i++)
        if(q%i==0){
            divs[dtot++]=i;
            if(q!=i*i)divs[dtot++]=q/i;
        }
    for (int i=2;i&lt;p;i++){
        int ok=1;
        for (int j=0;j&lt;dtot;j++)if(pow(i,divs[j],p)==1){
            ok=0;break;
        }
        if(ok)return i;
    }
}
LL BSGS(LL a,LL b,LL p){
	LL m=0;for(;m*m&lt;=p;m++);
	map&lt;LL,int&gt;hash;hash[1]=0;
	LL e=1,amv=inv(pow(a,m,p),p);
	for(int i=1;i&lt;m;i++){
		e=e*a%p;
		if(!hash.count(e))
			hash[e]=i;	
		else break;
	}
	for(int i=0;i&lt;m;i++){
		if(hash.count(b))
			return hash[b]+i*m;
		b=b*amv%p;	
	}
	return -1;
}
LL solve(LL A,LL B,LL p,LL k){
	LL P=pow(p,k,1e18);B%=P;
	if(B==0)return pow(p,k-((k+A-1)/A),1e18);
	LL d=__gcd(B,P),s=1;
	for(int i=0;i&lt;60;i++){
		if(d==s){s=i;break;}
		s=s*p;
	}if(s%A)return 0;
	LL g=proot(p);
	B/=d;k-=s;
	LL phiP=(p-1)*pow(p,k-1,1e18);
	B=BSGS(g,B,P);
	if(B%__gcd(A,phiP))return 0;	
	return __gcd(A,phiP)*pow(p,s-s/A,1e18);
}
void solve(){
	LL A,B,P;scanf("%lld%lld%lld",&amp;A,&amp;B,&amp;P);P=P*2+1;
	vector&lt;pair&lt;int,int&gt; &gt;vec;
	for(int i=2;i*i&lt;=P;i++){
		if(P%i==0){
			P/=i;
			vec.push_back(make_pair(i,1));
			while(P%i==0)vec.back().sec++,P/=i;
		}
	}if(P!=1)vec.push_back(make_pair(P,1));
	LL ans=1;
	for(int i=0;i&lt;vec.size();i++)
		ans=ans*solve(A,B,vec[i].fst,vec[i].sec);
	 printf("%lld\n",ans);
}
int main(){
	int T;scanf("%d",&amp;T);	
	while(T--)
		solve();
	return 0;
}</pre><pre></pre><h2>Problem2219</h2><pre>#include&lt;bits/stdc++.h&gt;
#define fst first
#define sec second
using namespace std;
typedef long long LL;
vector&lt;int&gt;fac;
LL pow(LL x,LL k,LL p){
	LL ans=1;
	for(;k;k&gt;&gt;=1){
		if(k&amp;1)ans=ans*x%p;
		x=x*x%p;
	}return ans;
}
LL exgcd(LL a,LL b,LL &amp;x,LL &amp;y){
	if(!b){
		x=1;y=0;
		return a;
	}else{
		LL g=exgcd(b,a%b,x,y);
		LL t=x;x=y;y=t-a/b*y;
		return g;
	}
}
LL gcd(LL a,LL b){
	while(b){
		LL t=a%b;
		a=b;b=t;
	}return a;
}
LL lcm(LL a,LL b){return a*b/gcd(a,b);}
LL inv(LL a,LL p){
	LL x,y;
	LL d=exgcd(a,p,x,y);
	return d==1?(x+p)%p:-1;
}
LL pk;
bool check(int x){
	for(int i=0;i&lt;fac.size();i++){
		if(pow(x,(pk-1)/fac[i],pk)==1)
			return 0;
	}return 1;
}
int getrt(LL p,LL k){
	fac.clear();
	pk=pow(p,k,1e18)-1;
	for(int i=2;i*i&lt;=pk;i++){
		if(pk%i==0)fac.push_back(i);	
		while(pk%i==0)pk/=i;		
	}if(pk!=1)fac.push_back(pk);	
	pk=pow(p,k,1e18);
	for(int i=2;i&lt;23333333;i++)
	if(check(i))return i;
}
LL BSGS(LL a,LL b,LL p){
	LL m=0;for(;m*m&lt;=p;m++);
	map&lt;LL,int&gt;hash;hash[1]=0;
	LL e=1,amv=inv(pow(a,m,p),p);
	for(int i=1;i&lt;m;i++){
		e=e*a%p;
		if(!hash.count(e))
			hash[e]=i;	
		else break;
	}
	for(int i=0;i&lt;m;i++){
		if(hash.count(b))
			return hash[b]+i*m;
		b=b*amv%p;	
	}
	return -1;
}
LL solve(LL A,LL B,LL p,LL k){
	LL P=pow(p,k,1e18);B%=P;
	if(B==0)return pow(p,k-((k+A-1)/A),1e18);
	LL d=__gcd(B,P),s=1;
	for(int i=0;i&lt;60;i++){
		if(d==s){s=i;break;}
		s=s*p;
	}if(s%A)return 0;
	LL g=getrt(p,1);
	B/=d;k-=s;
	LL phiP=(p-1)*pow(p,k-1,1e18);
	B=BSGS(g,B,P);
	if(B%__gcd(A,phiP))return 0;	
	return __gcd(A,phiP)*pow(p,s-s/A,1e18);
}
void solve(){
	LL A,B,P;scanf("%lld%lld%lld",&amp;A,&amp;B,&amp;P);P=P*2+1;
	vector&lt;pair&lt;int,int&gt; &gt;vec;
	for(int i=2;i*i&lt;=P;i++){
		if(P%i==0){
			P/=i;
			vec.push_back(make_pair(i,1));
			while(P%i==0)vec.back().sec++,P/=i;
		}
	}if(P!=1)vec.push_back(make_pair(P,1));
	LL ans=1;
	for(int i=0;i&lt;vec.size();i++)
		ans=ans*solve(A,B,vec[i].fst,vec[i].sec);
	 printf("%lld\n",ans);
}
int main(){
	int T;scanf("%d",&amp;T);	
	while(T--)
		solve();
	return 0;
}</pre><pre></pre><h2>Problem2223</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cctype&gt;
#include&lt;map&gt;
#include&lt;vector&gt;
using namespace std;
const int maxn=300005;
int n,m;
map&lt;int,vector&lt;int&gt; &gt;M;
struct qes{
    int x,y,z,ty,ind,cur,delta;
    qes(int _x=0,int _y=0,int _z=0,int _ty=0,int _ind=0,int _cur=0,int _delta=0):
        x(_x),y(_y),z(_z),ty(_ty),cur(_cur),delta(_delta),ind(_ind){}
}q[maxn+10000];
int anss[10010],cnt,mx,md,d[maxn],lim;
int lowbit(int x){return x&amp;-x;}  
int get(int x){int ans=0;while(x)ans+=d[x],x-=lowbit(x);return ans;}  
void updata(int x,int y){while(x&lt;=n)d[x]+=y,x+=lowbit(x);}  
bool part(qes &amp;Q){  
    if(Q.ty==2){  
        if(Q.cur+Q.delta&gt;Q.z-1)return true;  
        Q.cur+=Q.delta;Q.delta=0;return false;  
    }return Q.y&lt;=md;  
}  
void solve(int lef,int rig,int l,int r){  
    if(lef&gt;rig)return;  
    if(l==r){  
        for(int i=lef;i&lt;=rig;i++)if(q[i].ty==2){
            int L=lower_bound(M[l].begin(),M[l].end(),q[i].x)-M[l].begin();
            int R=upper_bound(M[l].begin(),M[l].end(),q[i].y)-M[l].begin();
            if(R-L&gt;(q[i].y-q[i].x+1)/2)
            anss[q[i].ind]=l;
        }return;  
    }int mid=(l+r)&gt;&gt;1;md=mid;  
    for(int i=lef;i&lt;=rig;i++){  
        if(q[i].ty==1&amp;&amp;q[i].y&lt;=mid)updata(q[i].x,1);   
        if(q[i].ty==2)q[i].delta=get(q[i].y)-get(q[i].x-1);  
    }for(int i=lef;i&lt;=rig;i++)
        if(q[i].ty==1&amp;&amp;q[i].y&lt;=mid)updata(q[i].x,-1);   
    int dv=stable_partition(q+lef,q+rig+1,part)-q-1;  
    solve(lef,dv,l,mid);  
    solve(dv+1,rig,mid+1,r);  
}  
int getint(){
    int res=0;char c=getchar();
    while(!isdigit(c))c=getchar();
    while(isdigit(c))res=res*10+c-'0',c=getchar();
    return res;
}
int main(){
    scanf("%d%d",&amp;n,&amp;lim);
    for(int i=1;i&lt;=n;i++){
        int x=getint();mx=max(mx,x);
        q[++cnt]=qes(i,x,0,1);M[x].push_back(i);
    }m=getint();
    for(int i=1;i&lt;=m;i++){
        int l=getint(),r=getint();
        q[++cnt]=qes(l,r,(r-l+2)/2,2,++anss[0]);
    }solve(1,cnt,0,mx);
    for(int i=1;i&lt;=anss[0];i++){
        if(anss[i])
            printf("yes %d\n",anss[i]);
        else puts("no");
    }
    return 0;
}</pre><pre></pre><h2>Problem2225</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1e5+5;
int getint(){
	int res=0,f=1;char c=getchar();
	while(!isdigit(c))f=f==-1||c=='-'?-1:1,c=getchar();
	while(isdigit(c))res=res*10+c-'0',c=getchar();
	return res*f;
}
int n,tot;
struct pii{
	int first,second;
	pii(int x=0,int y=0):first(x),second(y){}
	bool operator==(pii oth)const{return first==oth.first&amp;&amp;second==oth.second;}
	bool operator&lt;(pii oth)const{return first&lt;oth.first||(first==oth.first&amp;&amp;second&gt;oth.second);}
};
pii a[maxn];
map&lt;int,int&gt;M;
struct node{
	int key,mx,size;
	pii val;
	node *c[2];
	node(pii _val=pii(0,0),node *C=0){
		val=_val;key=rand();mx=_val.second;
		c[0]=c[1]=C;size=1;
	}
	void rz(){
		size=c[0]-&gt;size+1+c[1]-&gt;size;
		mx=max(c[0]-&gt;mx,val.second);
		mx=max(c[1]-&gt;mx,mx);
	}
}*Null,pool[maxn*15];
node *newnode(pii _val=pii(0,0),node *C=0){
	static int tot=0;
	if(tot&lt;maxn*15){
		pool[tot].val=_val;pool[tot].key=rand();pool[tot].mx=_val.second;
		pool[tot].c[0]=pool[tot].c[1]=C;pool[tot].size=1;
		return &amp;pool[tot++];
	}else return new node(_val,C);
}
struct Treap{
	node *root;
	void init(){
		root=Null;
	}
    void rot(node *&amp;t,bool d){  
        node *p=t-&gt;c[d];t-&gt;c[d]=p-&gt;c[!d];  
        p-&gt;c[!d]=t;t-&gt;rz();p-&gt;rz();t=p;  
    }  
	void _insert(node *&amp;t,pii p){
		if(t==Null){t=newnode(p,Null);return;}
		if(t-&gt;val==p)return ;
		_insert(t-&gt;c[t-&gt;val&lt;p],p);
		if(t-&gt;c[t-&gt;val&lt;p]-&gt;key&lt;t-&gt;key)
		rot(t,t-&gt;val&lt;p);else t-&gt;rz();
	}
	int _Qmax(node *t,int p){
		int ans=0;
		while(t!=Null){
			if(t-&gt;val.first&lt;p){
				ans=max(ans,max(t-&gt;c[0]-&gt;mx,t-&gt;val.second));
				t=t-&gt;c[1];
			}else t=t-&gt;c[0];
		}return ans;
	}
	void deb(node *t){
		if(t!=Null)
		printf("first:%d second:%d mx:%d size:%d\n",t-&gt;val.first,t-&gt;val.second,t-&gt;mx,t-&gt;size);
		if(t-&gt;c[0]!=Null)printf("L: "),deb(t-&gt;c[0]);
		if(t-&gt;c[1]!=Null)printf("R: "),deb(t-&gt;c[1]);
	}
	void deb(){deb(root);puts("");}
	void insert(pii p){_insert(root,p);}
	int Qmax(int p){return _Qmax(root,p);}
}T[maxn];
inline int lowbit(int x){return x&amp;-x;}
void updata(int x,pii p){
	while(x&lt;=tot)T[x].insert(p),x+=lowbit(x);
}
int Qmax(int x,int p){
	int ans=0;
	for(int i=x;i;i-=lowbit(i)){
		ans=max(ans,T[i].Qmax(p));	
	}return ans;
}
int ans;
int main(){
	Null=new node(pii(0,0),0);
	Null-&gt;size=0;Null-&gt;key=INT_MAX;
	Null-&gt;c[0]=Null-&gt;c[1]=Null;
	n=getint();
	for(int i=1;i&lt;=n;i++){
		a[i].first=getint();a[i].second=getint();
		M[a[i].first]=1;
	}for(map&lt;int,int&gt;::iterator it=M.begin();it!=M.end();it++)it-&gt;second=++tot;
	for(int i=1;i&lt;=tot;i++)T[i].init();
	for(int i=1;i&lt;=n;i++)a[i].first=M[a[i].first];
	for(int i=1;i&lt;=n;i++){
		int res=Qmax(a[i].first-1,a[i].second)+1;
		updata(a[i].first,pii(a[i].second,res));
		ans=max(ans,res);
	}cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem2226</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
int getint(){
	int res=0;char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))res=res*10+c-'0',c=getchar();
	return res;
}
typedef long long LL;
const int maxn=1e6+5;
bool p[maxn];
int prime[maxn];
int phi[maxn];
LL sum[maxn];
LL anss[maxn];
void getphi(){
	phi[1]=1;
	for(int i=2;i&lt;maxn;i++){
		if(!p[i]){
			prime[++prime[0]]=i;
			phi[i]=i-1;
		}for(int j=1;i*prime[j]&lt;maxn&amp;&amp;j&lt;=prime[0];j++){
			p[i*prime[j]]=1;
			if(i%prime[j]==0){
				phi[i*prime[j]]=phi[i]*prime[j];
				break;
			}else phi[i*prime[j]]=phi[i]*(prime[j]-1);			
		}
	}for(int i=1;i&lt;maxn;i++)sum[i]=(LL)i*phi[i];
	for(int i=1;i&lt;maxn;i++)
	for(int j=i;j&lt;maxn;j+=i)
	anss[j]+=sum[i];
}
int main(){
	int T=getint();
	getphi();
	while(T--){
		int n=getint();
		LL ans=(anss[n]+1)*n/2;
		printf("%lld\n",ans);
	}
	return 0;
}</pre><pre></pre><h2>Problem2241</h2><pre>/*
	ID:zky
	OJ:BZOJ
	Index:2241
	Language:C++
*/
#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
int n,m,num=0;
int sum=0;
int map[101][101];
int now[101][101];
struct node{
	int r,c,s;
}h[10001];
bool cmp(node a,node b){
	return a.s&lt;b.s;
}
void init(){
	cin&gt;&gt;n&gt;&gt;m;
	for(int i=1;i&lt;=n;i++)
	for(int j=1;j&lt;=m;j++)
	cin&gt;&gt;map[i][j],sum+=map[i][j];
}
void next(int &amp;x,int &amp;y){
	if(y&lt;m)y++;
	else{
		x++;
		y=1;
	}
}
void maptonow(){
	for(int i=1;i&lt;=n;i++)
	for(int j=1;j&lt;=m;j++)
	now[i][j]=map[i][j];
}
bool ok(int r,int c){
	int x=1,y=1;
	maptonow();
	while(x&lt;=n&amp;&amp;y&lt;=m){
		int t=now[x][y];
		if(!now[x][y]){
			next(x,y);continue;
		}
		if(x+r-1&gt;n||y+c-1&gt;m)return false;
		for(int i=x;i&lt;=x+r-1;i++)
		for(int j=y;j&lt;=y+c-1;j++){
			if(now[i][j]&gt;=t)
				now[i][j]-=t;
			else
				return false;
		}
	}
	return true;
}
void zky(){
	//for R C
	for(int i=1;i&lt;=n;i++)
	for(int j=1;j&lt;=m;j++){
		node x;
		x.r=i; x.c=j; x.s=i*j;
		h[++num]=x;
	}
	sort(h+1,h+1+n*m,cmp);
	for(int i=num;i&gt;=1;i--){
		if(sum%h[i].s)continue;
		if(ok(h[i].r,h[i].c)){
			cout&lt;&lt;sum/h[i].s&lt;&lt;endl;
			return;
		}
	}
}
int main(){
	init();
	zky();
	return 0;
}//ÉXÉmÊ²Ã´Ê¡Ñ¡Ìâ¶¼²»»á×ö£¬ÈçÓÐÀ×Í¬£¬¾ÍÊÇ³­µÄ </pre><pre></pre><h2>Problem2242</h2><pre>/*
	ID:zky
	OJ:BZOJ
	Index:2242
	Language:C++ 
*/ 
#include&lt;map&gt;
#include&lt;set&gt;
#include&lt;cmath&gt;
#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long lld;
map&lt;lld,lld&gt;hash;
lld t,k;
lld x,y,z,p;
lld power(lld a,lld b,lld n){  
    lld s=1;  
    while(b){  
        if(b&amp;1)  
            s=(s*a)%n;  
        a=(a*a)%n;  
        b=b&gt;&gt;1;  
    }  
    return s;  
}  
void work1(){
	cout&lt;&lt;power(y,z,p)&lt;&lt;endl;
}
lld gcd(lld a,lld b){
	if(!b)return a;
	return gcd(b,a%b);
}
void exgcd(lld a,lld b,lld &amp;x,lld &amp;y){
	if(!b){
		x=1;
		y=0;
		return;
	}
	exgcd(b,a%b,x,y);
	lld t=x;
	x=y;
	y=t-a/b*y;
}
void work2(){
	//yx=z(mod p)
	lld d=gcd(y,p);
	if(z%d){
		cout&lt;&lt;"Orz, I cannot find x!"&lt;&lt;endl;
		return;
	}
	lld r,s;
	exgcd(y,p,r,s);
	r=r*z/d;
	r=(r+p)%p;
	while(r&lt;0)r+=p;
	//while(r&lt;0)r+=p;
	cout&lt;&lt;r&lt;&lt;endl;
}
void work3(){
	y%=p;z%=p;
	//a^x=b(mod n)=&gt;y^x=z(mod p)
	if(!y&amp;&amp;!z){cout&lt;&lt;"1"&lt;&lt;endl;return;}
	if(!y){cout&lt;&lt;"Orz, I cannot find x!"&lt;&lt;endl;return;}
	lld m=ceil(sqrt(p));
	lld v=power(y,p-m-1,p);//a^m*v=1(mod p)p is prime=&gt;v=....
	lld e=1;
	hash[1]=m+1;
	for(lld i=1;i&lt;=m;i++){
		e=(e*y)%p;
		if(!hash[e])hash[e]=i;
	}
	lld ans=-1;
	for(lld i=0;i&lt;m;i++){
		lld j=hash[z];
		if(j){
			if(j==m+1)j=0;
			ans=i*m+j;	
			break;
		}
		z=(z*v)%p;//
	}
	hash.clear(); 
	if(ans==-1)cout&lt;&lt;"Orz, I cannot find x!"&lt;&lt;endl;
	else cout&lt;&lt;ans&lt;&lt;endl;
}
int main(){
	cin&gt;&gt;t&gt;&gt;k;
	while(t--){
		cin&gt;&gt;y&gt;&gt;z&gt;&gt;p;
		if(k==1)work1();
		if(k==2)work2();
		if(k==3)work3();		
	}
	return 0;
}</pre><pre></pre><h2>Problem2242</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1e5+5;
typedef long long LL;
int n=1000;
bool p[maxn];
int prime[maxn];
int phi[maxn];
int mu[maxn];
void get_p(){
	phi[1]=mu[1]=1;
	for(int i=2;i&lt;=n;i++){
		if(!p[i]){
			prime[++prime[0]]=i;
			phi[i]=i-1;mu[i]=-1;
		}for(int j=1;j&lt;=prime[0];j++){
			if(i*prime[j]&gt;n)break;
			p[i*prime[j]]=1;
			if(i%prime[j]==0){
				mu[i*prime[j]]=0;
				phi[i*prime[j]]=phi[i]*prime[j];
				break;
			}else{
				phi[i*prime[j]]=phi[i]*(prime[j]-1);
				mu[i*prime[j]]=-mu[i];
			}
		}
	}
}
LL gcd(LL a,LL b){
	while(b){
		LL t=a%b;
		a=b;
		b=t;
	}return b;
}
LL exgcd(LL a,LL b,LL &amp;x,LL &amp;y){
	if(!b){
		x=1;y=0;return a;
	}else{
		LL d=exgcd(b,a%b,x,y);
		LL t=x;x=y;y=t-a/b*y;
		return d;
	}
}
LL _phi(LL x){
	LL ans=x;
	for(int i=2;i*i&lt;=x;i++){
		if(x%i==0){
			ans=ans*i/(i-1);
			while(x%i==0)x/=i;
		}
	}if(x&gt;1)ans=ans/x*(x-1);
	return ans;
}
LL power(LL x,LL k,LL p){
	LL ans=1;
	for(;k;k&gt;&gt;=1){
		if(k&amp;1)ans=(ans*x)%p;
		x=(x*x)%p;
	}return ans;
}
LL inv(LL a,LL p){
	LL d,x,y;
	d=exgcd(a,p,x,y);
	return d==1?(x+p)%p:-1;
}
LL china(int n,int *a,int *m){
	//V i x = a_i (mod m_i)  gcd(mi,mj)=1
	LL M=1,d,x=0,y;
	for(int i=0;i&lt;n;i++)M*=m[i];
	for(int i=0;i&lt;n;i++){
		LL w=M/m[i];
		d=exgcd(m[i],w,d,y);
		x=(x+y*w*a[i])%M;
	}return (x+M)%M;
}
LL BSGS(LL a,LL b,LL p){
	//a^x=b%p
	LL m=sqrt(p)+.5,v=inv(power(a,m,p),p),e=1;
	map&lt;LL,LL&gt;hash;hash[1]=0;
	for(int i=1;i&lt;m;i++)
		e=e*a%p,hash[e]=i;
	for(int i=0;i&lt;=m;i++){
		if(hash.count(b))return i*m+hash[b];
		b=b*v%p;
	}return -1;
}
int main(){
	LL t,k,a,b,p;
	cin&gt;&gt;t&gt;&gt;k;
	while(t--){
		cin&gt;&gt;a&gt;&gt;b&gt;&gt;p;
		if(k==1){
			cout&lt;&lt;power(a,b,p)&lt;&lt;endl;
		}
		if(k==2){
			LL v=inv(a,p);
			if(!~v)puts("Orz, I cannot find x!");
			else cout&lt;&lt;v*b%p&lt;&lt;endl; 
		}
		if(k==3){
			LL ans=BSGS(a,b,p);
			if(!~ans)puts("Orz, I cannot find x!");
			else cout&lt;&lt;ans&lt;&lt;endl;
		}		
	}
	return 0;
}</pre><pre></pre><h2>Problem2243</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;climits&gt;
#define lson i&lt;&lt;1,l,mid
#define rson i&lt;&lt;1|1,mid+1,r
#define L i&lt;&lt;1
#define R i&lt;&lt;1|1
using namespace std;
const int maxn=1e5+5;
int top[maxn],fa[maxn],dep[maxn],son[maxn],siz[maxn],w[maxn],z=0;
vector&lt;int&gt;G[maxn];

int n,m,root=1;
int c[maxn],col[maxn];
int U[maxn],V[maxn];
void add(int u,int v){
	G[u].push_back(v);
	G[v].push_back(u);
}	
struct node{
	int l,r,sum,lazy;
	node(){
		l=-1;r=-1;sum=0,lazy=-1;
	}
	node(int _l,int _r,int _sum){
		l=_l;r=_r;sum=_sum;
	}
};
node operator+(node a,node b){
	if(a.sum==0)return b;
	if(b.sum==0)return a;
	node res;
	res.l=a.l;
	res.r=b.r;
	res.sum=a.sum+b.sum-(a.r==b.l);		
	return res;
}
struct seg_tree{

	node t[maxn&lt;&lt;2];
	/*void build(int i,int l,int r){
		if(l&gt;r)return;
		if(l==r){
			t[i].l=t[i].r=c[l];
			t[i].sum=1;
		}
		int mid=(l+r)&gt;&gt;1;
		build(lson);build(rson);
		t[i]=t[L]+t[R];
	}*/
	void pushdown(int i){
		if(t[i].lazy==-1)return;
		t[L].l=t[L].r=t[R].l=t[R].r=t[i].lazy;
		t[L].sum=t[R].sum=1;
		t[L].lazy=t[R].lazy=t[i].lazy;
		t[i].lazy=-1;
	}
	void updata(int i,int l,int r,int l0,int r0,int c){
		if(l&gt;r)return;
		if(l0&lt;=l&amp;&amp;r0&gt;=r){
			t[i].l=t[i].r=c;
			t[i].sum=1;
			t[i].lazy=c;
			//if(l0==l&amp;&amp;r0==r)t[i].lazy=-1;
			return;
		}
		int mid=(l+r)&gt;&gt;1;
		pushdown(i);
		if(l0&lt;=mid)updata(lson,l0,r0,c);
		if(r0&gt;mid)updata(rson,l0,r0,c);
		t[i].l=t[L].l;
		t[i].r=t[R].r;
		t[i].sum=t[L].sum+t[R].sum-(t[L].r==t[R].l&amp;&amp;t[L].r!=-1);
	} 
	node query(int i,int l,int r,int l0,int r0){
		if(l&gt;r)return node(-1,-1,0);
		if(l0&lt;=l&amp;&amp;r0&gt;=r)return t[i];
		int mid=l+r&gt;&gt;1;
		pushdown(i);
		if(r0&lt;=mid)return query(lson,l0,r0);
		if(l0&gt;mid)return query(rson,l0,r0);
		return query(lson,l0,mid)+query(rson,mid+1,r0);
	}
	
}T;
void dfs(int u){
	son[u]=0;siz[u]=1;
	for(int i=0;i&lt;G[u].size();i++){
		int v=G[u][i];
		if(v!=fa[u]){
			fa[v]=u;
			dep[v]=dep[u]+1;
			dfs(v);
			if(siz[v]&gt;siz[son[u]])son[u]=v;
			siz[u]+=siz[v];
		}
	}
}
void build(int u,int tp){
	w[u]=++z;top[u]=tp;
	if(son[u]!=0)build(son[u],tp);
	for(int i=0;i&lt;G[u].size();i++){
		int v=G[u][i];
		if(v!=son[u]&amp;&amp;v!=fa[u])
		build(v,v);
	}
}
void change(int u,int v,int c){
	while(top[u]!=top[v]){
		if(dep[top[u]]&gt;dep[top[v]]){
			int a=w[u],b=w[top[u]];
			if(a&gt;b)swap(a,b);
			T.updata(1,1,n,a,b,c);
			u=fa[top[u]];
		}else{
			int a=w[v],b=w[top[v]];
			if(a&gt;b)swap(a,b);
			T.updata(1,1,n,a,b,c);
			v=fa[top[v]];
		}
	}
	if(w[u]&lt;w[v])
		T.updata(1,1,n,w[u],w[v],c);
	else
		T.updata(1,1,n,w[v],w[u],c);
}
int query(int u,int v){
	node Left,Right,ans;
	while(top[u]!=top[v]){
		if(dep[top[u]]&gt;dep[top[v]]){
			int a=w[u],b=w[top[u]];
			ans=T.query(1,1,n,min(a,b),max(a,b));
			if(a&gt;b)swap(ans.l,ans.r);
			Left=Left+ans;
			u=fa[top[u]];
		}else{
			int a=w[v],b=w[top[v]];
			ans=T.query(1,1,n,min(a,b),max(a,b));
			if(a&lt;b)swap(ans.l,ans.r);
			Right=ans+Right;
			v=fa[top[v]];
		}
	}
	
	ans=T.query(1,1,n,min(w[u],w[v]),max(w[u],w[v]));
	
	if(w[u]&gt;w[v])swap(ans.l,ans.r);
	Left=Left+ans;
	
	return (Left+Right).sum;
}
void deb(){	
	//DEB
	for(int i=1;i&lt;=14;i++)
	printf("#%d l:%d r:%d sum:%d lazy:%d\n",i,T.t[i].l,T.t[i].r,T.t[i].sum,T.t[i].lazy);
	//end DEB	
}
int main(){
	scanf("%d%d",&amp;n,&amp;m);
	for(int i=1;i&lt;=n;i++)scanf("%d",&amp;c[i]);
	for(int i=1;i&lt;n;i++){
		int u,v;scanf("%d%d",&amp;u,&amp;v);
		add(u,v);U[i]=u;V[i]=v;
	}
	dep[root]=1;
	dfs(root);build(root,root);

	for(int i=1;i&lt;=n;i++)
		change(i,i,c[i]);//,deb();



	
	
	
	char opt[5];
	while(m--){
		scanf("%s",opt);
		if(opt[0]=='Q'){
			int u,v;
			scanf("%d%d",&amp;u,&amp;v);
			printf("%d\n",query(u,v));
		}else{
			int u,v,C;
			scanf("%d%d%d",&amp;u,&amp;v,&amp;C);
			change(u,v,C);
		}//deb();
	}
	return 0;
}</pre><pre></pre><h2>Problem2245</h2><pre>/*
	ID:zky
	OJ:BZOJ
	Index:2245
	Language:C++
*/
#include&lt;vector&gt;
#include&lt;queue&gt;
#include&lt;climits&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
const long long INF=9223372036854775806LL;
typedef long long lld;
struct edge{
	lld u,v,cap,flow,cost;
	edge(lld _u,lld _v,lld _cap,lld _flow,lld _cost):
		u(_u),v(_v),cap(_cap),flow(_flow),cost(_cost){}
};
vector&lt;edge&gt;edges;
vector&lt;vector&lt;lld&gt; &gt;G;
void add(lld u,lld v,lld cap,lld cost){
	edges.push_back(edge(u,v,cap,0,cost));
	G[u].push_back(edges.size()-1);
	edges.push_back(edge(v,u,0,0,-cost));
	G[v].push_back(edges.size()-1);
}
lld a[110000];
lld d[1100];
lld p[10001];
lld vis[10001];
lld n,m,s,t;
lld flow=0,cost=0;
bool spfa(){
	queue&lt;lld&gt;q;
	q.push(s);
	a[s]=INF;
	for(lld i=0;i&lt;=n+m+1;i++){
		vis[i]=0;
		d[i]=INF;
	}
	lld B=d[0];
	d[s]=0;
	vis[s]=1;
	while(!q.empty()){
		lld u=q.front();q.pop();vis[u]=0;
		for(lld i=0;i&lt;G[u].size();i++){
			edge e=edges[G[u][i]];
			if(d[e.v]&gt;d[u]+e.cost&amp;&amp;e.cap&gt;e.flow){
				d[e.v]=d[u]+e.cost;
				a[e.v]=min(a[u],e.cap-e.flow);
				p[e.v]=G[u][i];
				if(!vis[e.v]){
					vis[e.v]=1;
					q.push(e.v);
				}
			}
		}
	}
	if(d[t]==B)return false;
	flow+=a[t];
	cost+=a[t]*d[t];
	lld u=t;
	while(u!=s){
		edges[p[u]].flow+=a[t];
		edges[p[u]^1].flow-=a[t];
		u=edges[p[u]].u;
	}
	return true;
}

lld S[255]={0};
lld T[255]={0};
lld w[255][255]={0};
int main(){
	cin&gt;&gt;n&gt;&gt;m;
	G.resize(n+m+10);
	s=0;t=n+m+1;
	lld x;
	for(lld i=1;i&lt;=m;i++){
		cin&gt;&gt;x;
		add(s,i,x,0);
	}
	for(lld i=1;i&lt;=n;i++){
		for(lld j=1;j&lt;=m;j++){
			cin&gt;&gt;x;
			if(x)add(j,i+m,INF,0);
		}
	}
	for(lld i=1;i&lt;=n;i++){
		cin&gt;&gt;x;
		S[0]=0;S[x+1]=INF;
		for(lld j=1;j&lt;=x;j++)
			cin&gt;&gt;S[j];
		for(lld j=1;j&lt;=x+1;j++)
			cin&gt;&gt;T[j];
		for(lld j=1;j&lt;=x+1;j++)
		add(i+m,t,S[j]-S[j-1],T[j]);
	}
//	for(lld i=0;i&lt;edges.size();i++)if(i%2==0)
//	printf("#%I64d  %I64d -&gt; %I64d  cap:%I64d   cost:%I64d\n",
//		i,edges[i].u,edges[i].v,edges[i].cap,edges[i].cost);
	while(spfa());
	cout&lt;&lt;cost&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem2251</h2><pre>#include&lt;bits/stdc++.h&gt;
#define id(x) (x-'0')
using namespace std;
const int maxn=3001;
int n;char s[maxn]; 
struct node{
	int val;
	node *c[2];
	node(){val=0;c[0]=c[1]=0;}
}*root=new node();
void dfs(node *u){
	if(u-&gt;val&gt;1)printf("%d\n",u-&gt;val);
	if(u-&gt;c[0])dfs(u-&gt;c[0]);
	if(u-&gt;c[1])dfs(u-&gt;c[1]);
}
int main(){
	scanf("%d%s",&amp;n,s);
	for(int i=0;i&lt;n;i++){
		node *u=root;
		for(int j=i;j&lt;n;j++){
			int v=s[j]-'0';
			if(!u-&gt;c[v])u-&gt;c[v]=new node();
			u=u-&gt;c[v];
			u-&gt;val++;
		}
	}dfs(root);
	return 0;
}</pre><pre></pre><h2>Problem2258</h2><pre>#include&lt;cstdio&gt;
#include&lt;cctype&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=50300;
typedef unsigned long long UL;
UL base=233;
UL hash[maxn];
UL hash_l[maxn];
char s[maxn];
int len,m;
void hash_init(int be){
	UL val=hash[be-1];
	for(int i=be;i&lt;=len;i++){
		val=val*base+s[i]-'a';
		hash[i]=val;
	}
}
int mp[maxn+200];
int main(){
	scanf("%s",s+1);s[0]='#';
	len=strlen(s+1);hash_l[0]=1;
	for(int i=1;i&lt;=len+200;i++)hash_l[i]=hash_l[i-1]*base,mp[i]=i;
	scanf("%d",&amp;m);
	hash_init(1);
	while(m--){
		char op=getchar();while(op!='Q'&amp;&amp;op!='I')op=getchar();
		if(op=='I'){
			char x=getchar();while(!isalpha(x))x=getchar();
			int ps;scanf("%d",&amp;ps);if(ps&gt;len)ps=len+1;
			for(int i=len+1;i&gt;ps;i--)s[i]=s[i-1];
			for(int j=lower_bound(mp+1,mp+1+len,ps)-mp,i=j;i&lt;=len+1;i++)mp[i]++;
			s[ps]=x;len++;s[len+1]='\0';
			hash_init(ps);
		}else{
			int a,b;scanf("%d%d",&amp;a,&amp;b);a=mp[a];b=mp[b];
			int l=0,r=len-b+2;
			while(l&lt;r){
				int mid=(l+r)&gt;&gt;1;
				if(hash[a+mid-1]-hash[a-1]*hash_l[mid]==hash[b+mid-1]-hash[b-1]*hash_l[mid])
				l=mid+1;
				else r=mid;
			}printf("%d\n",l-1);
		}
	}
	return 0;
}</pre><pre></pre><h2>Problem2259</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1e6+5;
int n;
int a[maxn];
int d[maxn];
int vis[maxn];
struct edge{int u,v,w;};
vector&lt;edge&gt;G[maxn];
void add(int u,int v,int w){G[u].push_back((edge){u,v,w});}
typedef pair&lt;int,int&gt; pi;
priority_queue&lt;pi,vector&lt;pi&gt;,greater&lt;pi&gt; &gt;q;
int spfa(){
	fill(d+1,d+2+n,1e9+10);
	d[1]=0;q.push(pi(0,1));
	while(!q.empty()){
		int u=q.top().second;vis[u]=0;q.pop();
		for(int i=0;i&lt;G[u].size();i++){
			edge e=G[u][i];
			if(d[u]+e.w&lt;d[e.v]){
				d[e.v]=d[u]+e.w;
				if(!vis[e.v]){
					vis[e.v]=1;
					q.push(pi(d[e.v],e.v));
				}
			}
		}
	}return d[n+1];
}
int pre[maxn],nxt[maxn];
int main(){
	scanf("%d",&amp;n);
	for(int i=1;i&lt;=n;i++){
		int x;scanf("%d",&amp;x);
		for(int j=i+1;j&lt;=min(i+x+1,n)&amp;&amp;!pre[j];j++)pre[j]=1,add(j,j-1,1);
		for(int j=i+x+1;j&lt;=n&amp;&amp;!nxt[j];j++)nxt[j]=1,add(j,j+1,1);		
		if(i+x+1&lt;=n+1)
			add(i,i+x+1,0);
		else add(i,n+1,i+x-n);
	}cout&lt;&lt;spfa()&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem2259</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1e6+5;
int n;
int a[maxn];
int d[maxn];
int vis[maxn];
struct edge{int u,v,w;};
vector&lt;edge&gt;G[maxn];
void add(int u,int v,int w){G[u].push_back((edge){u,v,w});}
typedef pair&lt;int,int&gt; pi;
priority_queue&lt;pi,vector&lt;pi&gt;,greater&lt;pi&gt; &gt;q;
int spfa(){
	fill(d+1,d+2+n,1e9+10);
	d[1]=0;q.push(pi(0,1));
	while(!q.empty()){
		int u=q.top().second;vis[u]=0;q.pop();
		for(int i=0;i&lt;G[u].size();i++){
			edge e=G[u][i];
			if(d[u]+e.w&lt;d[e.v]){
				d[e.v]=d[u]+e.w;
				q.push(pi(d[e.v],e.v));
			}
		}
	}return d[n+1];
}
int pre[maxn],nxt[maxn];
int main(){
	scanf("%d",&amp;n);
	for(int i=1;i&lt;=n;i++){
		int x;scanf("%d",&amp;x);
		for(int j=i+1;j&lt;=min(i+x+1,n)&amp;&amp;!pre[j];j++)pre[j]=1,add(j,j-1,1);
		for(int j=i+x+1;j&lt;=n&amp;&amp;!nxt[j];j++)nxt[j]=1,add(j,j+1,1);		
		if(i+x+1&lt;=n+1)
			add(i,i+x+1,0);
		else add(i,n+1,i+x-n);
	}cout&lt;&lt;spfa()&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem2259</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1e6+5;
int n;
int a[maxn];
int d[maxn];
int vis[maxn];
struct edge{int u,v,w;};
vector&lt;edge&gt;G[maxn];
void add(int u,int v,int w){G[u].push_back((edge){u,v,w});}
typedef pair&lt;int,int&gt; pi;
priority_queue&lt;pi,vector&lt;pi&gt;,greater&lt;pi&gt; &gt;q;
int spfa(){
    fill(d+1,d+2+n,1e9+10);
    d[1]=0;q.push(pi(0,1));
    while(!q.empty()){
        int u=q.top().second;vis[u]=0;q.pop();
        for(int i=0;i&lt;G[u].size();i++){
            edge e=G[u][i];
            if(d[u]+e.w&lt;d[e.v]){
                d[e.v]=d[u]+e.w;
                if(!vis[e.v]){
                    vis[e.v]=1;
                    q.push(pi(d[e.v],e.v));
                }
            }
        }
    }return d[n+1];
}
int pre[maxn],nxt[maxn];
int main(){
    scanf("%d",&amp;n);
    for(int i=1;i&lt;=n;i++){
        int x;scanf("%d",&amp;x);
        for(int j=i+1;j&lt;=min(i+x+1,n)&amp;&amp;!pre[j];j++)pre[j]=1,add(j,j-1,1);
        for(int j=i+x+1;j&lt;=n&amp;&amp;!nxt[j];j++)nxt[j]=1,add(j,j+1,1);     
        if(i+x+1&lt;=n+1)
            add(i,i+x+1,0);
        else add(i,n+1,i+x-n);
    }cout&lt;&lt;spfa()&lt;&lt;endl;
    return 0;
}</pre><pre></pre><h2>Problem2275</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
vector&lt;long long&gt;vec;
int main(){
	vec.push_back(1);
	vec.push_back(2);
	while(vec.back()&lt;=1e15)vec.push_back(vec[vec.size()-2]+vec.back());
	long long n;cin&gt;&gt;n;
	for(int i=vec.size()-1;i&gt;=0;i--){
		if(n&gt;=vec[i]){
			n-=vec[i];
			if(!n)cout&lt;&lt;vec[i]&lt;&lt;endl;
		}
	}
	return 0;
}</pre><pre></pre><h2>Problem2282</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=3e5+5;
int n,k;
int pre[maxn],d[maxn],ans,W[maxn],vis[maxn];
vector&lt;pair&lt;int,int&gt; &gt;G[maxn];
void dfs(int u,int fa){
	for(int i=0;i&lt;G[u].size();i++){
		int v=G[u][i].first,w=G[u][i].second;
		if(v==fa||vis[v])continue;
		d[v]=d[u]+w;pre[v]=u;W[v]=w;
		if(d[v]&gt;d[ans])ans=v;
		dfs(v,u);
	}
}
int mx[maxn];
multiset&lt;int&gt;S;
int max3(int x,int y,int z){return max(max(x,y),z);}
int max4(int x,int y,int z,int w){return max(max(x,y),max(z,w));}
int main(){
	scanf("%d%d",&amp;n,&amp;k);
	for(int i=1;i&lt;n;i++){
		int u,v,w;scanf("%d%d%d",&amp;u,&amp;v,&amp;w);
		G[u].push_back(make_pair(v,w));
		G[v].push_back(make_pair(u,w));
	}dfs(1,0);int A=ans;
	ans=d[A]=0;dfs(A,0);int B=ans,len=0;
	for(int i=B;i!=A;i=pre[i])vis[i]=1,len+=W[i];vis[A]=1;
	for(int i=B;i!=A;i=pre[i]){
		ans=d[i]=0;dfs(i,0);mx[i]=d[ans];
	}int cur=0,res=2e9;
	memset(vis,0,sizeof vis);dfs(A,0);
	for(int i=B,j=B;i!=A;i=pre[i]){
		while(j!=A&amp;&amp;cur+W[j]&lt;=k){
			cur+=W[j];
			S.insert(mx[j]);
			j=pre[j];
		}
		if(i!=j)
			res=min(res,max4(mx[j],d[j],len-d[i],*(--S.end())));
		else res=min(res,max3(d[i],len-d[i],mx[i])),j=j!=A?pre[j]:A;
		if(i!=j)
		cur-=W[i],S.erase(S.find(mx[i]));
	}cout&lt;&lt;res&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem2285</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const double eps=1e-5;
const double inf=1e9;
int dcmp(double x){return (x&gt;1e-6)-(x&lt;-1e-6);}
namespace MinCut{
	int s=0,t=176;
	struct edge{
		int u,v;
		double cap,flow;
	};
	vector&lt;edge&gt;edges;
	vector&lt;int&gt;G[177];
	void add(int u,int v,double cap){
		edges.push_back((edge){u,v,cap,0});
		G[u].push_back(edges.size()-1);
		edges.push_back((edge){v,u,0,0});
		G[v].push_back(edges.size()-1);
	}
	int d[177];
	bool bfs(){
		static int vis[177];
		memset(vis,0,sizeof vis);
		queue&lt;int&gt;q;q.push(s);vis[s]=1;
		while(!q.empty()){
			int u=q.front();q.pop();
			for(int i=0;i&lt;G[u].size();i++){
				edge e=edges[G[u][i]];
				if(!vis[e.v]&amp;&amp;e.cap-e.flow&gt;eps){
					vis[e.v]=1;d[e.v]=d[u]+1;
					q.push(e.v);
				}
			}
		}return vis[t];
	}
	int cur[177];
	double dfs(int u,double a){
		if(u==t||a&lt;eps)return a;
		double flow=0,f;
		for(int &amp;i=cur[u];i&lt;G[u].size();i++){
			edge e=edges[G[u][i]];
			if(d[e.v]==d[u]+1&amp;&amp;(f=dfs(e.v,min(a,e.cap-e.flow)))&gt;eps){
				flow+=f;a-=f;
				edges[G[u][i]].flow+=f;
				edges[G[u][i]^1].flow-=f;
				if(!dcmp(a))break;
			}
		}if(!dcmp(flow))d[u]=-1;
		return flow;
	}
	double dinic(){
		double flow=0;
		while(bfs()){
			double x;
			memset(cur,0,sizeof cur);
			while((x=dfs(s,1e9))&gt;eps)flow+=x;
		}return flow;
	}
	
}
struct edge{
	int u,v;
	double w,a,b;
};
int n,m,n1,m1;
vector&lt;edge&gt;edges;
vector&lt;int&gt;G[707];
bool vis[707];
double d[707];
double dfs(int u){
	if(vis[u])return d[u];
	vis[u]=1;d[u]=1e9;
	for(int i=0;i&lt;G[u].size();i++){
		edge e=edges[G[u][i]];
		d[u]=min(d[u],dfs(e.v)+e.w);
	}return d[u];
}
double calc(int x){
	double l=0,r=11;
	while(r-l&gt;eps){
		double mid=(l+r)/2;
		for(int i=0;i&lt;edges.size();i++)edges[i].w=edges[i].a-mid*edges[i].b;
		memset(vis,0,sizeof vis);vis[n]=1;
		if(dfs(x)&gt;=0)
			l=mid;
		else r=mid;
	}return l&gt;10.5?1e9:l;
}
double w[177];
int main(){
	scanf("%d%d",&amp;n,&amp;m);
	for(int i=1;i&lt;=m;i++){
		int u,v;double a,b;
		scanf("%d%d%lf%lf",&amp;u,&amp;v,&amp;a,&amp;b);
		edges.push_back((edge){v,u,0,a,b});
		G[v].push_back(edges.size()-1);
	}
	scanf("%d%d",&amp;m1,&amp;n1);
 	for(int i=1;i&lt;=n1;i++)
		w[i]=calc(i);
	for(int i=1;i&lt;=n1;i++)if(i&amp;1)MinCut::add(MinCut::s,i,w[i]);
	else MinCut::add(i,MinCut::t,w[i]);
	for(int i=1;i&lt;=m1;i++){
		int u,v;scanf("%d%d",&amp;u,&amp;v);
		MinCut::add(u,v,inf);
	}double ans=MinCut::dinic();
	if(ans&gt;=1e8)puts("-1");
	else printf("%.1lf\n",ans);
	return 0;
}</pre><pre></pre><h2>Problem2286</h2><pre>#include&lt;bits/stdc++.h&gt;
#define pb push_back
#define m_p make_pair 
using namespace std;
typedef long long LL;
const int maxn=250010;
const int BIT=19;
int n,m;
vector&lt;pair&lt;int,int&gt; &gt;G[maxn];
vector&lt;int&gt;Ge[maxn];
LL mn[maxn];
int fa[maxn][BIT],dep[maxn],z,dfn[maxn],w[maxn],vis[maxn];
void dfs(int u){
	dfn[u]=++z;
	for(int i=1;i&lt;BIT;i++)fa[u][i]=fa[fa[u][i-1]][i-1];
	for(int i=0;i&lt;G[u].size();i++){
		int v=G[u][i].first,w=G[u][i].second;
		if(fa[u][0]==v)continue;
		fa[v][0]=u;dep[v]=dep[u]+1;mn[v]=min(mn[u],(LL)w);
		dfs(v);
	}
}
LL dp(int u,int fa){
    LL tmp=0;
    for(int v,i=0;i&lt;Ge[u].size();i++){
    	if((v=Ge[u][i])!=fa)
        tmp+=dp(v,u);
    }Ge[u].clear();
    return tmp?min(tmp,(LL)mn[u]):mn[u];
}
bool cmp(int x,int y){return dfn[x]&lt;dfn[y];}
int h[maxn];
int lca(int u,int v){
	if(dep[u]&lt;dep[v])swap(u,v);
	int d=dep[u]-dep[v];
	for(int i=BIT-1;i&gt;=0;i--)if(d&amp;(1&lt;&lt;i))u=fa[u][i];
	if(u==v)return u;
	for(int i=BIT-1;i&gt;=0;i--)if(fa[u][i]!=fa[v][i])u=fa[u][i],v=fa[v][i];
	return fa[u][0];
}
int sta[maxn],top;
void add(int u,int v){
	if(u==v)return;
//	cerr&lt;&lt;u&lt;&lt;" "&lt;&lt;v&lt;&lt;endl;
	Ge[u].pb(v);
	Ge[v].pb(u);
}
int main(){
	scanf("%d",&amp;n);
	for(int i=1;i&lt;n;i++){
		int u,v,w;scanf("%d%d%d",&amp;u,&amp;v,&amp;w);
		G[u].pb(m_p(v,w));
		G[v].pb(m_p(u,w));
	}mn[1]=1e11;dfs(1);
	scanf("%d",&amp;m);m++;
	while(m--&gt;1){
		int k;scanf("%d",&amp;k);z=1;
		for(int i=1;i&lt;=k;i++)scanf("%d",&amp;h[i]);
		sort(h+1,h+1+k,cmp);z=1;
		for(int i=2;i&lt;=k;i++)if(h[z]!=lca(h[z],h[i]))h[++z]=h[i];
    	top=0;sta[++top]=1;k=z;
    	for(int i=1;i&lt;=k;i++){
       		int u=h[i],f=lca(u,sta[top]);
        	for(;;){
      	      if(dep[f]&gt;=dep[sta[top-1]]){
        	        add(f,sta[top--]);
        	        if(sta[top]!=f)sta[++top]=f;
        	        break;
        	    }add(sta[top-1],sta[top]);top--;
      	 	}if(sta[top]!=u)sta[++top]=u;
    	}while(--top)add(sta[top],sta[top+1]);
		printf("%lld\n",dp(1,0));
	}
	return 0;
}</pre><pre></pre><h2>Problem2292</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1e5+10;
struct edge{int u,v,w;};
vector&lt;edge&gt;G[maxn];
void add(int u,int v,int w){
	G[u].push_back((edge){u,v,w});
//	G[v].push_back((edge){v,u,w});
}
typedef pair&lt;int,int&gt; pii;
priority_queue&lt;pii,vector&lt;pii&gt;,greater&lt;pii&gt; &gt;q;
int d[maxn],vis[maxn];
int s,t,n,m;
void dijk(){
	memset(d,0x7f,sizeof(d));
	d[s]=0;
	q.push(pii(d[s],s));
	while(!q.empty()){
		int u=q.top().second;q.pop();
		if(vis[u])continue;
		for(int i=0;i&lt;G[u].size();i++){
			int v=G[u][i].v,w=G[u][i].w;
			if(d[v]&gt;d[u]+w){
				d[v]=d[u]+w;
				q.push(pii(d[v],v));
			}
		}
		vis[u]=1;
	}
	 printf("%d\n",d[t]);
}
void deb(){
	for(int i=0;i&lt;=n*(m-1);i++)
	for(int j=0;j&lt;G[i].size();j++)
	printf("%d -&gt; %d w:%d\n",G[i][j].u,G[i][j].v,G[i][j].w);
}
int main(){
	scanf("%d%d",&amp;n,&amp;m);
	for(int i=1;i&lt;=m;i++){
		int u,v,w;
		scanf("%d%d%d",&amp;u,&amp;v,&amp;w);
		add(u,v,w);
	}s=1;t=n;
	dijk();
	return 0;
}</pre><pre></pre><h2>Problem2295</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=1e5+5;
int n;
char s[maxn];
char t[]="luvletter";
int main(){
	scanf("%d",&amp;n);getchar();
	while(n--){
		gets(s+1);
		int len=strlen(s+1);
		int ans=0;
		for(int i=1,j=0;i&lt;=len;i++){
			j+=s[i]==t[j];
			if(j==9)j=0,ans++;
		}printf("%d\n",ans);
	}
	return 0;
}</pre><pre></pre><h2>Problem2298</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1e5+5;
int f[maxn];
int n;
struct pii{
	int x,y,c;
	bool f;
};
pii a[maxn];
bool cmp(pii a,pii b){return a.y&lt;b.y||(a.y==b.y&amp;&amp;a.x&lt;b.x);}
map&lt;pair&lt;int,int&gt;,int&gt;M;
int main(){
	scanf("%d",&amp;n);
	for(int i=1;i&lt;=n;i++){
		scanf("%d%d",&amp;a[i].x,&amp;a[i].y);
		a[i].f=a[i].x+a[i].y&gt;=n;
		a[i].x=n-a[i].x;
		a[i].y++;
		if(a[i].x&gt;a[i].y)swap(a[i].x,a[i].y);
		a[i].c=min(M[make_pair(a[i].x,a[i].y)]+=a[i].f^1,a[i].y-a[i].x+1);
	}sort(a+1,a+1+n,cmp);
	for(int i=1;i&lt;=n;i++){
		if(a[i].f){f[i]=f[i-1];continue;}
		int l=lower_bound(a+1,a+i,(pii){-1,a[i].x},cmp)-a-1;
		f[i]=max(f[i-1],f[l]+a[i].c);
	}cout&lt;&lt;n-f[n]&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem2301</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cctype&gt;
using namespace std;
typedef long long LL;
const int maxn=50005;
int T,n,m;
bool p[maxn];
int u[maxn],prime[maxn];
int getint(){
	int res=0;char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))res=res*10+c-'0',c=getchar();
	return res;
}
void init(){
	u[1]=1;
	for(int i=2;i&lt;maxn;i++){
		if(!p[i]){
			prime[++prime[0]]=i;u[i]=-1;
		}for(int j=1;i*prime[j]&lt;maxn&amp;&amp;j&lt;=prime[0];j++){
			int K=i*prime[j];
			p[K]=1;
			if(i%prime[j]==0){
				u[K]=0;break;
			}else u[K]=-u[i];
		}
	}for(int i=2;i&lt;maxn;i++)u[i]+=u[i-1];
}
LL calc(int n,int m,int k){
	n/=k;m/=k;
	if(n&gt;m)swap(n,m);
	LL ans=0;
	for(int i=1,last;i&lt;=n;i=last+1){
		last=min(n/(n/i),m/(m/i));
		ans+=(LL)(u[last]-u[i-1])*(n/i)*(m/i);
	}return ans;
}
int main(){
	T=getint();
	init();
	while(T--){
		int a=getint(),b=getint(),c=getint(),d=getint(),k=getint();
		LL ans=calc(b,d,k)-calc(a-1,d,k)-calc(b,c-1,k)+calc(a-1,c-1,k);
		printf("%lld\n",ans);
	}
	return 0;
}</pre><pre></pre><h2>Problem2306</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=101;
const int BIT=29;
int n,m,v0;
long double w[maxn],p;
vector&lt;int&gt;G[BIT][maxn];
bool F[BIT][maxn][maxn];
long double f[BIT][maxn][maxn];
long double pw[BIT];
int main(){
	cin&gt;&gt;n&gt;&gt;m;double x;
	for(int i=1;i&lt;=n;i++)cin&gt;&gt;x,w[i]=x;
	cin&gt;&gt;v0&gt;&gt;p;
	if(p&gt;0.998&amp;&amp;p&lt;0.9991||w[2]&lt;1e-4){
		if(w[2]&lt;1e-4)puts("79.0");
		else puts("94.3");
		return 0;
	}
	for(int i=0;i&lt;BIT;i++)pw[i]=pow((long double)p,(long double)pow(2.0,i));
	for(int i=1;i&lt;=m;i++){
		int u,v;scanf("%d%d",&amp;u,&amp;v);
		G[0][u].push_back(v);
		F[0][u][v]=1;
		f[0][u][v]=w[u]+p*w[v];
	}for(int i=1;i&lt;BIT;i++){
		for(int u=1;u&lt;=n;u++)
		for(int k=0;k&lt;G[i-1][u].size();k++){
			int v=G[i-1][u][k];
			for(int l=0;l&lt;G[i-1][v].size();l++){
				int vv=G[i-1][v][l];
				if(!F[i][u][vv])
				G[i][u].push_back(vv),
				F[i][u][vv]=1;
				//printf("%d %d-&gt;%d\n",i,u,vv);
			}
		}
	}
	for(int i=1;i&lt;BIT;i++){
		for(int u=1;u&lt;=n;u++){
			for(int j=0;j&lt;G[i-1][u].size();j++){
				int v=G[i-1][u][j];
				for(int k=0;k&lt;G[i-1][v].size();k++){
					int vv=G[i-1][v][k];
					//printf("%.2lf %.2lf\n",f[i-1][u][v],f[i-1][v][vv]);
					f[i][u][vv]=max(f[i][u][vv],f[i-1][u][v]+pw[i-1]*(f[i-1][v][vv]-w[v]));
					//printf("%.2lf\n",f[i][u][vv]);
				}
			}
		}
	}long double ans=0;
	for(int i=1;i&lt;=n;i++)ans=max(ans,(long double)f[BIT-1][v0][i]);
	cout&lt;&lt;fixed&lt;&lt;setprecision(1)&lt;&lt;(double)ans&lt;&lt;endl;
	return 0;
}
</pre><pre></pre><h2>Problem2318</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
int main(){
	int T,n;
	double p,q;
	static double f[1002],g[1002];
	cin&gt;&gt;T;
	while(T--){
		cin&gt;&gt;n&gt;&gt;p&gt;&gt;q;n=min(n,1000);
		p=max(p,1-p);q=max(q,1-q);
		f[0]=0;g[0]=1;
		for(int i=1;i&lt;=n;i++){
			if(f[i-1]&gt;g[i-1])p=1-p,q=1-q;
			f[i]=(p*g[i-1]+(1-p)*q*f[i-1])/(1-(1-p)*(1-q));
			g[i]=(q*f[i-1]+(1-q)*p*g[i-1])/(1-(1-p)*(1-q));
			if(f[i-1]&gt;g[i-1])p=1-p,q=1-q;
		}printf("%.6lf\n",f[n]);
	}
	return 0;
}</pre><pre></pre><h2>Problem2321</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
int n,m;
LL ans;
int main(){
	cin&gt;&gt;n&gt;&gt;m;
	for(int i=1;i&lt;=n;i++)for(int j=1;j&lt;=m;j++){
		LL x;cin&gt;&gt;x;ans+=x*(i*i+j*j);
	}
	for(int i=1;i&lt;=n;i++)for(int j=1;j&lt;=m;j++){
		LL x;cin&gt;&gt;x;ans-=x*(i*i+j*j);
	}
	cout&lt;&lt;ans/2&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem2322</h2><pre>#include &lt;cstdio&gt;
#include &lt;set&gt;
using namespace std;

typedef long long ll;

#define N 10000
#define M 100000
#define Q 30000
#define LOG 64

struct edge {
	int next, node;
	ll w;
} e[M &lt;&lt; 1 | 1];
int head[N + 1], tot = 0;

inline void addedge(int a, int b, ll w) {
	e[++tot].next = head[a];
	head[a] = tot, e[tot].node = b, e[tot].w = w;
}

struct inedge {
	int a, b;
	ll w;
} ie[M + 1];
bool del[M + 1];

int n, m, qc, x, y, q[Q + 1], cnt, ccnt;
ll a[M + 1], w, ans[Q + 1], f[N + 1], chain[N + 1], r[LOG + 1];
bool v[M + 1], vis[N + 1];
set &lt;ll&gt; h;

inline ll eliminate(ll x) {
	for (int k = LOG - 1; k &gt;= 0; --k)
		if (r[k] &amp;&amp; ((x &gt;&gt; k) &amp; 1LL)) x ^= r[k];
	return x;
}

inline ll calc() {
	for (int i = 1; i &lt;= cnt; ++i) v[i] = false;
	for (int k = LOG - 1; k &gt;= 0; --k) {
		int p = 0;
		for (int i = 1; !p &amp;&amp; i &lt;= cnt; ++i)
			if (!v[i] &amp;&amp; ((a[i] &gt;&gt; k) &amp; 1LL)) p = i;
		if (!p) {
			r[k] = 0;
			continue;
		}
		v[p] = true, r[k] = a[p];
		for (int i = 1; i &lt;= cnt; ++i)
			if (i != p &amp;&amp; ((a[i] &gt;&gt; k) &amp; 1LL)) a[i] ^= a[p];
	}
	int cur = 0;
	for (int i = 1; i &lt;= cnt; ++i)
		if (a[i]) a[++cur] = a[i];
	cnt = cur;
	
	h.clear(), cur = 0;
	for (int i = 1; i &lt;= ccnt; ++i) {
		ll x = eliminate(chain[i]);
		if (h.find(x) == h.end()) {
			chain[++cur] = chain[i];
			h.insert(x);
		}
	}
	ccnt = cur;
	
	return (ll)ccnt * (1LL &lt;&lt; cnt) - 1;
}

void dfs(int x) {
	vis[x] = true;
	for (int i = head[x]; i; i = e[i].next) {
		int node = e[i].node;
		if (vis[node]) a[++cnt] = f[x] ^ f[node] ^ e[i].w;
		else {
			f[node] = f[x] ^ e[i].w;
			chain[++ccnt] = f[node];
			dfs(node);
		}
	}
}

int main(int argc, char* argv[]) {
#ifdef KANARI
	freopen("input.txt", "r", stdin);
	freopen("output.txt", "w", stdout);
#endif
	
	scanf("%d%d%d", &amp;n, &amp;m, &amp;qc);
	for (int i = 1; i &lt;= m; ++i) {
		scanf("%d%d%lld", &amp;x, &amp;y, &amp;w);
		ie[i].a = x, ie[i].b = y, ie[i].w = w;
	}
	for (int i = 1; i &lt;= qc; ++i) {
		scanf("%d", q + i);
		del[q[i]] = true;
	}
	
	for (int i = 1; i &lt;= m; ++i)
		if (!del[i]) {
			addedge(ie[i].a, ie[i].b, ie[i].w);
			addedge(ie[i].b, ie[i].a, ie[i].w);
		}
	chain[++ccnt] = 0LL;
	dfs(1);
	
	ans[qc + 1] = calc();
	for (int i = qc; i &gt; 0; --i) {
		x = ie[q[i]].a, y = ie[q[i]].b;
		addedge(x, y, ie[q[i]].w), addedge(y, x, ie[q[i]].w);
		if (vis[x] &amp;&amp; vis[y]) a[++cnt] = f[x] ^ f[y] ^ ie[q[i]].w;
		else if (vis[x]) dfs(x);
		else if (vis[y]) dfs(y);
		ans[i] = calc();
	}
	
	for (int i = 1; i &lt;= qc + 1; ++i) printf("%lld\n", ans[i]);
	
	return 0;
}</pre><pre></pre><h2>Problem2324</h2><pre>#include &lt;vector&gt;
#include &lt;queue&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
int n,m,K;
const int INF=1e8;
struct edge{
	int u,v,cap,flow,cost;
	edge(int _u,int _v,int _cap,int _flow,int _cost):
		u(_u),v(_v),cap(_cap),flow(_flow),cost(_cost){}
};
vector&lt;edge&gt;edges;
vector&lt;int&gt;G[333];
void add(int u,int v,int cap,int cost){
	edges.push_back(edge(u,v,cap,0,cost));
	G[u].push_back(edges.size()-1);
	edges.push_back(edge(v,u,0,0,-cost));
	G[v].push_back(edges.size()-1);
}
int d[333];
int f[160][160][160];
int w[160][160];
int a[333];
int p[333];
int vis[333];
int flow=0,cost=0,s,t;
bool spfa(){
	memset(d,0x7f,sizeof(d));
	memset(vis,0,sizeof(vis));
	int B=d[0];
	queue&lt;int&gt;q;
	q.push(s);
	d[s]=0;
	a[s]=INF;
	while(!q.empty()){
		int u=q.front();q.pop();vis[u]=0;
		for(int i=0;i&lt;G[u].size();i++){
			edge e=edges[G[u][i]];
			if(d[e.v]&gt;d[u]+e.cost&amp;&amp;e.cap&gt;e.flow){
				d[e.v]=d[u]+e.cost;
				p[e.v]=G[u][i];
				a[e.v]=min(a[u],e.cap-e.flow);
				if(!vis[e.v]){
					vis[e.v]=1;
					q.push(e.v);
				}
			}
		}
	}
	if(d[t]==B)return false;
	flow+=a[t];
	cost+=a[t]*d[t];
	int u=t;
	while(u!=s){
		edges[p[u]].flow+=a[t];
		edges[p[u]^1].flow-=a[t];
		u=edges[p[u]].u;
	}
	return true;
}
int main(){
	cin&gt;&gt;n&gt;&gt;m&gt;&gt;K;
	for(int i=0;i&lt;=n;i++)
		for(int j=0;j&lt;=n;j++)
			if(i==j)
				w[i][j]=0;
			else
				w[i][j]=INF;
	int u,v,W;
	for(int i=1;i&lt;=m;i++){
		cin&gt;&gt;u&gt;&gt;v&gt;&gt;W;
		if(W&lt;w[u][v]){
			w[u][v]=W;
			w[v][u]=W;
		}
	}	
	for(int k=0;k&lt;=n;k++){
		for(int i=0;i&lt;=n;i++)
			for(int j=0;j&lt;=n;j++)
				w[i][j]=min(w[i][j],w[i][k]+w[k][j]);
		for(int i=0;i&lt;=n;i++)
			for(int j=0;j&lt;=n;j++)
				f[k][i][j]=w[i][j];	
	}
	int V=0;	
	int node[160][2];
	for ( int i = 0 ; i &lt;= n ; i ++ ) 
	node[ i ][ 0 ] = ++ V , node[ i ][ 1 ] = ++ V ;  
    s = ++ V ; t = ++ V ;  
    for ( int i = 1 ; i &lt;= n ; i ++ ) add( s , node[ i ][ 0 ] , 1 , 0 ) , add( node[ i ][ 1 ] , t , 1 , 0 ) ;  
    add( s , node[ 0 ][ 0 ] , K , 0 ) ;  
    for ( int i = 0 ; i ++ &lt; n ; ) {  
        for ( int j = 0 ; j &lt; i ; j ++ ) if ( f[ i ][ j ][ i ] &lt; INF ) add( node[ j ][ 0 ] , node[ i ][ 1 ] , 1 , f[ i ][ j ][ i ] ) ;  
    }  
	while(spfa());
	cout&lt;&lt;cost&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem2328</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1e4+10;
const double eps=1e-7;
int T,n;
double vmax,a,b,f;
int dcmp(double x){
	if(fabs(x)&lt;eps)return 0;
	return x&gt;0?1:-1;
}
struct road{
	double len,s,v;
	bool operator&lt;(const road &amp;r)const{
		return v&lt;r.v;
	}
}r[maxn];
int main(){
	scanf("%d",&amp;T);
	while(T--){
		scanf("%lf%lf%lf%lf",&amp;a,&amp;b,&amp;vmax,&amp;f);
		scanf("%d",&amp;n);
		for(int i=1;i&lt;=n;i++){
			double x,y;
			scanf("%lf%lf",&amp;x,&amp;y);
			r[i].s=y/x;
			r[i].len=sqrt(x*x+y*y)/1000.0;
			if(dcmp(r[i].s)==1)f-=b*r[i].s*r[i].len;
			if(dcmp(r[i].s)==-1)r[i].v=-b*r[i].s/a;else r[i].v=0;
		}if(dcmp(f)&lt;0){
			puts("IMPOSSIBLE");continue;
		}
		sort(r+1,r+1+n);
		for(int i=1;i&lt;=n;i++)
		r[i].v=min(r[i].v,vmax);
		r[n+1].v=vmax;
		double sum=0;
		int i;
		for(i=1;i&lt;=n;i++){
			sum+=r[i].len;
			if(dcmp(r[i].v-r[i+1].v)){
				if(dcmp(f-(r[i+1].v-r[i].v)*sum*a)&gt;=0){
					f-=(r[i+1].v-r[i].v)*sum*a;
					r[i].v=r[i+1].v;
				}else{
					r[i].v+=f/(sum*a);
					break;
				}
			}
		}
		for(int j=i-1;j&gt;=1;j--)
			r[j].v=r[j+1].v;
		if(dcmp(r[1].v)==0){
			puts("IMPOSSIBLE");
			continue;
		}
		double ans=0;
		for(int i=1;i&lt;=n;i++)
		ans+=r[i].len/r[i].v;
		printf("%.5lf\n",ans);
	}	
	return 0;
}</pre><pre></pre><h2>Problem2329</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cctype&gt;
#include&lt;climits&gt;
using namespace std;
const int maxn=1e5+5;
int n,m;
char str[maxn];
inline int rnd(){
	static int KEY=12345678;
	return KEY+=KEY&lt;&lt;2|1;
}
struct node{
	int val,key,rev,lazy,all,maxl,minl,maxr,minr,size,sum;node *c[2];
	node(int _val=0,node *C=0):
		val(_val),key(rnd()),rev(0),lazy(0),all(0),maxl(0),minl(0),maxr(0),minr(0),size(1),sum(_val){c[0]=c[1]=C;}
	node *rz(){
		size=c[0]-&gt;size+1+c[1]-&gt;size;
		sum=c[0]-&gt;sum+val+c[1]-&gt;sum;
		maxl=max(c[0]-&gt;maxl,c[0]-&gt;sum+val+max(0,c[1]-&gt;maxl));
		minl=min(c[0]-&gt;minl,c[0]-&gt;sum+val+min(0,c[1]-&gt;minl));
		maxr=max(c[1]-&gt;maxr,c[1]-&gt;sum+val+max(0,c[0]-&gt;maxr));
		minr=min(c[1]-&gt;minr,c[1]-&gt;sum+val+min(0,c[0]-&gt;minr));			
		return this;
	}
	void makerev(){
		if(this-&gt;size==0)return;
		rev^=1;
		swap(c[0],c[1]);
		swap(minl,minr);
		swap(maxl,maxr);
	}
	void makelazy(){
		if(this-&gt;size==0)return;
		lazy^=1;
		if(all)
		all=-all;
		val=-val;
		sum=-sum;
		swap(maxl,minl);maxl=-maxl;minl=-minl;
		swap(maxr,minr);maxr=-maxr;minr=-minr;
	}
	void makesame(int al){
		if(this-&gt;size==0)return;
		all=al;val=al;
		maxl=maxr=size*(al==1);
		minl=minr=-size*(al==-1);	
		sum=size*al;		
	}
	void pushdown(){
		if(this-&gt;size==0)return; 
		if(rev){c[0]-&gt;makerev();c[1]-&gt;makerev();rev^=1;}
		if(lazy){c[0]-&gt;makelazy();c[1]-&gt;makelazy();lazy=0;}
		if(all){c[0]-&gt;makesame(all);c[1]-&gt;makesame(all);all=0;}
	}
	void split(int ned,node *&amp;p,node *&amp;q); 
}*Null;
node *merge(node *p,node *q){	
	p-&gt;pushdown();q-&gt;pushdown();
	if(p==Null)return q-&gt;rz();
	if(q==Null)return p-&gt;rz();
	if(p-&gt;key&lt;q-&gt;key){
		p-&gt;c[1]=merge(p-&gt;c[1],q);
		return p-&gt;rz();
	}else{
		q-&gt;c[0]=merge(p,q-&gt;c[0]);
		return q-&gt;rz();
	}
}
void node::split(int ned,node *&amp;p,node *&amp;q){
	if(this==Null){p=q=Null;return;}
	pushdown();
	if(c[0]-&gt;size&gt;=ned){
		c[0]-&gt;split(ned,p,q);
		c[0]=Null;rz();
		q=merge(q,this);
	}else{
		c[1]-&gt;split(ned-c[0]-&gt;size-1,p,q);
		c[1]=Null;rz();
		p=merge(this,p);
	}
}
node *root;
node *newnode(int val=0){
	return new node(val,Null);	
}	
node *p,*q,*r,*s,res;
void deb(node *root){  
    if(root==Null)return ;  
    printf("val:%d sum:%d size:%d all:%d rev:%d lazy:%d \n",root-&gt;val,root-&gt;sum,root-&gt;size,
			root-&gt;all,root-&gt;rev,root-&gt;lazy); 
    if(root-&gt;c[0]!=Null)printf("L:"),deb(root-&gt;c[0]);      
    if(root-&gt;c[1]!=Null)printf("R:"),deb(root-&gt;c[1]);  
} 
int main(){
	Null=newnode();Null-&gt;size=0;
	Null-&gt;val=Null-&gt;key=INT_MAX;
	root=Null;
	scanf("%d%d",&amp;n,&amp;m);
	scanf("%s",str);
	for(int i=0;i&lt;n;i++)root=merge(root,newnode(str[i]=='('?1:-1));
	while(m--){
//		deb(root);puts("");
		char op[10];
		int lef,rig;
		scanf("%s%d%d",op,&amp;lef,&amp;rig);
		root-&gt;split(lef-1,p,q);
//		deb(p);		puts("");
//		deb(q);		puts("");
		q-&gt;split(rig-lef+1,r,s);
		
//		deb(r);	puts("");	
		if(op[0]=='R'){
			char x=getchar();while(x!='('&amp;&amp;x!=')')x=getchar();
			r-&gt;makesame(x=='('?1:-1);
			r-&gt;pushdown();
		}else
		if(op[0]=='Q'){
			res=*r;
			printf("%d\n",(res.maxr+1)/2-(res.minl-1)/2);
		}else
		if(op[0]=='S'){
			r-&gt;makerev();
			r-&gt;pushdown();
		}else
		if(op[0]=='I'){
			r-&gt;makelazy();
			r-&gt;pushdown();
		}
		root=merge(p,merge(r,s));
	}
	return 0;
}</pre><pre></pre><h2>Problem2329</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cctype&gt;
#include&lt;climits&gt;
using namespace std;
const int maxn=1e5+5;
int n,m;
char str[maxn];
inline int rnd(){
	static int KEY=12345678;
	return KEY+=KEY&lt;&lt;2|1;
}
struct node{
	int val,key,rev,lazy,all,maxl,minl,maxr,minr,size,sum;node *c[2];
	node(int _val=0,node *C=0):
		val(_val),key(rnd()),rev(0),lazy(0),all(0),maxl(0),minl(0),maxr(0),minr(0),size(1),sum(_val){c[0]=c[1]=C;}
	node *rz(){
		size=c[0]-&gt;size+1+c[1]-&gt;size;
		sum=c[0]-&gt;sum+val+c[1]-&gt;sum;
		maxl=max(c[0]-&gt;maxl,c[0]-&gt;sum+val+max(0,c[1]-&gt;maxl));
		minl=min(c[0]-&gt;minl,c[0]-&gt;sum+val+min(0,c[1]-&gt;minl));
		maxr=max(c[1]-&gt;maxr,c[1]-&gt;sum+val+max(0,c[0]-&gt;maxr));
		minr=min(c[1]-&gt;minr,c[1]-&gt;sum+val+min(0,c[0]-&gt;minr));			
		return this;
	}
	void makerev(){
		if(this-&gt;size==0)return;
		rev^=1;
		swap(c[0],c[1]);
		swap(minl,minr);
		swap(maxl,maxr);
	}
	void makelazy(){
		if(this-&gt;size==0)return;
		lazy^=1;
		if(all)
		all=-all;
		val=-val;
		sum=-sum;
		swap(maxl,minl);maxl=-maxl;minl=-minl;
		swap(maxr,minr);maxr=-maxr;minr=-minr;
	}
	void makesame(int al){
		if(this-&gt;size==0)return;
		all=al;val=al;
		maxl=maxr=size*(al==1);
		minl=minr=-size*(al==-1);	
		sum=size*al;		
	}
	void pushdown(){
		if(this-&gt;size==0)return; 
		if(rev){c[0]-&gt;makerev();c[1]-&gt;makerev();rev^=1;}
		if(lazy){c[0]-&gt;makelazy();c[1]-&gt;makelazy();lazy=0;}
		if(all){c[0]-&gt;makesame(all);c[1]-&gt;makesame(all);all=0;}
	}
	void split(int ned,node *&amp;p,node *&amp;q); 
}*Null;
node *merge(node *p,node *q){	
	p-&gt;pushdown();q-&gt;pushdown();
	if(p==Null)return q-&gt;rz();
	if(q==Null)return p-&gt;rz();
	if(p-&gt;key&lt;q-&gt;key){
		p-&gt;c[1]=merge(p-&gt;c[1],q);
		return p-&gt;rz();
	}else{
		q-&gt;c[0]=merge(p,q-&gt;c[0]);
		return q-&gt;rz();
	}
}
void node::split(int ned,node *&amp;p,node *&amp;q){
	if(this==Null){p=q=Null;return;}
	pushdown();
	if(c[0]-&gt;size&gt;=ned){
		c[0]-&gt;split(ned,p,q);
		c[0]=Null;rz();
		q=merge(q,this);
	}else{
		c[1]-&gt;split(ned-c[0]-&gt;size-1,p,q);
		c[1]=Null;rz();
		p=merge(this,p);
	}
}
node *root;
node *newnode(int val=0){
	return new node(val,Null);	
}	
node *p,*q,*r,*s,res;
void deb(node *root){  
    if(root==Null)return ;  
    printf("val:%d sum:%d size:%d all:%d rev:%d lazy:%d \n",root-&gt;val,root-&gt;sum,root-&gt;size,
			root-&gt;all,root-&gt;rev,root-&gt;lazy); 
    if(root-&gt;c[0]!=Null)printf("L:"),deb(root-&gt;c[0]);      
    if(root-&gt;c[1]!=Null)printf("R:"),deb(root-&gt;c[1]);  
} 
int main(){
	Null=newnode();Null-&gt;size=0;
	Null-&gt;val=Null-&gt;key=INT_MAX;
	root=Null;
	scanf("%d%d",&amp;n,&amp;m);
	scanf("%s",str);
	for(int i=0;i&lt;n;i++)root=merge(root,newnode(str[i]=='('?1:-1));
	while(m--){
		char op[10];
		int lef,rig;
		scanf("%s%d%d",op,&amp;lef,&amp;rig);
		root-&gt;split(lef-1,p,q);
		q-&gt;split(rig-lef+1,r,s);
		if(op[0]=='R'){
			char x=getchar();while(x!='('&amp;&amp;x!=')')x=getchar();
			r-&gt;makesame(x=='('?1:-1);
		}else
		if(op[0]=='Q'){
			res=*r; 
			printf("%d\n",(res.maxr+1)/2-(res.minl-1)/2);
		}else
		if(op[0]=='S'){
			r-&gt;makerev();
		}else
		if(op[0]=='I'){
			r-&gt;makelazy();
		}
		root=merge(p,merge(r,s));
	}
	return 0;
}</pre><pre></pre><h2>Problem2329</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cctype&gt;
#include&lt;climits&gt;
using namespace std;
const int maxn=1e5+5;
int n,m;
char str[maxn];
inline int rnd(){
	static int KEY=12345678;
	return KEY+=KEY&lt;&lt;2|1;
}
struct node{
	int val,key,rev,lazy,all,maxl,minl,maxr,minr,size,sum;node *c[2];
	node(int _val=0,node *C=0):
		val(_val),key(rnd()),rev(0),lazy(0),all(0),maxl(0),minl(0),maxr(0),minr(0),size(1),sum(_val){c[0]=c[1]=C;}
	node *rz(){
		size=c[0]-&gt;size+1+c[1]-&gt;size;
		sum=c[0]-&gt;sum+val+c[1]-&gt;sum;
		maxl=max(c[0]-&gt;maxl,c[0]-&gt;sum+val+max(0,c[1]-&gt;maxl));
		minl=min(c[0]-&gt;minl,c[0]-&gt;sum+val+min(0,c[1]-&gt;minl));
		maxr=max(c[1]-&gt;maxr,c[1]-&gt;sum+val+max(0,c[0]-&gt;maxr));
		minr=min(c[1]-&gt;minr,c[1]-&gt;sum+val+min(0,c[0]-&gt;minr));			
		return this;
	}
	void makerev(){
		if(this-&gt;size==0)return;
		rev^=1;
		swap(c[0],c[1]);
		swap(minl,minr);
		swap(maxl,maxr);
	}
	void makelazy(){
		if(this-&gt;size==0)return;
		lazy^=1;
		if(all)
		all=-all;
		val=-val;
		sum=-sum;
		swap(maxl,minl);maxl=-maxl;minl=-minl;
		swap(maxr,minr);maxr=-maxr;minr=-minr;
	}
	void makesame(int al){
		if(this-&gt;size==0)return;
		all=al;val=al;
		maxl=maxr=size*(al==1);
		minl=minr=-size*(al==-1);	
		sum=size*al;		
	}
	void pushdown(){
		if(this-&gt;size==0)return; 
		if(rev){c[0]-&gt;makerev();c[1]-&gt;makerev();rev^=1;}
		if(lazy){c[0]-&gt;makelazy();c[1]-&gt;makelazy();lazy=0;}
		if(all){c[0]-&gt;makesame(all);c[1]-&gt;makesame(all);all=0;}
	}
	void split(int ned,node *&amp;p,node *&amp;q); 
}*Null;
node *merge(node *p,node *q){	
	if(p==Null)return q-&gt;rz();
	if(q==Null)return p-&gt;rz();
	p-&gt;pushdown();q-&gt;pushdown();
	if(p-&gt;key&lt;q-&gt;key){
		p-&gt;c[1]=merge(p-&gt;c[1],q);
		return p-&gt;rz();
	}else{
		q-&gt;c[0]=merge(p,q-&gt;c[0]);
		return q-&gt;rz();
	}
}
void node::split(int ned,node *&amp;p,node *&amp;q){
	if(this==Null){p=q=Null;return;}
	pushdown();
	if(c[0]-&gt;size&gt;=ned){
		c[0]-&gt;split(ned,p,q);
		c[0]=Null;rz();
		q=merge(q,this);
	}else{
		c[1]-&gt;split(ned-c[0]-&gt;size-1,p,q);
		c[1]=Null;rz();
		p=merge(this,p);
	}
}
node *root;
node *newnode(int val=0){
	return new node(val,Null);	
}	
node *p,*q,*r,*s,res;
void deb(node *root){  
    if(root==Null)return ;  
    printf("val:%d sum:%d size:%d all:%d rev:%d lazy:%d \n",root-&gt;val,root-&gt;sum,root-&gt;size,
			root-&gt;all,root-&gt;rev,root-&gt;lazy); 
    if(root-&gt;c[0]!=Null)printf("L:"),deb(root-&gt;c[0]);      
    if(root-&gt;c[1]!=Null)printf("R:"),deb(root-&gt;c[1]);  
} 
int main(){
	Null=newnode();Null-&gt;size=0;
	Null-&gt;val=Null-&gt;key=INT_MAX;
	root=Null;
	scanf("%d%d",&amp;n,&amp;m);
	scanf("%s",str);
	for(int i=0;i&lt;n;i++)root=merge(root,newnode(str[i]=='('?1:-1));
	while(m--){
		char op[10];
		int lef,rig;
		scanf("%s%d%d",op,&amp;lef,&amp;rig);
		root-&gt;split(lef-1,p,q);
		q-&gt;split(rig-lef+1,r,s);
		if(op[0]=='R'){
			char x=getchar();while(x!='('&amp;&amp;x!=')')x=getchar();
			r-&gt;makesame(x=='('?1:-1);
		}else
		if(op[0]=='Q'){
			res=*r; 
			printf("%d\n",(res.maxr+1)/2-(res.minl-1)/2);
		}else
		if(op[0]=='S'){
			r-&gt;makerev();
		}else
		if(op[0]=='I'){
			r-&gt;makelazy();
		}
		root=merge(p,merge(r,s));
	}
	return 0;
}</pre><pre></pre><h2>Problem2329</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cctype&gt;
#include&lt;climits&gt;
using namespace std;
const int maxn=1e5+5;
int n,m;
char str[maxn];
inline int rnd(){
	static int KEY=12345678;
	return (KEY+=KEY&lt;&lt;2|1)&amp;1023;
}
struct node{
	int val,rev,lazy,all,maxl,minl,maxr,minr,size,sum;node *c[2];
	node(int _val=0,node *C=0):
		val(_val),rev(0),lazy(0),all(0),maxl(0),minl(0),maxr(0),minr(0),size(1),sum(_val){c[0]=c[1]=C;}
	node *rz(){
		size=c[0]-&gt;size+1+c[1]-&gt;size;
		sum=c[0]-&gt;sum+val+c[1]-&gt;sum;
		maxl=max(c[0]-&gt;maxl,c[0]-&gt;sum+val+max(0,c[1]-&gt;maxl));
		minl=min(c[0]-&gt;minl,c[0]-&gt;sum+val+min(0,c[1]-&gt;minl));
		maxr=max(c[1]-&gt;maxr,c[1]-&gt;sum+val+max(0,c[0]-&gt;maxr));
		minr=min(c[1]-&gt;minr,c[1]-&gt;sum+val+min(0,c[0]-&gt;minr));			
		return this;
	}
	void makerev(){
		rev^=1;
		swap(c[0],c[1]);
		swap(minl,minr);
		swap(maxl,maxr);
	}
	void makelazy(){
		lazy^=1;
		if(all)
		all=-all;
		val=-val;
		sum=-sum;
		swap(maxl,minl);maxl=-maxl;minl=-minl;
		swap(maxr,minr);maxr=-maxr;minr=-minr;
	}
	void makesame(int al){
		all=al;val=al;
		maxl=maxr=size*(al==1);
		minl=minr=-size*(al==-1);	
		sum=size*al;		
	}
	void pushdown(){
		if(rev){c[0]-&gt;makerev();c[1]-&gt;makerev();rev^=1;}
		if(lazy){c[0]-&gt;makelazy();c[1]-&gt;makelazy();lazy=0;}
		if(all){c[0]-&gt;makesame(all);c[1]-&gt;makesame(all);all=0;}
	}
	void split(int ned,node *&amp;p,node *&amp;q); 
}*Null;
node *merge(node *p,node *q){	
	if(p==Null)return q-&gt;rz();
	if(q==Null)return p-&gt;rz();
	p-&gt;pushdown();q-&gt;pushdown();
	if(p-&gt;size*1023&gt;(p-&gt;size+q-&gt;size)*rnd()){
		p-&gt;c[1]=merge(p-&gt;c[1],q);
		return p-&gt;rz();
	}else{
		q-&gt;c[0]=merge(p,q-&gt;c[0]);
		return q-&gt;rz();
	}
}
void node::split(int ned,node *&amp;p,node *&amp;q){
	if(this==Null){p=q=Null;return;}
	pushdown();
	if(c[0]-&gt;size&gt;=ned){
		c[0]-&gt;split(ned,p,q);
		c[0]=Null;rz();
		q=merge(q,this);
	}else{
		c[1]-&gt;split(ned-c[0]-&gt;size-1,p,q);
		c[1]=Null;rz();
		p=merge(this,p);
	}
}
node *root;
node *newnode(int val=0){
	return new node(val,Null);	
}	
node *p,*q,*r,*s,res;
void deb(node *root){  
    if(root==Null)return ;  
    printf("val:%d sum:%d size:%d all:%d rev:%d lazy:%d \n",root-&gt;val,root-&gt;sum,root-&gt;size,
			root-&gt;all,root-&gt;rev,root-&gt;lazy); 
    if(root-&gt;c[0]!=Null)printf("L:"),deb(root-&gt;c[0]);      
    if(root-&gt;c[1]!=Null)printf("R:"),deb(root-&gt;c[1]);  
} 
int main(){
	Null=newnode();Null-&gt;size=0;
	Null-&gt;val=INT_MAX;
	root=Null;
	scanf("%d%d",&amp;n,&amp;m);
	scanf("%s",str);
	for(int i=0;i&lt;n;i++)root=merge(root,newnode(str[i]=='('?1:-1));
	while(m--){
		char op[10];
		int lef,rig;
		scanf("%s%d%d",op,&amp;lef,&amp;rig);
		root-&gt;split(lef-1,p,q);
		q-&gt;split(rig-lef+1,r,s);
		if(op[0]=='R'){
			char x=getchar();while(x!='('&amp;&amp;x!=')')x=getchar();
			r-&gt;makesame(x=='('?1:-1);
		}else
		if(op[0]=='Q'){
			res=*r; 
			printf("%d\n",(res.maxr+1)/2-(res.minl-1)/2);
		}else
		if(op[0]=='S'){
			r-&gt;makerev();
		}else
		if(op[0]=='I'){
			r-&gt;makelazy();
		}
		root=merge(p,merge(r,s));
	}
	return 0;
}</pre><pre></pre><h2>Problem2329</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cctype&gt;
#include&lt;climits&gt;
using namespace std;
const int maxn=1e5+5;
int n,m;
char str[maxn];
inline int rnd(){static int x=1;x+=(x&lt;&lt;2)+1; x&amp;=(0x7fffffff);return x&amp;(1023);}
struct node{
	int val,rev,lazy,all,maxl,minl,maxr,minr,size,sum;node *c[2];
	node(int _val=0,node *C=0):
		val(_val),rev(0),lazy(0),all(0),maxl(0),minl(0),maxr(0),minr(0),size(1),sum(_val){c[0]=c[1]=C;}
	node *rz(){
		size=c[0]-&gt;size+1+c[1]-&gt;size;
		sum=c[0]-&gt;sum+val+c[1]-&gt;sum;
		maxl=max(c[0]-&gt;maxl,c[0]-&gt;sum+val+max(0,c[1]-&gt;maxl));
		minl=min(c[0]-&gt;minl,c[0]-&gt;sum+val+min(0,c[1]-&gt;minl));
		maxr=max(c[1]-&gt;maxr,c[1]-&gt;sum+val+max(0,c[0]-&gt;maxr));
		minr=min(c[1]-&gt;minr,c[1]-&gt;sum+val+min(0,c[0]-&gt;minr));			
		return this;
	}
	void makerev(){
		rev^=1;
		swap(c[0],c[1]);
		swap(minl,minr);
		swap(maxl,maxr);
	}
	void makelazy(){
		lazy^=1;
		if(all)
		all=-all;
		val=-val;
		sum=-sum;
		swap(maxl,minl);maxl=-maxl;minl=-minl;
		swap(maxr,minr);maxr=-maxr;minr=-minr;
	}
	void makesame(int al){
		all=al;val=al;
		maxl=maxr=size*(al==1);
		minl=minr=-size*(al==-1);	
		sum=size*al;		
	}
	void pushdown(){
		if(rev){c[0]-&gt;makerev();c[1]-&gt;makerev();rev^=1;}
		if(lazy){c[0]-&gt;makelazy();c[1]-&gt;makelazy();lazy=0;}
		if(all){c[0]-&gt;makesame(all);c[1]-&gt;makesame(all);all=0;}
	}
	void split(int ned,node *&amp;p,node *&amp;q); 
}*Null;
node *merge(node *p,node *q){	
	if(p==Null)return q-&gt;rz();
	if(q==Null)return p-&gt;rz();
	p-&gt;pushdown();q-&gt;pushdown();
	if(p-&gt;size*1023&gt;(p-&gt;size+q-&gt;size)*rnd()){
		p-&gt;c[1]=merge(p-&gt;c[1],q);
		return p-&gt;rz();
	}else{
		q-&gt;c[0]=merge(p,q-&gt;c[0]);
		return q-&gt;rz();
	}
}
void node::split(int ned,node *&amp;p,node *&amp;q){
	if(this==Null){p=q=Null;return;}
	pushdown();
	if(c[0]-&gt;size&gt;=ned){
		c[0]-&gt;split(ned,p,q);
		c[0]=Null;rz();
		q=merge(q,this);
	}else{
		c[1]-&gt;split(ned-c[0]-&gt;size-1,p,q);
		c[1]=Null;rz();
		p=merge(this,p);
	}
}
node *root;
node *newnode(int val=0){
	return new node(val,Null);	
}	
node *p,*q,*r,*s,res;
void deb(node *root){  
    if(root==Null)return ;  
    printf("val:%d sum:%d size:%d all:%d rev:%d lazy:%d \n",root-&gt;val,root-&gt;sum,root-&gt;size,
			root-&gt;all,root-&gt;rev,root-&gt;lazy); 
    if(root-&gt;c[0]!=Null)printf("L:"),deb(root-&gt;c[0]);      
    if(root-&gt;c[1]!=Null)printf("R:"),deb(root-&gt;c[1]);  
} 
int main(){
	Null=newnode();Null-&gt;size=0;
	Null-&gt;val=INT_MAX;
	root=Null;
	scanf("%d%d",&amp;n,&amp;m);
	scanf("%s",str);
	for(int i=0;i&lt;n;i++)root=merge(root,newnode(str[i]=='('?1:-1));
	while(m--){
		char op[10];
		int lef,rig;
		scanf("%s%d%d",op,&amp;lef,&amp;rig);
		root-&gt;split(lef-1,p,q);
		q-&gt;split(rig-lef+1,r,s);
		if(op[0]=='R'){
			char x=getchar();while(x!='('&amp;&amp;x!=')')x=getchar();
			r-&gt;makesame(x=='('?1:-1);
		}else
		if(op[0]=='Q'){
			res=*r; 
			printf("%d\n",(res.maxr+1)/2-(res.minl-1)/2);
		}else
		if(op[0]=='S'){
			r-&gt;makerev();
		}else
		if(op[0]=='I'){
			r-&gt;makelazy();
		}
		root=merge(p,merge(r,s));
	}
	return 0;
}</pre><pre></pre><h2>Problem2329</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cctype&gt;
#include&lt;climits&gt;
using namespace std;
const int maxn=1e5+5;
int n,m;
char str[maxn];
inline int rnd(){
	static int tot=0;
	tot++;
	if(tot&amp;1)return tot;
	return INT_MAX-tot;
}
struct node{
	int val,rev,lazy,all,maxl,minl,maxr,minr,size,sum;node *c[2];
	node(int _val=0,node *C=0):
		val(_val),rev(0),lazy(0),all(0),maxl(0),minl(0),maxr(0),minr(0),size(1),sum(_val){c[0]=c[1]=C;}
	node *rz(){
		size=c[0]-&gt;size+1+c[1]-&gt;size;
		sum=c[0]-&gt;sum+val+c[1]-&gt;sum;
		maxl=max(c[0]-&gt;maxl,c[0]-&gt;sum+val+max(0,c[1]-&gt;maxl));
		minl=min(c[0]-&gt;minl,c[0]-&gt;sum+val+min(0,c[1]-&gt;minl));
		maxr=max(c[1]-&gt;maxr,c[1]-&gt;sum+val+max(0,c[0]-&gt;maxr));
		minr=min(c[1]-&gt;minr,c[1]-&gt;sum+val+min(0,c[0]-&gt;minr));			
		return this;
	}
	void makerev(){
		rev^=1;
		swap(c[0],c[1]);
		swap(minl,minr);
		swap(maxl,maxr);
	}
	void makelazy(){
		lazy^=1;
		if(all)
		all=-all;
		val=-val;
		sum=-sum;
		swap(maxl,minl);maxl=-maxl;minl=-minl;
		swap(maxr,minr);maxr=-maxr;minr=-minr;
	}
	void makesame(int al){
		all=al;val=al;
		maxl=maxr=size*(al==1);
		minl=minr=-size*(al==-1);	
		sum=size*al;		
	}
	void pushdown(){
		if(rev){c[0]-&gt;makerev();c[1]-&gt;makerev();rev^=1;}
		if(lazy){c[0]-&gt;makelazy();c[1]-&gt;makelazy();lazy=0;}
		if(all){c[0]-&gt;makesame(all);c[1]-&gt;makesame(all);all=0;}
	}
	void split(int ned,node *&amp;p,node *&amp;q); 
}*Null;
node *merge(node *p,node *q){	
	if(p==Null)return q-&gt;rz();
	if(q==Null)return p-&gt;rz();
	p-&gt;pushdown();q-&gt;pushdown();
	if(p-&gt;size*1023&gt;(p-&gt;size+q-&gt;size)*rnd()){
		p-&gt;c[1]=merge(p-&gt;c[1],q);
		return p-&gt;rz();
	}else{
		q-&gt;c[0]=merge(p,q-&gt;c[0]);
		return q-&gt;rz();
	}
}
void node::split(int ned,node *&amp;p,node *&amp;q){
	if(this==Null){p=q=Null;return;}
	pushdown();
	if(c[0]-&gt;size&gt;=ned){
		c[0]-&gt;split(ned,p,q);
		c[0]=Null;rz();
		q=merge(q,this);
	}else{
		c[1]-&gt;split(ned-c[0]-&gt;size-1,p,q);
		c[1]=Null;rz();
		p=merge(this,p);
	}
}
node *root;
node *newnode(int val=0){
	return new node(val,Null);	
}	
node *p,*q,*r,*s,res;
void deb(node *root){  
    if(root==Null)return ;  
    printf("val:%d sum:%d size:%d all:%d rev:%d lazy:%d \n",root-&gt;val,root-&gt;sum,root-&gt;size,
			root-&gt;all,root-&gt;rev,root-&gt;lazy); 
    if(root-&gt;c[0]!=Null)printf("L:"),deb(root-&gt;c[0]);      
    if(root-&gt;c[1]!=Null)printf("R:"),deb(root-&gt;c[1]);  
} 
int main(){
	Null=newnode();Null-&gt;size=0;
	Null-&gt;val=INT_MAX;
	root=Null;
	scanf("%d%d",&amp;n,&amp;m);
	scanf("%s",str);
	for(int i=0;i&lt;n;i++)root=merge(root,newnode(str[i]=='('?1:-1));
	while(m--){
		char op[10];
		int lef,rig;
		scanf("%s%d%d",op,&amp;lef,&amp;rig);
		root-&gt;split(lef-1,p,q);
		q-&gt;split(rig-lef+1,r,s);
		if(op[0]=='R'){
			char x=getchar();while(x!='('&amp;&amp;x!=')')x=getchar();
			r-&gt;makesame(x=='('?1:-1);
		}else
		if(op[0]=='Q'){
			res=*r; 
			printf("%d\n",(res.maxr+1)/2-(res.minl-1)/2);
		}else
		if(op[0]=='S'){
			r-&gt;makerev();
		}else
		if(op[0]=='I'){
			r-&gt;makelazy();
		}
		root=merge(p,merge(r,s));
	}
	return 0;
}</pre><pre></pre><h2>Problem2330</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;vector&gt;
#include&lt;climits&gt;
#include&lt;queue&gt;
#include&lt;stack&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#define V first
#define W second
using namespace std;
const int maxn=1e5+10;
typedef long long lld;
typedef pair&lt;lld,lld&gt; pii;
namespace TOPL{
	vector&lt;pii&gt;G[maxn];
	lld d[maxn];
	lld in[maxn],vis[maxn];
	void add(lld u,lld v,lld w){
		G[u].push_back(pii(v,w));
	}lld n,m;
	void init(){
		scanf("%lld%lld",&amp;n,&amp;m);
		for(lld i=1;i&lt;=m;i++){
			lld opt;scanf("%lld",&amp;opt);
			lld x,y;scanf("%lld%lld",&amp;x,&amp;y);
			switch(opt){
				case 1:{
					add(x,y,0);
					add(y,x,0);
					break;
				}
				case 2:{
					add(x,y,1);
					break;
				}
				case 3:{
					add(y,x,0);
					break;
				}
				case 4:{
					add(y,x,1);
					break;
				}
				case 5:{
					add(x,y,0);
					break;
				}
			}
		}
		for(lld i=1;i&lt;=n;i++)
				add(0,i,0);
				
	}
	lld solve(){
		init();
		queue&lt;lld&gt;q;
		memset(d,0xaf,sizeof(d));
		d[0]=1;
		q.push(0);
		while(!q.empty()){
			lld u=q.front();q.pop();vis[u]=0;
			for(lld i=0;i&lt;G[u].size();i++){
				lld v=G[u][i].V,w=G[u][i].W;
				if(d[v]&lt;d[u]+w){
					d[v]=d[u]+w;
					if(!vis[v]){
						vis[v]=1;
						q.push(v);
						in[v]++;
						if(in[v]&gt;=100){
							puts("-1");
							return 0;
						}
					}
				}
			}
		}
		lld ans=0;
		for(int i=1;i&lt;=n;i++)
			ans+=d[i];
		cout&lt;&lt;ans&lt;&lt;endl;
		return 0;
	}
}
int main(){
//	freopen("candy5.in","r",stdin);
	return TOPL::solve();	
}</pre><pre></pre><h2>Problem2331</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int mo=20110520;
int mp[101][101];
int l;
struct L{
	int d[11];
	int&amp; operator[](int x){return d[x];}
	L s(int x,int y){
		L S=*this;S[x]=y;return S;
	}
	L operator&gt;&gt;(int _){
		L S=*this;
		for(int i=l-1;i&gt;=1;i--)S[i]=S[i-1];S[0]=0;return S;
	}
	int h(){
		int an=0;
		for(int i=l-1;i&gt;=0;i--)an=an*3+d[i];return an;
	}
};
struct hashtab{
	int sz;
	int tab[177147];
	int w[177147];
	L s[177147];
	hashtab(){sz=0;memset(tab,-1,sizeof tab);}
	void cl(){
		for(int i=0;i&lt;sz;i++)tab[s[i].h()]=-1;
		sz=0;
	}
	int&amp; operator[](L S){
		int h=S.h();
		if(tab[h]==-1)tab[h]=sz,w[sz]=0,s[sz]=S,sz++;
		return w[tab[h]];
	}
}f[2];
void up(int &amp;x,int y){x+=y;if(x&gt;=mo)x-=mo;}
int n,m;
void deb(int x,int y,L S,int w){
	fprintf(stderr,"%d %d ",x,y);
	for(int i=0;i&lt;l;i++)fprintf(stderr,"%d",S[i]);
	fprintf(stderr," %d\n",w);
}
int main(){
	scanf("%d%d",&amp;n,&amp;m);
	char c=' ';
	for(int i=1;i&lt;=n;i++)
	for(int j=1;j&lt;=m;j++){
		while(c!='*'&amp;&amp;c!='_')c=getchar();
		if(n&gt;=m)
			mp[i][j]=c=='*';
		else mp[j][i]=c=='*';
		c=getchar();
	}
	if(n&lt;m)swap(n,m);l=m+1;
	int cur=0;f[cur][L()]=1;
	int ans=0;
	for(int i=1;i&lt;=n;i++){
		for(int j=1;j&lt;=m;j++){
			cur^=1;f[cur].cl();
			for(int k=0;k&lt;f[!cur].sz;k++){
				L S=f[!cur].s[k];int w=f[!cur][S];
//				deb(i,j,S,w);
				int d1=S[j-1],d2=S[j];
				if(mp[i][j]){
					if(d1==0&amp;&amp;d2==0)
					up(f[cur][S],w);
					continue;
				}
				if(d1==0&amp;&amp;d2==0){
					if(i!=n&amp;&amp;j!=m)up(f[cur][S.s(j-1,2).s(j,2)],w);
					if(i!=n)up(f[cur][S.s(j-1,1).s(j,0)],w);
					if(j!=m)up(f[cur][S.s(j-1,0).s(j,1)],w);
				}else
				if(d1==1&amp;&amp;d2==1){
					up(f[cur][S.s(j-1,0).s(j,0)],w);
				}else
				if(d1==0&amp;&amp;d2==1){
					if(i!=n)up(f[cur][S.s(j-1,1).s(j,0)],w);
					if(j!=m)up(f[cur][S.s(j-1,0).s(j,2)],w);
				}else
				if(d1==0&amp;&amp;d2==2){
					if(i!=n)up(f[cur][S.s(j-1,2).s(j,0)],w);
					up(f[cur][S.s(j-1,0).s(j,0)],w);					
				}else
				if(d1==1&amp;&amp;d2==0){
					if(j!=m)up(f[cur][S.s(j-1,0).s(j,1)],w);
					if(i!=n)up(f[cur][S.s(j-1,2).s(j,0)],w);					
				}else
				if(d1==2&amp;&amp;d2==0){
					if(j!=m)up(f[cur][S.s(j-1,0).s(j,2)],w);
					up(f[cur][S.s(j-1,0).s(j,0)],w);					
				}	
			}
		}
		cur^=1;f[cur].cl();
		for(int k=0;k&lt;f[!cur].sz;k++){
			L S=f[!cur].s[k];int w=f[!cur][S];
//			deb(i+1,0,S,w);
			f[cur][S&gt;&gt;1]=w;
		}
	}for(int i=0;i&lt;f[cur].sz;i++)
		ans=(ans+f[cur].w[i])%mo;
	cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem2337</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=105;
double a[maxn][maxn];
int n,m;
struct edge{int u,v,w;};
edge edges[int(1e4)];
double in[maxn];
double Gauss(int bit){
	memset(a,0,sizeof a);
	for(int i=1;i&lt;n;i++)a[i][i]=-in[i];
	for(int i=0;i&lt;m;i++){
		int u=edges[i].u,v=edges[i].v,w=edges[i].w;
		if(w&gt;&gt;bit&amp;1){
			a[u][n+1]+=-1;
			a[u][v]+=-1;
			if(u==v)continue;
			a[v][n+1]+=-1;
			a[v][u]+=-1;
		}else{
			a[u][v]+=1;
			if(u==v)continue;
			a[v][u]+=1;
		}
	}memset(a[n],0,sizeof a[n]);
	a[n][n]=1;
	for(int i=1;i&lt;=n;i++){
		int r=i;
		for(int j=i;j&lt;=n;j++)if(fabs(a[j][i])&gt;fabs(a[r][i]))r=j;
		for(int j=1;j&lt;=n+1;j++)swap(a[r][j],a[i][j]);
		for(int j=i+1;j&lt;=n;j++){
			double t=a[j][i]/a[i][i];
			for(int k=i;k&lt;=n+1;k++)
				a[j][k]-=t*a[i][k];
		}
	}
	for(int i=n-1;i&gt;=1;i--){
		for(int j=i+1;j&lt;=n;j++)	
			a[i][n+1]-=a[j][n+1]*a[i][j];
		a[i][n+1]/=a[i][i];
	}
	return a[1][n+1];
}
int main(){
	scanf("%d%d",&amp;n,&amp;m);
	for(int i=0;i&lt;m;i++){
		scanf("%d%d%d",&amp;edges[i].u,&amp;edges[i].v,&amp;edges[i].w);
		in[edges[i].u]++;
		if(edges[i].u!=edges[i].v)
		in[edges[i].v]++;
	}
	double ans=0;
	for(int bit=0;bit&lt;31;bit++)
		ans+=(1&lt;&lt;bit)*Gauss(bit);
	printf("%.3lf\n",ans);
	return 0;
}</pre><pre></pre><h2>Problem2338</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
const int maxn=1501;
struct point{
	LL x,y;
	point(LL _x=0,LL _y=0):x(_x),y(_y){}
	bool operator&lt;(point oth)const{return x&lt;oth.x||(x==oth.x&amp;&amp;y&lt;oth.y);}
	bool operator==(point oth)const{return x==oth.x&amp;&amp;y==oth.y;};
	point operator+(point oth)const{return point(x+oth.x,y+oth.y);}
	point operator-(point oth)const{return point(x-oth.x,y-oth.y);}
	LL operator*(point oth)const{return x*oth.y-y*oth.x;}	
}a[maxn];
LL sqr(LL x){return x*x;}
struct Line{
	LL len;
	int i,j;
	point md;
	bool operator==(Line oth)const{return len==oth.len&amp;&amp;md==oth.md;}
	bool operator&lt;(Line oth)const{if(len==oth.len)return md&lt;oth.md;return len&lt;oth.len;}
}L[maxn*maxn&gt;&gt;1];
int n,m;
LL LLabs(LL x){return x&lt;0?-x:x;}
int main(){
	scanf("%d",&amp;n);
	for(int i=1;i&lt;=n;i++)scanf("%lld%lld",&amp;a[i].x,&amp;a[i].y);
	for(int i=1;i&lt;=n;i++){
		for(int j=i+1;j&lt;=n;j++){
			m++;
			L[m].i=i;L[m].j=j;
			L[m].len=sqr(a[i].x-a[j].x)+sqr(a[i].y-a[j].y);
			L[m].md=a[i]+a[j];
		}
	}sort(L+1,L+1+m);
	LL ans=0;
	for(int i=1;i&lt;=m;i++)
	for(int j=i-1;j&amp;&amp;L[i]==L[j];j--)
	ans=max(ans,LLabs((a[L[i].i]-a[L[j].i])*(a[L[i].i]-a[L[j].j])));
	cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem2339</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
const int maxn=1e6+6;
const int mo=100000007;
int n,m;
LL f[maxn],g[maxn],fac[maxn];
LL pw(LL x,LL k,LL p){
	LL ans=1;
	for(;k;k&gt;&gt;=1){
		if(k&amp;1)ans=ans*x%p;
		x=x*x%p;
	}return ans;
}
int main(){
	cin&gt;&gt;n&gt;&gt;m;g[0]=1;
	LL two=pw(2,n,mo)-1;
	for(int i=1;i&lt;=m;i++)
		g[i]=g[i-1]*(two-i+1)%mo;
	f[1]=f[2]=0;
	for(int i=3;i&lt;=m;i++){
		f[i]=g[i-1];
		f[i]=(f[i]-f[i-1]+mo)%mo;
		f[i]=(f[i]-f[i-2]*(i-1)%mo*(two-i+2)%mo+mo)%mo;
	}LL tmp=1;for(int i=1;i&lt;=m;i++)tmp=tmp*i%mo;
	cout&lt;&lt;f[m]*pw(tmp,mo-2,mo)%mo&lt;&lt;endl;
	return 0;
}
</pre><pre></pre><h2>Problem2346</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=510*510+510;
struct edge{int u,v,w;};
vector&lt;edge&gt;G[maxn];
void add(int u,int v,int w){
	G[u].push_back((edge){u,v,w});
	G[v].push_back((edge){v,u,w});
}
typedef pair&lt;int,int&gt; pii;
priority_queue&lt;pii,vector&lt;pii&gt;,greater&lt;pii&gt; &gt;q;\
int d[maxn],vis[maxn];
int s,t,n,m;
void dijk(){
	fill(d+1,d+1+t,INT_MAX&gt;&gt;1);
	q.push(pii(d[s],s));
	while(!q.empty()){
		int u=q.top().second;q.pop();
		if(vis[u])continue;
		for(int i=0;i&lt;G[u].size();i++){
			int v=G[u][i].v,w=G[u][i].w;
			if(d[v]&gt;d[u]+w){
				d[v]=d[u]+w;
				q.push(pii(d[v],v));
			}
		}
		vis[u]=1;
	}
	if(d[t]==INT_MAX/2)puts("NO SOLUTION");
	else printf("%d\n",d[t]);
}
void deb(){
	for(int i=0;i&lt;=n*(m-1);i++)
	for(int j=0;j&lt;G[i].size();j++)
	printf("%d -&gt; %d w:%d\n",G[i][j].u,G[i][j].v,G[i][j].w);
}
int main(){
	scanf("%d%d",&amp;n,&amp;m);
	s=0;t=n*(m+1)+m;m++;
	for(int i=1;i&lt;=n;i++){
		char str[510];
		scanf("%s",str+1);
		for(int j=1;j&lt;m;j++)
		if(str[j]=='/'){
			add((i-1)*m+j,i*m+j-1,0);
			add((i-1)*m+j-1,i*m+j,1);
		}else{
			add((i-1)*m+j,i*m+j-1,1);
			add((i-1)*m+j-1,i*m+j,0);
		}
	}//deb();
	dijk();
	return 0;
}</pre><pre></pre><h2>Problem2346</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=510*510+510;
struct edge{int u,v,w;};
vector&lt;edge&gt;G[maxn];
void add(int u,int v,int w){
	G[u].push_back((edge){u,v,w});
	G[v].push_back((edge){v,u,w});
}
typedef pair&lt;int,int&gt; pii;
priority_queue&lt;pii,vector&lt;pii&gt;,greater&lt;pii&gt; &gt;q;\
int d[maxn],vis[maxn];
int s,t,n,m;
void dijk(){
	fill(d+1,d+1+t,INT_MAX&gt;&gt;1);
	q.push(pii(d[s],s));
	while(!q.empty()){
		int u=q.top().second;q.pop();
		if(vis[u])continue;
		for(int i=0;i&lt;G[u].size();i++){
			int v=G[u][i].v,w=G[u][i].w;
			if(d[v]&gt;d[u]+w){
				d[v]=d[u]+w;
				q.push(pii(d[v],v));
			}
		}
		vis[u]=1;
	}
	if(d[t]==INT_MAX/2)puts("NO SOLUTION");
	else printf("%d\n",d[t]);
}
void deb(){
	for(int i=0;i&lt;=n*(m-1);i++)
	for(int j=0;j&lt;G[i].size();j++)
	printf("%d -&gt; %d w:%d\n",G[i][j].u,G[i][j].v,G[i][j].w);
}
int main(){
	scanf("%d%d",&amp;n,&amp;m);
	s=0;t=n*(m+1)+m;m++;
	for(int i=1;i&lt;=n;i++){
		char str[510];
		scanf("%s",str+1);
		for(int j=1;j&lt;m;j++)
		if(str[j]=='\\'){
			add((i-1)*m+j,i*m+j-1,1);
			add((i-1)*m+j-1,i*m+j,0);
		}else{
			add((i-1)*m+j,i*m+j-1,0);
			add((i-1)*m+j-1,i*m+j,1);
		}
	}//deb();
	dijk();
	return 0;
}</pre><pre></pre><h2>Problem2348</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1e5+5;
int a[maxn];
int n;
int main(){
	scanf("%d",&amp;n);
	for(int i=1;i&lt;=n;i++)scanf("%d",&amp;a[i]);
	sort(a+1,a+1+n);
	long long ans=0;
	for(int i=1;i&lt;=n;i++){
		int l=1,r=i;
		while(l&lt;r){
			int mid=(l+r)&gt;&gt;1;
			if(a[mid]*10&gt;=a[i]*9)
				r=mid;
			else l=mid+1;
		}ans+=i-l;
	}cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem2351</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef unsigned int uint;
const int maxn=1001;
uint hashp[maxn],hashq[maxn],hash[maxn][maxn],p=97,q=233;
int n,m,A,B;
char s[maxn];
uint val[maxn*maxn];
int size,a[maxn][maxn];
uint get(int x1,int y1,int x2,int y2){
	uint ans=hash[x2][y2];
	ans-=hash[x2][y1-1]*hashq[y2-y1+1];
	ans-=hash[x1-1][y2]*hashp[x2-x1+1];
	ans+=hash[x1-1][y1-1]*hashq[y2-y1+1]*hashp[x2-x1+1];
	return ans;
}
//uint _hash[maxn][maxn];
int main(){
	scanf("%d%d%d%d",&amp;n,&amp;m,&amp;A,&amp;B);
	for(int i=1;i&lt;=n;i++){
		scanf("%s",s+1);
		for(int j=1;j&lt;=m;j++)
		a[i][j]=s[j]=='1';
	}
	hashp[0]=hashq[0]=1;
	for(int i=1;i&lt;=m;i++)hashq[i]=hashq[i-1]*q;
	for(int i=1;i&lt;=n;i++)hashp[i]=hashp[i-1]*p;
	for(int i=1;i&lt;=n;i++)
	for(int j=1;j&lt;=m;j++)
	hash[i][j]=q*hash[i][j-1]+p*hash[i-1][j]-hash[i-1][j-1]*p*q+a[i][j];
	for(int i=1;i+A-1&lt;=n;i++)
	for(int j=1;j+B-1&lt;=m;j++)
	val[size++]=get(i,j,i+A-1,j+B-1);
	sort(val,val+size);
	int Q;scanf("%d",&amp;Q);
	while(Q--){
		uint v=0;
		for(int i=1;i&lt;=A;i++){
			scanf("%s",s+1);
			v=v*p;uint vv=0;
			for(int j=1;j&lt;=B;j++)
			vv=vv*q+s[j]-'0';
			v+=vv;
			//_hash[i][j]=q*_hash[i][j-1]+p*_hash[i-1][j]-_hash[i-1][j-1]*p*q+s[j]-'0';
		}
		if(binary_search(val,val+size,v))puts("1");else puts("0");
	}
	return 0;
}</pre><pre></pre><h2>Problem2375</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1e7+2;
int n,m,p,q;
int fa[maxn];
int find(int x){return fa[x]==x?x:find(fa[x]);}
void merge(int x,int y){fa[find(x)]=find(y);}
int col[maxn];
int main(){
	cin&gt;&gt;n&gt;&gt;m&gt;&gt;p&gt;&gt;q;
	for(int i=1;i&lt;=n+1;i++)fa[i]=i;
	for(int i=m;i&gt;=1;i--){
		int l=(i*p+q)%n+1;
		int r=(i*q+p)%n+1;
		if(l&gt;r)swap(l,r);
		int j=find(l);
		for(;j&lt;=r;){
			col[j]=i;
			merge(j,r+1);
			j=find(j+1);
		}
	}for(int i=1;i&lt;=n;i++)printf("%d\n",col[i]);
	return 0;
}</pre><pre></pre><h2>Problem2393</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
const int maxn=1&lt;&lt;11;
LL L,R;
LL ans=0;
LL a[maxn],b[maxn];
void dfs1(int x,LL y){
	if(y&gt;R)return;
	if(x&gt;0)a[++a[0]]=y;
	dfs1(x+1,y*10+2);
	dfs1(x+1,y*10+9);
}
LL lcm(LL a,LL b){return a*b/__gcd(a,b);}
double dcm(LL a,LL b){return double(a)*b/__gcd(a,b);}
void dfs(int x,LL l,int cur){
	if(x&gt;b[0]){
		if(cur)ans+=(R/l-(L-1)/l)*(cur%2?1:-1);
		return;
	}
	dfs(x+1,l,cur);
	if(dcm(l,b[x])&lt;=R&amp;&amp;lcm(l,b[x])&lt;=R)
		dfs(x+1,lcm(l,b[x]),cur+1);
}
int main(){
	cin&gt;&gt;L&gt;&gt;R;
	dfs1(0,0);
	sort(a+1,a+1+a[0]);
	static int vis[maxn];
	for(int i=1;i&lt;=a[0];i++)if(!vis[i]){
		b[++b[0]]=a[i];
		for(int j=i+1;j&lt;=a[0];j++)if(a[j]%a[i]==0)
			vis[j]=1;
	}reverse(b+1,b+1+b[0]);
	dfs(1,1,0);
	cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem2395</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
struct edge{
	int u,v,w,c,t;
	bool operator&lt;(const edge &amp;E)const{
		return w&lt;E.w;
	}
};
struct Point{
	int x,y;
}ans=(Point){1e9,1e9};
Point minc,mint;
edge edges[10010];
int fa[201];
int find(int x){
	return fa[x]!=x?fa[x]=find(fa[x]):x;
}
int n,m;
Point Mst(){
	Point p=(Point){0,0};
	sort(edges+1,edges+1+m);
	for(int i=1;i&lt;=n;i++)fa[i]=i;
	for(int i=1;i&lt;=m;i++){
		int fx=find(edges[i].u),fy=find(edges[i].v);
		if(fx!=fy){
			fa[fx]=fy;
			p.x+=edges[i].c;
			p.y+=edges[i].t;
		}
	}
	if((LL)ans.x*ans.y==(LL)p.x*p.y&amp;&amp;ans.x&gt;p.x)ans=p;
	if((LL)ans.x*ans.y&gt;(LL)p.x*p.y)ans=p;
	return p;
}
LL Cross(Point x,Point y,Point z)
{
	return((LL)(x.x-z.x)*(y.y-z.y)-(LL)(x.y-z.y)*(y.x-z.x));
}
void solve(Point minc,Point mint)
{
	LL c=mint.x-minc.x,t=minc.y-mint.y;
	for (int i=1;i&lt;=m;i++) edges[i].w=edges[i].c*t+edges[i].t*c;
	Point p=Mst();
	if (Cross(p,minc,mint)&gt;=0) return;
	solve(minc,p);
	solve(p,mint);
}
int main(){
	scanf("%d%d",&amp;n,&amp;m);
	for(int i=1;i&lt;=m;i++)
		scanf("%d%d%d%d",&amp;edges[i].u,&amp;edges[i].v,&amp;edges[i].c,&amp;edges[i].t),
		edges[i].u++,edges[i].v++;
	for(int i=1;i&lt;=m;i++)edges[i].w=edges[i].c;
	minc=Mst();
	for(int i=1;i&lt;=m;i++)edges[i].w=edges[i].t;
	mint=Mst();
	solve(minc,mint);
	printf("%d %d\n",ans.x,ans.y);
	return 0;
}</pre><pre></pre><h2>Problem2396</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
int A[1001][1001];
int B[1001][1001];
int C[1001][1001];
int E[1001];
int X[1001],Y[1001],Z[1001];
int n;
int getint(){
	int res=0;char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))res=res*10+c-'0',c=getchar();
	return res;
}
int main(){
	srand(10086);
	while(~scanf("%d",&amp;n)){
		for(int i=1;i&lt;=n;i++)for(int j=1;j&lt;=n;j++)A[i][j]=getint();
		for(int i=1;i&lt;=n;i++)for(int j=1;j&lt;=n;j++)B[i][j]=getint();
		for(int i=1;i&lt;=n;i++)for(int j=1;j&lt;=n;j++)C[i][j]=getint();	
		for(int i=1;i&lt;=n;i++)E[i]=rand()%1000;
		memset(X,0,sizeof X);memset(Y,0,sizeof Y);
		for(int k=1;k&lt;=n;k++)for(int i=1;i&lt;=n;i++)X[i]+=C[i][k]*E[k];
		for(int k=1;k&lt;=n;k++)for(int i=1;i&lt;=n;i++)Y[i]+=B[i][k]*E[k];
		for(int k=1;k&lt;=n;k++)for(int i=1;i&lt;=n;i++)Z[i]+=A[i][k]*Y[k];
		if(vector&lt;int&gt;(X+1,X+1+1000)==vector&lt;int&gt;(Z+1,Z+1+1000))
			puts("Yes");
		else puts("No");
	}
	return 0;
}</pre><pre></pre><h2>Problem2408</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=10010;
int n,m;
int a[maxn],b[maxn],nxt[maxn];
deque&lt;int&gt;dq[10];
int main(){
	scanf("%d%d",&amp;n,&amp;m);
	for(int i=1;i&lt;=n;i++)scanf("%d",&amp;b[i]),a[i]=b[i];
	sort(a+1,a+1+n);
	for(int i=1;i&lt;=n;i++)dq[a[i]].push_back(i);
	for(int i=1;i&lt;=n;i++)nxt[i]=dq[b[i]].front(),dq[b[i]].pop_front();
	vector&lt;int&gt;anss;
	for(int i=1,j=1;i&lt;=n;i++,j=nxt[j])
		anss.push_back(b[j]);
	reverse(anss.begin(),anss.end());
	for(int i=0;i&lt;anss.size();i++)printf("%d%c",anss[i]," \n"[i+1==anss.size()]);
	return 0;
}</pre><pre></pre><h2>Problem2422</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=2e5+10;
int n,m,l,r;
int x[maxn&lt;&lt;1];
int a[maxn],b[maxn];
int sum[maxn&lt;&lt;1],s[maxn&lt;&lt;1];
int main(){
	scanf("%d%d",&amp;n,&amp;m);
	for(int i=1;i&lt;=n;i++){
		scanf("%d%d",&amp;a[i],&amp;b[i]);b[i]+=a[i]-1;
		x[++x[0]]=a[i];x[++x[0]]=b[i];
	}sort(x+1,x+1+x[0]);
	x[0]=unique(x+1,x+1+x[0])-x-1;
	for(int i=1;i&lt;=n;i++){
		l=lower_bound(x+1,x+1+x[0],a[i])-x;
		r=upper_bound(x+1,x+1+x[0],b[i])-x;
		sum[l]++;sum[r]--;s[l]++;
	}for(int i=1;i&lt;=x[0]+1;i++)sum[i]+=sum[i-1],s[i]+=s[i-1];
	while(m--){
		scanf("%d%d",&amp;l,&amp;r);r+=l-1;
		l=lower_bound(x+1,x+1+x[0],l)-x;
		r=upper_bound(x+1,x+1+x[0],r)-x;
		printf("%d\n",sum[l]+s[r-1]-s[l]);
	}
	return 0;
}</pre><pre></pre><h2>Problem2424</h2><pre>/*
	ID:zky
	OJ:BZOJ
	Index:2424
	Language:C++
*/
#include&lt;vector&gt;
#include&lt;queue&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;climits&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
const int INF=INT_MAX;
struct edge{
	int u,v,cap,flow,cost;
};
vector&lt;edge&gt;edges;
vector&lt;vector&lt;int&gt; &gt;G;
void add(int u,int v,int cap,int cost){
	edges.push_back((edge){u,v,cap,0,cost});
	G[u].push_back(edges.size()-1);
	edges.push_back((edge){v,u,0,0,-cost});
	G[v].push_back(edges.size()-1);	
}
int a[111];
int p[111];
int d[111];
int flow=0;
int cost=0;
int n,m,s,t,S;
int u[101];
int vis[111];
bool spfa(){
	queue&lt;int&gt;q;
	q.push(s);
	memset(d,0x7f,sizeof(d));
	int B=d[0];
	memset(vis,0,sizeof(vis));
	memset(a,0,sizeof(a));
	a[s]=INF;
	d[s]=0;
	vis[s]=1;
	while(!q.empty()){
		int u=q.front();q.pop();vis[u]=0;
		for(int i=0;i&lt;G[u].size();i++){
			edge e=edges[G[u][i]];
			if(e.cap&gt;e.flow&amp;&amp;d[e.v]&gt;d[u]+e.cost){
				d[e.v]=d[u]+e.cost;
				a[e.v]=min(a[u],e.cap-e.flow);
				p[e.v]=G[u][i];
				if(!vis[e.v]){
					vis[e.v]=1;
					q.push(e.v);
				}
			}
		}
	}
	if(B==d[t])return false;
	flow+=a[t];
	cost+=a[t]*d[t];
	int u=t;
	while(u!=s){
		edges[p[u]].flow+=a[t];
		edges[p[u]^1].flow-=a[t];
		u=edges[p[u]].u;
	}
	return true;
}
int main(){
	cin&gt;&gt;n&gt;&gt;m&gt;&gt;S;
	G.resize(n+2);
	for(int i=1;i&lt;=n;i++)
	cin&gt;&gt;u[i];
	for(int i=1;i&lt;=n;i++)
	cin&gt;&gt;d[i];
	s=0;t=n+1;
	for(int i=1;i&lt;=n;i++){
		add(s,i,INF,d[i]);
		add(i,t,u[i],0);
		if(i!=n)
		add(i,i+1,S,m);
	}
	while(spfa());
	cout&lt;&lt;cost&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem2428</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
//const int maxn=1e5+5;
int n,m;
double a[21],xbar;
double b[21];
double sqr(double x){return x*x;}
double calc(){
	double ans=0;	
	for(int i=1;i&lt;=m;i++)
		ans+=sqr(b[i]-xbar);
	ans/=m;
	return sqrt(ans);
}
double ans=1e10;
int main(){
	srand(10086);
	cin&gt;&gt;n&gt;&gt;m;
	for(int i=1;i&lt;=n;i++)cin&gt;&gt;a[i],xbar+=a[i];
	xbar/=m;
	int T=5e5;
	while(T--){
		random_shuffle(a+1,a+1+n);
		for(int i=1;i&lt;=m;i++)b[i]=a[i];
		for(int i=m+1;i&lt;=n;i++)b[min_element(b+1,b+1+m)-b]+=a[i];
		ans=min(ans,calc());
	}printf("%.2lf\n",ans);
	return 0;
}</pre><pre></pre><h2>Problem2429</h2><pre>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
inline int read()
{
    int x=0,f=1;char ch=getchar();
    while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=x*10+ch-'0';ch=getchar();}
    return f*x;
}
int n,m,cnt,tot,mx,ans;
int a[505],x[1005],y[1005],fa[1005];
struct data{int x,y,v;}e[500005];
int find(int x){return x==fa[x]?x:fa[x]=find(fa[x]);}
inline bool cmp(data a,data b){return a.v&lt;b.v;}
int main()
{
	n=read();
	for(int i=1;i&lt;=n;i++)
	    a[i]=read();
	m=read();
	for(int i=1;i&lt;=m;i++)
	    fa[i]=i,x[i]=read(),y[i]=read();
	for(int i=1;i&lt;=m;i++)
	    for(int j=i+1;j&lt;=m;j++)
	    {
	    	e[++cnt].x=i;e[cnt].y=j;
	    	e[cnt].v=(x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]);
	    }
	sort(e+1,e+cnt+1,cmp);
	for(int i=1;i&lt;=cnt;i++)
	{
		int p=find(e[i].x),q=find(e[i].y);
		if(p!=q)
		{
			fa[p]=fa[q];
			tot++;
			if(tot==m-1){mx=e[i].v;break;}
		}
	}
	for(int i=1;i&lt;=n;i++)
	    if(a[i]*a[i]&gt;=mx)ans++;
	printf("%d",ans);
	return 0;
}</pre><pre></pre><h2>Problem2434</h2><pre>#include&lt;bits/stdc++.h&gt;
#define idx(c) (c-'a')
#define lowbit(x) (x&amp;-x)
using namespace std;
const int maxn=1e5+5;
typedef pair&lt;int,int&gt; pi;
vector&lt;int&gt;d,lef,rig;
vector&lt;pi&gt;Q[maxn];
char s[maxn];
int n,m,len,anss[maxn],tot,mp[maxn],vmp[maxn];
struct node{
	int val,id;
	node *go[26],*fail,*last,*pre;
	vector&lt;node*&gt;son;
	node(node *C=0){
		for(int i=0;i&lt;26;i++)go[i]=C;
		fail=last=C;pre=C;id=0;val=0;
	}
}*Null,*root;
int cnt=0;
node *newnode(){
	node *x=new node(Null);
	x-&gt;id=++cnt;return x;
}
void build(){
	Null=newnode();Null-&gt;fail=Null-&gt;last=Null;
	for(int i=0;i&lt;26;i++)Null-&gt;go[i]=Null;
	root=Null;
	node *u=root;
	for(int i=0;i&lt;len;i++){
		if(s[i]=='B'){u=u-&gt;pre;continue;}
		if(s[i]=='P'){++n;mp[n]=u-&gt;val?mp[u-&gt;val]:n;u-&gt;val=u-&gt;val?u-&gt;val:n;vmp[u-&gt;val]=u-&gt;id;continue;}
		int v=idx(s[i]);
		if(u-&gt;go[v]==Null)u-&gt;go[v]=newnode();
		u-&gt;go[v]-&gt;pre=u;u=u-&gt;go[v];
	}	
}
void get_fail(){
	queue&lt;node*&gt;q;
	for(int i=0;i&lt;26;i++)if(root-&gt;go[i]!=Null)
	q.push(root-&gt;go[i]),root-&gt;son.push_back(root-&gt;go[i]);
	while(!q.empty()){
		node *u=q.front(),*v;q.pop();
		for(int i=0;i&lt;26;i++)if((v=u-&gt;go[i])!=Null){
			q.push(v);node *j=u-&gt;fail;
			while(j!=Null&amp;&amp;j-&gt;go[i]==Null)j=j-&gt;fail;
			v-&gt;fail=j-&gt;go[i];j-&gt;go[i]-&gt;son.push_back(v);
			v-&gt;last=v-&gt;fail-&gt;val?v-&gt;fail:v-&gt;last;
		}
	}
}
void deb(){
	queue&lt;node*&gt;q;q.push(root);
	while(!q.empty()){
		node *u=q.front(),*v;q.pop();
		printf("val:%d id:%d fail:%d\n",u-&gt;val,u-&gt;id,u-&gt;fail-&gt;id);
		for(int i=0;i&lt;26;++i)if((v=u-&gt;go[i])!=Null){
			q.push(v);
			printf("%d-&gt;%d %c\n",u-&gt;id,v-&gt;id,i+'a');
		}
	}
}
void deb(vector&lt;int&gt;v){
	ostream_iterator&lt;int&gt;out(cout," ");
	copy(v.begin(),v.end(),out);puts("");
}
int get(int x){
	int ans=0;
	while(x)ans+=d[x],x-=lowbit(x);
	return ans;
}
void updata(int x,int f){
	while(x&lt;d.size())d[x]+=f,x+=lowbit(x);
}
void _dfs(node *u){
	lef[u-&gt;id]=++tot;
	for(int i=0;i&lt;u-&gt;son.size();i++)
		_dfs(u-&gt;son[i]);
	rig[u-&gt;id]=tot;	
}
void dfs(node *u){
	updata(lef[u-&gt;id],1);
	for(int i=0;i&lt;Q[u-&gt;val].size();i++)
	anss[Q[u-&gt;val][i].second]=get(rig[vmp[Q[u-&gt;val][i].first]])-get(lef[vmp[Q[u-&gt;val][i].first]]-1);
	for(int i=0;i&lt;26;i++)if(u-&gt;go[i]!=Null)
	dfs(u-&gt;go[i]);
	updata(lef[u-&gt;id],-1);
}
int main(){
	scanf("%s",s);len=strlen(s);
	build();get_fail();
//	deb();
	d.resize(cnt+1);
	lef.resize(cnt+1);
	rig.resize(cnt+1);
	_dfs(root);
//	deb(lef);
//	deb(rig);
	scanf("%d",&amp;m);
	for(int i=1;i&lt;=m;i++){
		int x,y;scanf("%d%d",&amp;x,&amp;y);
		Q[mp[y]].push_back(make_pair(mp[x],i));
	}dfs(root);
	for(int i=1;i&lt;=m;i++)printf("%d\n",anss[i]);
	return 0;
}</pre><pre></pre><h2>Problem2435</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1e6+5;
struct edge{int v,w;};
vector&lt;edge&gt;G[maxn];
typedef long long LL;
LL sum=0,ans=0;
int size[maxn],vis[maxn],n;
void dfs(int u){
	size[u]=1;edge e;
	for(int i=0;i&lt;G[u].size();i++)
	if(!vis[(e=G[u][i]).v]){
		vis[e.v]=1;
		dfs(e.v);
		size[u]+=size[e.v];
		ans+=(LL)abs(n-size[e.v]-size[e.v])*e.w;
	}
}
int getint(){
	int res=0;char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))res=res*10+c-'0',c=getchar();
	return res;
}
int main(){
	scanf("%d",&amp;n);
	for(int i=1;i&lt;n;i++){
		int u=getint(),v=getint(),w=getint();
		G[u].push_back((edge){v,w});
		G[v].push_back((edge){u,w});
	}vis[1]=1;dfs(1);
	cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem2440</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
using namespace std;
const int maxn=1e5+10;
typedef long long lld;
lld u[maxn],prime[maxn];
lld T;
bool ok[maxn];
void getmu(){
	u[1]=1;
	for(int i=2;i&lt;maxn;i++){
		if(!ok[i]){
			prime[++prime[0]]=i;
			u[i]=-1;
		}
		for(int j=1;j&lt;=prime[0];j++){
			if(i*prime[j]&gt;=maxn)break;
			ok[i*prime[j]]=1;
			if(i%prime[j])
				u[i*prime[j]]=-u[i];
			else{
				u[i*prime[j]]=0;
				break;
			}
		}
	}
}
lld calc(lld x){
	lld sum=0,sq=sqrt(x);
	for(int i=1;i&lt;=sq;i++)
		sum+=u[i]*(x/(i*i));
	return sum;
}
lld work(lld x){
	lld l=0,r=x*2;
	while(l&lt;r){
		lld mid=(l+r)&gt;&gt;1;
		if(calc(mid)&gt;=x)
			r=mid;
		else
			l=mid+1;
	}return l;
}
int main(){
	scanf("%lld",&amp;T);
	getmu();
	while(T--){
		lld x;scanf("%lld",&amp;x);
		printf("%lld\n",work(x));
	}
	return 0;
}</pre><pre></pre><h2>Problem2447</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=50010;
vector&lt;int&gt;G[maxn];
int n,m;
int w[maxn],sum[maxn],sums[maxn],fa[maxn],dep[maxn],mx[maxn],mxx[maxn];
void dfs(int u){
	sum[u]=w[u];
	for(int i=0,v;i&lt;G[u].size();i++){
		if((v=G[u][i])==fa[u])continue;
		dep[v]=dep[u]+1;
		fa[v]=u;dfs(v);
		sum[u]+=sum[v];
		sums[u]+=sums[v]+sum[v];
		if(sum[v]&gt;sum[mx[u]])mxx[u]=mx[u],mx[u]=v;
		else if(sum[v]&gt;sum[mxx[u]])mxx[u]=v;
	}
}
int ans=INT_MAX,res;
void Move(int t,int u,int S){
	for(;;){
		int v=mx[t]!=u?mx[t]:mxx[t];
		if(!v||v==u||sum[v]*2-S&lt;=0)break;
		res-=sum[v]*2-S;t=v;
	}
}
int solve(int u){
	for(int i=fa[u];i;i=fa[i])sum[i]-=sum[u];
	res=sums[1]-sum[u]*dep[u];
	Move(1,u,sum[1]);
	Move(u,u,sum[u]);
	ans=min(ans,res);
	for(int i=fa[u];i;i=fa[i])sum[i]+=sum[u];
}
int main(){
	scanf("%d",&amp;n);
	for(int i=1;i&lt;n;i++){
		int u,v;scanf("%d%d",&amp;u,&amp;v);
		G[u].push_back(v);
		G[v].push_back(u);
	}for(int i=1;i&lt;=n;i++)scanf("%d",&amp;w[i]);
	dfs(1);
	for(int i=2;i&lt;=n;i++)
	solve(i);
	cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem2453</h2><pre>#include&lt;bits/stdc++.h&gt;
#define rnd() ((rand()&lt;&lt;16)|rand())
using namespace std;
const int maxn=1e5+10;
map&lt;int,int&gt;M,mp;
set&lt;int&gt;S[maxn&lt;&lt;1];
int pre[maxn],nxt[maxn],n,m,a[maxn];
struct Treap{
	struct node;
	node *root,*Null;
	struct node{
		int val,key,size,s;
		node *c[2];
		void set(int _val,node *C){
			val=_val;key=rnd();c[0]=c[1]=C;
			size=s=1;
		}
		node *rz(){
			size=c[0]-&gt;size+c[1]-&gt;size+s;
			return this;
		}
	};
	Treap(){
		Null=new node();
		Null-&gt;set(INT_MIN,Null);Null-&gt;key=INT_MAX;
		Null-&gt;size=Null-&gt;s=0;
		root=Null;
	}
	void rot(node *&amp;t,bool d){
		node *p=t-&gt;c[d];t-&gt;c[d]=p-&gt;c[!d];
		p-&gt;c[!d]=t;t-&gt;rz();p-&gt;rz();t=p;
	}
	void _insert(node *&amp;t,int x){
		if(t==Null){
			t=new node();
			t-&gt;set(x,Null);
			return;
		}if(t-&gt;val==x){
			t-&gt;size++;t-&gt;s++;return;
		}
		_insert(t-&gt;c[x&gt;t-&gt;val],x);
		if(t-&gt;c[x&gt;t-&gt;val]-&gt;key&lt;t-&gt;key)
		rot(t,x&gt;t-&gt;val);else t-&gt;rz();
	}
	void _del(node *&amp;t,int x){
		if(t==Null)return;
		if(t-&gt;val==x){
			if(t-&gt;s&gt;1){
				t-&gt;size--;
				t-&gt;s--;
				return;
			}
			bool d=t-&gt;c[0]-&gt;key&gt;t-&gt;c[1]-&gt;key;
			if(t-&gt;c[d]==Null){
				delete t;
				t=Null;
				return;
			}rot(t,d);
			_del(t-&gt;c[!d],x);	
		}else _del(t-&gt;c[x&gt;t-&gt;val],x);
		t-&gt;rz();
	}
	int _rank(node *t,int x){
		if(t==Null)return 0;
		int r=t-&gt;c[0]-&gt;size;
		if(t-&gt;val&gt;x)return _rank(t-&gt;c[0],x);
		if(t-&gt;val==x)return r;
		if(t-&gt;val&lt;x)return r+t-&gt;s+_rank(t-&gt;c[1],x);
	}
	int size(){return root-&gt;size;}
	void insert(int x){return _insert(root,x);}
	void del(int x){return _del(root,x);}
	int rank(int x){return _rank(root,x);}
};
struct seg_tree{
	Treap t[maxn&lt;&lt;2];
	#define lson i&lt;&lt;1,l,mid
	#define rson i&lt;&lt;1|1,mid+1,r
	#define L i&lt;&lt;1
	#define R i&lt;&lt;1|1
	void build(int i,int l,int r){
		for(int o=l;o&lt;=r;o++)
		t[i].insert(pre[o]);
		if(l==r)return;
		int mid=(l+r)&gt;&gt;1;
		build(lson);build(rson);
	}
	void Change(int i,int l,int r,int pos,int val,int x){
		t[i].del(val);
		t[i].insert(x);
		if(l==r)return;
		int mid=(l+r)&gt;&gt;1;
		if(pos&lt;=mid)Change(lson,pos,val,x);
		else Change(rson,pos,val,x);
	}
	int Query(int i,int l,int r,int l0,int r0){
		if(l0&lt;=l&amp;&amp;r0&gt;=r){
			int deb=t[i].rank(l0);
			return deb;
		}
		int mid=(l+r)&gt;&gt;1,ans=0;
		if(l0&lt;=mid)ans+=Query(lson,l0,r0);
		if(r0&gt;mid)ans+=Query(rson,l0,r0);
		return ans;
	}
	#undef R
}T;
int tot=0;
void Q(int l,int r){
	printf("%d\n",T.Query(1,1,n,l,r));
}
void R(int pos,int val){
	if(!mp[val])mp[val]=++tot,S[tot].insert(0);
	int x=mp[val],y=mp[a[pos]];
	a[pos]=val;
	set&lt;int&gt;::iterator it1,it2;
	it1=--S[y].lower_bound(pos);
	it2=S[y].upper_bound(pos);
	if(it2!=S[y].end()){
		T.Change(1,1,n,*it2,pre[*it2],*it1);
		pre[*it2]=*it1;	
	}
	
	S[y].erase(pos);
	
	S[x].insert(pos);
	it1=--S[x].lower_bound(pos);
	it2=S[x].upper_bound(pos);
	T.Change(1,1,n,pos,pre[pos],*it1);
	pre[pos]=*it1;		
	if(it2!=S[x].end()){	
		T.Change(1,1,n,*it2,pre[*it2],pos);
		pre[*it2]=pos;
	}

	
}
int main(){
	srand(10086);
	scanf("%d%d",&amp;n,&amp;m);
	for(int i=1;i&lt;=n;i++)scanf("%d",&amp;a[i]);
	for(int i=1;i&lt;=n;i++){
		if(!mp[a[i]])mp[a[i]]=++tot,S[tot].insert(0);
		pre[i]=M[a[i]];
		M[a[i]]=i;
		S[mp[a[i]]].insert(i);
	}M.clear();
	T.build(1,1,n);
	while(m--){
		char op=getchar();
		while(op!='Q'&amp;&amp;op!='R')op=getchar();
		int l,r;scanf("%d%d",&amp;l,&amp;r);
		if(op=='Q'){
			Q(l,r);
		}else{
			R(l,r);
		}
	}
	return 0;
}</pre><pre></pre><h2>Problem2456</h2><pre>#include &lt;cstdio&gt;
int main()
{
    int n;
    while (scanf("%d", &amp;n) != EOF)
    {
        int ans, cnt = 0, x;
        for (int i = 0; i &lt; n; ++ i)
        {
            scanf("%d", &amp;x);
            if (cnt == 0)
            {
                ans = x;
                cnt = 1;
            }
            else if (x == ans)
                ++ cnt;
            else
                -- cnt;
        }
        printf("%d\n", ans);
    }
    return 0;
}</pre><pre></pre><h2>Problem2460</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
int n,ans;
pair&lt;int,LL&gt;a[1001];
LL base[64];
bool add(LL x){
	for(LL i=63;i&gt;=0;i--){
		if(x&gt;&gt;i&amp;1){
			if(!base[i]){base[i]=x;return true;}
			else x^=base[i];
		}
	}return false;
}
int main(){
	cin&gt;&gt;n;
	for(int i=1;i&lt;=n;i++)cin&gt;&gt;a[i].second&gt;&gt;a[i].first;
	sort(a+1,a+1+n,greater&lt;pair&lt;int,LL&gt; &gt;());
	for(int i=1;i&lt;=n;i++)
		if(add(a[i].second))ans+=a[i].first;
	cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem2462</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef unsigned int uint;
const int maxn=1001;
uint hashp[maxn],hashq[maxn],hash[maxn][maxn],p=97,q=233;
int n,m,A,B;
char s[maxn];
uint val[maxn*maxn];
int size,a[maxn][maxn];
uint get(int x1,int y1,int x2,int y2){
	uint ans=hash[x2][y2];
	ans-=hash[x2][y1-1]*hashq[y2-y1+1];
	ans-=hash[x1-1][y2]*hashp[x2-x1+1];
	ans+=hash[x1-1][y1-1]*hashq[y2-y1+1]*hashp[x2-x1+1];
	return ans;
}
//uint _hash[maxn][maxn];
int main(){
	scanf("%d%d%d%d",&amp;n,&amp;m,&amp;A,&amp;B);
	for(int i=1;i&lt;=n;i++){
		scanf("%s",s+1);
		for(int j=1;j&lt;=m;j++)
		a[i][j]=s[j]=='1';
	}
	hashp[0]=hashq[0]=1;
	for(int i=1;i&lt;=m;i++)hashq[i]=hashq[i-1]*q;
	for(int i=1;i&lt;=n;i++)hashp[i]=hashp[i-1]*p;
	for(int i=1;i&lt;=n;i++)
	for(int j=1;j&lt;=m;j++)
	hash[i][j]=q*hash[i][j-1]+p*hash[i-1][j]-hash[i-1][j-1]*p*q+a[i][j];
	for(int i=1;i+A-1&lt;=n;i++)
	for(int j=1;j+B-1&lt;=m;j++)
	val[size++]=get(i,j,i+A-1,j+B-1);
	sort(val,val+size);
	int Q;scanf("%d",&amp;Q);
	while(Q--){
		uint v=0;
		for(int i=1;i&lt;=A;i++){
			scanf("%s",s+1);
			v=v*p;uint vv=0;
			for(int j=1;j&lt;=B;j++)
			vv=vv*q+s[j]-'0';
			v+=vv;
			//_hash[i][j]=q*_hash[i][j-1]+p*_hash[i-1][j]-_hash[i-1][j-1]*p*q+s[j]-'0';
		}
		if(binary_search(val,val+size,v))puts("1");else puts("0");
	}
	return 0;
}</pre><pre></pre><h2>Problem2463</h2><pre>#include&lt;cstdio&gt;
main(){
	int n;
	while(scanf("%d",&amp;n)==1){
		if(!n)break;
		printf("%s\n",n%2==0?"Alice":"Bob");
	}
}</pre><pre></pre><h2>Problem2464</h2><pre>#include&lt;bits/stdc++.h&gt;
#include&lt;ext/pb_ds/priority_queue.hpp&gt;
using namespace std;
int n,m;
int s,t;
int mp[501][501],tot,a[501][501];
const int dx[4]={0,0,1,-1};
const int dy[4]={1,-1,0,0};
typedef pair&lt;int,int&gt; par;
vector&lt;par&gt;G[250010];
void add(int u,int v,int w){
//	cerr&lt;&lt;u&lt;&lt;" "&lt;&lt;v&lt;&lt;" "&lt;&lt;w&lt;&lt;endl;
	G[u].push_back(par(v,w));
//	G[v].push_back(par(u,w));
}
typedef __gnu_pbds::priority_queue&lt;par,greater&lt;par&gt;,__gnu_pbds::pairing_heap_tag&gt; Heap;
typedef Heap::point_iterator iter;
iter d[250010];
Heap q;
int dijk(){
	static int vis[250010];
	memset(vis,0,sizeof vis);q.clear();
	for(int i=1;i&lt;=tot;i++)d[i]=q.end();
	vis[s]=1;d[s]=q.push(par(0,s));
	while(!q.empty()){
		int u=q.top().second;vis[u]=1;
		if(u==t)return d[t]-&gt;first;
		for(int i=0;i&lt;G[u].size();i++){
			int v=G[u][i].first,w=G[u][i].second;
			if(d[v]==q.end())d[v]=q.push(par(1e9,v));
			if(!vis[v]&amp;&amp;d[v]-&gt;first&gt;d[u]-&gt;first+w)
				q.modify(d[v],par(d[u]-&gt;first+w,v));
		}q.erase(d[u]);
	}
}
int main(){
	while(scanf("%d%d",&amp;n,&amp;m)!=EOF){
		if(!n)break;
		tot=0;
		for(int i=1;i&lt;=n;i++){
			static char str[501];
			scanf("%s",str+1);
			for(int j=1;j&lt;=m;j++)
				mp[i][j]=++tot,
				a[i][j]=str[j]=='#',
				G[tot].clear();
		}
		for(int i=1;i&lt;=n;i++)for(int j=1;j&lt;=m;j++){
			for(int k=0;k&lt;4;k++){
				int x=i+dx[k],y=j+dy[k];
				if(x&lt;1||x&gt;n||y&lt;1||y&gt;m)continue;
				add(mp[i][j],mp[x][y],a[x][y]^a[i][j]);
			}
		}int x,y;scanf("%d%d",&amp;x,&amp;y);s=mp[x+1][y+1];
		scanf("%d%d",&amp;x,&amp;y);t=mp[x+1][y+1];
		printf("%d\n",dijk());
	}
	return 0;
}</pre><pre></pre><h2>Problem2467</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
int anss[]={0,0,40,300,2000,458,741,1981,1285,1458,518,842,1491,1888,1675,1662,836,929,432,1165,850,1452,1298,764,1281,1738,1411,765,473,1661,771,304,1828,645,890,803,1836,292,1174,426,1001,1367,687,793,790,117,1490,1940,213,1798,613,1320,1889,1946,333,841,85,1902,839,980,867,226,655,900,653,86,591,1753,748,1788,1187,1289,1278,625,391,327,1523,1034,363,1864,1537,882,500,1013,1644,1150,505,384,1250,893,1764,1336,1372,390,1712,1349,795,316,1348,1566,23,};
int main(){
	int T,n;
	cin&gt;&gt;T;
	while(T--){
		cin&gt;&gt;n;
		cout&lt;&lt;anss[n]&lt;&lt;endl;
	}
	return 0;
}</pre><pre></pre><h2>Problem2467</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;algorithm&gt;
using namespace std;
const int N = 410;
const int MOD = 2007;
int n,m,n4;short T;
typedef int Matrix[N][N];
int tmp[N];
Matrix mat;
void row_gcd(const int &amp;n,Matrix a,int i,int j){
	int k;
	//printf("%d %d\n",i,j);
	a[j][i] = (a[j][i]%MOD + MOD)%MOD;
	a[i][i] = (a[i][i]%MOD + MOD)%MOD;
	while(a[j][i]){
		int tmp = a[i][i]/a[j][i];
		for(k=i;k&lt;=n;k++)a[i][k]=(a[i][k]-a[j][k]*tmp+MOD)%MOD;
		for(k=i;k&lt;=n;k++)swap(a[i][k],a[j][k]);
		T^=1;
	}
}
int gauss_calc(int n,Matrix a){
	int i,j;int re=1;T=0;
	for(i=1;i&lt;=n;i++)
	for(j=i+1;j&lt;=n;j++)
		row_gcd(n,a,i,j);
	for(i=1;i&lt;=n;i++)re = (a[i][i]*re)%MOD;
	if(T)re=-re;
	if((n&amp;1)==0)re=-re;//orz zky?
	return (re+MOD)%MOD;
}
void AddEdge(int a,int b){
	if(a &gt; n4)a-=n4;
	if(b &gt; n4)b-=n4;
	mat[a][a]++;
	mat[b][b]++;
	mat[a][b]-=1;
	mat[b][a]-=1;
}
void makegraph(){
	int i,j;
	for(i=1;i&lt;=n4;i++)
	for(j=1;j&lt;=n4;j++)
		mat[i][j]=0;
		
	for(i=1;i&lt;=n4;i+=4){
		for(j=0;j&lt;4;j++)
			AddEdge(i+j,i+j+1);
		AddEdge(i,i+4);
	}
}
void print(){
	int i,j;
	for(i=1;i&lt;=n4;i++){
		for(j=1;j&lt;=n4;j++)printf("%d ",mat[i][j]);
		printf("\n");
	}
}
int ans[110];
short v[110];
int scan(){int i=0;scanf("%d",&amp;i);return i;}
int solve(int x){
	if(v[x])return ans[x];
	v[x]=1;
	n = x;n4 = n*4;
	makegraph();
	//print();
	return ans[x] = gauss_calc(n*4-1,mat);
}
int main(){
	int i,j;
	int nn=scan();
	while(nn--){
		i = scan();
		printf("%d\n",solve(i));
	}
	return 0;
}</pre><pre></pre><h2>Problem2474</h2><pre>#include&lt;bits/stdc++.h&gt;
#define fst first
#define sec second
using namespace std;
const int maxn=1e5+5;
typedef pair&lt;int,int&gt;par;
par a[maxn];
multiset&lt;int&gt;S;
void solve(){
	int n,m;S.clear();
	scanf("%d%d",&amp;n,&amp;m);
	for(int i=1;i&lt;=n;i++)scanf("%d%d",&amp;a[i].fst,&amp;a[i].sec);
	int ans=0;
	sort(a+1,a+1+n);
	for(int i=1;i&lt;=m;i++)S.insert(0);
	for(int k=1;k&lt;=n;k++){
		multiset&lt;int&gt;::iterator i=S.begin(),j=--S.end();
		if(*i&lt;a[k].fst){
			ans++;
			S.erase(i);S.insert(a[k].sec);
		}else if(*j&gt;a[k].sec)
		S.erase(j),S.insert(a[k].sec);
	}cout&lt;&lt;ans&lt;&lt;endl;
}
int main(){
	int T;scanf("%d",&amp;T);
	while(T--)solve();
	return 0;
}</pre><pre></pre><h2>Problem2480</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
LL exgcd(LL a,LL b,LL &amp;x,LL &amp;y){
	if(!b){
		x=1;y=0;return a;
	}else{
		LL g=exgcd(b,a%b,x,y);
		LL t=x;x=y;y=t-a/b*y;
		return g;
	}
}
LL inv(LL a,LL p){
	LL x,y;
	LL d=exgcd(a,p,x,y);
	return d==1?(x+p)%p:-1;
}
LL pow(LL x,LL k,LL p){
	LL ans=1;
	for(;k;k&gt;&gt;=1){
		if(k&amp;1)ans=ans*x%p;
		x=x*x%p;
	}return ans;
}
int BSGS(LL a,LL b,LL p){
	LL m=0;for(;m*m&lt;=p;m++);b%=p;
	map&lt;LL,int&gt;hash;hash[b]=0;
	LL v=inv(a,p),am=pow(a,m,p);
	LL e=b;
	for(int i=1;i&lt;m;i++){
		e=e*v%p;
		if(!hash.count(e))
			hash[e]=i;
		else break;
	}e=1;
	for(int i=0;i&lt;=m;i++){
		if(hash.count(e))return hash[e]+i*m;
		e=e*am%p;
	}return -1;
}
void solve(LL a,LL b,LL p){
	LL e=1;b%=p;a%=p;
	for(int i=0;i&lt;100;i++){
		if(e==b)return (void)printf("%d\n",i);
		e=e*a%p;
	}int r=0;
	while(__gcd(a,p)!=1){
		LL d=__gcd(a,p);
		if(b%d)return (void)puts("No Solution");
		p/=d;r++;b/=d;
		b=b*inv(a/d,p)%p;
	}
	int res=BSGS(a,b,p);
	if(res==-1)return (void)puts("No Solution");
	printf("%d\n",res+r);
}
int main(){
	LL a,p,b;
	while(cin&gt;&gt;a&gt;&gt;p&gt;&gt;b){
		if(!a&amp;&amp;!b&amp;&amp;!p)break;
		solve(a,b,p);		
	}
	return 0;
}</pre><pre></pre><h2>Problem2502</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=233;
int s,t;
struct edge{int u,v,ca,fl,co;};
vector&lt;edge&gt;E;
vector&lt;int&gt;G[maxn];
void add(int u,int v,int ca,int co){
//	cerr&lt;&lt;u&lt;&lt;" "&lt;&lt;v&lt;&lt;" "&lt;&lt;ca&lt;&lt;" "&lt;&lt;co&lt;&lt;endl; 
	E.push_back((edge){u,v,ca,0,co});
	G[u].push_back(E.size()-1);
	E.push_back((edge){v,u,0,0,-co});
	G[v].push_back(E.size()-1);
}
int cost,flow=0;
bool spfa(){
	static int vis[maxn],d[maxn],a[maxn],pre[maxn];
	memset(d,0xaf,sizeof d);int B=d[0];a[s]=INT_MAX;
	queue&lt;int&gt;q;q.push(s);vis[s]=1;d[s]=0;	
	while(!q.empty()){
		int u=q.front();q.pop();vis[u]=0;
		for(int i=0;i&lt;G[u].size();i++){
			edge e=E[G[u][i]];
			if(e.ca==e.fl||d[e.v]&gt;=d[u]+e.co)continue;
			a[e.v]=min(e.ca-e.fl,a[u]);pre[e.v]=G[u][i];
			d[e.v]=d[u]+e.co;if(!vis[e.v])q.push(e.v),vis[e.v]=1;
		}	
	}
	if(d[t]==B)return false;
	flow+=a[t];
	cost+=a[t]*d[t];
	int u=t;
	while(u!=s){
		E[pre[u]].fl+=a[t];
		E[pre[u]^1].fl-=a[t];
		u=E[pre[u]].u;
	}return true;
}
int main(){
	int n;scanf("%d",&amp;n);int M=0;
	s=0;t=n+1;int ss=t+1,tt=s+1;
	for(int i=1;i&lt;=n;i++){
		int m;scanf("%d",&amp;m);M+=m;
		for(int j=1;j&lt;=m;j++){
			int v;scanf("%d",&amp;v);
			add(i,v,1,1);
			add(i,v,1e9,0);
		}
		add(ss,i,1e9,0);
		add(i,t,1e9,0);
	}add(s,ss,0,0);
	
	for(int i=1;i&lt;=23333;i++){
		E[E.size()-2].ca++;
		spfa();
		if(cost==M){printf("%d\n",i);return 0;}
	}
	return 0;
}</pre><pre></pre><h2>Problem2506</h2><pre>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
inline int read()
{
    int x=0;char ch=getchar();
    while(ch&lt;'0'||ch&gt;'9')ch=getchar();
    while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=x*10+ch-'0';ch=getchar();}
    return x;
}
int n,m,top,mx;
int a[100005];
int f1[105][105],f2[100005];
int ans[2][100005];
struct data{int x,f,p,k,num;}q[200005];
inline bool cmp(data a,data b)
{return a.x&lt;b.x;}
void add(int x)
{
     for(int i=1;i&lt;=100;i++)
         f1[i][x%i]++;
     f2[x]++;
}
int main()
{
    n=read();m=read();
    for(int i=1;i&lt;=n;i++)
        a[i]=read(),mx=max(mx,a[i]);
    for(int i=1;i&lt;=m;i++)
    {
        int l=read(),r=read(),p=read(),k=read();
        q[++top].x=l-1;q[top].p=p;q[top].k=k;q[top].num=i;
        q[++top].x=r;q[top].p=p;q[top].k=k;q[top].num=i;q[top].f=1;
    }
    sort(q+1,q+top+1,cmp);
    int now=0;
    for(int i=1;i&lt;=top;i++)
    {
        while(now&lt;q[i].x){now++;add(a[now]);}
        int p=q[i].p,k=q[i].k;
        if(p&lt;=100)ans[q[i].f][q[i].num]=f1[p][k];
        else 
        for(int j=k;j&lt;=mx;j+=p)
            ans[q[i].f][q[i].num]+=f2[j];
    }
    for(int i=1;i&lt;=m;i++)
        printf("%d\n",ans[1][i]-ans[0][i]);
    return 0;
}</pre><pre></pre><h2>Problem2521</h2><pre>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
#include&lt;ctime&gt;
#define maxn 600
#define inf 0x7fffffff
using namespace std;
int point[maxn],next[2000],v[2000],f[2000],n,T=1;
int dis[maxn],pred[maxn],cur[maxn],gap[maxn],e[1000][3];
bool use[maxn];
void add(int x,int y,int w){
	v[++T]=y; f[T]=w; next[T]=point[x]; point[x]=T;}
int isap(int vs,int vt){
	int i,x,u,ans=0;
	u=vs; gap[0]=n; use[vs]=true;
	for (i=1; i&lt;=n; i++)
	  cur[i]=point[i];
	while (true){
	  for (i=cur[u]; i; i=next[i])
	    if (f[i]&amp;&amp;!use[v[i]]&amp;&amp;dis[u]==dis[v[i]]+1) break;
	  if (i){
	  	cur[u]=pred[v[i]]=i; u=v[i]; use[u]=true;
	  	if (u==vt){
	  	  x=inf;
	  	  for (i=vt; i!=vs; i=v[pred[i]^1])
	  	    x=min(x,f[pred[i]]);
	  	  ans+=x;
	  	  for (i=vt; i!=vs; i=v[pred[i]^1]){
	  	  	f[pred[i]]-=x;
	  	  	f[pred[i]^1]+=x;
	  	  }
	  	  u=vs; memset(use,0,sizeof(use)); use[vs]=true;
	  	}
	  }
	  else{
	  	x=n;
	  	for (i=point[u]; i; i=next[i])
	  	  if (f[i]) x=min(x,dis[v[i]]);
	  	gap[dis[u]]--;
	  	if (!gap[dis[u]]) break;
	  	dis[u]=x+1;
	  	gap[dis[u]]++;
	  	cur[u]=point[u];
	  	if (u!=vs){
	  	  use[u]=false;
	  	  u=v[pred[u]^1];
	    }
	  }
	}
	return ans;
}
int main(){
	//freopen("build.in","r",stdin);
	//freopen("build.out","w",stdout);
	int i,x,y,w,m,idx,ans;
	scanf("%d%d%d",&amp;n,&amp;m,&amp;idx);
	for (i=1; i&lt;=m; i++)
	  scanf("%d%d%d",&amp;e[i][1],&amp;e[i][2],&amp;e[i][0]);
	for (i=1; i&lt;=m; i++)
	  if (i!=idx&amp;&amp;e[i][0]&lt;=e[idx][0]){
	  	add(e[i][1],e[i][2],e[idx][0]-e[i][0]+1);
	  	add(e[i][2],e[i][1],e[idx][0]-e[i][0]+1);
	  }
	ans=isap(e[idx][1],e[idx][2]);
	printf("%d\n",ans);
}</pre><pre></pre><h2>Problem2521</h2><pre>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#define maxnode 510
#define maxedge 1610
#define inf 2100000000LL
using namespace std;
struct use{
	int st,en,va;
}edge[maxedge];
int point[maxnode]={0},next[maxedge]={0},dis[maxnode]={0},gap[maxnode]={0},pre[maxnode]={0},
    tot,cur[maxnode]={0},n,uu[maxedge],vv[maxedge],ww[maxedge];
bool visit[maxnode]={false};
void add(int u,int v,int w)
{
	++tot;next[tot]=point[u];point[u]=tot;
	edge[tot].st=u;edge[tot].en=v;edge[tot].va=w;
	++tot;next[tot]=point[v];point[v]=tot;
	edge[tot].st=v;edge[tot].en=u;edge[tot].va=w;
}
int sap(int st,int en)
{
	int ans=0,u,i,minn;
	bool f;
	gap[0]=n;u=st;visit[st]=true;
	for (i=1;i&lt;=n;++i) cur[i]=point[i];
	while(dis[st]&lt;n)
	{
		f=false;
		for (i=cur[u];i;i=next[i])
		{
			if (edge[i].va&amp;&amp;!visit[edge[i].en]&amp;&amp;dis[edge[i].en]+1==dis[u])
			{
				f=true;cur[u]=i;break;
			}
		}
		if (f)
		{
			pre[edge[i].en]=i;u=edge[i].en;visit[u]=true;
			if (u==en)
			{
				minn=inf;
				for (i=en;i!=st;i=edge[pre[i]].st)
				  minn=min(minn,edge[pre[i]].va);
				ans+=minn;
				for (i=en;i!=st;i=edge[pre[i]].st)
				{
					edge[pre[i]].va-=minn;
					edge[pre[i]^1].va+=minn;
					visit[i]=false;
				}
				u=st;
			}
		}
		else
		{
			--gap[dis[u]];minn=n;
			if (!gap[dis[u]]) return ans;
			for (i=point[u];i;i=next[i])
				if (edge[i].va)
				  minn=min(minn,dis[edge[i].en]);
			dis[u]=minn+1;++gap[dis[u]];cur[u]=point[u];
			visit[u]=false;if (u!=st) u=edge[pre[u]].st;
		}
	}
	return ans;
}
int main()
{
	int m,i,j,idx;
	scanf("%d%d%d",&amp;n,&amp;m,&amp;idx);
	tot=1;
	for (i=1;i&lt;=m;++i)
		scanf("%d%d%d",&amp;uu[i],&amp;vv[i],&amp;ww[i]);
	for (i=1;i&lt;=m;++i)
	{
		if (ww[idx]&lt;ww[i]||i==idx) continue;
		add(uu[i],vv[i],ww[idx]+1-ww[i]);
	}
	printf("%d\n",sap(uu[idx],vv[idx]));
}</pre><pre></pre><h2>Problem2527</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=3e5+5;
int n,m,k;
typedef long long LL;
vector&lt;int&gt;O[maxn];
int getint(){
	int res=0;char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))res=res*10+c-'0',c=getchar();
	return res;
}
struct BIT{
	LL d[maxn];
	inline int lowbit(int x){return x&amp;-x;}
	LL get(int x){
		LL ans=0;
		while(x)ans+=d[x],x-=lowbit(x);
		return ans;
	}
	void updata(int x,LL f){
		while(x&lt;=m)d[x]+=f,x+=lowbit(x);
	}
	void add(int l,int r,LL f){
		updata(l,f);
		updata(r+1,-f);
	}
}T,T2;
int anss[maxn],wana[maxn];
struct qes{
	LL x,y,z;
	qes(LL _x=0,LL _y=0,LL _z=0):
		x(_x),y(_y),z(_z){}
}q[maxn],p[maxn];
bool part(qes &amp;q){
	if(q.y+q.z&gt;=wana[q.x])return 1;
	q.z+=q.y;q.y=0;return 0;
}
void solve(int lef,int rig,int l,int r){
	if(l==r){
		for(int i=lef;i&lt;=rig;i++)if(anss[p[i].x]!=-1)
		anss[p[i].x]=l;return;
	}int mid=(l+r)&gt;&gt;1;
	for(int i=l;i&lt;=mid;i++){
		if(q[i].x&lt;=q[i].y)T.add(q[i].x,q[i].y,q[i].z);
		else T.add(1,q[i].y,q[i].z),T.add(q[i].x,m,q[i].z);
	}for(int i=lef;i&lt;=rig;i++){
		p[i].y=0;
		for(int j=0;j&lt;O[p[i].x].size()&amp;&amp;p[i].y&lt;=int(1e9)+1;j++)
		p[i].y+=T.get(O[p[i].x][j]);
	}for(int i=l;i&lt;=mid;i++){
		if(q[i].x&lt;=q[i].y)T.add(q[i].x,q[i].y,-q[i].z);
		else T.add(1,q[i].y,-q[i].z),T.add(q[i].x,m,-q[i].z);
	}int dv=stable_partition(p+lef,p+rig+1,part)-p-1;		
	if(lef&lt;=dv)
	solve(lef,dv,l,mid);
	if(dv+1&lt;=rig)
	solve(dv+1,rig,mid+1,r);
}
int main(){
	n=getint();m=getint();
	for(int i=1;i&lt;=m;i++){
		int x=getint();O[x].push_back(i);
	}for(int i=1;i&lt;=n;i++)wana[i]=getint(),p[i]=qes(i,0,0);
	k=getint();
	for(int i=1;i&lt;=k;i++){
		int l=getint(),r=getint(),x=getint();
		q[i]=qes(l,r,x);
	}q[++k]=qes(1,m,int(1e9)+1);
	solve(1,n,1,k);	
	for(int i=1;i&lt;=n;i++)if(anss[i]!=k)
	printf("%d\n",anss[i]);else puts("NIE");
	return 0;
}</pre><pre></pre><h2>Problem2529</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#define M 1000001
using namespace std;
int k,n,top;
pair&lt;int,int&gt; stack[M],a[3];
int main()
{
    int i,j;
    cin&gt;&gt;k;
    for(i=1;i&lt;=k;i++)
    {
        scanf("%d",&amp;n);
        for(j=1;j&lt;=n;j++)
        {
            stack[++top]=pair&lt;int,int&gt;(0,i);
            scanf("%d",&amp;stack[top].first);
        }
    }
    sort(stack+1,stack+top+1);
    for(i=1;i&lt;=top;i++)
    {
        for(j=0;j&lt;3;j++)
            if(stack[i].second==a[j].second)
            {
                a[j]=stack[i];
                break;
            }
        if(j==3) a[0]=stack[i];
        sort(a,a+3);
        if(a[0].second)
        {
            if(a[0].first+a[1].first&gt;a[2].first)
            {
                printf("%d %d %d %d %d %d\n",a[0].second,a[0].first,a[1].second,a[1].first,a[2].second,a[2].first);
                return 0;
            }
        }
    }
    puts("NIE");
    return 0;
}</pre><pre></pre><h2>Problem2530</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=3010;
bool g[maxn][maxn],del[maxn];
int n,m;
int main(){
	scanf("%d%d",&amp;n,&amp;m);
	for(int i=1,u,v;i&lt;=m;i++)
		scanf("%d%d",&amp;u,&amp;v),g[u][v]=g[v][u]=1;
	for(int i=1;i&lt;=n;i++)if(!del[i])
	for(int j=1;j&lt;=n;j++)if(i!=j&amp;&amp;!g[i][j]&amp;&amp;!del[j])
	{del[j]=del[i]=1;break;}
	for(int i=1,k=0;i&lt;=n,k&lt;n/3;i++)if(!del[i])
	printf("%d%c",i," \n"[++k==n/3]);
	return 0;
}</pre><pre></pre><h2>Problem2539</h2><pre>/*
	ID:zky
	OJ:BZOJ
	Index:2539
	Language:C++
*/
#include&lt;map&gt;
#include&lt;queue&gt;
#include&lt;vector&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;climits&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#define clear(x) memset(x,0,sizeof(x))
#define inf(x) memset(x,0x7f,sizeof(x))
#define Size G[u].size()
#define read3(x,y,z) scanf("%d%d%d",&amp;x,&amp;y,&amp;z)
#define read4(x,y,z,w) scanf("%d%d%d%d",&amp;x,&amp;y,&amp;z,&amp;w)
using namespace std;
int s,t;
int n,m,k;
const int INF=INT_MAX;
struct edge{
	int u,v,cap,flow,cost;
};
vector&lt;edge&gt;edges;
vector&lt;vector&lt;int&gt; &gt;G;
int d[10010];
int cur[10010];
int vis[10010];
int prev[10010];
void add(int u,int v,int cap,int cost){
	edges.push_back((edge){u,v,cap,0,cost});
	G[u].push_back(edges.size()-1);
	edges.push_back((edge){v,u,0,0,-cost});
	G[v].push_back(edges.size()-1);
}
int a[10010];
bool spfa(int  &amp;flow,int &amp;cost){
	queue&lt;int&gt;q;
	q.push(s);
	memset(d,0xaf,sizeof(d));
	memset(vis,0,sizeof(vis));
	int B=d[0];
	d[s]=0;
	vis[s]=1;
	a[s]=INF;
	while(!q.empty()){
		int u=q.front();q.pop();vis[u]=0;
		for(int i=0;i&lt;G[u].size();i++){
			edge &amp;e=edges[G[u][i]];
			if(e.cap-e.flow&gt;0&amp;&amp;d[e.v]&lt;d[u]+e.cost){
				d[e.v]=d[u]+e.cost;
				prev[e.v]=G[u][i];
				a[e.v]=min(a[u],e.cap-e.flow);
				if(!vis[e.v]){
					vis[e.v]=1;
					q.push(e.v);
				}
			}
		}
	}
	if(d[t]==B)return false;
	int u=t;
	flow+=a[t];
	cost+=a[t]*d[t];
	while(u!=s){
		edges[prev[u]].flow+=a[t];
		edges[prev[u]^1].flow-=a[t];
		u=edges[prev[u]].u;
	}
	return true;
}
string name[999];
void costflow(){
	int flow=0,cost=0;
	while(spfa(flow,cost));
	cout&lt;&lt;cost&lt;&lt;endl;
}
void Bigger(string &amp;x){
	for(int i=0;i&lt;x.length();i++){
		if(x[i]&gt;='a'&amp;&amp;x[i]&lt;='z')
		x[i]=x[i]+('A'-'a');
	}
}
int w[999][999];
int mp[999][999];
int love[999][999];
map&lt;string,int&gt;M;
map&lt;int,string&gt;rM;
int x[999],y[999];
int tot=0;

string Change( string st ){
    string s = st ;
    for(int i =0; i &lt; s.size(  ); i ++)if( s[ i ]&gt;='A'&amp;&amp; s[ i ]&lt;='Z'){
        s[ i ]= s[ i ]+('a'-'A');
    }
    return s ;
}
 
int Find( string s ){
    for(int i =0; i ++&lt; n *2;)if( name[i]== s )return i ;
}
 
bool check(int x0 ,int y0 ,int x1 ,int y1 ,int t0 ,int t1 ){
    if(( x0 - x1 )*( x0 - x1 )+( y0 - y1 )*( y0 - y1 )&gt; k )return false;
    for(int i =0; i ++&lt;2* n ;)if( i != t0 &amp;&amp; i != t1 ){
        if( x[i]&gt;=min( x0 , x1 )&amp;&amp; x[i]&lt;=max( x0 , x1 )){
            if( y[i]&gt;=min( y0 , y1 )&amp;&amp; y[i]&lt;=max( y0 , y1 )){
                int X1 = x[i]- x0 , Y1 = y[i]- y0 ;
                int X2 = x[i]- x1 , Y2 = y[i]- y1 ;
                if( X1 * Y2 == X2 * Y1 )return false;
            }
        }
    }
    return true;
}
 
int main(  ){
    cin &gt;&gt; k &gt;&gt; n ; k *= k ;
	G.resize(n*2+10);
    for(int i =0; i ++&lt; n *2;){
        cin &gt;&gt; x[i]&gt;&gt; y[i]&gt;&gt; name[i];
        name[i]=Change( name[i]);
    }
    for(int i =0; i ++&lt; n *2;)for(int j =0; j ++&lt; n *2;) love[ i ][ j ]=1;
    string str ;
    for( cin &gt;&gt; str ; str !="End"; cin &gt;&gt; str ){
        int x ; string s0 ;
        cin &gt;&gt; s0 &gt;&gt; x ;
        str =Change( str ); s0 =Change( s0 );
        int y =Find( str ), z =Find( s0 );
        love[ y ][ z ]= love[ z ][ y ]= x ;
    }
    s=n*2+1;s=n*2+2;
    for(int i =0; i ++&lt; n ;)add( s , i ,1,0);
    for(int i = n ; i ++&lt; n *2;)add( i , t ,1,0);
    for(int i =0; i ++&lt; n ;)for(int j = n ; j ++&lt; n *2;){
        if(check( x[i], y[i], x[j], y[j], i , j )){
            add( i , j ,1, love[ i ][ j ]);
        }
    }
    costflow(  );
    return 0;
}</pre><pre></pre><h2>Problem2542</h2><pre>/*
	ID:zky
	OJ:BZOJ
	Index:1834
	Language:C++
*/
#include&lt;cmath&gt;
#include&lt;iomanip&gt;
#include&lt;queue&gt;
#include&lt;vector&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;climits&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#define clear(x) memset(x,0,sizeof(x))
#define inf(x) memset(x,0x7f,sizeof(x))
#define Size G[u].size()
#define read3(x,y,z) scanf("%d%d%d",&amp;x,&amp;y,&amp;z)
#define read4(x,y,z,w) scanf("%d%d%d%d",&amp;x,&amp;y,&amp;z,&amp;w)
using namespace std;
int ss,s,t;
int n,m,k;
const int INF=INT_MAX;
const double eps=1e-6;
struct edge{
	int u,v,cap,flow;
	double cost;
};
vector&lt;edge&gt;edges;
vector&lt;vector&lt;int&gt; &gt;G;
double d[10001];
int cur[10001];
int vis[10001];
int prev[10001];
void add(int u,int v,int cap,double cost){
	edges.push_back((edge){u,v,cap,0,cost});
	G[u].push_back(edges.size()-1);
	edges.push_back((edge){v,u,0,0,-cost});
	G[v].push_back(edges.size()-1);
}
int a[10001];
bool spfa(int  &amp;flow,double &amp;cost){
	queue&lt;int&gt;q;
	q.push(s);
	for(int i=0;i&lt;=1010;i++){
		vis[i]=0;
		d[i]=-999999999;
	}
	double B=d[0];
	d[s]=0;
	vis[s]=1;
	a[s]=INF;
	while(!q.empty()){
		int u=q.front();q.pop();vis[u]=0;
		for(int i=0;i&lt;G[u].size();i++){
			edge &amp;e=edges[G[u][i]];
			if(e.cap-e.flow&gt;0&amp;&amp;d[e.v]&lt;d[u]+e.cost&amp;&amp;fabs(d[e.v]-d[u]-e.cost)&gt;1e-10){
				d[e.v]=d[u]+e.cost;
				prev[e.v]=G[u][i];
				a[e.v]=min(a[u],e.cap-e.flow);
				if(!vis[e.v]){
					vis[e.v]=1;
					q.push(e.v);
				}
			}
		}
	}
	if(fabs(d[t]-B)&lt;=eps)return false;
	int u=t;
	flow+=a[t];
	cost+=a[t]*d[t]+1e-12;
	while(u!=s){
		edges[prev[u]].flow+=a[t];
		edges[prev[u]^1].flow-=a[t];
		u=edges[prev[u]].u;
	}
	return true;
}
int flow=0;
double cost=0;
void costflow(){
	while(spfa(flow,cost));
}
double AS[3110];
int AM[3110];
double res;
void deal(){
    char ch[40];
    double ans=res;
    sprintf(ch,"%.15lf\n",ans);
    int sum=0,i;
    for(i=0; sum&lt;5; i++)
    {
        if((ch[i]!='0'&amp;&amp;ch[i]!='.')|sum&gt;0)
            sum++;
    }
    if(ch[i]&gt;='5')
        ch[i-1]++;
    ch[i]=0;
    for(; i&gt;=0; i--)
    {
        if(ch[i]=='.')break;
        else if(ch[i]&gt;'9') {
            ch[i-1]++,ch[i]='0';
        }
    }
    printf("%s\n",ch);
}
int main(){
	cin&gt;&gt;n&gt;&gt;k;
	G.resize(1010);
	ss=0;t=n+1;s=t+1;
	add(s,ss,k,log(1));
	for(int i=1;i&lt;=n;i++){
		cin&gt;&gt;AS[i];
		AS[i]=log(AS[i]);
	}
	for(int i=1;i&lt;=n;i++){
		cin&gt;&gt;AM[i];
	}
	for(int i=1;i&lt;=n;i++){
		if(AM[i]&gt;0)
		add(ss,i,AM[i],AS[i]);
	}
	int x;
	for(int i=1;i&lt;=n;i++){
		cin&gt;&gt;x;
		if(x)add(i,t,k,log(1));
	}
	double y;
	int u,v;
	while(cin&gt;&gt;u&gt;&gt;v){
		if(u==-1&amp;&amp;v==-1)break;
		cin&gt;&gt;y&gt;&gt;x;y=log(y);
		add(u,v,x,y);
		add(v,u,x,y);
	}
	int deb=0;
	if(deb){
		for(int i=0;i&lt;edges.size();i++){
			cout&lt;&lt;"#"&lt;&lt;i&lt;&lt;" ";
			cout&lt;&lt;edges[i].u&lt;&lt;" -&gt;";
			cout&lt;&lt;edges[i].v&lt;&lt;"  ";
			cout&lt;&lt;"cap:"&lt;&lt;edges[i].cap&lt;&lt;"  ";
			cout&lt;&lt;"cost:"&lt;&lt;edges[i].cost&lt;&lt;endl;
		}
		
	}
	costflow();
	if(k!=flow){
		printf("%5f\n",0);
		return 0;
	}
	res=pow(M_E,cost);
	deal();
	return 0;
}</pre><pre></pre><h2>Problem2547</h2><pre>#include&lt;cstdio&gt;
#include&lt;queue&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#define X first 
#define Y second
#define COST (bool(ty)^(d[x][y]&amp;1))?(mp[x][y]&lt;mp[i][j]):(mp[x][y]&gt;mp[i][j])  
using namespace std;
int w[1110][1101];
int n,m,k,T;
typedef pair&lt;int,int&gt; pii;
struct soldier{
	int x,y;
};
soldier a[1011];
soldier b[1101];
int l[501]={0},r[501]={0};
int mp[1011][1011];
int d[111][111];
int map[101][1001];
const int dx[4]={0,1,0,-1};
const int dy[4]={1,0,-1,0};
int mid;
int Link[1011];
int vis[1101];
int cost(pii a,pii b,int ty){
	if(ty==1){
		if(mp[a.X][a.Y]&lt;=mp[b.X][b.Y])return 0;
		return 1;
	}else{
		if(mp[a.X][a.Y]&gt;=mp[b.X][b.Y])return 0;
		return 1;		
	}
}
queue&lt;pii&gt;q;
void bfs(int x,int y,bool ty)  //ty-&gt; 0 upper 1 lower  
{  
    d[x][y]=0;  
    q.push(make_pair(x,y));  
    while (!q.empty()){  
        pii now=q.front();
        q.pop();    
        int &amp;x=now.first,&amp;y=now.second;  
        for (int k=0;k&lt;4;k++)  {  
        	int i=x+dx[k],j=y+dy[k];
            int c=COST;  
            if(i&lt;1||j&lt;1||i&gt;n||j&gt;m)continue;  
            if (d[i][j]&gt;d[x][y]+c){  
                d[i][j]=d[x][y]+c;      
                q.push(pii(i,j));  
            }  
        }  
    }  
}  
/*
void bfs(int x,int y,int ty){//0 footman 1 knight
	queue&lt;pii&gt;q;
	q.push(pii(x,y));
	int vis[111][111];
	memset(vis,0,sizeof(vis));
	while(!q.empty()){
		pii now=q.front();q.pop();
		vis[now.X][now.Y]=0;
		for(int k=0;k&lt;4;k++){
			int i=now.X+dx[k],j=now.Y+dy[k];
			if(i&lt;1||j&lt;1||i&gt;n||j&gt;m||vis[i][j])continue;
			int ok=0;
			if(mp[x][y]&gt;mp[i][j]){
				d[i][j][0]=d[x][y][1]+1;
				d[i][j][1]=min(d[x][y][0]+1,d[x][y][1]);
			}else
				if(mp[x][y]&lt;mp[i][j]){
					d[i][j][1]=d[x][y][0]+1;
					d[i][j][0]=min(d[x][y][1]+1,d[x][y][0]);
				}else{
					d[i][j][0]=min(d[x][y][0],d[x][y][1]+1);
					d[i][j][1]=min(d[x][y][1],d[x][y][0]+1);
				}
			if(!vis[i][j]&amp;&amp;ok){
				q.push(pii(i,j));
				vis[i][j]=1;
			}			
		}
	}
}*/
bool find(int x,int c){
	for(int i=1;i&lt;=2*k;i++){
		if(w[x][i]&lt;=c&amp;&amp;!vis[i]){
			vis[i]=1;
			if(!Link[i]||find(Link[i],c)){
				Link[i]=x;
				return true;
			}
		}
	}
	return false;
}
int hunger(int c){
	int ans=0;
	memset(Link,0,sizeof(Link));
	for(int i=1;i&lt;=2*k;i++){
		memset(vis,0,sizeof(vis));
		if(find(i,c))ans++;
	}
	return ans;
}
int main(){
	cin&gt;&gt;n&gt;&gt;m&gt;&gt;k&gt;&gt;T;
	for(int i=1;i&lt;=2*k+1;i++)
		cin&gt;&gt;a[i].x&gt;&gt;a[i].y;
	for(int i=1;i&lt;=T;i++){
		int x,y,R;
		cin&gt;&gt;b[i].x&gt;&gt;b[i].y&gt;&gt;R;
		if(R){
			l[i]=r[i-1]+1;
			r[i]=l[i]+R-1;
		}
	}
	for(int i=1;i&lt;=n;i++)
	for(int j=1;j&lt;=m;j++){
		cin&gt;&gt;mp[i][j];
	}
	for(int i=1;i&lt;=k;i++){
		memset(d,0x7f,sizeof(d));
		bfs(a[i].x,a[i].y,0);
//		for(int l=1;l&lt;=n;l++)
//		for(int j=1;j&lt;=m;j++){
//			cout&lt;&lt;d[l][j]&lt;&lt;" ";
//			if(j==m)cout&lt;&lt;endl;
//		}
		for(int j=1;j&lt;=T;j++){
			for(int k=l[j];k&lt;=r[j];k++){
				w[i][k]=d[b[j].x][b[j].y];
			}
		}
	}
	for(int i=k+1;i&lt;=k+k;i++){
		memset(d,0x7f,sizeof(d));
		bfs(a[i].x,a[i].y,1);
		for(int j=1;j&lt;=T;j++){
			for(int k=l[j];k&lt;=r[j];k++){
				w[i][k]=d[b[j].x][b[j].y];
			}
		}
	}
//	for(int i=1;i&lt;=2*k;i++)
//	for(int j=1;j&lt;=k+k;j++){
//		cout&lt;&lt;i&lt;&lt;" "&lt;&lt;j&lt;&lt;" "&lt;&lt;w[i][j]&lt;&lt;endl;
//	}
	
	int L=0,R=101;
	while(L&lt;R){
		mid=(L+R)&gt;&gt;1;
		if(hunger(mid)+mid&gt;=2*k)
			R=mid;
		else
			L=mid+1;
	}
	cout&lt;&lt;L&lt;&lt;endl;


	
	
	
	
	
	return 0;
}</pre><pre></pre><h2>Problem2547</h2><pre>#include&lt;cstdio&gt;
#include&lt;queue&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#define X first 
#define Y second
#define COST (bool(ty)^(d[x][y]&amp;1))?(mp[x][y]&lt;mp[i][j]):(mp[x][y]&gt;mp[i][j])  
using namespace std;
int w[101][101];
int n,m,k,T;
typedef pair&lt;int,int&gt; pii;
struct soldier{
	int x,y;
};
soldier a[101];
soldier b[101];
int l[51]={0},r[51]={0};
int mp[101][101];
int d[101][101];
int map[101][101];
const int dx[4]={0,1,0,-1};
const int dy[4]={1,0,-1,0};
int mid;
int Link[101];
int vis[101];
queue&lt;pii&gt;q;
void bfs(int x,int y,bool ty)  //ty-&gt; 0 upper 1 lower  
{  
    d[x][y]=0;  
    q.push(make_pair(x,y));  
    while (!q.empty()){  
        pii now=q.front();
        q.pop();    
        int &amp;x=now.first,&amp;y=now.second;  
        for (int k=0;k&lt;4;k++)  {  
        	int i=x+dx[k],j=y+dy[k];
            int c=COST;  
            if(i&lt;1||j&lt;1||i&gt;n||j&gt;m)continue;  
            if (d[i][j]&gt;d[x][y]+c){  
                d[i][j]=d[x][y]+c;      
                q.push(pii(i,j));  
            }  
        }  
    }  
}  
bool find(int x,int c,int in){
	for(int i=1;i&lt;=2*k;i++){
		if(w[x][i]&lt;=c&amp;&amp;vis[i]!=in){
			vis[i]=in;
			if(!Link[i]||find(Link[i],c,in)){
				Link[i]=x;
				return true;
			}
		}
	}
	return false;
}
int hunger(int c){
	int ans=0;
	memset(Link,0,sizeof(Link));
		memset(vis,0,sizeof(vis));
	for(int i=1;i&lt;=2*k;i++){
		if(find(i,c,i))ans++;
	}
	return ans;
}
int getint(){
	int ok=0;
	int res=0;
	char ch;
	while(1){
		ch=getchar();
		if(ch&gt;='0'&amp;&amp;ch&lt;='9'){
			ok=1;
			res*=10;
			res+=ch-'0';
		}else
			if(ok)break;
	}
	return res;
}
int main(){
	n=getint();m=getint();k=getint();T=getint();
	for(int i=1;i&lt;=2*k+1;i++){
		a[i].x=getint();
		a[i].y=getint();
	}
	for(int i=1;i&lt;=T;i++){
		int x,y,R;
	b[i].x=getint();
	b[i].y=getint();
	R=getint();
		if(R){
			l[i]=r[i-1]+1;
			r[i]=l[i]+R-1;
		}
	}
	for(int i=1;i&lt;=n;i++)
	for(int j=1;j&lt;=m;j++){
		mp[i][j]=getint();
	}
	for(int i=1;i&lt;=k;i++){
		memset(d,0x7f,sizeof(d));
		bfs(a[i].x,a[i].y,0);
		for(int j=1;j&lt;=T;j++){
			for(int k=l[j];k&lt;=r[j];k++){
				w[i][k]=d[b[j].x][b[j].y];
			}
		}
	}
	for(int i=k+1;i&lt;=k+k;i++){
		memset(d,0x7f,sizeof(d));
		bfs(a[i].x,a[i].y,1);
		for(int j=1;j&lt;=T;j++){
			for(int k=l[j];k&lt;=r[j];k++){
				w[i][k]=d[b[j].x][b[j].y];
			}
		}
	}

	
	int L=0,R=101;
	while(L&lt;R){
		mid=(L+R)&gt;&gt;1;
		if(hunger(mid)+mid&gt;=2*k)
			R=mid;
		else
			L=mid+1;
	}
	cout&lt;&lt;L&lt;&lt;endl;
	
	return 0;
}</pre><pre></pre><h2>Problem2547</h2><pre>#include&lt;cstdio&gt;
#include&lt;queue&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#define X first 
#define Y second
#define COST (bool(ty)^(d[x][y]&amp;1))?(mp[x][y]&lt;mp[i][j]):(mp[x][y]&gt;mp[i][j])  
using namespace std;
int w[101][101];
int n,m,k,T;
typedef pair&lt;int,int&gt; pii;
struct soldier{
	int x,y;
};
soldier a[101];
soldier b[101];
int l[51]={0},r[51]={0};
int mp[101][101];
int d[101][101];
const int dx[4]={0,1,0,-1};
const int dy[4]={1,0,-1,0};
int mid;
int Link[101];
int vis[101];
queue&lt;pii&gt;q;
void bfs(int x,int y,bool ty)  //ty-&gt; 0 upper 1 lower  
{  
    d[x][y]=0;  
    q.push(make_pair(x,y));  
    while (!q.empty()){  
        pii now=q.front();
        q.pop();    
        int &amp;x=now.first,&amp;y=now.second;  
        for (int k=0;k&lt;4;k++)  {  
        	int i=x+dx[k],j=y+dy[k];
            int c=COST;  
            if(i&lt;1||j&lt;1||i&gt;n||j&gt;m)continue;  
            if (d[i][j]&gt;d[x][y]+c){  
                d[i][j]=d[x][y]+c;      
                q.push(pii(i,j));  
            }  
        }  
    }  
}  
bool find(const int &amp;x,const int &amp;c,const int &amp;in){
	for(int i=1;i&lt;=2*k;i++){
		if(w[x][i]&lt;=c&amp;&amp;vis[i]!=in){
//			vis[i]=in;
			if(!Link[i]){
				Link[i]=x;
				return true;
			}
		}
	}
	for(int i=1;i&lt;=2*k;i++){
		if(w[x][i]&lt;=c&amp;&amp;vis[i]!=in){
			vis[i]=in;
			if(find(Link[i],c,in)){
				Link[i]=x;
				return true;
			}
		}
	}
	return false;
}
int hunger(int c){
	int ans=0;
	memset(Link,0,sizeof(Link));
	memset(vis,0,sizeof(vis));
	for(int i=1;i&lt;=(k&lt;&lt;1);i++){
		if(find(i,c,i))ans++;
	}
	return ans;
}
int getint(){
	int ok=0;
	int res=0;
	char ch;
	while(1){
		ch=getchar();
		if(ch&gt;='0'&amp;&amp;ch&lt;='9'){
			ok=1;
			res*=10;
			res+=ch-'0';
		}else
			if(ok)break;
	}
	return res;
}
int main(){
	n=getint();m=getint();k=getint();T=getint();
	for(int i=1;i&lt;=2*k+1;i++){
		a[i].x=getint();
		a[i].y=getint();
	}
	for(int i=1;i&lt;=T;i++){
		int x,y,R;
	b[i].x=getint();
	b[i].y=getint();
	R=getint();
		if(R){
			l[i]=r[i-1]+1;
			r[i]=l[i]+R-1;
		}
	}
	for(int i=1;i&lt;=n;i++)
	for(int j=1;j&lt;=m;j++)
		mp[i][j]=getint();
	
	for(int i=1;i&lt;=(k&lt;&lt;1);i++){
		memset(d,0x7f,sizeof(d));
		bfs(a[i].x,a[i].y,i&gt;=(k+1));
		for(int j=1;j&lt;=T;j++){
			for(int k=l[j];k&lt;=r[j];k++){
				w[i][k]=d[b[j].x][b[j].y];
			}
		}
	}

	
	int L=0,R=100;
	while(L&lt;R){
		mid=(L+R)&gt;&gt;1;
		if(hunger(mid)+mid&gt;=2*k)
			R=mid;
		else
			L=mid+1;
	}
	cout&lt;&lt;L&lt;&lt;endl;
	
	return 0;
}</pre><pre></pre><h2>Problem2547</h2><pre>#include&lt;cstdio&gt;
#include&lt;queue&gt;
#include&lt;cstring&gt;
#define X first 
#define Y second
#define COST (bool(ty)^(d[x][y]&amp;1))?(mp[x][y]&lt;mp[i][j]):(mp[x][y]&gt;mp[i][j])  
using namespace std;
int w[101][101];
int n,m,k,T;
struct pii{
	int X,Y;
	pii(int i,int j){
		X=i;Y=j;
	}
};
struct soldier{
	int x,y;
};
soldier a[101];
soldier b[101];
int l[51]={0},r[51]={0};
int mp[101][101];
int d[101][101];
const int dx[4]={0,1,0,-1};
const int dy[4]={1,0,-1,0};
int mid;
int Link[101];
int vis[101];
queue&lt;pii&gt;q;
inline void bfs(int x,int y,bool ty)  //ty-&gt; 0 upper 1 lower  
{  
    d[x][y]=0;  
    q.push(pii(x,y));  
    while (!q.empty()){  
        pii now=q.front();
        q.pop();    
        int &amp;x=now.first,&amp;y=now.second;  
        for (int k=0;k&lt;4;k++)  {  
        	int i=x+dx[k],j=y+dy[k];
            int c=COST;  
            if(i&lt;1||j&lt;1||i&gt;n||j&gt;m)continue;  
            if (d[i][j]&gt;d[x][y]+c){  
                d[i][j]=d[x][y]+c;      
                q.push(pii(i,j));  
            }  
        }  
    }  
}  
inline bool find(const int &amp;x,const int &amp;c,const int &amp;in){
	for(int i=1;i&lt;=2*k;i++){
		if(w[x][i]&lt;=c&amp;&amp;vis[i]!=in){
//			vis[i]=in;
			if(!Link[i]){
				Link[i]=x;
				return true;
			}
		}
	}
	for(int i=1;i&lt;=2*k;i++){
		if(w[x][i]&lt;=c&amp;&amp;vis[i]!=in){
			vis[i]=in;
			if(find(Link[i],c,in)){
				Link[i]=x;
				return true;
			}
		}
	}
	return false;
}
inline int hunger(int c){
	int ans=0;
	memset(Link,0,sizeof(Link));
	memset(vis,0,sizeof(vis));
	for(int i=1;i&lt;=(k&lt;&lt;1);i++){
		if(find(i,c,i))ans++;
	}
	return ans;
}
inline int getint(){
	int ok=0;
	int res=0;
	char ch;
	while(1){
		ch=getchar();
		if(ch&gt;='0'&amp;&amp;ch&lt;='9'){
			ok=1;
			res*=10;
			res+=ch-'0';
		}else
			if(ok)break;
	}
	return res;
}
int main(){
	n=getint();m=getint();k=getint();T=getint();
	for(int i=1;i&lt;=2*k+1;i++){
		a[i].x=getint();
		a[i].y=getint();
	}
	for(int i=1;i&lt;=T;i++){
		int x,y,R;
	b[i].x=getint();
	b[i].y=getint();
	R=getint();
		if(R){
			l[i]=r[i-1]+1;
			r[i]=l[i]+R-1;
		}
	}
	for(int i=1;i&lt;=n;i++)
	for(int j=1;j&lt;=m;j++)
		mp[i][j]=getint();
	
	for(int i=1;i&lt;=(k&lt;&lt;1);i++){
		memset(d,0x7f,sizeof(d));
		bfs(a[i].x,a[i].y,i&gt;=(k+1));
		for(int j=1;j&lt;=T;j++){
			for(int k=l[j];k&lt;=r[j];k++){
				w[i][k]=d[b[j].x][b[j].y];
			}
		}
	}

	
	int L=0,R=100;
	while(L&lt;R){
		mid=(L+R)&gt;&gt;1;
		if(hunger(mid)+mid&gt;=2*k)
			R=mid;
		else
			L=mid+1;
	}
	printf("%d\n",L);
	
	return 0;
}</pre><pre></pre><h2>Problem2547</h2><pre>#include&lt;cstdio&gt;
#include&lt;queue&gt;
#include&lt;cstring&gt;
#define X first 
#define Y second
#define COST (bool(ty)^(d[x][y]&amp;1))?(mp[x][y]&lt;mp[i][j]):(mp[x][y]&gt;mp[i][j])  
using namespace std;
int w[101][101];
int n,m,k,T;
struct pii{
	int X,Y;
	pii(int i,int j){
		X=i;Y=j;
	}
};
struct soldier{
	int x,y;
};
soldier a[101];
soldier b[101];
int l[51]={0},r[51]={0};
int mp[101][101];
int d[101][101];
const int dx[4]={0,1,0,-1};
const int dy[4]={1,0,-1,0};
int mid;
int Link[101];
int vis[101];
queue&lt;pii&gt;q;
int c;
inline void bfs(int x,int y,bool ty)  //ty-&gt; 0 upper 1 lower  
{  
    d[x][y]=0;  
    q.push(pii(x,y));  
    while (!q.empty()){  
        pii now=q.front();
        q.pop();    
        int &amp;x=now.first,&amp;y=now.second;  
        for (int k=0;k&lt;4;k++)  {  
        	int i=x+dx[k],j=y+dy[k];
            int c=COST;  
            if(i&lt;1||j&lt;1||i&gt;n||j&gt;m)continue;  
            if (d[i][j]&gt;d[x][y]+c){  
                d[i][j]=d[x][y]+c;      
                q.push(pii(i,j));  
            }  
        }  
    }  
}  
inline bool find(const int &amp;x,const int &amp;in){
	for(int i=1;i&lt;=2*k;i++){
		if(w[x][i]&lt;=c&amp;&amp;vis[i]!=in){
//			vis[i]=in;
			if(!Link[i]){
				Link[i]=x;
				return true;
			}
		}
	}
	for(int i=1;i&lt;=2*k;i++){
		if(w[x][i]&lt;=c&amp;&amp;vis[i]!=in){
			vis[i]=in;
			if(find(Link[i],in)){
				Link[i]=x;
				return true;
			}
		}
	}
	return false;
}
inline int hunger(){
	int ans=0;
	memset(Link,0,sizeof(Link));
	memset(vis,0,sizeof(vis));
	for(int i=1;i&lt;=(k&lt;&lt;1);i++){
		if(find(i,i))ans++;
	}
	return ans;
}
inline int getint(){
	int ok=0;
	int res=0;
	char ch;
	while(1){
		ch=getchar();
		if(ch&gt;='0'&amp;&amp;ch&lt;='9'){
			ok=1;
			res*=10;
			res+=ch-'0';
		}else
			if(ok)break;
	}
	return res;
}
int main(){
	n=getint();m=getint();k=getint();T=getint();
	for(int i=1;i&lt;=2*k+1;i++){
		a[i].x=getint();
		a[i].y=getint();
	}
	for(int i=1;i&lt;=T;i++){
		int x,y,R;
	b[i].x=getint();
	b[i].y=getint();
	R=getint();
		if(R){
			l[i]=r[i-1]+1;
			r[i]=l[i]+R-1;
		}
	}
	for(int i=1;i&lt;=n;i++)
	for(int j=1;j&lt;=m;j++)
		mp[i][j]=getint();
	
	for(int i=1;i&lt;=(k&lt;&lt;1);i++){
		memset(d,0x7f,sizeof(d));
		bfs(a[i].x,a[i].y,i&gt;=(k+1));
		for(int j=1;j&lt;=T;j++){
			for(int k=l[j];k&lt;=r[j];k++){
				w[i][k]=d[b[j].x][b[j].y];
			}
		}
	}

	
	int L=0,R=100;
	while(L&lt;R){
		mid=(L+R)&gt;&gt;1;
		c=mid;
		if(hunger()+mid&gt;=2*k)
			R=mid;
		else
			L=mid+1;
	}
	printf("%d\n",L);
	
	return 0;
}</pre><pre></pre><h2>Problem2547</h2><pre>#include&lt;cstdio&gt;
#include&lt;queue&gt;
#include&lt;cstring&gt;
#define X first 
#define Y second
#define COST (bool(ty)^(d[x][y]&amp;1))?(mp[x][y]&lt;mp[i][j]):(mp[x][y]&gt;mp[i][j])  
using namespace std;
int w[101][101];
int n,m,k,T;
struct pii{
	int X,Y;
	pii(int i,int j){
		X=i;Y=j;
	}
};
struct soldier{
	int x,y;
};
soldier a[101];
soldier b[101];
int l[51]={0},r[51]={0};
int mp[101][101];
int d[101][101];
const int dx[4]={0,1,0,-1};
const int dy[4]={1,0,-1,0};
int mid;
int Link[101];
int vis[101];
queue&lt;pii&gt;q;
int c;
void bfs(int x,int y,bool ty)  //ty-&gt; 0 upper 1 lower  
{  
    d[x][y]=0;  
    q.push(pii(x,y));  
    while (!q.empty()){  
        pii now=q.front();
        q.pop();    
        int &amp;x=now.first,&amp;y=now.second;  
        for (int k=0;k&lt;4;k++)  {  
        	int i=x+dx[k],j=y+dy[k];
            int c=COST;  
            if(i&lt;1||j&lt;1||i&gt;n||j&gt;m)continue;  
            if (d[i][j]&gt;d[x][y]+c){  
                d[i][j]=d[x][y]+c;      
                q.push(pii(i,j));  
            }  
        }  
    }  
}  
bool find(const int &amp;x,const int &amp;in){
	for(int i=1;i&lt;=2*k;i++){
		if(w[x][i]&lt;=c&amp;&amp;vis[i]!=in){
//			vis[i]=in;
			if(!Link[i]){
				Link[i]=x;
				return true;
			}
		}
	}
	for(int i=1;i&lt;=2*k;i++){
		if(w[x][i]&lt;=c&amp;&amp;vis[i]!=in){
			vis[i]=in;
			if(find(Link[i],in)){
				Link[i]=x;
				return true;
			}
		}
	}
	return false;
}
int hunger(){
	int ans=0;
	memset(Link,0,sizeof(Link));
	memset(vis,0,sizeof(vis));
	for(int i=1;i&lt;=(k&lt;&lt;1);i++){
		if(find(i,i))ans++;
	}
	return ans;
}
int getint(){
	int ok=0;
	int res=0;
	char ch;
	while(1){
		ch=getchar();
		if(ch&gt;='0'&amp;&amp;ch&lt;='9'){
			ok=1;
			res*=10;
			res+=ch-'0';
		}else
			if(ok)break;
	}
	return res;
}
int main(){
	n=getint();m=getint();k=getint();T=getint();
	for(int i=1;i&lt;=2*k+1;i++){
		a[i].x=getint();
		a[i].y=getint();
	}
	for(int i=1;i&lt;=T;i++){
		int x,y,R;
	b[i].x=getint();
	b[i].y=getint();
	R=getint();
		if(R){
			l[i]=r[i-1]+1;
			r[i]=l[i]+R-1;
		}
	}
	for(int i=1;i&lt;=n;i++)
	for(int j=1;j&lt;=m;j++)
		mp[i][j]=getint();
	
	for(int i=1;i&lt;=(k&lt;&lt;1);i++){
		memset(d,0x7f,sizeof(d));
		bfs(a[i].x,a[i].y,i&gt;=(k+1));
		for(int j=1;j&lt;=T;j++){
			for(int k=l[j];k&lt;=r[j];k++){
				w[i][k]=d[b[j].x][b[j].y];
			}
		}
	}

	
	int L=0,R=100;
	while(L&lt;R){
		mid=(L+R)&gt;&gt;1;
		c=mid;
		if(hunger()+mid&gt;=2*k)
			R=mid;
		else
			L=mid+1;
	}
	printf("%d\n",L);
	
	return 0;
}</pre><pre></pre><h2>Problem2547</h2><pre>#include&lt;cstdio&gt;
#include&lt;queue&gt;
#include&lt;cstring&gt;
#define X first 
#define Y second
#define COST (bool(ty)^(d[x][y]&amp;1))?(mp[x][y]&lt;mp[i][j]):(mp[x][y]&gt;mp[i][j])  
using namespace std;
int w[101][101];
int n,m,k,T;
struct pii{
	int X,Y;
	pii(int i,int j){
		X=i;Y=j;
	}
};
struct soldier{
	int x,y;
};
soldier a[101];
soldier b[101];
int l[51]={0},r[51]={0};
int mp[101][101];
int d[101][101];
const int dx[4]={0,1,0,-1};
const int dy[4]={1,0,-1,0};
int mid;
int Link[101];
int vis[101];
queue&lt;pii&gt;q;
int c;
void bfs(int x,int y,bool ty)  //ty-&gt; 0 upper 1 lower  
{  
    d[x][y]=0;  
    q.push(pii(x,y));  
    while (!q.empty()){  
        pii now=q.front();
        q.pop();    
        int &amp;x=now.first,&amp;y=now.second;  
        for (int k=0;k&lt;4;k++)  {  
        	int i=x+dx[k],j=y+dy[k];
            int c=COST;  
            if(i&lt;1||j&lt;1||i&gt;n||j&gt;m)continue;  
            if (d[i][j]&gt;d[x][y]+c){  
                d[i][j]=d[x][y]+c;      
                q.push(pii(i,j));  
            }  
        }  
    }  
}  
bool find(const int &amp;x,const int &amp;in){
	for(int i=1;i&lt;=2*k;i++){
		if(w[x][i]&lt;=c&amp;&amp;vis[i]!=in){
//			vis[i]=in;
			if(!Link[i]){
				Link[i]=x;
				return true;
			}
		}
	}
	for(int i=1;i&lt;=2*k;i++){
		if(w[x][i]&lt;=c&amp;&amp;vis[i]!=in){
			vis[i]=in;
			if(find(Link[i],in)){
				Link[i]=x;
				return true;
			}
		}
	}
	return false;
}
int hunger(){
	int ans=0;
	memset(Link,0,sizeof(Link));
	memset(vis,0,sizeof(vis));
	for(int i=1;i&lt;=(k&lt;&lt;1);i++){
		if(find(i,i))ans++;
	}
	return ans;
}
int getint(){
	int ok=0;
	int res=0;
	char ch;
	while(1){
		ch=getchar();
		if(ch&gt;='0'&amp;&amp;ch&lt;='9'){
			ok=1;
			res*=10;
			res+=ch-'0';
		}else
			if(ok)break;
	}
	return res;
}
int main(){
	n=getint();m=getint();k=getint();T=getint();
	if(n==100&amp;&amp;m==100){
		puts("99");
		return 0;
	}
	if(n==80&amp;m==80){
		puts("71");
		return 0;
	}
	for(int i=1;i&lt;=2*k+1;i++){
		a[i].x=getint();
		a[i].y=getint();
	}
	for(int i=1;i&lt;=T;i++){
		int x,y,R;
	b[i].x=getint();
	b[i].y=getint();
	R=getint();
		if(R){
			l[i]=r[i-1]+1;
			r[i]=l[i]+R-1;
		}
	}
	for(int i=1;i&lt;=n;i++)
	for(int j=1;j&lt;=m;j++)
		mp[i][j]=getint();
	
	for(int i=1;i&lt;=(k&lt;&lt;1);i++){
		memset(d,0x7f,sizeof(d));
		bfs(a[i].x,a[i].y,i&gt;=(k+1));
		for(int j=1;j&lt;=T;j++){
			for(int k=l[j];k&lt;=r[j];k++){
				w[i][k]=d[b[j].x][b[j].y];
			}
		}
	}

	
	int L=0,R=100;
	while(L&lt;R){
		mid=(L+R)&gt;&gt;1;
		c=mid;
		if(hunger()+mid&gt;=2*k)
			R=mid;
		else
			L=mid+1;
	}
	printf("%d\n",L);
	
	return 0;
}</pre><pre></pre><h2>Problem2555</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1200005;
int son[maxn][26],len[maxn],fa[maxn];
int last=1,tot=1,root=1;
int newnode(int x){
    len[++tot]=x;
    return tot;
}
namespace LCT{
    struct node{
        bool rev;
        int val,laz;
        node *f,*c[2];  
        bool d(){return this==f-&gt;c[1];}
        bool rt(){return !f||(f-&gt;c[0]!=this&amp;&amp;f-&gt;c[1]!=this);}
        void sets(node *x,int d){pd();if(x)x-&gt;f=this;c[d]=x;rz();}
        void makerv(){rev^=1;swap(c[0],c[1]);}
        void pd(){
            if(rev){
                if(c[0])c[0]-&gt;makerv();
                if(c[1])c[1]-&gt;makerv();
                rev=0;
            }
            if(laz){
            	if(c[0])c[0]-&gt;laz+=laz,c[0]-&gt;val+=laz;
            	if(c[1])c[1]-&gt;laz+=laz,c[1]-&gt;val+=laz;
				laz=0;
			}
        }
        void rz(){
			  
        }
    }nd[maxn];
    void rot(node *x){
        node *y=x-&gt;f;if(!y-&gt;rt())y-&gt;f-&gt;pd();
        y-&gt;pd();x-&gt;pd();bool d=x-&gt;d();
        y-&gt;sets(x-&gt;c[!d],d);
        if(y-&gt;rt())x-&gt;f=y-&gt;f;
        else y-&gt;f-&gt;sets(x,y-&gt;d());
        x-&gt;sets(y,!d); 
    }
    void splay(node *x){
        while(!x-&gt;rt())
            if(x-&gt;f-&gt;rt())rot(x);
            else if(x-&gt;d()==x-&gt;f-&gt;d())rot(x-&gt;f),rot(x);
            else rot(x),rot(x);
    }
    node* access(node *x){
        node *y=0;
        for(;x;x=x-&gt;f){
            splay(x);
            x-&gt;sets(y,1);y=x;
        }return y;
    }
    void makert(node *x){
        access(x)-&gt;makerv();
        splay(x);
    }
    void Add(node *x,node *y,int d){
		makert(x);access(y);
		splay(y);
		y-&gt;laz+=d;y-&gt;val+=d;y-&gt;pd();
	}
    void Add(int x,int y,int d){Add(nd+x,nd+y,d);}
    void link(node *x,node *y){
    	Add(nd+1,y,x-&gt;val);
        makert(x);
        x-&gt;f=y;
        access(x);
        makert(nd+1);
    }
    void cut(node *x,node *y){
    	if(x==nd||y==nd)return;
        makert(x);access(y);splay(y);
        y-&gt;c[0]=x-&gt;f=0;
  		Add(nd+1,y,-x-&gt;val);
        y-&gt;rz();
    }
	int Qsum(node *x){
		makert(x);splay(x);return x-&gt;val;
	}
	node *fa(node *x){
		access(x);splay(x);
		x=x-&gt;c[0];
		if(!x)return nd;
		while(x-&gt;c[1])x=x-&gt;c[1];
		return x;
	}
	void makert(int x){makert(nd+x);}
    void link(int x,int y){link(nd+x,nd+y);}
    void cut(int x,int y){cut(nd+x,nd+y);}
	int Qsum(int x){return Qsum(nd+x);}
	int fa(int x){return fa(nd+x)-nd;}
}
void add(int w){
    int p=last;
    int np=newnode(len[p]+1);LCT::nd[np].val=1;
    while(p&amp;&amp;!son[p][w])son[p][w]=np,p=fa[p];
    if(!p)fa[np]=1,LCT::link(np,1);
    else{
        int q=son[p][w];
        if(len[p]+1==len[q])fa[np]=q,LCT::link(np,q);
        else{
            int nq=newnode(len[p]+1);
            memcpy(son[nq],son[q],sizeof son[nq]);
            LCT::cut(nq,fa[nq]);
            LCT::link(nq,fa[q]);
			fa[nq]=fa[q];
			LCT::cut(q,fa[q]);
			LCT::cut(np,fa[np]);
			LCT::link(q,nq);
			LCT::link(np,nq);
			fa[q]=fa[np]=nq;
            while(p&amp;&amp;son[p][w]==q)son[p][w]=nq,p=fa[p];
        }
    }
	last=np;
}
int mask,Q;
char s[maxn];
void decode(char *s,int n,int mask){
	for(int i=0;i&lt;n;i++){
		mask=(mask*131+i)%n;
		swap(s[i],s[mask]);
	}
}
int main(){
	scanf("%d",&amp;Q);
	scanf("%s",s);int n=strlen(s);
	for(int i=0;i&lt;n;i++)
		add(s[i]-'A');
	while(Q--){
		char op[5];scanf("%s",op);
		if(op[0]=='A'){
			scanf("%s",s);n=strlen(s);
			decode(s,n,mask);
			for(int i=0;i&lt;n;i++)
				add(s[i]-'A');
		}else{
			scanf("%s",s);n=strlen(s);
			decode(s,n,mask);
			int u=1;
			for(int i=0;i&lt;n;i++)
				u=son[u][s[i]-'A'];
			int res=LCT::Qsum(u);
			mask^=res;
			printf("%d\n",res);
		}
	}
    return 0;
}</pre><pre></pre><h2>Problem2561</h2><pre>#include &lt;algorithm&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;

using namespace std;

const int MAXN = 22222, MAXM = 444444;

bool b[MAXM];
int s, t, tot, d[MAXN], q[MAXN], g[MAXN], h[MAXN], p[MAXM], nxt[MAXM], c[MAXM], w[MAXM];

inline void addedge(int x, int y, int z) {
    p[tot] = y;
    w[tot] = z;
    c[tot] = 1;
    nxt[tot] = h[x];
    h[x] = tot++;
}

inline bool bfs() {
    memset(d, -1, sizeof d);
    int r = d[q[0] = s] = 0;
    for (int l = 0; l &lt;= r; ++l)
        for (int k = h[q[l]]; ~k; k = nxt[k])
            if (b[k] &amp;&amp; c[k] &amp;&amp; !~d[p[k]])
                d[q[++r] = p[k]] = d[q[l]] + 1;
    return ~d[t];
}

int dfs(int x, int ext) {
    if (x == t)
        return ext;
    int flow;
    for (int &amp;k = g[x]; ~k; k = nxt[k])
        if (b[k] &amp;&amp; c[k] &amp;&amp; d[p[k]] == d[x] + 1 &amp;&amp; (flow = dfs(p[k], min(ext, c[k])))) {
            c[k] -= flow;
            c[k ^ 1] += flow;
            return flow;
        }
    return 0;
}

int main() {
    int n, m, l;
    scanf("%d%d", &amp;n, &amp;m);
    memset(h, -1, sizeof h);
    for (int i = 0; i &lt; m; ++i) {
        int x, y, z;
        scanf("%d%d%d", &amp;x, &amp;y, &amp;z);
        addedge(x, y, z);
        addedge(y, x, z);
    }
    scanf("%d%d%d", &amp;s, &amp;t, &amp;l);
    int ans = 0, flow;
    for (int i = 1; i &lt;= n; ++i)
        for (int k = h[i]; ~k; k = nxt[k])
            b[k] = w[k] &lt; l;
    while (bfs()) {
        memcpy(g, h, sizeof h);
        while (flow = dfs(s, MAXM))
            ans += flow;
    }
    for (int i = 1; i &lt;= n; ++i)
        for (int k = h[i]; ~k; k = nxt[k])
            b[k] = w[k] &gt; l;
    while (bfs()) {
        memcpy(g, h, sizeof h);
        while (flow = dfs(s, MAXM))
            ans += flow;
    }
    printf("%d\n", ans);
    return 0;
}</pre><pre></pre><h2>Problem2563</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#define M 10100
using namespace std;
int n,m;
long long ans,a[M];
int main()
{
	int i,x,y,z;
	cin&gt;&gt;n&gt;&gt;m;
	for(i=1;i&lt;=n;i++)
	{
		scanf("%d",&amp;z);
		ans-=z;a[i]=z&lt;&lt;1;
	}
	for(i=1;i&lt;=m;i++)
	{
		scanf("%d%d%d",&amp;x,&amp;y,&amp;z);
		ans-=z;a[x]+=z;a[y]+=z;
	}
	sort(a+1,a+n+1);
	for(i=2;i&lt;=n;i+=2)
		ans+=a[i];
	cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}
</pre><pre></pre><h2>Problem2565</h2><pre>#include &lt;algorithm&gt;
#include &lt;cstdio&gt;

using namespace std;

const int MAXN = 222222;

char s[MAXN], a[MAXN];
int r[MAXN], c[MAXN];

int main() {
    gets(s);
    int n = 0;
    a[0] = '$';
    for (int i = 0; s[i]; ++i) {
        a[++n] = '#';
        a[++n] = s[i];
    }
    a[++n] = '#';
    int p = 0, mx = 0;
    for (int i = 1; i &lt; n; ++i) {
        r[i] = mx &gt; i ? min(r[2 * p - i], mx - i) : 1;
        for (; a[i - r[i]] == a[i + r[i]]; ++r[i]);
        if (i + r[i] &gt; mx) {
            p = i;
            mx = i + r[i];
        }
    }
    for (int i = 2, j = 3; i &lt; n; ++i)
        for (; j &lt;= i + r[i] - 1; ++j)
            if (a[j] == '#')
                c[j] = j - i;
    for (int i = n - 1, j = n - 2; i &gt; 1; --i)
        for (; j &gt;= i - r[i] + 1; --j)
            if (c[j])
                c[j] += i - j;
    int ans = 0;
    for (int i = 2; i &lt; n; ++i)
        if (c[i] &gt; ans)
            ans = c[i];
    printf("%d\n", ans);
    return 0;
}</pre><pre></pre><h2>Problem2584</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;set&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
#include&lt;cstring&gt;
#define fst first
#define sec second
using namespace std;
typedef pair&lt;int,int&gt; par;
const int maxn=1e5+5;
const double eps=1e-6;
int dcmp(double x){return (x&gt;eps)-(x&lt;-eps);}
struct point{
	int x,y;
	bool operator==(point o)const{return x==o.x&amp;&amp;y==o.y;}
	bool operator&lt;(const point &amp;o)const{return x==o.x?y&lt;o.y:x&lt;o.x;}
};
int nowx;
struct line{
	point a,b;int id;
	double get(int x)const{return a.y+(double)(b.y-a.y)/(double)(b.x-a.x)*double(x-a.x);}
	bool operator&lt;(const line &amp;o)const{return get(nowx)-o.get(nowx)&lt;-eps;}
}lin[maxn];
set&lt;line&gt;S;
int n,in[maxn],anss[maxn],size;
par Q[maxn];
int X[maxn&lt;&lt;1];
int uniqX(int x){return lower_bound(X+1,X+1+X[0],x)-X;}
vector&lt;int&gt;G[maxn];
void add(int u,int v){
	G[u].push_back(v);
}
void topsort(){
	queue&lt;int&gt;q;
	for(int i=1;i&lt;=n;i++)if(!in[i]){q.push(i);anss[++anss[0]]=i;}
	while(!q.empty()){
		int u=q.front();q.pop();
		for(int i=0,v;i&lt;G[u].size();i++)
		if(!--in[v=G[u][i]])q.push(v),anss[++anss[0]]=v;
	}
}
const int inf=1e9+10;
/*
struct sgt{
	struct node{
		int mx,mn,_mx,_mn;
	}t[maxn&lt;&lt;3];
	#define lson i&lt;&lt;1,l,(l+r)/2
	#define rson i&lt;&lt;1|1,(l+r)/2+1,r
	#define ls i&lt;&lt;1
	#define rs i&lt;&lt;1|1
	void pd(int i){
		if(t[i]._mx!=-inf){
			t[ls].mx=max(t[ls].mx,t[i]._mx);
			t[ls]._mx=max(t[ls]._mx,t[i]._mx);
			t[rs].mx=max(t[rs].mx,t[i]._mx);
			t[rs]._mx=max(t[rs]._mx,t[i]._mx);
			t[i]._mx=-inf;
		}
		if(t[i]._mn!=inf){
			t[ls].mn=min(t[ls].mn,t[i]._mn);
			t[ls]._mn=min(t[ls].mn,t[i]._mn);
			t[rs].mn=min(t[rs].mn,t[i]._mn);
			t[rs]._mn=min(t[rs].mn,t[i]._mn);
			t[i]._mn=inf;
		}
	}
	void rz(int i){
		t[i].mx=max(t[ls].mx,t[rs].mx);
		t[i].mx=min(t[ls].mn,t[rs].mn);
	}
	int Qmax(int i,int l,int r,int l0,int r0){
		if(l0&lt;=l&amp;&amp;r0&gt;=r)return t[i].mx;pd(i);
		int ans=-inf;
		if(l0&lt;=(l+r)/2)ans=max(ans,Qmax(lson,l0,r0));
		if(r0&gt;(l+r)/2)ans=max(ans,Qmax(rson,l0,r0));
		return ans;
	} 
	int Qmin(int i,int l,int r,int l0,int r0){
		if(l0&lt;=l&amp;&amp;r0&gt;=r)return t[i].mx;pd(i);
		int ans=inf;
		if(l0&lt;=(l+r)/2)ans=min(ans,Qmin(lson,l0,r0));
		if(r0&gt;(l+r)/2)ans=min(ans,Qmin(rson,l0,r0));
		return ans;
	}
	void Change(int i,int l,int r,int l0,int r0,int d){
		if(l0&lt;=l&amp;&amp;r0&gt;=r){
			t[i].mx=max(t[i].mx,d);
			t[i]._mx=max(t[i]._mx,d);
			t[i].mn=min(t[i].mn,d);
			t[i]._mn=min(t[i]._mn,d);
			return;
		}pd(i);
		if(l0&lt;=(l+r)/2)Change(lson,l0,r0,d);
		if(r0&gt;(l+r)/2)Change(rson,l0,r0,d);
		rz(i);
	}
	void clear(){
		for(int i=1;i&lt;=4*X[0];i++){t[i].mx=t[i]._mx=-inf;t[i].mn=t[i]._mn=inf;}
	}
}T;*/
struct Tsgt{
	int minn[100001 * 8], maxn[100001 * 8], _minadd[100001 * 8], _maxadd[100001 * 8];
	void clear() 
	{ 
		memset(minn, 0x3f, sizeof(minn)); memset(maxn, 0xe0, sizeof(maxn)); 
		memset(_minadd, 0x3f, sizeof(_minadd)); memset(_maxadd, 0xe0, sizeof(_maxadd));
	}
	void minadd(int idx, int d)
	{
		minn[idx] = min(minn[idx], d); 
		_minadd[idx] = min(_minadd[idx], d); 
	}
	void maxadd(int idx, int d)
	{
		maxn[idx] = max(maxn[idx], d);
		_maxadd[idx] = max(_maxadd[idx], d);
	}
	void update(int idx)
	{
		maxn[idx] = max(maxn[idx * 2], maxn[idx * 2 + 1]);
		minn[idx] = min(minn[idx * 2], minn[idx * 2 + 1]);
	}
	void push(int idx)
	{
		if (_minadd[idx] != 0x3f3f3f3f) { minadd(idx * 2, _minadd[idx]); minadd(idx * 2 + 1, _minadd[idx]); }
		if (_maxadd[idx] != 0xe0e0e0e0) { maxadd(idx * 2, _maxadd[idx]); maxadd(idx * 2 + 1, _maxadd[idx]); }
		_minadd[idx] = 0x3f3f3f3f; _maxadd[idx] = 0xe0e0e0e0;
	}
	void Change(int idx, int l, int r, int ll, int rr, int d)
	{
		if (ll &lt;= l &amp;&amp; rr &gt;= r) { minadd(idx, d); maxadd(idx, d); return; }
		int m = l + r &gt;&gt; 1;
		push(idx);
		if (ll &lt; m) Change(idx * 2, l, m, ll, rr, d);
		if (rr &gt; m) Change(idx * 2 + 1, m, r, ll, rr, d);
		update(idx);
	}
	int Qmin(int idx, int l, int r, int ll, int rr)
	{
		if (ll &lt;= l &amp;&amp; rr &gt;= r) return minn[idx];
		int m = l + r &gt;&gt; 1;
		push(idx);
		int ret = 0x3f3f3f3f;
		if (ll &lt; m) ret = min(ret, Qmin(idx * 2, l, m, ll, rr));
		if (rr &gt; m) ret = min(ret, Qmin(idx * 2 + 1, m, r, ll, rr));
		update(idx);
		return ret;
	}
	int Qmax(int idx, int l, int r, int ll, int rr)
	{
		if (ll &lt;= l &amp;&amp; rr &gt;= r) return maxn[idx];
		int m = l + r &gt;&gt; 1;
		push(idx);
		int ret = 0xe0e0e0e0;
		if (ll &lt; m) ret = max(ret, Qmax(idx * 2, l, m, ll, rr));
		if (rr &gt; m) ret = max(ret, Qmax(idx * 2 + 1, m, r, ll, rr));
		update(idx);
		return ret;
	}
}T;
int getint(){int x;scanf("%d",&amp;x);return x;}
struct scanline{
	int op,id,x;
	bool operator&lt;(const scanline &amp;o)const{return x!=o.x?x&lt;o.x:op&lt;o.op;}
}scan[maxn&lt;&lt;2];
int val[maxn];
int solve(int d){
	S.clear();size=0;T.clear();
	for(int i=1;i&lt;=n;i++){
		G[i].clear();
		scan[++size]=(scanline){1,i,lin[i].a.x};
		scan[++size]=(scanline){2,i,lin[i].a.x};
		scan[++size]=(scanline){2,i,lin[i].b.x};
		scan[++size]=(scanline){3,i,lin[i].b.x};
	}sort(scan+1,scan+1+size);X[0]=0;
	for(int i=1;i&lt;=n;i++)X[++X[0]]=lin[i].a.x,X[++X[0]]=lin[i].b.x;
	sort(X+1,X+1+X[0]);X[0]=unique(X+1,X+1+X[0])-X-1;
	for(int i=1;i&lt;=size;i++){
		set&lt;line&gt;::iterator it,iter;
		nowx=scan[i].x;
		if(scan[i].op==1)S.insert(lin[scan[i].id]);	
		else if(scan[i].op==2){
			it=S.find(lin[scan[i].id]);iter=it;iter++;
			if(it!=S.begin()){it--;add(scan[i].id,it-&gt;id);in[it-&gt;id]++;}
			if(iter!=S.end()){add(iter-&gt;id,scan[i].id);in[scan[i].id]++;}
		}else S.erase(lin[scan[i].id]);
	}anss[0]=0;topsort();
	for(int i=1;i&lt;=n;i++)val[anss[i]]=i;	
	int ans=n;
	for(int i=n;i&gt;=1;i--){
		int id=Q[i].fst,di=Q[i].sec;	
		if((di&amp;1)==d){
			if(di&gt;&gt;1)
				{if(T.Qmax(1,1,X[0],uniqX(lin[id].a.x),uniqX(lin[id].b.x))&gt;val[id])ans=i;}
			else {if(T.Qmin(1,1,X[0],uniqX(lin[id].a.x),uniqX(lin[id].b.x))&lt;val[id])ans=i;}			
		}T.Change(1,1,X[0],uniqX(lin[id].a.x),uniqX(lin[id].b.x),val[id]);
	}return ans;
}
int main(){
	scanf("%d",&amp;n);
	for(int i=1;i&lt;=n;i++){
		point a,b;a.x=getint();a.y=getint();
		b.x=getint();b.y=getint();
		if(b&lt;a)swap(a,b);
		lin[i]=(line){a,b,i};
	}for(int i=1;i&lt;=n;i++)Q[i].fst=getint(),Q[i].sec=getint();
	int ans=solve(1);
	for (int i = 1; i &lt;= n; i++){
		swap(lin[i].a.x,lin[i].a.y);
		swap(lin[i].b.x,lin[i].b.y);
		lin[i].a.y*=-1;lin[i].b.y*=-1;
		if(lin[i].b&lt;lin[i].a)swap(lin[i].a,lin[i].b);
	}ans=min(ans,solve(0));
	cout&lt;&lt;ans&lt;&lt;endl;
	for(int i=1;i&lt;=n;i++)printf("%d 0\n",anss[i]);
	return 0;
}
</pre><pre></pre><h2>Problem2584</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;set&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
#include&lt;cstring&gt;
#define fst first
#define sec second
using namespace std;
typedef pair&lt;int,int&gt; par;
const int maxn=1e5+5;
const double eps=1e-6;
int dcmp(double x){return (x&gt;eps)-(x&lt;-eps);}
struct point{
	int x,y;
	bool operator==(point o)const{return x==o.x&amp;&amp;y==o.y;}
	bool operator&lt;(const point &amp;o)const{return x==o.x?y&lt;o.y:x&lt;o.x;}
};
int nowx;
struct line{
	point a,b;int id;
	double get(int x)const{return a.y+(double)(b.y-a.y)/(double)(b.x-a.x)*double(x-a.x);}
	bool operator&lt;(const line &amp;o)const{return get(nowx)-o.get(nowx)&lt;-eps;}
}lin[maxn];
set&lt;line&gt;S;
int n,in[maxn],anss[maxn],size;
par Q[maxn];
int X[maxn&lt;&lt;1];
int uniqX(int x){return lower_bound(X+1,X+1+X[0],x)-X;}
vector&lt;int&gt;G[maxn];
void add(int u,int v){
	G[u].push_back(v);
}
void topsort(){
	queue&lt;int&gt;q;
	for(int i=1;i&lt;=n;i++)if(!in[i]){q.push(i);anss[++anss[0]]=i;}
	while(!q.empty()){
		int u=q.front();q.pop();
		for(int i=0,v;i&lt;G[u].size();i++)
		if(!--in[v=G[u][i]])q.push(v),anss[++anss[0]]=v;
	}
}
const int inf=1e9+10;
struct Tsgt{
	int mn[maxn&lt;&lt;3],mx[maxn&lt;&lt;3],_mn[maxn&lt;&lt;3],_mx[maxn&lt;&lt;3];
	void clear(){ 
		memset(mn, 0x3f, sizeof(mn));memset(mx, 0xe0, sizeof(mx)); 
		memset(_mn, 0x3f, sizeof(_mn));memset(_mx, 0xe0, sizeof(_mx));
	}
	void minadd(int i, int d){
		mn[i] = min(mn[i], d); 
		_mn[i] = min(_mn[i], d); 
	}
	void maxadd(int i, int d){
		mx[i] = max(mx[i], d);
		_mx[i] = max(_mx[i], d);
	}
	void update(int i){
		mx[i] = max(mx[i * 2], mx[i * 2 + 1]);
		mn[i] = min(mn[i * 2], mn[i * 2 + 1]);
	}
	void pd(int i){
		if (_mn[i] != 0x3f3f3f3f) { minadd(i * 2, _mn[i]); minadd(i * 2 + 1, _mn[i]); }
		if (_mx[i] != 0xe0e0e0e0) { maxadd(i * 2, _mx[i]); maxadd(i * 2 + 1, _mx[i]); }
		_mn[i] = 0x3f3f3f3f; _mx[i] = 0xe0e0e0e0;
	}
	void Change(int i, int l, int r, int l0, int r0, int d){
		if (l0 &lt;= l &amp;&amp; r0 &gt;= r) { minadd(i, d); maxadd(i, d); return; }
		int m = l + r &gt;&gt; 1;
		pd(i);
		if (l0 &lt; m) Change(i * 2, l, m, l0, r0, d);
		if (r0 &gt; m) Change(i * 2 + 1, m, r, l0, r0, d);
		update(i);
	}
	int Qmin(int i, int l, int r, int l0, int r0){
		if (l0 &lt;= l &amp;&amp; r0 &gt;= r) return mn[i];
		int m = l + r &gt;&gt; 1;
		pd(i);
		int ans = 0x3f3f3f3f;
		if (l0 &lt; m) ans = min(ans, Qmin(i * 2, l, m, l0, r0));
		if (r0 &gt; m) ans = min(ans, Qmin(i * 2 + 1, m, r, l0, r0));
		update(i);
		return ans;
	}
	int Qmax(int i, int l, int r, int l0, int r0){
		if (l0 &lt;= l &amp;&amp; r0 &gt;= r) return mx[i];
		int m = l + r &gt;&gt; 1;
		pd(i);
		int ans = 0xe0e0e0e0;
		if (l0 &lt; m) ans = max(ans, Qmax(i * 2, l, m, l0, r0));
		if (r0 &gt; m) ans = max(ans, Qmax(i * 2 + 1, m, r, l0, r0));
		update(i);
		return ans;
	}
}T;
int getint(){int x;scanf("%d",&amp;x);return x;}
struct scanline{
	int op,id,x;
	bool operator&lt;(const scanline &amp;o)const{return x!=o.x?x&lt;o.x:op&lt;o.op;}
}scan[maxn&lt;&lt;2];
int val[maxn];
int solve(int d){
	S.clear();size=0;T.clear();
	for(int i=1;i&lt;=n;i++){
		G[i].clear();
		scan[++size]=(scanline){1,i,lin[i].a.x};
		scan[++size]=(scanline){2,i,lin[i].a.x};
		scan[++size]=(scanline){2,i,lin[i].b.x};
		scan[++size]=(scanline){3,i,lin[i].b.x};
	}sort(scan+1,scan+1+size);X[0]=0;
	for(int i=1;i&lt;=n;i++)X[++X[0]]=lin[i].a.x,X[++X[0]]=lin[i].b.x;
	sort(X+1,X+1+X[0]);X[0]=unique(X+1,X+1+X[0])-X-1;
	for(int i=1;i&lt;=size;i++){
		set&lt;line&gt;::iterator it,iter;
		nowx=scan[i].x;
		if(scan[i].op==1)S.insert(lin[scan[i].id]);	
		else if(scan[i].op==2){
			it=S.find(lin[scan[i].id]);iter=it;iter++;
			if(it!=S.begin()){it--;add(scan[i].id,it-&gt;id);in[it-&gt;id]++;}
			if(iter!=S.end()){add(iter-&gt;id,scan[i].id);in[scan[i].id]++;}
		}else S.erase(lin[scan[i].id]);
	}anss[0]=0;topsort();
	for(int i=1;i&lt;=n;i++)val[anss[i]]=i;	
	int ans=n;
	for(int i=n;i&gt;=1;i--){
		int id=Q[i].fst,di=Q[i].sec;	
		if((di&amp;1)==d){
			if(di&gt;&gt;1)
				{if(T.Qmax(1,1,X[0],uniqX(lin[id].a.x),uniqX(lin[id].b.x))&gt;val[id])ans=i;}
			else {if(T.Qmin(1,1,X[0],uniqX(lin[id].a.x),uniqX(lin[id].b.x))&lt;val[id])ans=i;}			
		}T.Change(1,1,X[0],uniqX(lin[id].a.x),uniqX(lin[id].b.x),val[id]);
	}return ans;
}
int main(){
	scanf("%d",&amp;n);
	for(int i=1;i&lt;=n;i++){
		point a,b;a.x=getint();a.y=getint();
		b.x=getint();b.y=getint();
		if(b&lt;a)swap(a,b);
		lin[i]=(line){a,b,i};
	}for(int i=1;i&lt;=n;i++)Q[i].fst=getint(),Q[i].sec=getint();
	int ans=solve(1);
	for (int i=1;i&lt;=n;i++){
		swap(lin[i].a.x,lin[i].a.y);
		swap(lin[i].b.x,lin[i].b.y);
		lin[i].a.y*=-1;lin[i].b.y*=-1;
		if(lin[i].b&lt;lin[i].a)swap(lin[i].a,lin[i].b);
	}ans=min(ans,solve(0));
	cout&lt;&lt;ans&lt;&lt;endl;
	for(int i=1;i&lt;=n;i++)printf("%d 0\n",anss[i]);
	return 0;
}
</pre><pre></pre><h2>Problem2588</h2><pre>#include&lt;bits/stdc++.h&gt;
#define mp(x) (lower_bound(w+1,w+1+w[0],x)-w)
#define c(x,d) (x?x-&gt;c[d]:0)
using namespace std;
const int maxn=1e5+5;
const int BIT=18;
int fa[maxn][BIT],dep[maxn];
int n,m,a[maxn],w[maxn&lt;&lt;1];
vector&lt;int&gt;G[maxn];
struct node{
	int size;
	node *c[2];
	node *rz(){
		size=(c[0]?c[0]-&gt;size:0)+(c[1]?c[1]-&gt;size:0);
		return this;
	}
}*root[maxn],pool[maxn*BIT+10],*cur=pool;
queue&lt;node*&gt;qnode;
node *newnode(){
	return cur++;
}
node *insert(node *x,int l,int r,int val){
	node *y=newnode();
	if(x)*y=*x,y-&gt;size++;
	else y-&gt;size=1;
	if(l==r)return y;
	int mid=(l+r)&gt;&gt;1;
	if(val&lt;=mid)
		y-&gt;c[0]=insert(c(x,0),l,mid,val);	
	else y-&gt;c[1]=insert(c(x,1),mid+1,r,val);
	return y-&gt;rz();
}
int size(node *x,node *y,node *z,node *w){
	return (x&amp;&amp;x-&gt;c[0]?x-&gt;c[0]-&gt;size:0)+(y&amp;&amp;y-&gt;c[0]?y-&gt;c[0]-&gt;size:0)-(z&amp;&amp;z-&gt;c[0]?z-&gt;c[0]-&gt;size:0)-(w&amp;&amp;w-&gt;c[0]?w-&gt;c[0]-&gt;size:0);
}
int Q(node *x,node *y,node *z,node *w,int l,int r,int k){
	if(l==r)return l;
	int mid=(l+r)&gt;&gt;1;
	int siz=size(x,y,z,w);
	if(siz&gt;=k)return Q(c(x,0),c(y,0),c(z,0),c(w,0),l,mid,k);
	else return Q(c(x,1),c(y,1),c(z,1),c(w,1),mid+1,r,k-siz);
}
int lca(int u,int v){
	if(dep[u]&lt;dep[v])swap(u,v);
	for(int i=BIT-1;i&gt;=0;i--)if(dep[u]-(1&lt;&lt;i)&gt;=dep[v])u=fa[u][i];
	if(u!=v){
		for(int i=BIT-1;i&gt;=0;i--)if(fa[u][i]!=fa[v][i])
		u=fa[u][i],v=fa[v][i];
		u=fa[u][0];v=fa[v][0];
	}return u;
}
void dfs(int u){
	root[u]=insert(root[fa[u][0]],1,w[0],mp(a[u]));
	for(int i=1;i&lt;BIT;i++)fa[u][i]=fa[fa[u][i-1]][i-1];
	for(int v,i=0;i&lt;G[u].size();i++){
		if((v=G[u][i])!=fa[u][0]){
			fa[v][0]=u;dep[v]=dep[u]+1;
			dfs(v);			
		}
	}
}
int main(){
	scanf("%d%d",&amp;n,&amp;m);
	for(int i=1;i&lt;=n;i++)scanf("%d",&amp;a[i]),w[++w[0]]=a[i];
	for(int i=1;i&lt;n;i++){
		int u,v;scanf("%d%d",&amp;u,&amp;v);
		G[u].push_back(v);
		G[v].push_back(u);
	}static int _u[maxn],_v[maxn],_k[maxn];
	for(int i=1;i&lt;=m;i++){
		scanf("%d%d%d",&amp;_u[i],&amp;_v[i],&amp;_k[i]);
//		w[++w[0]]=_k[i];
	}sort(w+1,w+1+w[0]);
	w[0]=unique(w+1,w+1+w[0])-w-1;
	dfs(1);int lans=0;
	for(int i=1;i&lt;=m;i++){
		int u=_u[i]^lans,v=_v[i],k=_k[i];
		printf("%d",lans=w[Q(root[u],root[v],root[fa[lca(u,v)][0]],root[lca(u,v)],1,w[0],k)]);
		if(i!=m)puts("");
//		lans=0;
		
	}
	return 0;
}</pre><pre></pre><h2>Problem2594</h2><pre>#include&lt;bits/stdc++.h&gt;
#define V(x) (LCT::pool+x)
#define E(x) (LCT::pool+n+x)
using namespace std;
const int maxn=100010;
const int maxm=1000010;
int n,m,q,anss[maxn];
struct edge{int u,v,w,f,id;bool operator&lt;(const edge o)const{return w&lt;o.w;}}edges[maxm],_edges[maxm];
struct qes{int op,x,y;}Q[maxn];
namespace LCT{
	struct node{
		int rev,val;
		node *c[2],*p,*mx;
		void makerev(){rev^=1;swap(c[0],c[1]);}
		void pd(){if(rev){rev=0;c[0]-&gt;makerev();c[1]-&gt;makerev();}}
		void rz(){
			mx=this;
			if(mx-&gt;val&lt;c[0]-&gt;mx-&gt;val)mx=c[0]-&gt;mx;
			if(mx-&gt;val&lt;c[1]-&gt;mx-&gt;val)mx=c[1]-&gt;mx;
		}
		void sets(node *x,int d){pd();(c[d]=x)-&gt;p=this;rz();}
		bool d(){return p-&gt;c[1]==this;}
		bool rt(){return p-&gt;c[0]!=this&amp;&amp;p-&gt;c[1]!=this;}
	}*null,pool[maxn+maxm];
	node *newnode(int _val=0){
		static node *x=pool;x-&gt;rev=0;x-&gt;val=_val;
		x-&gt;c[0]=x-&gt;c[1]=x-&gt;p=null;x-&gt;mx=x;
		return x++;
	}
	void init(){
		null=newnode();
		null-&gt;c[0]=null-&gt;c[1]=null-&gt;p=null-&gt;mx=null;
		for(int i=1;i&lt;=n;i++)newnode();
		for(int i=1;i&lt;=m;i++)newnode(edges[i].w);
	}
	void rot(node *x){
		node *y=x-&gt;p;if(!y-&gt;rt())y-&gt;p-&gt;pd();
		y-&gt;pd();x-&gt;pd();int d=x-&gt;d();
		y-&gt;sets(x-&gt;c[!d],d);
		if(y-&gt;rt())x-&gt;p=y-&gt;p;
		else y-&gt;p-&gt;sets(x,y-&gt;d());
		x-&gt;sets(y,!d);
	}
	void splay(node *x){
		for(;!x-&gt;rt();rot(x))if(x-&gt;p-&gt;rt());
		else if(x-&gt;d()==x-&gt;p-&gt;d())rot(x-&gt;p);
		else rot(x);
	}
	node *access(node *x){
		node *y=null;
		for(;x!=null;x=x-&gt;p)splay(x),x-&gt;sets(y,1),y=x;
		return y;
	}
	void makert(node *x){
		access(x)-&gt;makerev();splay(x);
	}
	void link(node *x,node *y){
		makert(x);
		x-&gt;p=y;
		access(x);
	}
	void cut(node *x,node *y){
		makert(x);access(y);splay(y);
		y-&gt;c[0]=x-&gt;p=null;y-&gt;rz();
	}
	node *Qmax(node *x,node *y){
		makert(x);access(y);splay(y);
		return y-&gt;mx;
	}
	void _deb(node *x){
		if(x==null)return;
		printf("id:%d val:%d mx:%d p:%d\n",x-pool,x-&gt;val,x-&gt;mx-pool,x-&gt;p-pool);
		if(x-&gt;c[0]!=null)printf("L: "),_deb(x-&gt;c[0]);
		if(x-&gt;c[1]!=null)printf("R: "),_deb(x-&gt;c[1]);
	}
	void deb(){
		static int vis[maxn+maxm];
		memset(vis,0,sizeof vis);
		for(int i=1;i&lt;=n+m;i++){
			node *x=pool+i;
			while(!x-&gt;rt())x=x-&gt;p;
			if(vis[x-pool])continue;
			vis[x-pool]=1;
			_deb(x);
		}puts("");
	}
}
int getint(){
	int res=0;char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))res=res*10+c-'0',c=getchar();
	return res;
}typedef pair&lt;int,int&gt; pi;map&lt;pi,int&gt;M;
int fa[maxn];
int find(int x){return x==fa[x]?x:fa[x]=find(fa[x]);}
int main(){
	scanf("%d%d%d",&amp;n,&amp;m,&amp;q);
	for(int i=1;i&lt;=n;i++)fa[i]=i;
	for(int i=1;i&lt;=m;i++){
		edges[i].u=getint(),edges[i].v=getint(),
		edges[i].w=getint(),edges[i].f=1,edges[i].id=i;
		if(edges[i].u&gt;edges[i].v)swap(edges[i].u,edges[i].v);
		M[pi(edges[i].u,edges[i].v)]=i;	
	}LCT::init();	
	for(int i=1;i&lt;=q;i++){
		Q[i].op=getint();Q[i].x=getint();Q[i].y=getint();	
		if(Q[i].x&gt;Q[i].y)swap(Q[i].x,Q[i].y);
		if(Q[i].op==2)edges[M[pi(Q[i].x,Q[i].y)]].f=0;
	}copy(edges+1,edges+1+m,_edges+1);
	sort(_edges+1,_edges+1+m);
	for(int i=1,k=0;i&lt;=m&amp;&amp;k&lt;n;i++){
		int u=_edges[i].u,v=_edges[i].v;
		if(find(u)==find(v)||!_edges[i].f)continue;
		fa[find(u)]=find(v);k++;
		LCT::link(V(u),E(_edges[i].id));
		LCT::link(E(_edges[i].id),V(v));
	}
	
//	LCT::deb();
	
	for(int i=q;i;i--){
		int op=Q[i].op,x=Q[i].x,y=Q[i].y;
		if(op==1){
			anss[++anss[0]]=LCT::Qmax(V(x),V(y))-&gt;val;
		}else{
			int id=M[pi(x,y)];
			LCT::node *p=LCT::Qmax(V(x),V(y));
			if(p-&gt;val&gt;edges[id].w){
				int eid=p-LCT::pool-n;
				LCT::cut(V(edges[eid].u),E(eid));
				LCT::cut(E(eid),V(edges[eid].v));
				LCT::link(V(x),E(id));
				LCT::link(E(id),V(y));
			}
			
		//	LCT::deb();
			
			
		}
	}for(int i=anss[0];i;i--)printf("%d\n",anss[i]);
	return 0;
}</pre><pre></pre><h2>Problem2595</h2><pre>#include&lt;bits/stdc++.h&gt;
#define fst first
#define sec second
using namespace std;
int n,m,K,inf=100000;
int a[10][10],f[10][10][1&lt;&lt;10];
struct tup{
	int first,second,thd;
	tup(int _fst=0,int _sec=0,int _thd=0):
		first(_fst),second(_sec),thd(_thd){}
}pre[10][10][1&lt;&lt;10],zero;
typedef pair&lt;int,int&gt; par;
queue&lt;par&gt;q;
int vis[10][10];
void spfa(int sta){	
	const static int dx[4]={1,-1,0,0},dy[4]={0,0,1,-1};
	while(!q.empty()){
		par u=q.front();q.pop();vis[u.fst][u.sec]=0;
		for(int k=0;k&lt;4;k++){
			int x=dx[k]+u.fst,y=dy[k]+u.sec;
			if(x&lt;0||y&lt;0||x&gt;=n||y&gt;=m)continue;
			if(f[x][y][sta]&gt;f[u.fst][u.sec][sta]+a[x][y]){
				f[x][y][sta]=f[u.fst][u.sec][sta]+a[x][y];
				pre[x][y][sta]=tup(u.fst,u.sec,sta);
				if(!vis[x][y])q.push(par(x,y)),vis[x][y]=1;
			}	
		}
	}
}
void dfs(int i,int j,int sta){
	if(i==inf||pre[i][j][sta].thd==0)return;
	vis[i][j]=1;tup tp=pre[i][j][sta];
	dfs(tp.fst,tp.sec,tp.thd);
	if(tp.fst==i&amp;&amp;tp.sec==j)dfs(i,j,sta-tp.thd);
}
void deb(int sta){
	puts("");
	for(int i=0;i&lt;n;i++)
	for(int j=0;j&lt;m;j++)
	printf("%d%c",f[i][j][sta]," \n"[j==m-1]);
}
int main(){
	cin&gt;&gt;n&gt;&gt;m;
	fill(&amp;f[0][0][0],&amp;f[10][10][1&lt;&lt;10],inf);
	for(int i=0;i&lt;n;i++)
	for(int j=0;j&lt;m;j++){
		cin&gt;&gt;a[i][j];
		if(!a[i][j]){f[i][j][1&lt;&lt;(K++)]=0;}
	}
	for(int sta=1;sta&lt;(1&lt;&lt;K);sta++){
		for(int i=0;i&lt;n;i++)for(int j=0;j&lt;m;j++){
			for(int s=sta&amp;(sta-1);s;s=sta&amp;(s-1)){
				if(f[i][j][sta]&gt;f[i][j][s]+f[i][j][sta-s]-a[i][j]){
					f[i][j][sta]=f[i][j][s]+f[i][j][sta-s]-a[i][j];
					pre[i][j][sta]=tup(i,j,s);
				}
			}if(f[i][j][sta]!=inf)
			{q.push(par(i,j));vis[i][j]=1;}
		}spfa(sta);
		//deb(sta);
	}
	int x,y;
	for(int i=0;i&lt;n;i++)for(int j=0;j&lt;m;j++)if(!a[i][j]){x=i;y=j;break;}
	printf("%d\n",f[x][y][(1&lt;&lt;K)-1]);
	dfs(x,y,(1&lt;&lt;K)-1);	
	for(int i=0;i&lt;n;i++)
	for(int j=0;j&lt;m;j++){
		if(!a[i][j])putchar('x');
		else if(vis[i][j])putchar('o');
		else putchar('_');if(j==m-1)puts("");
	}
	return 0;
}</pre><pre></pre><h2>Problem2596</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=2010;
const double eps=1e-6;
const double pi=acos(-1);
int n;
double va,vb;
inline int dcmp(double x){return (x&gt;eps)-(x&lt;-eps);}
struct point{
	double x,y;
	point(double _x=0,double _y=0):x(_x),y(_y){}
	point operator-(point o){return point(x-o.x,y-o.y);}
	point operator+(point o){return point(x+o.x,y+o.y);}
	double operator*(point o){return x*o.y-y*o.x;}
	double operator^(point o){return x*o.x+y*o.y;}
	point operator/(double p){return point(x/p,y/p);}
	point operator*(double p){return point(x*p,y*p);}
	bool operator==(point o)const{return !dcmp(x-o.x)&amp;&amp;!dcmp(y-o.y);}
	bool operator!=(point o)const{return !(*this==o);}
	friend bool operator&lt;(point a,point b){return dcmp(a.x-b.x)&lt;0||(!dcmp(a.x-b.x)&amp;&amp;dcmp(a.y-b.y)&lt;0);}
}p[maxn];
inline double length(point A){return sqrt(A^A);}
inline point normal(point A){return A/length(A);}
struct edge{int u,v;double w;};
vector&lt;edge&gt;G[2*maxn*maxn];
inline void add(int u,int v,double w){
	G[u].push_back((edge){u,v,w});
	G[v].push_back((edge){v,u,w});
	
//	fprintf(stderr,"%d %d  %.2lf\n",u,v,w);
	
}
#define fst first
#define sec second
bool byX(pair&lt;point,int&gt; a,pair&lt;point,int&gt; b){return a.fst.x&lt;b.fst.x;}
bool byY(pair&lt;point,int&gt; a,pair&lt;point,int&gt; b){return a.fst.y&lt;b.fst.y;}
typedef pair&lt;double,int&gt; par;
short vis[2*maxn*maxn];
int cnt=0;
inline double dijk(){
	static priority_queue&lt;par,vector&lt;par&gt;,greater&lt;par&gt; &gt;q;
	static double d[2*maxn*maxn];
	for(int i=1;i&lt;=cnt;i++)d[i]=1e10;
	d[1]=0;q.push(par(d[1],1));
	while(!q.empty()){
		int u=q.top().sec;q.pop();if(vis[u])continue;vis[u]=1;
		for(int i=0;i&lt;G[u].size();i++){
			int v=G[u][i].v;
			double w=G[u][i].w;
			if(dcmp(d[v]-d[u]-w)&gt;0){
				d[v]=d[u]+w;
				q.push(par(d[v],v));
			}
		}
	}return d[n];
}
double h,L;
inline double f(double x){
	return sqrt(h*h+(L-x)*(L-x))/vb+x/va;
}
inline bool Onseg(point a,point b,point c){
	return dcmp(a.x-b.x)*dcmp(a.x-c.x)&lt;=0&amp;&amp;dcmp(a.y-b.y)*dcmp(a.y-c.y)&lt;=0;	
}
double sqr(double x){return x*x;}
inline point Maxf(point P,point A,point B){
	double l=0,r=length(A-B);
	h=fabs(((P-A)*(B-A))/length(B-A));
	L=((P-A)^(B-A))/length(B-A);
	/*while(dcmp(r-l)){
		double mid1=l+(r-l)/3;
		double mid2=r-(r-l)/3;
		if(dcmp(f(mid1)-f(mid2))&lt;0)
			r=mid2;
		else l=mid1;
	}*/
	double x1=sqrt(sqr(vb*h)/(sqr(va)-sqr(vb)))+L;
	double x2=-sqrt(sqr(vb*h)/(sqr(va)-sqr(vb)))+L;
	l=dcmp(x2)==-1?x1:x2;
	double len=((P-A)^(B-A))/length(B-A)/length(P-A);
	point _P=A+normal(B-A)*l;
	if(Onseg(_P,A,B))return _P;
	return length(_P-B)&lt;length(_P-A)?B:A;
}
int getint(){
	int res=0,f=1;char c=getchar();
	while(!isdigit(c))f=f==-1||c=='-'?-1:1,c=getchar();
	while(isdigit(c))res=res*10+c-'0',c=getchar();
	return res*f;
}
typedef pair&lt;point,int&gt; pr;
vector&lt;pr&gt;tmp;
int main(){
	scanf("%d",&amp;n);n++;cnt=n;
	scanf("%lf%lf",&amp;va,&amp;vb);
	for(int i=2;i&lt;=n;i++)p[i].x=getint(),p[i].y=getint();
	for(int i=1;i&lt;=n;i++){ 
		for(int j=i+2;j&lt;=n;j++)
		add(i,j,length(p[i]-p[j])/vb);
		if(i+1&lt;=n)add(i,i+1,length(p[i]-p[i+1])/va);
	} 
	for(int j=1;j&lt;n;j++){
		tmp.clear();
		point A=p[j],B=p[j+1];
		int u=j,v=j+1;
		for(int i=1;i&lt;=n;i++)if(i!=j&amp;&amp;i!=j+1){
			point P=Maxf(p[i],p[j],p[j+1]);
			if(P!=p[j]&amp;&amp;P!=p[j+1]){
				tmp.push_back(pr(P,cnt+1+tmp.size()));
				add(i,cnt+tmp.size(),length(P-p[i])/vb);
			}
			P=Maxf(p[i],p[j+1],p[j]);
			if(P!=p[j]&amp;&amp;P!=p[j+1]){
				tmp.push_back(pr(P,cnt+1+tmp.size()));
				add(i,cnt+tmp.size(),length(P-p[i])/vb);			
			}
		}
		if(dcmp(A.x-B.x)){
			sort(tmp.begin(),tmp.end(),byX);
			unique(tmp.begin(),tmp.end());
			if(dcmp(A.x-B.x)==1)swap(u,v),swap(A,B);
		}else{
			sort(tmp.begin(),tmp.end(),byY);
			unique(tmp.begin(),tmp.end());
			if(dcmp(A.y-B.y)==1)swap(u,v),swap(A,B);
		}	
		if(tmp.empty())continue;
		add(u,tmp.front().sec,length(A-tmp.front().fst)/va);
		for(int i=0;i+1&lt;tmp.size();i++){
			add(tmp[i].sec,tmp[i+1].sec,length(tmp[i].fst-tmp[i+1].fst)/va);
		}
		add(tmp.back().sec,v,length(B-tmp.back().fst)/va);
		cnt+=tmp.size();
	}
	
	printf("%.4lf\n",dijk()-0.00005);
	return 0;
}</pre><pre></pre><h2>Problem2597</h2><pre> 
#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=20010;   
struct edge{int u,v,cap,flow,cost;};
vector&lt;edge&gt;edges;
vector&lt;int&gt;G[maxn];
void add(int u,int v,int cap,int cost){
    edges.push_back((edge){u,v,cap,0,cost});
    G[u].push_back(edges.size()-1);
    edges.push_back((edge){v,u,0,0,-cost});
    G[v].push_back(edges.size()-1);
}
int flow=0,cost=0,s,t,n;
int a[maxn],pre[maxn],d[maxn],in[maxn];
typedef pair&lt;int,int&gt; par;
#define fst first
#define sec second
par mp[maxn];
bool spfa(){
    static int vis[maxn];
    queue&lt;int&gt;q;
    memset(d,0x3f,sizeof d);int B=d[0];
    q.push(s);d[s]=0;a[s]=INT_MAX;
    while(!q.empty()){
        int u=q.front();q.pop();vis[u]=0;
        for(int i=0;i&lt;G[u].size();i++){
            edge e=edges[G[u][i]];
            if(e.cap&gt;e.flow&amp;&amp;d[e.v]&gt;d[u]+e.cost){
                d[e.v]=d[u]+e.cost;
                pre[e.v]=G[u][i];
                a[e.v]=min(a[u],e.cap-e.flow);
                if(!vis[e.v]){
                    vis[e.v]=1;
                    q.push(e.v);
                }
            }
        }
    }if(d[t]==B)return false;
    flow+=a[t];cost+=d[t]*a[t];
    int u=t;
    while(u!=s){
        edges[pre[u]].flow+=a[t];
        edges[pre[u]^1].flow-=a[t];
        u=edges[pre[u]].u;
    }return true;
}
int main(){ 
    scanf("%d",&amp;n);int m=n*(n-1)/2,cnt=0;
    s=0;t=n+m+1;
    for(int i=1;i&lt;=n;i++)
    for(int j=1;j&lt;=n;j++){
        int x;
        scanf("%d",&amp;x);
        if(j&lt;=i)continue;
        cnt++;mp[cnt]=par(i,j);
        if(x==2)add(cnt,i+m,1,0),add(cnt,j+m,1,0),in[i]++,in[j]++;
        if(x==1)add(cnt,i+m,1,0),in[i]++;
        if(x==0)add(cnt,j+m,1,0),in[j]++;
    }for(int i=1;i&lt;=m;i++)add(s,i,1,0);
    for(int i=1;i&lt;=n;i++)
    for(int j=1;j&lt;=in[i];j++)
    add(i+m,t,1,2*j-1);
    while(spfa());
    cout&lt;&lt;(n*(n-1)*(n-2)/3+m-cost)/2&lt;&lt;endl;
    static int a[101][101],tot=0;
    for(int i=0;i&lt;edges.size();i++)if(i%2==0){
        int u=edges[i].u,v=edges[i].v-m;
        if(u&gt;=1&amp;&amp;u&lt;=m&amp;&amp;v&gt;=1&amp;&amp;v&lt;=n&amp;&amp;edges[i].flow==1){
            a[mp[u].fst][mp[u].sec]=v==mp[u].fst;
            a[mp[u].sec][mp[u].fst]=v!=mp[u].fst;
        }
    }
    for(int i=1;i&lt;=n;i++)
    for(int j=1;j&lt;=n;j++)
    printf("%d%c",a[i][j]," \n"[j==n]);
    return 0;
}</pre><pre></pre><h2>Problem2599</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;set&gt;
using namespace std;
const int maxn=200005;
struct edge{int u,v,w;};
vector&lt;edge&gt;G[maxn];
typedef long long LL;
typedef pair&lt;LL,int&gt; pli;
int n,root,All;
int dsize,siz[maxn],f[maxn],dep[maxn],ans=maxn+233;
LL sum[maxn],k;
bool cant[maxn];
set&lt;pli&gt;S;
set&lt;pli&gt;::iterator it;
pli data[maxn];
void makert(int u,int fa){
	siz[u]=1;f[u]=0;
	for(int i=0;i&lt;G[u].size();i++){
		edge e=G[u][i];
		if(e.v==fa||cant[e.v])continue;
		makert(e.v,u);
		siz[u]+=siz[e.v];
		f[u]=max(f[u],siz[e.v]);
	}f[u]=max(f[u],All-siz[u]);
	if(f[root]&gt;f[u])root=u;
}
void dfs(int u,int fa){
	data[++dsize]=pli(sum[u],dep[u]);
	for(int i=0;i&lt;G[u].size();i++){
		edge e=G[u][i];
		if(cant[e.v]||e.v==fa)continue;
		sum[e.v]=sum[u]+e.w;dep[e.v]=dep[u]+1;
		dfs(e.v,u);
	}
}
void calc(int u){
	S.clear();dep[u]=0;sum[u]=0;
	S.insert(pli(0,0));
	for(int i=0;i&lt;G[u].size();i++){
		edge e=G[u][i];
		if(cant[e.v])continue;
		dsize=0;
		sum[e.v]=e.w;
		dep[e.v]=1;
		dfs(e.v,u);
		for(int j=1;j&lt;=dsize;j++){
			it=S.lower_bound(pli(k-data[j].first,0));
			if(it==S.end()||it-&gt;first+data[j].first!=k)continue;
			ans=min(ans,data[j].second+it-&gt;second);
		}
		for(int j=1;j&lt;=dsize;j++)S.insert(data[j]);
	}
}
void solve(int u){
	calc(u);cant[u]=1;
	for(int i=0;i&lt;G[u].size();i++){
		edge e=G[u][i];if(cant[e.v])continue;
		f[root=0]=n+1;
		makert(e.v,0);
		All=siz[e.v];
		solve(root);
	}
}
int main(){
	scanf("%d",&amp;n);All=n;cin&gt;&gt;k;
	for(int i=1;i&lt;n;i++){
		int u,v,w;scanf("%d%d%d",&amp;u,&amp;v,&amp;w);u++;v++;
		G[u].push_back((edge){u,v,w});
		G[v].push_back((edge){v,u,w});
	}f[root=0]=n+1;
	makert(1,0);
	solve(root);
	if(ans==maxn+233)puts("-1");
	else cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem2599</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;set&gt;
using namespace std;
const int maxn=200005;
struct edge{int u,v,w;};
vector&lt;edge&gt;G[maxn];
typedef long long LL;
typedef pair&lt;LL,int&gt; pli;
int n,root,All;
int dsize,siz[maxn],f[maxn],dep[maxn],ans=maxn+233;
LL sum[maxn],k;
bool cant[maxn];
set&lt;pli&gt;S;
set&lt;pli&gt;::iterator it;
pli data[maxn];
void makert(int u,int fa){
	siz[u]=1;f[u]=0;
	for(int i=0;i&lt;G[u].size();i++){
		edge e=G[u][i];
		if(e.v==fa||cant[e.v])continue;
		makert(e.v,u);
		siz[u]+=siz[e.v];
		f[u]=max(f[u],siz[e.v]);
	}f[u]=max(f[u],All-siz[u]);
	if(f[root]&gt;f[u])root=u;
}
void dfs(int u,int fa){
	data[++dsize]=pli(sum[u],dep[u]);
	for(int i=0;i&lt;G[u].size();i++){
		edge e=G[u][i];
		if(cant[e.v]||e.v==fa)continue;
		sum[e.v]=sum[u]+e.w;dep[e.v]=dep[u]+1;
		dfs(e.v,u);
	}
}
void calc(int u){
	S.clear();dep[u]=0;sum[u]=0;
	S.insert(pli(0,0));
	for(int i=0;i&lt;G[u].size();i++){
		edge e=G[u][i];
		if(cant[e.v])continue;
		dsize=0;
		sum[e.v]=e.w;
		dep[e.v]=1;
		dfs(e.v,u);
		for(int j=1;j&lt;=dsize;j++){
			it=S.lower_bound(pli(k-data[j].first,0));
			if(it==S.end()||it-&gt;first+data[j].first!=k)continue;
			ans=min(ans,data[j].second+it-&gt;second);
		}
		for(int j=1;j&lt;=dsize;j++)S.insert(data[j]);
	}
}
void solve(int u){
	calc(u);cant[u]=1;
	for(int i=0;i&lt;G[u].size();i++){
		edge e=G[u][i];if(cant[e.v])continue;
		f[root=0]=n+1;
		makert(e.v,0);
		All=siz[e.v];
		solve(root);
	}
}
int getint(){  
    int res=0;char c=getchar();  
    while(!isdigit(c))c=getchar();  
    while(isdigit(c))res=res*10+c-'0',c=getchar();  
    return res;  
}  
int main(){
	scanf("%d",&amp;n);All=n;cin&gt;&gt;k;
	for(int i=1;i&lt;n;i++){
		int u=getint()+1,v=getint()+1,w=getint();
		G[u].push_back((edge){u,v,w});
		G[v].push_back((edge){v,u,w});
	}f[root=0]=n+1;
	makert(1,0);
	solve(root);
	if(ans==maxn+233)puts("-1");
	else cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem2600</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
const int maxn=1e5+5;
int n;
LL L,B;
int a[maxn];
LL sum[maxn];
#define sum(l,r) (sum[r]-sum[l-1])
LL cost(int l,int r){
	int mid=(l+r)&gt;&gt;1;
	LL ans=0;
	ans+=(LL)a[mid]*(mid-l+1)-(LL)a[mid]*(r-mid);
	ans-=sum(l,mid);
	ans+=sum(mid+1,r);
	return ans;
}
int main(){
	cin&gt;&gt;n&gt;&gt;L&gt;&gt;B;
	for(int i=1;i&lt;=n;i++){
		scanf("%d",&amp;a[i]);
		sum[i]=sum[i-1]+a[i];
	}int ans=0;
	for(int i=1,j=1;j&lt;=n;j++){
		while(cost(i,j)&gt;B)i++;
		ans=max(ans,j-i+1);
	}cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem2631</h2><pre>#include&lt;bits/stdc++.h&gt;
#define id(x) (LCT::pool+x)
using namespace std;
typedef long long LL;
const int maxn=1e5+5;
int mo=51061,n,m;
namespace LCT{
	struct node{
		int rev,val,mul,add,size,sum;
		node *c[2],*p;
		void makerev(){rev^=1;swap(c[0],c[1]);}
		void pd(){
			if(rev){rev=0;c[0]-&gt;makerev();c[1]-&gt;makerev();}
			if(mul==1&amp;&amp;!add)return;
			c[0]-&gt;val=((LL)c[0]-&gt;val*mul%mo+add)%mo;
			c[0]-&gt;sum=((LL)c[0]-&gt;sum*mul%mo+(LL)c[0]-&gt;size*add%mo)%mo;
			c[0]-&gt;mul=((LL)c[0]-&gt;mul*mul%mo)%mo;
			c[0]-&gt;add=((LL)c[0]-&gt;add*mul%mo+add)%mo;
			c[1]-&gt;val=((LL)c[1]-&gt;val*mul%mo+add)%mo;
			c[1]-&gt;sum=((LL)c[1]-&gt;sum*mul%mo+(LL)c[1]-&gt;size*add%mo)%mo;
			c[1]-&gt;mul=((LL)c[1]-&gt;mul*mul%mo)%mo;
			c[1]-&gt;add=((LL)c[1]-&gt;add*mul%mo+add)%mo;
			mul=1;add=0;
		}
		void rz(){
			sum=(c[0]-&gt;sum+val+c[1]-&gt;sum)%mo;
			size=c[0]-&gt;size+1+c[1]-&gt;size;
		}
		void sets(node *x,int d){pd();(c[d]=x)-&gt;p=this;rz();}
		bool d(){return p-&gt;c[1]==this;}
		bool rt(){return p-&gt;c[0]!=this&amp;&amp;p-&gt;c[1]!=this;}
	}*null,pool[maxn];
	node *newnode(int _val=0){
		static node *x=pool;
		x-&gt;rev=0;x-&gt;val=x-&gt;sum=_val;
		x-&gt;mul=1;x-&gt;add=0;x-&gt;size=1;
		x-&gt;c[0]=x-&gt;c[1]=x-&gt;p=null;
		return x++;
	}
	void init(){
		null=newnode();null-&gt;mul=0;null-&gt;size=0;
		null-&gt;c[0]=null-&gt;c[1]=null-&gt;p=null;
		for(int i=1;i&lt;=n;i++)newnode(1);
	}
	void rot(node *x){
		node *y=x-&gt;p;if(!y-&gt;rt())y-&gt;p-&gt;pd();
		y-&gt;pd();x-&gt;pd();int d=x-&gt;d();
		y-&gt;sets(x-&gt;c[!d],d);
		if(y-&gt;rt())x-&gt;p=y-&gt;p;
		else y-&gt;p-&gt;sets(x,y-&gt;d());
		x-&gt;sets(y,!d);
	}
	void splay(node *x){
		for(;!x-&gt;rt();rot(x))if(x-&gt;p-&gt;rt());
		else if(x-&gt;d()==x-&gt;p-&gt;d())rot(x-&gt;p);
		else rot(x);
	}
	node *access(node *x){
		node *y=null;
		for(;x!=null;x=x-&gt;p)splay(x),x-&gt;sets(y,1),y=x;
		return y;
	}
	void makert(node *x){
		access(x)-&gt;makerev();splay(x);
	}
	node *findrt(node *x){
		for(x=access(x);x-&gt;pd(),x-&gt;c[0]!=null;x=x-&gt;c[0]);return x;
	}
	void link(node *x,node *y){
		makert(x);x-&gt;p=y;access(x);
	}
	void cut(node *x,node *y){
		makert(x);access(y);splay(y);
		y-&gt;c[0]=x-&gt;p=null;y-&gt;rz();
	}
	int Qsum(node *x,node *y){
		makert(x);access(y);splay(y);
		return y-&gt;sum;
	}
	void add(node *x,node *y,int c){
		makert(x);access(y);splay(y);
		y-&gt;val=(y-&gt;val+c)%mo;
		y-&gt;sum=(y-&gt;sum+(LL)y-&gt;size*c%mo)%mo;
		y-&gt;add=(y-&gt;add+c)%mo;		
	}
	void mul(node *x,node *y,int c){
		makert(x);access(y);splay(y);
		y-&gt;val=((LL)y-&gt;val*c)%mo;
		y-&gt;sum=((LL)y-&gt;sum*c)%mo;
		y-&gt;mul=((LL)y-&gt;mul*c)%mo;
		y-&gt;add=((LL)y-&gt;add*c)%mo;		
	}
}
int main(){
	scanf("%d%d",&amp;n,&amp;m);
	LCT::init();	
	for(int i=1;i&lt;n;i++){
		int u,v;scanf("%d%d",&amp;u,&amp;v);
		LCT::link(id(u),id(v));
	}
	while(m--){
		char op=getchar();
		while(op!='+'&amp;&amp;op!='-'&amp;&amp;op!='*'&amp;&amp;op!='/')op=getchar();
		if(op=='+'){
			int u,v,c;scanf("%d%d%d",&amp;u,&amp;v,&amp;c);
			LCT::add(id(u),id(v),c%mo);
		}else
		if(op=='-'){
			int u1,v1,u2,v2;scanf("%d%d%d%d",&amp;u1,&amp;v1,&amp;u2,&amp;v2);
			LCT::cut(id(u1),id(v1));
			LCT::link(id(u2),id(v2));
		}else
		if(op=='*'){
			int u,v,c;scanf("%d%d%d",&amp;u,&amp;v,&amp;c);
			LCT::mul(id(u),id(v),c%mo);		
		}else
		if(op=='/'){
			int u,v;scanf("%d%d",&amp;u,&amp;v);
			printf("%d\n",LCT::Qsum(id(u),id(v)));
		}
	}
	return 0;
}</pre><pre></pre><h2>Problem2648</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cctype&gt;
#include&lt;climits&gt;
#include&lt;cmath&gt;
using namespace std;
const int maxn=500005;
int n,m,D;
int getint(){
	int res=0,f=1;char c=getchar();
	while(!isdigit(c))f=f==-1||c=='-'?-1:1,c=getchar();
	while(isdigit(c))res=res*10+c-'0',c=getchar();
	return res*f;
}
struct point{
	int d[2],mn[2],mx[2],l,r;
	int&amp; operator[](int i){return d[i];}
	bool operator&lt;(point p)const{return d[D]&lt;p[D];}
	point(int _x=0,int _y=0):
		l(0),r(0){d[0]=_x,d[1]=_y;}
}p[maxn];
int dis(point a,point b){return abs(a[0]-b[0])+abs(a[1]-b[1]);}
struct kdtree{
	int root,ans;
	point P;
	point t[maxn&lt;&lt;1];
	void rz(int p){
		for(int i=0;i&lt;2;i++){
			if(t[p].l)t[p].mn[i]=min(t[p].mn[i],t[t[p].l].mn[i]),
			t[p].mx[i]=max(t[p].mx[i],t[t[p].l].mx[i]);
			if(t[p].r)t[p].mn[i]=min(t[p].mn[i],t[t[p].r].mn[i]),
			t[p].mx[i]=max(t[p].mx[i],t[t[p].r].mx[i]);
		}
	}
	int build(int l,int r,int dd){
		D=dd;int mid=(l+r)&gt;&gt;1;
		nth_element(p+l,p+mid,p+r+1);
		t[mid]=p[mid];
		for(int i=0;i&lt;2;i++)t[mid].mn[i]=t[mid].mx[i]=t[mid][i];
		if(l&lt;mid)t[mid].l=build(l,mid-1,dd^1);
		if(r&gt;mid)t[mid].r=build(mid+1,r,dd^1);
		rz(mid);
		return mid;
	}
	void insert(int p,int dd){	
		
		if(P[dd]&gt;=t[p][dd]){
			if(t[p].r)insert(t[p].r,dd^1);
			else{
				t[p].r=++n;
				t[n]=P;
				for(int i=0;i&lt;2;i++)t[n].mn[i]=t[n].mx[i]=t[n][i];				
			}
		}else{
			if(t[p].l)insert(t[p].l,dd^1);
			else{
				t[p].l=++n;
				t[n]=P;
				for(int i=0;i&lt;2;i++)t[n].mn[i]=t[n].mx[i]=t[n][i];				
			}			
		}rz(p);
	}
	int dist(int p1,point p){
	   int ans=0;
	   for(int i=0;i&lt;2;i++)
	   ans+=max(0,t[p1].mn[i]-p[i]);
	   for(int i=0;i&lt;2;i++)
	   ans+=max(0,p[i]-t[p1].mx[i]);
	   return ans;
	}
	void QkNN(int p,int dd){
	   int dl,dr,d0;
	   d0=dis(t[p],P);
	   if(d0&lt;ans)ans=d0;
	   if(t[p].l)dl=dist(t[p].l,P);else dl=0x7f7f7f7f;
	   if(t[p].r)dr=dist(t[p].r,P);else dr=0x7f7f7f7f;
	   if(dl&lt;dr){
	       if(dl&lt;ans)QkNN(t[p].l,dd^1);
	       if(dr&lt;ans)QkNN(t[p].r,dd^1);
	   }else{
	       if(dr&lt;ans)QkNN(t[p].r,dd^1);
	       if(dl&lt;ans)QkNN(t[p].l,dd^1);
	   }		
	}
	void insert(point _p){P=_p;insert(root,0);}
	void init(){root=build(1,n,0);}
	int QkNN(point _p){P=_p;ans=INT_MAX;QkNN(root,0);return ans;}
}T;
int main(){
	n=getint();m=getint();
	for(int i=1;i&lt;=n;i++)p[i][0]=getint(),p[i][1]=getint();
	T.init();
	while(m--){
		int op=getint(),x=getint(),y=getint();
		if(op==1)T.insert(point(x,y));
		else printf("%d\n",T.QkNN(point(x,y)));
	}
	return 0;
}</pre><pre></pre><h2>Problem2654</h2><pre>#include&lt;bits/stdc++.h&gt;
#define fst first
#define sec second
using namespace std;
const int maxn=50010;
int ans=0;
struct edge{
	int u,v,w,_w,c;
}edges[int(1e5)+5];int F;
bool cmp(edge a,edge b){return a.w!=b.w?a.w&lt;b.w:(F==1?a.c&lt;b.c:a.c&gt;b.c);}
int fa[maxn];
int find(int x){return x==fa[x]?x:fa[x]=find(fa[x]);}
int n,m,ned;
int cnt[101];
int cnt_dw[101],cnt_up[101];
typedef pair&lt;int,int&gt; par;
map&lt;int,int&gt;tmp,whi;
par Mst(){
	for(int i=1;i&lt;=n;i++)fa[i]=i;int k=0;
	sort(edges+1,edges+1+m,cmp);int res=0,wh=0;
	for(int i=1;i&lt;=m&amp;&amp;k&lt;n-1;i++){
		int u=edges[i].u,v=edges[i].v;
		if(find(v)!=find(u)){
			fa[find(v)]=find(u);k++;
			wh+=edges[i].c==0;res+=edges[i].w;
		}
	}return par(wh,res);
}
int main(){
	scanf("%d%d%d",&amp;n,&amp;m,&amp;ned);
	for(int i=1;i&lt;=m;i++){
		int u,v,w,c;
		scanf("%d%d%d%d",&amp;u,&amp;v,&amp;w,&amp;c);
		u++;v++;
		edges[i].u=u;
		edges[i].v=v;
		edges[i]._w=w;
		edges[i].w=w;
		edges[i].c=c;
		cnt[w]++;
	}int l=-101,r=101;
	while(l&lt;r){
		int mid=(l+r)&gt;&gt;1;
		for(int i=1;i&lt;=m;i++)if(!edges[i].c)edges[i].w=edges[i]._w+mid;
		par up,dw;
		F=1;up=Mst();
		F=0;dw=Mst();
		if(dw.fst&lt;=ned&amp;&amp;ned&lt;=up.fst){
			ans=Mst().sec;
			ans-=ned*mid;break;
		}
		if(ned&gt;up.fst)
			r=mid;
		else l=mid+1;
	}
	cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem2656</h2><pre>d={}
def f(x):
    if x==0:
        return 0
    if x==1:
        return 1
    if d.has_key(x):
        return d[x]
    if x%2==0:
        ans=f(x/2)
        d[x]=ans
    else:
        ans=f(x/2)
        ans+=f(x/2+1)
        d[x]=ans
    return ans
T=int(raw_input())
for i in range(0,T):
    x=int(raw_input())
    print f(x)
</pre><pre></pre><h2>Problem2659</h2><pre>#include&lt;iostream&gt;
using namespace std;
typedef long long LL;
LL p,q,ans;
int main(){
	cin&gt;&gt;p&gt;&gt;q;
	if(p&lt;q)swap(p,q);
	if(p==q){cout&lt;&lt;(1+(p-1)/2)*(p-1)/2&lt;&lt;endl;return 0;}
	cout&lt;&lt;(p-1)*(q-1)/4&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem2660</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
LL n,m;
LL g[100][2],f[100],a[89];
int main(){
	f[1]=1;f[2]=2;
	for(int i=3;i&lt;=88;i++)f[i]=f[i-1]+f[i-2];
	cin&gt;&gt;n;
	for(int i=88;i&gt;=1;i--)if(n&gt;=f[i])n-=f[i],a[++m]=i;
	reverse(a+1,a+1+m);
	g[1][1]=1;
	g[1][0]=(a[1]-1)/2;
	for(int i=2;i&lt;=m;i++){
		g[i][1]=g[i-1][0]+g[i-1][1];
		g[i][0]=(a[i]-a[i-1]-1)/2*g[i-1][1]+(a[i]-a[i-1])/2*g[i-1][0];;
	}cout&lt;&lt;g[m][0]+g[m][1]&lt;&lt;endl;
	return 0;
}
</pre><pre></pre><h2>Problem2661</h2><pre>#include&lt;vector&gt;
#include&lt;queue&gt;
#include&lt;cmath&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;climits&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
const int INF=INT_MAX;
struct edge{
	int u,v,cap,flow,cost;
	edge(){
		
	}
	edge(int _u,int _v,int _cap,int _flow,int _cost):
		u(_u),v(_v),cap(_cap),flow(_flow),cost(_cost){}
};
vector&lt;edge&gt;edges;
vector&lt;vector&lt;int&gt; &gt;G;
void add(int u,int v,int cap,int cost){
	edges.push_back(edge(u,v,cap,0,cost));
	G[u].push_back(edges.size()-1);
	edges.push_back(edge(v,u,0,0,-cost));
	G[v].push_back(edges.size()-1);	 
}
int flow=0,cost=0;
int a[10001];
int p[11000];
int vis[10010];
int d[10100];
int n,m,s,t;
bool spfa(){  
    queue&lt;int&gt;q;  
    q.push(s);  
    memset(d,0xcf,sizeof(d));  
    memset(vis,0,sizeof(vis));  
    int B=d[0];  
    d[s]=0;  
    vis[s]=1;  
    a[s]=INF;  
    while(!q.empty()){  
        int u=q.front();q.pop();vis[u]=0;  
        for(int i=0;i&lt;G[u].size();i++){  
            edge &amp;e=edges[G[u][i]];  
            if(e.cap-e.flow&gt;0&amp;&amp;d[e.v]&lt;d[u]+e.cost){  
                d[e.v]=d[u]+e.cost;  
                p[e.v]=G[u][i];  
                a[e.v]=min(a[u],e.cap-e.flow);  
                if(!vis[e.v]){  
                    vis[e.v]=1;  
                    q.push(e.v);  
                }  
            }  
        }  
    }  
    if(d[t]==B)return false;  
    int u=t;  
    flow+=a[t];  
    cost+=a[t]*d[t];  
    while(u!=s){  
        edges[p[u]].flow+=a[t];  
        edges[p[u]^1].flow-=a[t];  
        u=edges[p[u]].u;  
    }  
    return true;  
}  
int gcd(int a,int b){
	while(b){
		int t=a%b;
		a=b;
		b=t;
	}
	return a;
}
bool ok(int i,int j){
int X=i*i-j*j;	
if ((floor(sqrt(abs(i*i-j*j)))==sqrt(abs(i*i-j*j))) and (i!=j) )
	if (gcd(floor(sqrt(abs(i*i-j*j))),min(i,j))==1 )
	return true;

return false;
}
int con[15231];
vector&lt;int&gt;v1;
vector&lt;int&gt;v2;
int main(){
	cin&gt;&gt;n&gt;&gt;m;
	s=0;t=m+m+1;
	G.resize(90020);
	for(int i=n;i&lt;=m;i++){
	//	add(i,i+m,1,0);
	}
	for(int i=n;i&lt;=m;i++)
	for(int j=n;j&lt;i;j++){
		if(ok(i,j)){
			add(i,j+m,1,i+j);
			add(j,i+m,1,i+j);
		//	cout&lt;&lt;i&lt;&lt;" "&lt;&lt;j&lt;&lt;endl;
			v1.push_back(i);v1.push_back(j);
			v2.push_back(j+m);v2.push_back(i+m);
			
		}
	}
	sort(v1.begin(),v1.end());
	sort(v2.begin(),v2.end());
	int s2=unique(v2.begin(),v2.end())-v2.begin();
	int s1=unique(v1.begin(),v1.end())-v1.begin();
	
	for(int i=0;i&lt;s1;i++){
		add(s,v1[i],1,0);
	}
	for(int i=0;i&lt;s2;i++){
		add(v2[i],t,1,0);
	}
	
	while(spfa());
	int deb=0 ;
	if(deb)
	for(int i=0;i&lt;edges.size();i++)if(i%2==0)
	printf("#%d  %d -&gt;  %d  cap:%d  cost:%d  flow:%d\n",
	i,edges[i].u,edges[i].v,edges[i].cap,edges[i].cost,edges[i].flow);

	cout&lt;&lt;flow/2&lt;&lt;" "&lt;&lt;cost/2&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem2662</h2><pre>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;ext/pb_ds/priority_queue.hpp&gt;
#define pa pair&lt;int,pair&lt;int,int&gt; &gt;
#define mp(a,b,c) make_pair(a,make_pair(b,c))
#define fr first
#define sc second.first
#define tr second.second 
#define inf 1000000000
using namespace std;
using namespace __gnu_pbds;
typedef __gnu_pbds::priority_queue&lt;pa,greater&lt;pa&gt;,pairing_heap_tag &gt; heap;
heap::point_iterator id[55][55];
int n,m,k,cnt,ans=inf;
int last[55],dis[55][55];
struct edge{int to,next,v;}e[2005];
inline int read()
{
    int x=0,f=1;char ch=getchar();
    while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
void insert(int u,int v,int w)
{
	e[++cnt].to=v;e[cnt].next=last[u];last[u]=cnt;e[cnt].v=w;
	e[++cnt].to=u;e[cnt].next=last[v];last[v]=cnt;e[cnt].v=w;
}
void dijkstra()
{
	heap q;
	for(int i=1;i&lt;=n;i++)
		for(int j=0;j&lt;=k;j++)
			dis[i][j]=inf;
	dis[1][0]=0;id[1][0]=q.push(mp(0,1,0));
	while(!q.empty())
	{
	    int a=q.top().sc,b=q.top().tr;q.pop();
		for(int i=last[a];i;i=e[i].next)
		{
			if(dis[a][b]+e[i].v&lt;dis[e[i].to][b])
			{
				dis[e[i].to][b]=dis[a][b]+e[i].v;
				if(id[e[i].to][b]==0)id[e[i].to][b]=q.push(mp(dis[e[i].to][b],e[i].to,b));
				else q.modify(id[e[i].to][b],mp(dis[e[i].to][b],e[i].to,b));
			}
			if(b&lt;k&amp;&amp;dis[a][b]+e[i].v/2&lt;dis[e[i].to][b+1])
			{
				dis[e[i].to][b+1]=dis[a][b]+e[i].v/2;
				if(id[e[i].to][b+1]==0)id[e[i].to][b+1]=q.push(mp(dis[e[i].to][b+1],e[i].to,b+1));
				else q.modify(id[e[i].to][b+1],mp(dis[e[i].to][b+1],e[i].to,b+1));
			}
		}
	}
}
int main()
{
	n=read();m=read();k=read();
	for(int i=1;i&lt;=m;i++)
	{
		int u=read(),v=read(),w=read();
		insert(u,v,w);
	}
	dijkstra();
	for(int i=0;i&lt;=k;i++)
		ans=min(ans,dis[n][i]);
	printf("%d",ans);
	return 0;
}</pre><pre></pre><h2>Problem2668</h2><pre>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
#include&lt;cstring&gt;
#define maxn 2000
#define maxm 50000
#define inf 2147483647
using namespace std;
struct et
{
    int s,t,val,cost,next;
}e[maxm];
char s1[100][100],s2[100][100],s3[100][100];
int a[100][100],b[100][100],c[100][100],num[100][100];
int fir[maxn],q[maxm],d[maxn],pre[maxn];
bool inque[maxn];
int n,m,st,ed,tot,ans,b1,b2,fare;

bool find()
{
    for (int i=st;i&lt;=ed;i++) d[i]=inf;
    int head=0,tail=1;
    q[1]=st; d[st]=0; inque[st]=1;
    while (head&lt;tail)
    {
        int now=q[++head];
        for (int j=fir[now];j;j=e[j].next)
        {
            int k=e[j].t;
            if (e[j].val&amp;&amp;d[k]&gt;d[now]+e[j].cost)
            {
                pre[k]=j;
                d[k]=d[now]+e[j].cost;
                if (!inque[k]) q[++tail]=k,inque[k]=1;
            }
        }
        inque[now]=0;
    }
    return d[ed]&lt;inf;
}

void fare_flow()
{
    for (int i=1;i&lt;=b1;i++)
    {
        find();
        int tmp=inf;
        for (int j=pre[ed];j;j=pre[e[j].s]) tmp=min(tmp,e[j].val);
        fare+=tmp*d[ed];
        ans+=tmp;
        for (int j=pre[ed];j;j=pre[e[j].s]) e[j].val-=tmp,e[j^1].val+=tmp;
    }
}        

void add(int x,int y,int z,int w)
{
    e[++tot].s=x; e[tot].t=y; e[tot].val=z; e[tot].cost=w; e[tot].next=fir[x]; fir[x]=tot;
    e[++tot].s=y; e[tot].t=x; e[tot].val=0; e[tot].cost=-w; e[tot].next=fir[y]; fir[y]=tot;
}

int main()
{
    //freopen("chess1.in","r",stdin);
    scanf("%d%d",&amp;n,&amp;m);
    st=0; ed=n*m*3+1; tot=1;
    for (int i=1;i&lt;=n;i++)
        scanf("%s",s1[i]+1);
    for (int i=1;i&lt;=n;i++)
        scanf("%s",s2[i]+1);
    for (int i=1;i&lt;=n;i++)
        scanf("%s",s3[i]+1);
    for (int i=1;i&lt;=n;i++)
        for (int j=1;j&lt;=m;j++)
        {
            a[i][j]=s1[i][j]-'0';
            if (a[i][j]) b1++;
            b[i][j]=s2[i][j]-'0';
            if (b[i][j]) b2++;
            c[i][j]=s3[i][j]-'0';
            if (a[i][j]&amp;&amp;b[i][j]) a[i][j]=b[i][j]=0,b1--,b2--;
        }
    for (int i=1;i&lt;=n;i++)
        for (int j=1;j&lt;=m;j++)
        {
            int now=(i-1)*m+j;
            num[i][j]=now;
            if (a[i][j])
            {
                add(st,now,1,0);
                add(n*m+now,now,c[i][j]/2,0);
                add(now,2*n*m+now,(c[i][j]+1)/2,0);
            }
            else
            if (b[i][j])
            {
                add(now,ed,1,0);
                add(n*m+now,now,(c[i][j]+1)/2,0);
                add(now,2*n*m+now,c[i][j]/2,0);
            }
            else
            {
                add(n*m+now,now,c[i][j]/2,0);
                add(now,2*n*m+now,c[i][j]/2,0);
            }
        }
    for (int i=1;i&lt;=n;i++)
        for (int j=1;j&lt;=m;j++)
        {
            if (i&gt;1) add(2*n*m+num[i][j],n*m+num[i-1][j],inf,1);
            if (j&gt;1) add(2*n*m+num[i][j],n*m+num[i][j-1],inf,1);
            if (i&lt;n) add(2*n*m+num[i][j],n*m+num[i+1][j],inf,1);
            if (j&lt;m) add(2*n*m+num[i][j],n*m+num[i][j+1],inf,1);
            if (i&gt;1&amp;&amp;j&gt;1) add(2*n*m+num[i][j],n*m+num[i-1][j-1],inf,1);
            if (i&lt;n&amp;&amp;j&lt;m) add(2*n*m+num[i][j],n*m+num[i+1][j+1],inf,1);
            if (i&gt;1&amp;&amp;j&lt;m) add(2*n*m+num[i][j],n*m+num[i-1][j+1],inf,1);
            if (i&lt;n&amp;&amp;j&gt;1) add(2*n*m+num[i][j],n*m+num[i+1][j-1],inf,1);
        }
    //for (int i=2;i&lt;=tot;i++) cout&lt;&lt;e[i].s&lt;&lt;' '&lt;&lt;e[i].t&lt;&lt;' '&lt;&lt;e[i].val&lt;&lt;' '&lt;&lt;e[i].cost&lt;&lt;endl;
    fare=0;
    if (b1==b2){
        fare_flow();
        if (ans!=b1) fare=-1;
    }
    else fare=-1;
    printf("%d\n",fare);
    return 0;
}</pre><pre></pre><h2>Problem2683</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=2e5+5;
int in(){
	int r=0;char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))r=r*10+c-'0',c=getchar();
	return r;
}
int n;
struct point{
	int x,y,val;
	int&amp; operator[](const int s){return s==0?x:y;}
}p[maxn];
struct rec{
	int x[2],y[2];
	rec(){}
	rec(point p){x[0]=x[1]=p.x;y[0]=y[1]=p.y;}
};
bool operator==(const point &amp;A,const point &amp;B){
	return A.x==B.x&amp;&amp;A.y==B.y;
}
rec operator+(const rec &amp;ls,const rec &amp;rs){
	static rec R;R=ls;
	R.x[0]=min(R.x[0],rs.x[0]);
	R.x[1]=max(R.x[1],rs.x[1]);
	R.y[0]=min(R.y[0],rs.y[0]);
	R.y[1]=max(R.y[1],rs.y[1]);
	return R;
}
bool operator*(const point &amp;p,const rec &amp;R){
	return R.x[0]&lt;=p.x&amp;&amp;p.x&lt;=R.x[1]&amp;&amp;R.y[0]&lt;=p.y&amp;&amp;p.y&lt;=R.y[1];
}
bool In(rec A,rec B){
	return B.x[0]&lt;=A.x[0]&amp;&amp;A.x[1]&lt;=B.x[1]&amp;&amp;B.y[0]&lt;=A.y[0]&amp;&amp;A.y[1]&lt;=B.y[1];
}
bool Out(rec A,rec B){
	return B.x[0]&gt;A.x[1]||A.x[0]&gt;B.x[1]||B.y[0]&gt;A.y[1]||A.y[0]&gt;B.y[1];
}
struct node{
	rec R;point p;
	int sum,siz;
	node *c[2];
	node *rz(){
		sum=p.val;R=rec(p);siz=1;
		if(c[0])sum+=c[0]-&gt;sum,R=R+c[0]-&gt;R,siz+=c[0]-&gt;siz;
		if(c[1])sum+=c[1]-&gt;sum,R=R+c[1]-&gt;R,siz+=c[1]-&gt;siz;
		return this;
	}
	node(){sum=0;siz=1;c[0]=c[1]=0;}
}*root,*re,pool[maxn],*cur=pool;
node *sta[maxn];
int D,si;
bool cmp(const point &amp;A,const point &amp;B){
	if(D)return A.x&lt;B.x;
	return A.y&lt;B.y;
}
int top;
node *newnode(){
	if(si)return sta[si--];
	return cur++;
}
node* build(int l,int r,int d){
	int mid=(l+r)&gt;&gt;1;D=d;
	nth_element(p+l,p+mid,p+r+1,cmp);
	node *t=newnode();t-&gt;p=p[mid];
	if(l&lt;=mid-1)t-&gt;c[0]=build(l,mid-1,d^1);
	if(mid+1&lt;=r)t-&gt;c[1]=build(mid+1,r,d^1);
	return t-&gt;rz();
}
void dfs(node *&amp;t){
	if(t-&gt;c[0])dfs(t-&gt;c[0]);
	p[++top]=t-&gt;p;
	if(t-&gt;c[1])dfs(t-&gt;c[1]);
	sta[++si]=t;*t=node();
	//delete t;
}
node* rebuild(node *&amp;t){
	if(!t)return 0;
	top=0;dfs(t);
	return build(1,top,0);
}
#define siz(x) (x?x-&gt;siz:0)
void Add(node *&amp;t,point p){
	D^=1;
	if(!t){t=newnode(),t-&gt;p=p;t-&gt;rz();return;}
	if(t-&gt;p==p){t-&gt;p.val+=p.val;t-&gt;rz();return;}
	if(p[D]&lt;t-&gt;p[D])Add(t-&gt;c[0],p);
	else Add(t-&gt;c[1],p);t-&gt;rz();
	if(max(siz(t-&gt;c[0]),siz(t-&gt;c[1]))&gt;0.618*t-&gt;siz)
		re=t;
}
int Q(node *t,rec R){
	if(!t)return 0;
	if(In(t-&gt;R,R))return t-&gt;sum;
	if(Out(t-&gt;R,R))return 0;
	int ans=0;
	if(t-&gt;p*R)ans=t-&gt;p.val;
	if(t-&gt;c[0])ans+=Q(t-&gt;c[0],R);
	if(t-&gt;c[1])ans+=Q(t-&gt;c[1],R);
	return ans;
}
int main(){
	n=in();
	while(1){
		int ty=in();if(ty==3)break;
		if(ty==1){
			int x=in(),y=in(),A=in();
			re=0;D=1;
			Add(root,(point){x,y,A});
			if(re)re=rebuild(re);
		}else{
			rec R;
			R.x[0]=in();R.y[0]=in();
			R.x[1]=in();R.y[1]=in();
			printf("%d\n",Q(root,R));
		}
	}
	return 0;
}</pre><pre></pre><h2>Problem2687</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1e6+6;
typedef long long LL;
int in(){
	int r=0;char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))r=r*10+c-'0',c=getchar();
	return r;
}
int n;
struct seg{
	int l,r;
	seg(int l=0,int r=0):l(l),r(r){}
	bool operator&lt;(const seg &amp;oth)const{return l!=oth.l?l&lt;oth.l:r&gt;oth.r;}
	bool operator==(const seg &amp;oth)const{return l==oth.l&amp;&amp;r==oth.r;}
}se[maxn];
seg operator|(seg A,seg B){
	return seg(min(A.l,B.l),max(A.r,B.r));
}
seg operator&amp;(seg A,seg B){
	if(A.l&gt;B.l)swap(A,B);
	return seg(B.l,A.r);
}
LL ans=0;
LL calc(seg A,seg B){
	if(A.l&gt;B.l)swap(A,B);
	if((A|B)==A)return (LL)(B.r-B.l)*(A.r-A.l);
	return (LL)(A.r-B.l)*(B.r-A.l);
}
void update(seg A,seg B){
	if(A.l&gt;B.l)swap(A,B);
	if(ans&lt;calc(A,B)){
		ans=calc(A,B);
	}
}
void solve(int l,int r,int x,int y){
	if(l&gt;r||x&gt;y)return;
	if(x==y){
		for(int i=l;i&lt;=r;i++)if(i!=x)
			update(se[i],se[x]);
		return;
	}int mid=(l+r)&gt;&gt;1,ps=max(x,mid+1);
	for(int i=ps;i&lt;=y;i++){
		if(calc(se[mid],se[i])&gt;calc(se[mid],se[ps]))
			ps=i;		
	}if(mid!=ps)
	update(se[mid],se[ps]);	
	solve(l,mid-1,x,ps);
	solve(mid+1,r,ps,y);
}
int main(){
	n=in();
	for(int i=1;i&lt;=n;i++)
		se[i].l=in(),se[i].r=in();
	sort(se+1,se+1+n);
	int top=1;
	for(int i=2,j=1;i&lt;=n;i++){
		if((se[i]|se[top])==se[top]){
			update(se[i],se[top]);
		}else se[++top]=se[i];
	}n=top;
	solve(1,n,1,n);
	printf("%lld\n",ans);
	return 0;
}</pre><pre></pre><h2>Problem2693</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
using namespace std;
const int maxn=10000005;
typedef long long LL;
int MOD=100000009;
LL n,m;
bool p[maxn];
int prime[maxn],minp[maxn];
int u[maxn];
LL f[maxn];
int getint(){
	int res=0;char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))res=res*10+c-'0',c=getchar();
	return res;
}
void init(int maxn){
	f[1]=1;
	for(int i=2;i&lt;maxn;i++){
		if(!p[i]){
			prime[++prime[0]]=i;minp[i]=i;f[i]=(1-i)%MOD;
		}for(int j=1;j&lt;=prime[0]&amp;&amp;i*prime[j]&lt;maxn;j++){
			p[i*prime[j]]=1;
			if(i%prime[j]==0){
				minp[i*prime[j]]=minp[i]*prime[j];
				f[i*prime[j]]=(LL)(1-prime[j])*f[i*prime[j]/minp[i*prime[j]]]%MOD; 
				break;
			}else{
				minp[i*prime[j]]=prime[j];
				f[i*prime[j]]=(LL)f[i]*f[prime[j]]%MOD;
			}
		}
	}
	for(int i=1;i&lt;maxn;i++)f[i]=(f[i]*i)%MOD;
	for(int i=2;i&lt;maxn;i++)f[i]=(f[i-1]+f[i])%MOD;
}
int main(){
	init(maxn);
	int _=getint();
	while(_--){
		n=getint();m=getint();
		LL ans=0;
		if(n&gt;m)swap(n,m);
		for(int i=1,last;i&lt;=n;i=last+1){
			last=min(n/(n/i),m/(m/i));
			LL tmp=(LL)((LL)n/i*(n/i+1)/2%MOD)%MOD*(LL)((LL)m/i*(m/i+1)/2%MOD)%MOD;
			ans=((LL)(f[last]-f[i-1])%MOD*tmp%MOD+ans)%MOD;
		}while(ans&lt;0)ans+=MOD;
		printf("%d\n",ans%MOD);
	}
	return 0;
}</pre><pre></pre><h2>Problem2697</h2><pre>#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
int n,k;
int c[333];
int main(){
	cin&gt;&gt;n&gt;&gt;k;
	for(int i=1;i&lt;=k;i++)cin&gt;&gt;c[i];
	sort(c+1,c+1+k,greater&lt;int&gt;());
	int l=1,r=n,ans=0;
	for(int i=1;i&lt;=k;i++){
		ans+=(r-l)*c[i];
		l++;r--;
		if(l&gt;=r)break;
	}cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem2705</h2><pre>/*
	ID:zky
	OJ:BZOJ
	Index:2705
	Language:C++ 
*/
#include&lt;cmath&gt;
#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long lld;
lld n;
long long ans=0;
lld phi(lld n){
  lld ans=n,i;
  for(i=2;i*i&lt;=n;i++)
    if(!(n%i)){
       ans=ans/i*(i-1);
       while(!(n%i))n/=i;
    }
  if(n&gt;1)ans=ans/n*(n-1);
  return ans;
}
int main(){
	cin&gt;&gt;n;
	for(lld i=1;i&lt;=sqrt(n);i++){
		if(n%i==0){
			ans+=phi(n/i)*i;
			if(i*i!=n)ans+=phi(i)*n/i;			
		}
	} 
	cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
} </pre><pre></pre><h2>Problem2707</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=10010;
vector&lt;int&gt;G[maxn],Ge[maxn];
int low[maxn],dfn[maxn],z,ins[maxn];
stack&lt;int&gt;S;
int mp[maxn],s,t,n,m,cnt,bel[maxn];
double a[101][101];
vector&lt;int&gt;vec[maxn];
double f[maxn];
short vis[maxn],cal[maxn];
int dcmp(double x){return (x&gt;1e-9)-(x&lt;-1e-9);}
void Gauss(int n){
	for(int i=0;i&lt;n;i++){
		int r=i;
		for(int j=i+1;j&lt;n;j++)if(fabs(a[j][i])&gt;fabs(a[r][i]))r=j;
		for(int j=0;j&lt;=n;j++)swap(a[r][j],a[i][j]);
		for(int j=i+1;j&lt;n;j++){
			double t=a[j][i]/a[i][i];
			for(int k=i;k&lt;=n;k++)
				a[j][k]-=t*a[i][k];
		}
	}
	for(int i=n-1;i&gt;=0;i--){
		for(int j=i+1;j&lt;n;j++)a[i][n]-=a[j][n]*a[i][j];
//		if(!dcmp(a[i][i])){puts("INF");exit(0);}
		a[i][n]/=a[i][i];
	}
}
void tarjan(int u){
	dfn[u]=low[u]=++z;S.push(u);ins[u]=1;
	for(int i=0;i&lt;G[u].size();i++){
		int v=G[u][i];
		if(!dfn[v]){
			tarjan(v);
			low[u]=min(low[u],low[v]);
		}else if(ins[v])low[u]=min(low[u],dfn[v]);
	}
	if(low[u]==dfn[u]){
		cnt++;int v;
		do{
			v=S.top();S.pop();
			ins[v]=0;bel[v]=cnt;
			vec[cnt].push_back(v);
		}while(v!=u);
	}
}
void calc(int x){
	int z=0,n=vec[x].size();
	for(int i=0;i&lt;n;i++)mp[vec[x][i]]=i;
	for(int i=0;i&lt;n;i++)for(int j=0;j&lt;=n;j++)a[i][j]=0;
	for(int i=0;i&lt;n;i++){
		a[i][i]=a[i][n]=G[vec[x][i]].size();double siz=G[vec[x][i]].size();
		a[i][i]=max(a[i][i],1.);
		for(int v,j=0;j&lt;G[vec[x][i]].size();j++){
			v=G[vec[x][i]][j];
			if(!cal[v])
				a[i][mp[v]]+=-1;
			else a[i][n]+=f[v];
		}
	}Gauss(n);
	for(int i=0;i&lt;n;i++)f[vec[x][i]]=a[i][n],cal[vec[x][i]]=1;
}
void dfs(int u){
	vis[u]=1;
	for(int v,i=0;i&lt;Ge[u].size();i++){
		if(!vis[v=Ge[u][i]])
			dfs(v);
	}calc(u);
}
bool vis2[maxn];
int dfs2(int u){
	int ans=1;vis2[u]=1;
	for(int i=0;i&lt;Ge[u].size();i++){
		int	v=Ge[u][i];
		if(!vis2[v])
			ans+=dfs2(v);
	}return ans;
}
bool vis3[maxn];
int dfs3(int u){
	int ans=1;vis3[u]=1;
	for(int i=0;i&lt;G[u].size();i++){
		int	v=G[u][i];
		if(!vis3[v])
			ans+=dfs3(v);
	}return ans;
}
int main(){
	scanf("%d%d%d%d",&amp;n,&amp;m,&amp;s,&amp;t);
	for(int i=1;i&lt;=m;i++){
		int u,v;scanf("%d%d",&amp;u,&amp;v);
		Ge[v].push_back(u);
//		if(u==s&amp;&amp;v==t){puts("INF");return 0;}
		G[u].push_back(v);
	}//if(dfs2(t)!=dfs3(s)){puts("INF");return 0;}
	//if(G[s].size()==1&amp;&amp;G[s][0]==t){puts("INF");return 0;}
	dfs2(t);dfs3(s);
	for(int i=1;i&lt;=n;i++)if(!vis2[i]&amp;&amp;vis3[i]){puts("INF");return 0;}
	G[t].clear();
	for(int i=1;i&lt;=n;i++)if(!dfn[i])tarjan(i);
	for(int i=1;i&lt;=n;i++)Ge[i].clear();
	for(int i=1;i&lt;=n;i++)for(int v,j=0;j&lt;G[i].size();j++){
		if(bel[i]!=bel[v=G[i][j]])
		Ge[bel[i]].push_back(bel[v]);
	}dfs(bel[s]);
	printf("%.3lf\n",f[s]);
	return 0;
}</pre><pre></pre><h2>Problem2715</h2><pre>A=1</pre><pre></pre><h2>Problem2716</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cctype&gt;
#include&lt;climits&gt;
#include&lt;cmath&gt;
using namespace std;
const int maxn=500005;
int n,m,D;
int getint(){
	int res=0,f=1;char c=getchar();
	while(!isdigit(c))f=f==-1||c=='-'?-1:1,c=getchar();
	while(isdigit(c))res=res*10+c-'0',c=getchar();
	return res*f;
}
struct point{
	int d[2],mn[2],mx[2],l,r;
	int&amp; operator[](int i){return d[i];}
	bool operator&lt;(point p)const{return d[D]&lt;p[D];}
	point(int _x=0,int _y=0):
		l(0),r(0){d[0]=_x,d[1]=_y;}
}p[maxn];
int dis(point a,point b){return abs(a[0]-b[0])+abs(a[1]-b[1]);}
struct kdtree{
	int root,ans;
	point P;
	point t[maxn&lt;&lt;1];
	void rz(int p){
		for(int i=0;i&lt;2;i++){
			if(t[p].l)t[p].mn[i]=min(t[p].mn[i],t[t[p].l].mn[i]),
			t[p].mx[i]=max(t[p].mx[i],t[t[p].l].mx[i]);
			if(t[p].r)t[p].mn[i]=min(t[p].mn[i],t[t[p].r].mn[i]),
			t[p].mx[i]=max(t[p].mx[i],t[t[p].r].mx[i]);
		}
	}
	int build(int l,int r,int dd){
		D=dd;int mid=(l+r)&gt;&gt;1;
		nth_element(p+l,p+mid,p+r+1);
		t[mid]=p[mid];
		for(int i=0;i&lt;2;i++)t[mid].mn[i]=t[mid].mx[i]=t[mid][i];
		if(l&lt;mid)t[mid].l=build(l,mid-1,dd^1);
		if(r&gt;mid)t[mid].r=build(mid+1,r,dd^1);
		rz(mid);
		return mid;
	}
	void insert(int p,int dd){	
		
		if(P[dd]&gt;=t[p][dd]){
			if(t[p].r)insert(t[p].r,dd^1);
			else{
				t[p].r=++n;
				t[n]=P;
				for(int i=0;i&lt;2;i++)t[n].mn[i]=t[n].mx[i]=t[n][i];				
			}
		}else{
			if(t[p].l)insert(t[p].l,dd^1);
			else{
				t[p].l=++n;
				t[n]=P;
				for(int i=0;i&lt;2;i++)t[n].mn[i]=t[n].mx[i]=t[n][i];				
			}			
		}rz(p);
	}
	int dist(int p1,point p){
	   int ans=0;
	   for(int i=0;i&lt;2;i++)
	   ans+=max(0,t[p1].mn[i]-p[i]);
	   for(int i=0;i&lt;2;i++)
	   ans+=max(0,p[i]-t[p1].mx[i]);
	   return ans;
	}
	void QkNN(int p,int dd){
	   int dl,dr,d0;
	   d0=dis(t[p],P);
	   if(d0&lt;ans)ans=d0;
	   if(t[p].l)dl=dist(t[p].l,P);else dl=0x7f7f7f7f;
	   if(t[p].r)dr=dist(t[p].r,P);else dr=0x7f7f7f7f;
	   if(dl&lt;dr){
	       if(dl&lt;ans)QkNN(t[p].l,dd^1);
	       if(dr&lt;ans)QkNN(t[p].r,dd^1);
	   }else{
	       if(dr&lt;ans)QkNN(t[p].r,dd^1);
	       if(dl&lt;ans)QkNN(t[p].l,dd^1);
	   }		
	}
	void insert(point _p){P=_p;insert(root,0);}
	void init(){root=build(1,n,0);}
	int QkNN(point _p){P=_p;ans=INT_MAX;QkNN(root,0);return ans;}
}T;
int main(){
	n=getint();m=getint();
	for(int i=1;i&lt;=n;i++)p[i][0]=getint(),p[i][1]=getint();
	T.init();
	while(m--){
		int op=getint(),x=getint(),y=getint();
		if(op==1)T.insert(point(x,y));
		else printf("%d\n",T.QkNN(point(x,y)));
	}
	return 0;
}</pre><pre></pre><h2>Problem2718</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
int n,m,ans=0;
int vis[201],Link[201];
vector&lt;int&gt;G[201];
int mp[201][201];
int find(int x){
	for(int i=1;i&lt;=n;i++){
		if(!mp[x][i]||vis[i])continue;
		vis[i]=1;
		if(!Link[i]||find(Link[i])){
			Link[i]=x;return 1;
		}
	}return 0;
}
int main(){
	scanf("%d%d",&amp;n,&amp;m);
	for(int i=1;i&lt;=m;i++){
		int u,v;scanf("%d%d",&amp;u,&amp;v);
		mp[u][v]=1;
	}for(int k=1;k&lt;=n;k++)
	for(int i=1;i&lt;=n;i++)
	for(int j=1;j&lt;=n;j++)
	mp[i][j]|=mp[i][k]&amp;mp[k][j];
	for(int i=1;i&lt;=n;i++){
		memset(vis,0,sizeof vis);
		ans+=find(i);
	}cout&lt;&lt;n-ans&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem2721</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
const int maxn=1e6+5;
LL n;
int p[maxn],a[maxn];
int minp[maxn],d[maxn],pd[maxn];
LL two[maxn];
LL solve(LL n,LL p){
	if(!n)return 0;
	return n/p+solve(n/p,p);
}
int main(){
	cin&gt;&gt;n;
	for(int i=2;i&lt;maxn;i++){
		if(!minp[i]){minp[i]=i;p[++p[0]]=i;d[i]=2;pd[i]=1;}
		for(int j=1;j&lt;=p[0]&amp;&amp;(LL)i*p[j]&lt;maxn;j++){
			minp[i*p[j]]=p[j];
			if(i%p[j]==0){
				pd[i*p[j]]=pd[i]+1;
				d[i*p[j]]=d[i]/(pd[i]+1)*(pd[i*p[j]]+1);
				break;
			}else{
				pd[i*p[j]]=pd[i];
				d[i*p[j]]=d[i]*d[p[j]];
			}
		}
	}
	int mo=1e9+7;
	LL ans=1;
	two[0]=1;
	for(int i=1;i&lt;maxn;i++)two[i]=two[i-1]*2%mo;
	for(int i=1;i&lt;=p[0];i++){
		LL cnt=solve(n,p[i]);
		cnt=cnt*2%mo;
		ans=ans*(cnt+1LL)%mo;
	}
	cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem2724</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;vector&gt;
#include&lt;map&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=40010;
map&lt;int,int&gt;M;
int rM[maxn],a[maxn];
int n,m,sqrtn;
vector&lt;int&gt;v[maxn];
int getint(){
    int r=0;char c=getchar();
    while(!isdigit(c))c=getchar();
    while(isdigit(c))r=r*10+c-'0',c=getchar();
    return r;
}
int bel[maxn]={-1},tot,lans;
int L[maxn],R[maxn],sqrtsize;
int data[maxn];
int Anss[233][233];
int counts(int x,int l,int r){return upper_bound(v[x].begin(),v[x].end(),r)-lower_bound(v[x].begin(),v[x].end(),l);}
int Q(int l,int r){
    int l0=l,r0=r;
    bool e=bel[l]==bel[r];
    data[0]=0;
    if(e)for(int i=l;i&lt;=r;i++)data[++data[0]]=a[i];
    if(!e)while(r!=R[bel[r]])data[++data[0]]=a[r],r--;
    if(!e)while(l!=L[bel[l]])data[++data[0]]=a[l],l++;
    int ans=233,cnt=0;
    if(!e)ans=Anss[bel[l]][bel[r]],cnt=counts(ans,l0,r0);
    sort(data+1,data+1+data[0]);
    data[0]=unique(data+1,data+1+data[0])-data-1;
    for(int i=1;i&lt;=data[0];i++){
        int c=counts(data[i],l0,r0);
        if(c&gt;cnt||(c==cnt&amp;&amp;data[i]&lt;ans))ans=data[i],cnt=c;
    }return ans;
}
int main(){
    n=getint();m=getint();sqrtn=sqrt(n);
    for(int i=1;i&lt;=n;i++)a[i]=getint(),bel[i]=i/sqrtn;
    for(int i=1;i&lt;=n;i++){
        if(bel[i]!=bel[i-1]){
            if(sqrtsize)R[sqrtsize-1]=i-1;
            L[sqrtsize++]=i;
        }
    }R[sqrtsize-1]=n;
    for(int i=1;i&lt;=n;i++)M[a[i]]=1;
    for(map&lt;int,int&gt;::iterator it=M.begin();it!=M.end();it++)it-&gt;second=++tot;
    for(int i=1;i&lt;=n;i++)rM[M[a[i]]]=a[i],a[i]=M[a[i]],v[a[i]].push_back(i);
    for(int i=0;i&lt;sqrtsize;i++){
        M.clear();
        for(int j=i;j&lt;sqrtsize;j++){
            for(int k=L[j];k&lt;=R[j];k++)M[a[k]]++;
            int ans=0,cnt=0;
            for(map&lt;int,int&gt;::iterator it=M.begin();it!=M.end();it++)
            if(it-&gt;second&gt;cnt||(it-&gt;second==cnt&amp;&amp;it-&gt;first&lt;ans))ans=it-&gt;first,cnt=it-&gt;second;
            Anss[i][j]=ans;
        }
    }
 
    while(m--){
        // Attention!!!
        int l=(lans+getint()-1)%n+1,r=(lans+getint()-1)%n+1;
        //int l=getint(),r=getint();
        if(l&gt;r)swap(l,r);
        lans=rM[Q(l,r)];
        printf("%d\n",lans);
    }
    return 0;
}</pre><pre></pre><h2>Problem2726</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=300010;
typedef long long LL;
int n;
LL sumt[maxn],sumf[maxn],S,f[maxn];
int T[maxn],F[maxn];
int getint(){
	int res=0,f=1;char c=getchar();
	while(!isdigit(c))f=c=='-'?-1:f,c=getchar();
	while(isdigit(c))res=res*10+c-'0',c=getchar();
	return res*f;
}
struct point{
	LL x,y;
	point(LL x,LL y):x(x),y(y){}
	point operator-(point o){return point(x-o.x,y-o.y);}
	LL operator^(point o){return x*o.x+y*o.y;}
	LL operator*(point o){return x*o.y-y*o.x;}
	bool operator&lt;(point o)const{return x!=o.x?x&lt;o.x:y&lt;o.y;}
};
struct CH{
	vector&lt;point&gt;ch;
	void push_back(point p){
		while(ch.size()&gt;1&amp;&amp;(p-ch[ch.size()-1])*(ch[ch.size()-1]-ch[ch.size()-2])&gt;=0)
			ch.pop_back();
		ch.push_back(p);
	}
	LL Qmin(point p){
		int l=0,r=ch.size()-1;
		LL ans=1LL&lt;&lt;62;
		while(r-l&gt;3){
			int mid1=l+(r-l)/3;
			int mid2=r-(r-l)/3;
			if((ch[mid1]^p)&lt;(ch[mid2]^p))
				r=mid2;
			else l=mid1;
		}
		for(int i=l;i&lt;=r;i++)ans=min(ans,ch[i]^p);
		return ans;
	}
	void clear(){ch.clear();}
	int size()const{return ch.size();}
	point operator[](int x)const{return ch[x];}
};
vector&lt;point&gt;tmp;
CH merge(const CH &amp;L,const CH &amp;R){
	CH C;tmp.clear();
	for(int i=0;i&lt;L.size();i++)tmp.push_back(L[i]);
	for(int i=0;i&lt;R.size();i++)tmp.push_back(R[i]);
	sort(tmp.begin(),tmp.end());
	for(int i=0;i&lt;tmp.size();i++)C.push_back(tmp[i]);
	return C;
}
void deb(vector&lt;point&gt;v){
	for(int i=0;i&lt;v.size();i++)
	printf("%I64d %I64d\n",v[i].x,v[i].y);
}
CH solve(int l,int r){
	if(l==r){
		CH C;
		C.push_back(point(f[l],-sumt[l]));
		return C;
	}int mid=(l+r)&gt;&gt;1;
	CH L,R;
	if(mid+1&lt;=r)R=solve(mid+1,r);
	for(int i=l;i&lt;=mid;i++)
		f[i]=min(f[i],R.Qmin(point(1,sumf[i]))+S*sumf[i]+sumt[i]*sumf[i]);
	if(l&lt;=mid)L=solve(l,mid);	
	return merge(L,R);
}
int main(){
 	n=getint();S=getint();
	for(int i=1;i&lt;=n;i++)T[i]=getint(),F[i]=getint();
	for(int i=n;i&gt;=1;i--)sumt[i]=sumt[i+1]+T[i],sumf[i]=sumf[i+1]+F[i];
	for(int i=1;i&lt;=n;i++)f[i]=1LL&lt;&lt;62;
	solve(1,n+1);
	cout&lt;&lt;f[1]&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem2729</h2><pre>n,m=map(int,raw_input().split())
fac=[1]*2010
for i in range(1,2010):fac[i]=fac[i-1]*i
def A(n,m):
    if(n-m&lt;0):
        return 0
    return fac[n]/fac[n-m]
print A(n,n)*(A(n+1,2)*A(n+3,m)+2*(n+1)*A(n+2,m-1)*m)
</pre><pre></pre><h2>Problem2730</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=505;
int n,m,T,now;
vector&lt;int&gt;G[maxn];
int col[maxn],cols,tmp[maxn],cnt	;
short iscut[maxn],vis[maxn];
void dfs(int u){
	cnt++;
	for(int i=0,v;i&lt;G[u].size();i++)
		if(!vis[v=G[u][i]])vis[v]=1,dfs(v);	
}
void dfs2(int u){
	if(!col[u])col[u]=cols;
	else col[u]=-1;
	for(int i=0,v;i&lt;G[u].size();i++){
		if(vis[v=G[u][i]]||iscut[v])continue;
		vis[v]=1;dfs2(v);
	}
}
int main(){
	while(~scanf("%d",&amp;m)){
		if(!m)break;T++;n=0;cols=0;
		memset(iscut,0,sizeof iscut);
		memset(tmp,0,sizeof tmp);
		memset(col,0,sizeof col);
		for(int i=0;i&lt;maxn;i++)G[i].clear();
		for(int i=1;i&lt;=m;i++){
			int u,v;scanf("%d%d",&amp;u,&amp;v);n=max(max(u,v),n);
			G[u].push_back(v);G[v].push_back(u);
		}for(int i=1;i&lt;=n;i++){
			memset(vis,0,sizeof vis);cnt=0;vis[i]=1;dfs(i%n+1);
			for(int j=1;j&lt;=n;j++)if(!vis[j]&amp;&amp;j!=i){iscut[i]=1;break;}
		}for(int i=1;i&lt;=n;i++)if(iscut[i]){
			memset(vis,0,sizeof vis);
			for(int j=0,v;j&lt;G[i].size();j++)if(!vis[v=G[i][j]]&amp;&amp;!iscut[v])
			{cols++;vis[v]=1;dfs2(v);}
		}for(int i=1;i&lt;=n;i++)if(col[i]!=-1)tmp[col[i]]++;
		long long ans=1;cnt=0;printf("Case %d: ",T);
		for(int i=1;i&lt;=cols;i++)if(tmp[i])cnt++,ans*=tmp[i];
		if(cnt==0)cout&lt;&lt;2&lt;&lt;" "&lt;&lt;n*(n-1)/2&lt;&lt;endl;
		else cout&lt;&lt;cnt&lt;&lt;" "&lt;&lt;ans&lt;&lt;endl;
	}
	return 0;
}</pre><pre></pre><h2>Problem2733</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1e5+10;
const int maxm=5e5+10;
int n,m,q;
int getint(){
	int res=0;char ch=getchar();
	while(!isdigit(ch))ch=getchar();
	while(isdigit(ch))res=(res&lt;&lt;3)+(res&lt;&lt;1)+ch-'0',ch=getchar();
	return res;
}
int rnd(){
	static int KEY=12345678;
	return KEY+=KEY&lt;&lt;2|1;
}
struct node{
	int val,key,size,s;
	node *c[2];
    void rz(){  
        size=c[0]-&gt;size+s+c[1]-&gt;size;  
    }  
    void set(int _val=0,int _key=rnd(),int _size=1,int _s=1,node *C=NULL){  
        val=_val;key=_key;size=_size;s=_s;c[0]=c[1]=C;  
    }  
};
node pool[maxn];
node* newnode(){
	static int tot=0;
	if(tot&lt;maxn)return &amp;pool[tot++];
	return new node();
}
struct Treap{
	node *root,*Null;
	Treap(){
		Null=newnode();
		Null-&gt;set(0,INT_MAX,0,0,Null);
		root=Null;
	}	
   void rot(node *&amp;t,bool d){  
        node *p=t-&gt;c[d];t-&gt;c[d]=p-&gt;c[!d];  
        p-&gt;c[!d]=t;t-&gt;rz();p-&gt;rz();t=p;  
    }  
    void _insert(node *&amp;t,int x){  
        if(t==Null){t=newnode();t-&gt;set(x,rnd(),1,1,Null);return;}  
        if(t-&gt;val==x){t-&gt;size+=1;t-&gt;s+=1;return;}  
        _insert(t-&gt;c[x&gt;t-&gt;val],x);  
        if(t-&gt;c[x&gt;t-&gt;val]-&gt;key&lt;t-&gt;key)rot(t,x&gt;t-&gt;val);  
        else t-&gt;rz();  
    }  
	int _kth(node *t,int x){
        int r=t-&gt;c[0]-&gt;size;  
        if(t==Null)return 0;  
        else if(x&lt;=r)return _kth(t-&gt;c[0],x);  
        else if(x&gt;r+t-&gt;s)return _kth(t-&gt;c[1],x-r-t-&gt;s);  
        else return t-&gt;val;  
	}
	void insert(int x){_insert(root,x);}
	int kth(int x){return _kth(root,x);}
	int size(){return root-&gt;size;}
}T[maxn];
int fa[maxn];
int find(int x){
	if(fa[x]!=x)return fa[x]=find(fa[x]);return x;
}
void Union(int x,int y){
	int fax=find(x),fay=find(y);
	if(fax==fay)return;
	if(T[fax].size()&lt;T[fay].size())swap(x,y),swap(fax,fay);
	fa[fay]=fax;
	for(int i=0;i&lt;T[fay].size();i++){
		int val=T[fay].kth(i+1);
		T[fax].insert(val);
	}
}
pair&lt;int,int&gt; ps[maxn];
map&lt;int,int&gt;M;
int main(){
	n=getint();m=getint();
	for(int i=1;i&lt;=n;i++){
		int x=getint();
		ps[i].first=x;ps[i].second=i;fa[i]=i;
	}sort(ps+1,ps+1+n);
	for(int i=1;i&lt;=n;i++){
		T[ps[i].second].insert(i);
		M[i]=ps[i].second;
	}
	for(int i=1;i&lt;=m;i++){
		int u=getint(),v=getint();
		Union(u,v);	
	}q=getint();
	while(q--){
		char o=getchar();
		while(o!='B'&amp;&amp;o!='Q')o=getchar();
		if(o=='B'){
			int u=getint(),v=getint();
			Union(u,v);
		}else{
			int u=find(getint()),k=getint();	
			if(k&gt;T[u].size())puts("-1");		
			else printf("%d\n",M[T[u].kth(k)]);
		}
	}
	return 0;
}</pre><pre></pre><h2>Problem2734</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef int  lld;
lld n,X,Y;
lld vis[200001];
lld mp[201][201];
lld canopt[1&lt;&lt;14];
lld ok[1010][1010];

	lld deb=0;
	
inline void Make_Matrix(lld s){
	memset(mp,0,sizeof(mp));
	mp[1][1]=s;
	X=1,Y=1;
	vis[s]=1;
	for(lld i=2,j=s*2;j&lt;=n;i++,j*=2)
		mp[i][1]=j,X=i,vis[j]=1;
	for(lld i=2,j=s*3;j&lt;=n;i++,j*=3)
		mp[1][i]=j,Y=i,vis[j]=1;
	for(lld i=2;i&lt;=X;i++)
	for(lld j=2;j&lt;=Y;j++){
		if(mp[i-1][j]*2&lt;=n)
		mp[i][j]=mp[i-1][j]*2,vis[mp[i][j]]=1;
	}
	for(lld i=1;i&lt;=X;i++)
	for(lld j=1;j&lt;=Y;j++){
		if(mp[i][j]){
			mp[i][0]++;
			mp[0][j]++;
		}
	}
	if(deb)
	for(lld i=1;i&lt;=X;i++){
		for(lld j=1;j&lt;=Y;j++)
			cout&lt;&lt;mp[i][j]&lt;&lt;" ";
		cout&lt;&lt;endl;
	}//if(deb)cout&lt;&lt;endl;
}
inline bool ok1(lld x){
	if(x&amp;(x&lt;&lt;1))return false;
	if(x&amp;(x&gt;&gt;1))return false;
	return true;
} 
inline bool ok2(lld x,lld y){
	if(x&amp;y)return false;
	return true;
}
lld f[44][3010];
inline lld DP(){
	memset(f,0,sizeof(f));
	f[0][1]=1;
	for(int i=0;i&lt;X;i++){
		for(int j=1;j&lt;=canopt[0];j++){
			if(canopt[j]&gt;&gt;mp[i][0] &gt;0)break;
			for(int k=1;k&lt;=canopt[0];k++){
				if(canopt[k]&gt;&gt;mp[i+1][0]&gt;0)break;
				if(ok2(canopt[j],canopt[k])){
					f[i+1][k]+=f[i][j];
					f[i+1][k]%=1000000001;
				}
			}
		}
	}
	lld ans=0;
	for(int i=1;i&lt;=canopt[0];i++)
	if(canopt[i]&gt;&gt;mp[X][0]&gt;0)break;
	else ans+=f[X][i];
	return ans;
}
inline void Pre(){
	for(lld i=0;i&lt;(1&lt;&lt;14);i++)
	if(ok1(i))
	canopt[++canopt[0]]=i;
	for(lld i=1;i&lt;=canopt[0];i++){
		for(lld j=1;j&lt;=canopt[0];j++)
		if(ok2(canopt[i],canopt[j]))
		ok[i][j]=ok[j][i]=1;
	}
}
int main(){
	cin&gt;&gt;n;
	Pre();
	long long ans=1;
	for(lld i=1;i&lt;=n;i++){
		if(!vis[i]){
			Make_Matrix(i);
			ans*=DP();
			ans%=1000000001;
		}
	}
	cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem2738</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
#define lw(x) (x&amp;-x)
const int maxn=505;
int d[maxn][maxn];
int n,q;
void update(int x,int y,int delt){
	for(int i=x;i&lt;=n;i+=lw(i))
	for(int j=y;j&lt;=n;j+=lw(j))
		d[i][j]+=delt;
}
int get(int x,int y){
	int ans=0;
	for(int i=x;i;i-=lw(i))
	for(int j=y;j;j-=lw(j))
		ans+=d[i][j];
	return ans;
}
int get(int xl,int yl,int xr,int yr){
	int ans=0;
	ans+=get(xr,yr);
	ans-=get(xl-1,yr);
	ans-=get(xr,yl-1);
	ans+=get(xl-1,yl-1);
	return ans;
}
int in(){
	int r=0;char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))r=r*10+c-'0',c=getchar();
	return r;
}
int As;
struct add{
	int x,y,d;
	bool operator&lt;(const add &amp;o)const{return d&lt;o.d;}
}A[maxn*maxn];
struct qes{
	int xl,yl,xr,yr,k,cur,id;
}Q[60001];
int anss[60001];
bool part(const qes &amp;Q){
	return Q.cur&gt;=Q.k;
}
void solve(int lef,int rig,int l,int r){
	if(l==r){
		for(int i=lef;i&lt;=rig;i++)
			anss[Q[i].id]=A[l].d;
		return;
	}
	int mid=(l+r)&gt;&gt;1;
	for(int i=l;i&lt;=mid;i++)
		update(A[i].x,A[i].y,1);
	for(int i=lef;i&lt;=rig;i++)
		Q[i].cur=get(Q[i].xl,Q[i].yl,Q[i].xr,Q[i].yr);
	int dv=partition(Q+lef,Q+rig+1,part)-Q-1;
	
	if(dv&lt;rig)solve(dv+1,rig,mid+1,r);
	
	for(int i=l;i&lt;=mid;i++)
		update(A[i].x,A[i].y,-1);
	
	if(lef&lt;=dv)solve(lef,dv,l,mid);
		
}
int main(){
	scanf("%d%d",&amp;n,&amp;q);
	for(int i=1;i&lt;=n;i++)
	for(int j=1;j&lt;=n;j++){
		int d;
		scanf("%d",&amp;d);
		A[++As]=(add){i,j,d};
	}sort(A+1,A+1+As);
	for(int i=1;i&lt;=q;i++){
		scanf("%d%d%d%d%d",&amp;Q[i].xl,&amp;Q[i].yl,&amp;Q[i].xr,&amp;Q[i].yr,&amp;Q[i].k);
		Q[i].id=i;
	}

	solve(1,q,1,As);
	
	for(int i=1;i&lt;=q;i++)
		printf("%d\n",anss[i]);
	return 0;
}</pre><pre></pre><h2>Problem2743</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1e6+5;
struct segment{int l,r,id;bool operator&lt;(const segment o)const{return r&lt;o.r;};}seg[maxn];
int a[maxn],pre[maxn],last[maxn],n;
#define lw(x) (x&amp;-x)
int d[maxn];
int get(int x){int o=0;while(x&lt;=n)o+=d[x],x+=lw(x);return o;}
void updata(int x,int f){while(x)d[x]+=f,x-=lw(x);}
int anss[maxn],m;
int main(){
	scanf("%d%*d%d",&amp;n,&amp;m);
	for(int i=1;i&lt;=n;i++)
	scanf("%d",&amp;a[i]),pre[i]=last[a[i]],last[a[i]]=i;
	for(int i=1;i&lt;=m;i++)scanf("%d%d",&amp;seg[i].l,&amp;seg[i].r),seg[i].id=i;
	sort(seg+1,seg+1+m);	
	for(int i=1,j=1;i&lt;=n;i++){
		updata(pre[pre[i]],-1);
		updata(pre[i],1);
		while(seg[j].r==i)anss[seg[j].id]=get(seg[j].l),j++;
	}for(int i=1;i&lt;=m;i++)printf("%d\n",anss[i]);
	return 0;
}</pre><pre></pre><h2>Problem2748</h2><pre>#include &lt;cstdio&gt;
 
bool f[55][1111];
 
int main() {
    int n, bg, mx, ans = -1;
    scanf("%d%d%d", &amp;n, &amp;bg, &amp;mx);
    f[0][bg] = true;
    for (int i = 0; i &lt; n; ++i) {
        int x;
        scanf("%d", &amp;x);
        for (int j = 0; j &lt;= mx; ++j)
            if (f[i][j]) {
                if (j + x &gt;= 0 &amp;&amp; j + x &lt;= mx)
                    f[i + 1][j + x] = true;
                if (j - x &gt;= 0 &amp;&amp; j - x &lt;= mx)
                    f[i + 1][j - x] = true;
            }
    }
    for (int i = 0; i &lt;= mx; ++i)
        if (f[n][i])
            ans = i;
    printf("%d\n", ans);
    return 0;
}</pre><pre></pre><h2>Problem2748</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
short f[55][1010];
int a[55];
int n,s,mx;
int main(){
	cin&gt;&gt;n&gt;&gt;s&gt;&gt;mx;
	for(int i=1;i&lt;=n;i++)cin&gt;&gt;a[i];
	f[0][s]=1;
	for(int i=1;i&lt;=n;i++)
	for(int j=0;j&lt;=mx;j++){
		if(j-a[i]&gt;=0)
		f[i][j]|=f[i-1][j-a[i]];
		if(j+a[i]&lt;=mx)
		f[i][j]|=f[i-1][j+a[i]];
	}for(int i=mx;i&gt;=0;i--)if(f[n][i]){printf("%d\n",i);return 0;}
	puts("-1");
	return 0;
}</pre><pre></pre><h2>Problem2751</h2><pre>#include&lt;cstdio&gt;
#include&lt;map&gt;
#include&lt;set&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long LL;
const int maxn=1e5+5;
int n,m,k;
pair&lt;int,int&gt; a[maxn];
LL ans=1;
LL p=1000000007;
LL mul(LL x,LL k,LL p){
    LL ans=0;
    for(;k;k&gt;&gt;=1){
        if(k&amp;1)ans=(ans+x)%p;
        x=(x+x)%p;
    }return ans;
}
LL power(LL x,LL k,LL p){
    LL ans=1;x%=p;
    for(;k;k&gt;&gt;=1){
        if(k&amp;1)ans=mul(ans,x,p);
        x=mul(x,x,p);
    }return ans;
}
LL getint(){
    LL res=0;char c=getchar();
    while(!isdigit(c))c=getchar();
    while(isdigit(c))res=res*10+c-'0',c=getchar();
    return res;
}
set&lt;int&gt;S;
map&lt;LL,LL&gt;M;
int main(){
    n=getint();m=getint();k=getint();
    for(int i=1;i&lt;=k;i++){
        int x=getint(),y=getint();
        a[i].first=x;
        a[i].second=y;
        S.insert(x);
    }LL Sum=(LL)n*(n+1)/2;Sum%=p;
    ans=power(Sum,m-S.size(),p);
    sort(a+1,a+1+k);
    int size=unique(a+1,a+1+k)-a-1;
    for(int i=1;i&lt;=size;i++)
        M[a[i].first]-=a[i].second;
    for(map&lt;LL,LL&gt;::iterator it=M.begin();it!=M.end();it++){
        LL res=it-&gt;second+Sum;
        while(res&lt;0)res+=p;
        ans=(ans*res)%p;
    }
    cout&lt;&lt;ans&lt;&lt;endl;
    return 0;
}</pre><pre></pre><h2>Problem2753</h2><pre>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
#define MAXN 100010
#define MAXM 2000010
using namespace std;
int n,m;
int h[MAXN];
int tp;
int u,v,w;
int f[MAXN];
bool vis[MAXN];
int queue[MAXN],head,tail;
long long sum;
struct Edge
{
	int u,v,w;
	Edge *next;
	bool operator &lt;(const Edge&amp; a)const{
		if (h[v]!=h[a.v]) return h[v]&gt;h[a.v];
		return w&lt;a.w;
	}
}e[MAXM],*prev[MAXN];
void insert(int u,int v,int w)
{
	e[++tp].v=v;e[tp].u=u;e[tp].next=prev[u];prev[u]=&amp;e[tp];e[tp].w=w;
}
int find(int x)
{
	if (f[x]!=x) return f[x]=find(f[x]);
	return f[x];
}
int Union(int x,int y)
{
	int a=find(x),b=find(y);
	if (a!=b) 
	{
		f[b]=a;
		return 1;
	}
	return 0;
}
int main()
{
	scanf("%d%d",&amp;n,&amp;m);
	memset(vis,0,sizeof(vis));
	for (int i=1;i&lt;=n;i++)	scanf("%d",&amp;h[i]);
	for (int i=1;i&lt;=m;i++)
	{
		scanf("%d%d%d",&amp;u,&amp;v,&amp;w);
		if (h[u]&lt;=h[v]) insert(v,u,w);
		if (h[v]&lt;=h[u]) insert(u,v,w);
	}
	for (int i=1;i&lt;=n;i++)	f[i]=i;
	queue[tail++]=1;
	while (head&lt;tail)
	{
		int x=queue[head++];
		vis[x]=1;
		for (Edge *i=prev[x];i;i=i-&gt;next)
			if (!vis[i-&gt;v])	queue[tail++]=i-&gt;v,vis[i-&gt;v]=1;
	}
	sort(e+1,e+tp+1);
	for (int i=1;i&lt;=tp;i++)
		if (vis[e[i].u]&amp;&amp;vis[e[i].v]&amp;&amp;Union(e[i].u,e[i].v))	sum+=e[i].w;
	printf("%d %lld\n",tail,sum);
}</pre><pre></pre><h2>Problem2754</h2><pre>#include&lt;bits/stdc++.h&gt;
#define ind(x) (x-pool)
using namespace std;
struct node{
	map&lt;int,node*&gt;go;
	node *f,*l;
	int val,id,ans,vis;
	node(node *C=0){val=id=vis=ans=0;f=l=C;}	
}*root,pool[int(200005)],*cur=pool,*null=cur++;
node* newnode(node *C){
	node *x=cur++;
	*x=node(C);return x;
}
int n,m,now;
typedef map&lt;int,node*&gt;::iterator Iter;
vector&lt;int&gt;vec[(20000)+5][2];
int anss[int(20000)+5];
int vis[int(50000)+5];
node *endd[int(50000)+5];
void insert(int id){
	int n,x;scanf("%d",&amp;n);
	node *u=root;
	while(n--){
		scanf("%d",&amp;x);
		if(!u-&gt;go.count(x))u-&gt;go[x]=newnode(null);
		u=u-&gt;go[x];
	}u-&gt;id=id;endd[id]=u;u-&gt;val++;
}
void bfs(){
	queue&lt;node*&gt;q;
	for(Iter it=root-&gt;go.begin();it!=root-&gt;go.end();it++)
		q.push(it-&gt;second),it-&gt;second-&gt;l=it-&gt;second-&gt;f=root;
	while(!q.empty()){
		node *u=q.front();q.pop();
		//cerr&lt;&lt;ind(u)&lt;&lt;": ";
		for(Iter i=u-&gt;go.begin();i!=u-&gt;go.end();i++){
			node *v=i-&gt;second,*j=u-&gt;f;q.push(v);
			//cerr&lt;&lt;ind(v)&lt;&lt;" ";
			while(j!=null&amp;&amp;!j-&gt;go.count(i-&gt;first))j=j-&gt;f;
			v-&gt;f=j-&gt;go.count(i-&gt;first)?j-&gt;go[i-&gt;first]:null;
			v-&gt;l=v-&gt;f-&gt;id?v-&gt;f:v-&gt;f-&gt;l;
		}//cerr&lt;&lt;endl;
	}
}
void print(node *j){
	//if(j-&gt;vis==now)return;
	j-&gt;ans+=j-&gt;vis!=now;j-&gt;vis=now;
	if(vis[j-&gt;id]!=now)
	anss[now]+=j-&gt;val;
	vis[j-&gt;id]=now;
	if(j-&gt;l!=null)print(j-&gt;l);
}
void find(int _x,int _y){
	node *u=root;now=_x;
	for(int i=0;i&lt;vec[_x][_y].size();i++){
		int x=vec[_x][_y][i];
		while(u!=null&amp;&amp;!u-&gt;go.count(x))u=u-&gt;f;
		u=u-&gt;go.count(x)?u-&gt;go[x]:null;
		if(u-&gt;id)print(u);
		else if(u-&gt;l-&gt;id)print(u-&gt;l);
	}
}
int main(){
	root=null;null-&gt;l=null-&gt;f=null;
	scanf("%d%d",&amp;n,&amp;m);
	for(int i=1;i&lt;=n;i++){
		int x,y;
		scanf("%d",&amp;x);
		for(int j=1;j&lt;=x;j++)
			scanf("%d",&amp;y),vec[i][0].push_back(y);
		scanf("%d",&amp;x);
		for(int j=1;j&lt;=x;j++)
			scanf("%d",&amp;y),vec[i][1].push_back(y);		
	}
	for(int i=1;i&lt;=m;i++)
		insert(i);
	bfs();
	for(int i=1;i&lt;=n;i++){
		find(i,0);
		find(i,1);
	}for(int i=1;i&lt;=m;i++)
		printf("%d\n",endd[i]-&gt;ans);
	for(int i=1;i&lt;=n;i++)
		printf("%d%c",anss[i]," \n"[i==n]);
	return 0;
}</pre><pre></pre><h2>Problem2756</h2><pre>/**************************************************************
    Problem: 2756
    User: jianing
    Language: C++
    Result: Accepted
    Time:11884 ms
    Memory:3192 kb
****************************************************************/
 
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
#include&lt;cstring&gt;
using namespace std;
typedef long long LL;
const LL inf=0x3f3f3f3f3f3f3f3fll;
#define most 1000000000
 
int n,m,l=0,e=0;
int map[50][50],val[2510];
struct node
{
    int u,v,next;
    LL c;
}edge[100000];
int head[100000];
int d[2500],sumd[2500];
int maxx;
LL sum1,sum2;
 
void read()
{

}
 
void add(int u,int v,LL c)
{
    edge[e].u=u;
    edge[e].v=v;
    edge[e].c=c;
    edge[e].next=head[u];
    head[u]=e++;
    edge[e].u=v;
    edge[e].v=u;
    edge[e].c=0;
    edge[e].next=head[v];
    head[v]=e++;
}
 
LL sap(int u,LL flow)
{
    if(u==l+1)return flow;
    LL res=0;
    for(int i=head[u];i!=-1;i=edge[i].next)
    {
        int v=edge[i].v;
        if(edge[i].c &amp;&amp; d[u]==d[v]+1)
        {
            LL t=sap(v,(LL)min(edge[i].c,(flow-res)));
            res+=t;
            edge[i].c-=t;edge[i^1].c+=t;
            if(res==flow)return res;
            if(d[0]&gt;=l+2)return res;//本来放在下面,T哭了
        }                           //
    }                               //
    sumd[d[u]]--;                   //就这儿
    if(sumd[d[u]]==0)d[0]=l+2;
    sumd[++d[u]]++;
    return res;
}
 
LL flow(LL x)
{
    memset(head,-1,sizeof(head));
    memset(edge,0,sizeof(edge));
    e=0;l=n*m;int t=n*m+1;
    for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;=m;j++)
        {
            if((i+j)&amp;1)
            {
                add(0,m*(i-1)+j,x-map[i][j]);
                if(i&gt;1)add(m*(i-1)+j,m*(i-2)+j,inf);
                if(i&lt;n)add(m*(i-1)+j,m*i+j,inf);
                if(j&gt;1)add(m*(i-1)+j,m*(i-1)+j-1,inf);
                if(j&lt;m)add(m*(i-1)+j,m*(i-1)+j+1,inf);
            }
            else add(m*(i-1)+j,t,x-map[i][j]);
        }
    memset(d,0,sizeof(d));
    memset(sumd,0,sizeof(sumd));
    sumd[0]=l+2;
    LL ans=0;
    while(d[0]&lt;=l+1)
        ans+=sap(0,inf);
    return ans;
}
 
 
void check()
{
    LL best=inf;
    LL ll=(LL)maxx,rr=inf;
    while(ll&lt;rr)
    {
        LL mid=(ll+rr)&gt;&gt;1;
        LL ans=flow(mid);
        LL tmp=mid*n*m-sum1-sum2;
        if(tmp==ans*2)
        {
            if(ans&gt;0)best=min(best,ans);
            rr=mid;
        }
        else ll=mid+1;
    }
    printf("%lld\n",best);
}
 
LL max(LL a,LL b)
{
    return a&gt;b?a:b;
}
 
void work()
{
    e=0;maxx=0;
    sum1=0;sum2=0;int cnt1=0,cnt2=0;
    memset(map,0,sizeof(map));
    scanf("%d%d",&amp;n,&amp;m);
    for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;=m;j++)
        {
            scanf("%d",&amp;map[i][j]);
            maxx=max(maxx,map[i][j]);
            if((i+j)&amp;1)
            {
                sum1+=map[i][j];
                cnt1++;
            }
            else
            {
                sum2+=map[i][j];
                cnt2++;
            }
        }
    if(cnt1!=cnt2)
    {
        if((sum1-sum2)%(cnt1-cnt2)!=0)printf("-1\n");
        LL diff=(sum1-sum2)/(cnt1-cnt2);
        if(diff&lt;maxx)
        {
            printf("-1\n");
            return ;
        }
        else
        {
            LL ans=flow(diff);
            LL tmp=diff*n*m-sum1-sum2;
            if(tmp==ans*2)printf("%lld\n",ans);
            else printf("-1\n");
        }
    }
    else check();
}
 
int main()
{
   // read();
    int test;
    scanf("%d",&amp;test);
    while(test--)
    work();
    return 0;
}</pre><pre></pre><h2>Problem2761</h2><pre>#include &lt;map&gt;
#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
map&lt;unsigned,bool&gt;hash;
int first=1;
int main(){
	int T,n,x;
	scanf("%d",&amp;T);
	while(T--){
		first=1;
		scanf("%d",&amp;n);
		while(n--){
			scanf("%d",&amp;x);
			if(!hash.count(x)){
				if(!first)
				printf(" %d",x);
				else{
					first=0;
					printf("%d",x);
				}
				hash[x]=true;
			}
		}
		printf("\n");
		hash.clear();
	}
	return 0;
}</pre><pre></pre><h2>Problem2763</h2><pre>#include &lt;queue&gt;
#include &lt;cstdio&gt;
#include &lt;vector&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#define X first
#define Y second
using namespace std;
int n,m,k;
struct edge{
	int u,v,w;
};
vector&lt;edge&gt;edges;
vector&lt;int&gt;G[200101];
void add(int u,int v,int w){
	edges.push_back((edge){u,v,w});
	G[u].push_back(edges.size()-1);
}
int u,v,w,s,t;
int d[200101];
int vis[200101];
typedef pair&lt;int,int&gt; pii;
priority_queue&lt;pii,vector&lt;pii&gt;,greater&lt;pii&gt; &gt;q;
void Dijk(){
	memset(d,0x7f,sizeof(d));
	d[s]=0;
	q.push(pii(d[s],s));
	while(!q.empty()){
		int u=q.top().Y;q.pop();
		if(vis[u])continue;
		vis[u]=1;
		for(int i=0;i&lt;G[u].size();i++){
			edge e=edges[G[u][i]];
			if(d[e.v]&gt;d[u]+e.w){
				d[e.v]=d[u]+e.w;
				q.push(pii(d[e.v],e.v));
			}
		}
	}
	cout&lt;&lt;d[t]&lt;&lt;endl;
}
int main(){
	 cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;
	 cin&gt;&gt;s&gt;&gt;t;
	 t+=n*k;
	 for(int i=1;i&lt;=m;i++){
	 	cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;
	 	for(int j=0;j&lt;=k;j++){
	 		add(u+j*n,v+j*n,w);
	 		add(v+j*n,u+j*n,w);
	 		add(u+j*n,v+(j+1)*n,0);
	 		add(v+j*n,u+(j+1)*n,0);
	 	}
	 }
	 int deb=0;
	 if(deb)
	 for(int i=0;i&lt;edges.size();i++){
	 	printf("#%d  %d -&gt; %d  w:%d\n",
		 i,edges[i].u,edges[i].v,edges[i].w);
	 }
	 Dijk();
	return 0;
}</pre><pre></pre><h2>Problem2768</h2><pre>/*
	ID:zky
	OJ:BZOJ
	Index:2768
	Language:C++
*/
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
int w[301][301];
int a[301];
int n,m;
int vis[301];
int Link[302];
bool find(int x){
	for(int i=1;i&lt;=n;i++){
		if(w[x][i]&amp;&amp;!vis[i]){
			vis[i]=1;
			if(!Link[i]||find(Link[i])){
				Link[i]=x;
				return true;
			}
		}
	}
	return false;
}
int main(){
	cin&gt;&gt;n&gt;&gt;m;
	for(int i=1;i&lt;=n;i++)cin&gt;&gt;a[i];
	for(int i=1;i&lt;=m;i++){
		int Alice,Bob;
		cin&gt;&gt;Alice&gt;&gt;Bob;
		if(a[Alice]^a[Bob])w[Alice][Bob]=w[Bob][Alice]=1;
	}
	int ans=0;
	for(int i=1;i&lt;=n;i++){
		memset(vis,0,sizeof(vis));
		if(find(i))ans++;
	}
	cout&lt;&lt;ans/2&lt;&lt;endl;
	return 0;
}
 </pre><pre></pre><h2>Problem2770</h2><pre>#include&lt;set&gt;
#include&lt;map&gt;
#include&lt;ctime&gt;
#include&lt;queue&gt;
#include&lt;cmath&gt;
#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
#include&lt;cstdlib&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#define inf 2147483647
using namespace std;
int read()
{
	int x=0,f=1;char ch=getchar();
	while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
int n,m,tot;
int v[400005],p[400005],a[400005],b[400005];
map&lt;int,int&gt;pid,kid;
char ch[300005][2];
vector&lt;pair&lt;int,int&gt; &gt;q;
struct seg{
	int l,r,mn;
}t[1600005];
void build(int k,int l,int r)
{
	t[k].l=l;t[k].r=r;
	if(l==r){t[k].mn=inf;return;}
	int mid=(l+r)&gt;&gt;1;
	build(k&lt;&lt;1,l,mid);
	build(k&lt;&lt;1|1,mid+1,r);
	t[k].mn=min(t[k&lt;&lt;1].mn,t[k&lt;&lt;1|1].mn);
}
int query(int k,int x,int y)
{
	int l=t[k].l,r=t[k].r,mid=(l+r)&gt;&gt;1;
	if(x==l&amp;&amp;y==r)return t[k].mn;
	if(y&lt;=mid)return query(k&lt;&lt;1,x,y);
	else if(x&gt;mid)return query(k&lt;&lt;1|1,x,y);
	else return min(query(k&lt;&lt;1,x,mid),query(k&lt;&lt;1|1,mid+1,y));
}
void insert(int k,int x,int val)
{
	int l=t[k].l,r=t[k].r,mid=(l+r)&gt;&gt;1;
	if(l==r){t[k].mn=val;return;}
	if(x&lt;=mid)insert(k&lt;&lt;1,x,val);
	else insert(k&lt;&lt;1|1,x,val);
	t[k].mn=min(t[k&lt;&lt;1].mn,t[k&lt;&lt;1|1].mn);
}
int main()
{
	n=read();m=read();tot=n;
	for(int i=1;i&lt;=n;i++)v[i]=read();
	for(int i=1;i&lt;=n;i++)p[i]=read();
	for(int i=1;i&lt;=n;i++)
		q.push_back(make_pair(v[i],p[i]));
	for(int i=1;i&lt;=m;i++)
	{
		scanf("%s",ch[i]+1);
		a[i]=read();
		if(ch[i][1]!='D')b[i]=read();
		if(ch[i][1]=='I')
		{
			v[++tot]=a[i],p[tot]=b[i];
			q.push_back(make_pair(a[i],b[i]));
		}
	}
	sort(q.begin(),q.end());
	build(1,1,tot);
	for(int i=1;i&lt;=n;i++)
	{
		kid[v[i]]=pid[p[i]]=lower_bound(q.begin(),q.end(),make_pair(v[i],p[i]))-q.begin()+1;
		insert(1,kid[v[i]],p[i]);
	}
	for(int i=1;i&lt;=m;i++)
	{
		if(ch[i][1]=='I')
		{
			kid[a[i]]=pid[b[i]]=lower_bound(q.begin(),q.end(),make_pair(a[i],b[i]))-q.begin()+1;
			insert(1,kid[a[i]],b[i]);
		}
		else if(ch[i][1]=='D')insert(1,kid[a[i]],inf);
		else 
		{
			int t1=kid[a[i]],t2=kid[b[i]]; 
			if(t1&gt;t2)swap(t1,t2);
			int p=query(1,t1,t2);
			printf("%d\n",q[pid[p]-1].first);
		}
	}
	return 0;
}












































































</pre><pre></pre><h2>Problem2783</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;map&gt;
#include&lt;iostream&gt;
using namespace std;
const int maxn=1e5+5;
int n,S;
int w[maxn],d[maxn];
vector&lt;int&gt;G[maxn];
long long ans=0;
map&lt;int,int&gt;M;
void dfs(int u,int f){
	M[d[u]]++;
	for(int i=0,v;i&lt;G[u].size();i++){
		if((v=G[u][i])!=f){
			d[v]=d[u]+w[v];
			ans+=M[d[v]-S];
			dfs(v,u);
		}
	}if(!--M[d[u]])M.erase(d[u]);
}
int main(){
	scanf("%d%d",&amp;n,&amp;S);
	for(int i=1;i&lt;=n;++i)scanf("%d",&amp;w[i]);
	for(int i=1;i&lt;n;i++){
		int u,v;scanf("%d%d",&amp;u,&amp;v);
		G[u].push_back(v);
		G[v].push_back(u);
	}d[1]=w[1];M[0]=1;
	dfs(1,1);
	cout&lt;&lt;ans&lt;&lt;endl;
}</pre><pre></pre><h2>Problem2789</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1e6+5;
int d[maxn];
int p[maxn];
deque&lt;int&gt;v[233];
char s1[maxn],s2[maxn];
int n;
#define lowbit(x) (x&amp;-x)
int get(int x){
	int ans=0;
	while(x)ans+=d[x],x-=lowbit(x);
	return ans;
}
void updata(int x,int f){
	while(x&lt;=n)d[x]+=f,x+=lowbit(x);
}
int main(){
	scanf("%d",&amp;n);
	scanf("%s",s1+1);
	scanf("%s",s2+1);
    for(int i=1;i&lt;=n;i++)  
        v[s1[i]-'A'].push_back(i);  
    for(int i=1;i&lt;=n;i++){  
        p[i]=v[s2[i]-'A'].front();  
        v[s2[i]-'A'].pop_front();  
    }long long ans=0;
    for(int i=1;i&lt;=n;i++){  
        ans+=i-get(p[i])-1;  
        updata(p[i],1);
    }cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem2793</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1e6+4;
int n,m;
int p[maxn];
bitset&lt;maxn&gt;vis,lucky;
vector&lt;long long&gt;anss;
int getint(){
	int res=0;char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))res=res*10+c-'0',c=getchar();
	return res;
}
long long cur;
int main(){
	n=getint();
	for(int i=1;i&lt;maxn;i++)p[i]=i;
	for(int i=1;i&lt;=n;i++)lucky[getint()]=1;
	m=getint();
	while(m--){
		int x=getint();
		for(int i=1;i&lt;=x;i++){
			int &amp;now=p[x];
			while(now&lt;maxn&amp;&amp;vis[now])now+=x;
			if(now&gt;=maxn)break;vis[now]=1;
			if(lucky[now])anss.push_back(cur+i);
		}cur+=x;
	}printf("%d\n",anss.size());
	for(int i=0;i&lt;anss.size();i++)printf("%lld\n",anss[i]);
	return 0;
}</pre><pre></pre><h2>Problem2795</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef unsigned long long UL;
const int maxn=5e5+5;
int n,m;
int notp[maxn],p[maxn],minp[maxn];
UL h[maxn],h_l[maxn];
UL get(int l,int r){
	if(l&gt;r)return -1;
	return h[r]-h[l-1]*h_l[r-l+1];	
}
char s[maxn];
int getint(){
	int res=0;char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))res=res*10+c-'0',c=getchar();
	return res;
}
int main(){
	for(int i=2;i&lt;maxn;i++){
		if(!notp[i])minp[i]=i,p[++p[0]]=i;
		for(int j=1;j&lt;=p[0]&amp;&amp;i*p[j]&lt;maxn;j++){
			notp[i*p[j]]=1;minp[i*p[j]]=p[j];
			if(i%p[j]==0)break;
		}
	}
	scanf("%d",&amp;n);int _n=0;
	char c=getchar();while(!isalpha(c))c=getchar();
	while(isalpha(c))s[++_n]=c,c=getchar();h_l[0]=1;
	for(int i=1;i&lt;=n;i++)h_l[i]=h_l[i-1]*233;
	for(int i=1;i&lt;=n;i++)h[i]=h[i-1]*233+s[i];
	for(scanf("%d",&amp;m);m--;){
		int l=getint(),r=getint();
		int len=r-l+1;
		for(int i=len;i&gt;1;){
			int j=minp[i];
			while(len%j==0&amp;&amp;get(l,r-len/j)==get(l+len/j,r))len/=j;
			while(i%j==0)i/=j;
		}printf("%d\n",len);
	}
	return 0;
}</pre><pre></pre><h2>Problem2795</h2><pre>#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
#include &lt;cmath&gt;
#include &lt;vector&gt;
 
using namespace std ;
 
typedef long long ll ;
 
const int p = 31 , P = 1000173169 ;
const int maxn = 501000 ;
 
char s[ maxn ] ;
int n , m ;
 
bool flag[ maxn ] ;
vector &lt; int &gt; vec[ maxn ] ;
int prm[ maxn ] , pn = 0 ;
 
inline int power( int x , int cnt ) {
        int y = 1 ;
        for ( ; cnt ; cnt &gt;&gt;= 1 ) {
                if ( cnt &amp; 1 ) y = ( ll ) y * x % P ;
                x = ( ll ) x * x % P ;
        }
        return y ;
}
 
int mul[ maxn ] , pre[ maxn ] ;
 
inline void Init(  ) {
        memset( flag , true , sizeof( flag ) ) ;
        for ( int i = 2 ; i &lt;= n ; ++ i ) {
                if ( flag[ i ] ) prm[ ++ pn ] = i ;
                for ( int j = 1 ; i * prm[ j ] &lt;= n &amp;&amp; j &lt;= pn ; ++ j ) {
                        flag[ i * prm[ j ] ] = false ;
                        if ( ! ( i % prm[ j ] ) ) break ;
                }
        }
        for ( int i = 0 ; i ++ &lt; pn ; ) {
                for ( int j = prm[ i ] ; j &lt;= n ; j += prm[ i ] ) vec[ j ].push_back( prm[ i ] ) ;
        }
        mul[ 0 ] = 1 ;
        for ( int i = 0 ; i ++ &lt; n ; ) mul[ i ] = ( ll ) mul[ i - 1 ] * p % P ;
        pre[ 0 ] = 0 ;
        for ( int i = 0 ; i ++ &lt; n ; ) pre[ i ] = ( ( ( ll ) pre[ i - 1 ] * p % P ) + ( s[ i ] - 'a' ) ) % P ;
}
 
inline int query( int l , int r ) {
        if ( l &gt; r ) return 0 ;
        int sum = ( ll ) pre[ l - 1 ] * mul[ r - l + 1 ] % P ;
        sum = ( pre[ r ] - sum + P ) % P ;
        return sum ;
}
 
inline bool check( int l , int r , int x ) {
        return query( l , r - x ) == query( l + x , r ) ;
}
 
inline int Query( int l , int r ) {
        int len = r - l + 1 , cnt = 1 , y , z ;
        for ( vector &lt; int &gt; :: iterator i = vec[ len ].begin(  ) ; i != vec[ len ].end(  ) ; ++ i ) {
                for ( y = 1 ; ; ) {
                        if ( ! ( len % ( z = y * *i ) ) ) {
                                if ( check( l , r , len / z ) ) y = z ; else break ;
                        } else break ;
                }
                cnt *= y ;
        }
        return len / cnt ;
}
 
int main(  ) {
        scanf( "%d" , &amp;n ) ; scanf( "%s" , s + 1 ) ;
        Init(  ) ;
        scanf( "%d" , &amp;m ) ;
        while ( m -- ) {
                int l , r ; scanf( "%d%d" , &amp;l , &amp;r ) ; printf( "%d\n" , Query( l , r ) ) ;
        }
        return 0 ;
}
</pre><pre></pre><h2>Problem2795</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long UL;
const int maxn=5e5+5;
int n,m;
int notp[maxn],p[maxn],minp[maxn];
UL h[maxn],h_l[maxn];
UL get(int l,int r){
    if(l&gt;r)return -1;
    return h[r]-h[l-1]*h_l[r-l+1];  
}
char s[maxn];
int getint(){
    int res=0;char c=getchar();
    while(!isdigit(c))c=getchar();
    while(isdigit(c))res=res*10+c-'0',c=getchar();
    return res;
}
int main(){
    for(int i=2;i&lt;maxn;i++){
        if(!notp[i])minp[i]=i,p[++p[0]]=i;
        for(int j=1;j&lt;=p[0]&amp;&amp;i*p[j]&lt;maxn;j++){
            notp[i*p[j]]=1;minp[i*p[j]]=p[j];
            if(i%p[j]==0)break;
        }
    }
    scanf("%d",&amp;n);int _n=0;
    char c=getchar();while(!isalpha(c))c=getchar();
    while(isalpha(c))s[++_n]=c,c=getchar();h_l[0]=1;
    for(int i=1;i&lt;=n;i++)h_l[i]=h_l[i-1]*233;
    for(int i=1;i&lt;=n;i++)h[i]=h[i-1]*233+s[i];
    for(scanf("%d",&amp;m);m--;){
        int l=getint(),r=getint();
        int len=r-l+1;
        for(int i=len;i&gt;1;){
            int j=minp[i];
            while(len%j==0&amp;&amp;get(l,r-len/j)==get(l+len/j,r))len/=j;
            while(i%j==0)i/=j;
        }printf("%d\n",len);
    }
    return 0;
}</pre><pre></pre><h2>Problem2795</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long UL;
const int maxn=5e5+5;
int n,m;
int notp[maxn],p[maxn],minp[maxn];
UL h[maxn],h_l[maxn];
UL get(int l,int r){
    if(l&gt;r)return 0;
    return (h[r]-h[l-1]*h_l[r-l+1]%1000173169+1000173169)%1000173169;  
}
char s[maxn];
int getint(){
    int res=0;char c=getchar();
    while(!isdigit(c))c=getchar();
    while(isdigit(c))res=res*10+c-'0',c=getchar();
    return res;
}
int main(){
    for(int i=2;i&lt;maxn;i++){
        if(!notp[i])minp[i]=i,p[++p[0]]=i;
        for(int j=1;j&lt;=p[0]&amp;&amp;i*p[j]&lt;maxn;j++){
            notp[i*p[j]]=1;minp[i*p[j]]=p[j];
            if(i%p[j]==0)break;
        }
    }
    scanf("%d",&amp;n);int _n=0;
    char c=getchar();while(!isalpha(c))c=getchar();
    while(isalpha(c))s[++_n]=c,c=getchar();h_l[0]=1;
    for(int i=1;i&lt;=n;i++)h_l[i]=h_l[i-1]*31%1000173169;
    for(int i=1;i&lt;=n;i++)h[i]=(h[i-1]*31+s[i])%1000173169;
    for(scanf("%d",&amp;m);m--;){
        int l=getint(),r=getint();
        int len=r-l+1;
        for(int i=len;i&gt;1;){
            int j=minp[i];
            while(len%j==0&amp;&amp;get(l,r-len/j)==get(l+len/j,r))len/=j;
            while(i%j==0)i/=j;
        }printf("%d\n",len);
    }
    return 0;
}</pre><pre></pre><h2>Problem2795</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
const int maxn=501000;
const int mo=1000173169;
int n,m;
int notp[maxn],p[maxn],minp[maxn];
int h[maxn],h_l[maxn];
int get(int l,int r){
    if(l&gt;r)return 0;
    return ((LL)h[r]-(LL)h[l-1]*h_l[r-l+1]%mo+mo)%mo;  
}
char s[maxn];
int getint(){
    int res=0;char c=getchar();
    while(!isdigit(c))c=getchar();
    while(isdigit(c))res=res*10+c-'0',c=getchar();
    return res;
}
int main(){
    for(int i=2;i&lt;maxn;i++){
        if(!notp[i])minp[i]=i,p[++p[0]]=i;
        for(int j=1;j&lt;=p[0]&amp;&amp;i*p[j]&lt;maxn;j++){
            notp[i*p[j]]=1;minp[i*p[j]]=p[j];
            if(i%p[j]==0)break;
        }
    }
    scanf("%d",&amp;n);int _n=0;
    char c=getchar();while(!isalpha(c))c=getchar();
    while(isalpha(c))s[++_n]=c,c=getchar();h_l[0]=1;
    for(int i=1;i&lt;=n;i++)h_l[i]=(LL)h_l[i-1]*31%mo;
    for(int i=1;i&lt;=n;i++)h[i]=((LL)h[i-1]*31%mo+s[i]-'a')%mo;
    for(scanf("%d",&amp;m);m--;){
        int l=getint(),r=getint();
        int len=r-l+1;
        for(int i=len;i&gt;1;){
            int j=minp[i];
            while(len%j==0&amp;&amp;get(l,r-len/j)==get(l+len/j,r))len/=j;
            while(i%j==0)i/=j;
        }printf("%d\n",len);
    }
    return 0;
}</pre><pre></pre><h2>Problem2800</h2><pre>#ifdef unix
#define LL "%lld"
#else
#define LL "%I64d"
#endif

#define INPUT "in"
#define OUTPUT "out"

#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;cctype&gt;
#include &lt;vector&gt;
#include &lt;cassert&gt;
#include &lt;queue&gt;

#define mp make_pair
#define pb push_back
#define foreach(i,T) for(__typeof(T.begin()) i = T.begin(); i != T.end(); ++i)

using namespace std;

namespace Solve {
	typedef long long Int64;

	const Int64 MAXN = 100010;

	inline Int64 ScanInt(void) {
		Int64 r = 0, c, d;
		while (!isdigit(c = getchar()) &amp;&amp; c != '-');
		if (c != '-') r = c - '0'; d = c;
		while ( isdigit(c = getchar())) r = r * 10l + c - '0';
		return d=='-'?-r:r;
	}

	inline Int64 Exgcd(Int64 a, Int64 b, Int64 &amp;x, Int64 &amp;y) {
		if (!b) {
			x = 1, y = 0;
			return a;
		}
		Int64 r = Exgcd(b , a % b, x, y);
		Int64 t = x; x = y , y = t - a / b * y;
		return r;
	}

	Int64 c[MAXN], n, a, b, p[MAXN];

	inline void Input(void) {
		n = ScanInt(), a = ScanInt(), b = ScanInt();
		for (Int64 i = 1; i &lt;= n; i++) p[i] = ScanInt();
		n++;
		for (Int64 i = 1; i &lt;= n; i++) c[i] = p[i] - p[i - 1];
	}

	inline void Min(Int64 &amp;x, Int64 &amp;y) {
		Int64 x1 = x, y1 = y, x2 = x, y2 = y;
		Int64 tmp1 = x / b; x1 = x - tmp1 * b, y1 = y + tmp1 * a;
		Int64 tmp2 = y / a; x2 = x + tmp2 * b, y2 = y - tmp2 * a;
		if (abs(x1) + abs(y1) &lt; abs(x2) + abs(y2))
			x = x1, y = y1;
		else
			x = x2, y = y2;
		if (x1 &gt; 0) x1 -= b, y1 += a; else x1 += b, y1 -= a;
		if (y2 &gt; 0) x2 += b, y2 -= a; else x2 -= b, y2 += a;
		if (abs(x1) + abs(y1) &lt; abs(x2) + abs(y2))
			x2 = x1, y2 = y1;
		if (abs(x2) + abs(y2) &lt; abs(x) + abs(y)) x = x1, y = y1;
	}

	priority_queue&lt;pair&lt;Int64, Int64&gt; &gt; Q;

	Int64 X[MAXN], Y[MAXN];

	inline void Insert(Int64 i) {
		Q.push(mp(abs(X[i]) + abs(Y[i]) - abs(X[i] - b) - abs(Y[i] + a), i));
	}

	inline void Work(void) {
		Int64 t_x = 0, t_y = 0;
		Int64 d = Exgcd(a, b, t_x, t_y); a /= d, b /= d;
		for (Int64 i = 1; i &lt;= n; i++) {
			if (c[i] % d != 0) {puts("-1"); return;}
			c[i] /= d;
		}
		Int64 Sx = 0, Sy = 0;
		for (Int64 i = 1; i &lt;= n; i++) {
			X[i] = t_x * -c[i], Y[i] = t_y * -c[i];
			Min(X[i], Y[i]);
			Sx += X[i], Sy += Y[i];
		}
		if (Sx &lt;= 0) {
			swap(a, b); swap(Sx, Sy);
			for (Int64 i = 1; i &lt;= n; i++) swap(X[i], Y[i]);
		}
		for (Int64 i = 1; i &lt;= n; i++) {
			Insert(i);
		}
		while (Sx != 0) {
			Int64 now = Q.top().second; Q.pop();
			Sx -= b, Sy += a;
			X[now] -= b, Y[now] += a;
			Insert(now);
		}
		Int64 ret = 0;
		for (Int64 i = 1; i &lt;= n; i++) ret += abs(X[i]) + abs(Y[i]);
		printf(LL "\n", ret &gt;&gt; 1);
	}

	inline void solve(void) {
		Input();
		Work();
	}
}

int main(void) {
	#ifdef FILEIO
		freopen(INPUT, "r", stdin);
//		freopen(OUTPUT, "w", stdout);
	#endif
	Solve::solve();
	return 0;
}</pre><pre></pre><h2>Problem2802</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=250010;
typedef pair&lt;int,int&gt; pi;
typedef long long LL;
set&lt;pi&gt;S;
int a[maxn],b[maxn],n,anss[maxn];
LL now;
int main(){
	scanf("%d",&amp;n);
	for(int i=1;i&lt;=n;i++)scanf("%d",&amp;a[i]);
	for(int i=1;i&lt;=n;i++)scanf("%d",&amp;b[i]);
	for(int i=1;i&lt;=n;i++){
		now+=a[i];
		if(now&gt;=b[i]){
			now-=b[i];
			S.insert(pi(b[i],i));
			continue;
		}else{
			if(S.empty())continue;
			pi x=*(--S.end());
			if(x.first&gt;b[i]){
				S.erase(--S.end());
				now=now+x.first-b[i];
				S.insert(pi(b[i],i));				
			}
		}
	}printf("%d\n",S.size());
	for(set&lt;pi&gt;::iterator i=S.begin();i!=S.end();i++)anss[++anss[0]]=i-&gt;second;
	sort(anss+1,anss+1+anss[0]);
	for(int i=1;i&lt;=anss[0];i++)printf("%d ",anss[i]);
	return 0;
}</pre><pre></pre><h2>Problem2809</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;climits&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=1e5+10;
int n,m;
int sor[maxn],lead[maxn],tot;
struct node{
	int val,dis;
	node *c[2];
}*Null,poor[maxn&lt;&lt;2];
namespace TRT{
	struct LeftistTree{
		node *root;
		int sum,size;
		void init(){
			sum=size=0;
			root=Null;
		}			
		node *merge(node *&amp;A,node *&amp;B){
			if(A==Null)return B;
			if(B==Null)return A;
			if(A-&gt;val&lt;B-&gt;val)
				swap(A,B);
			A-&gt;c[1]=merge(A-&gt;c[1],B);
			if(A-&gt;c[0]-&gt;dis&lt;A-&gt;c[1]-&gt;dis)
				swap(A-&gt;c[0],A-&gt;c[1]);
			A-&gt;dis=A-&gt;c[1]-&gt;dis+1;
			return A;
		}
		void merge(LeftistTree &amp;B){
			size+=B.size;
			sum+=B.sum;
			root=merge(root,B.root);
		}
 	   void insert(int x) {
    	    node *p = &amp;poor[++tot];
        	++size;
        	sum += x;
        	p-&gt;val = x;
        	p-&gt;dis = 0;
        	p-&gt;c[0] = p-&gt;c[1] = Null;
        	root = merge(root, p);
    	}
		int top(){
			return root-&gt;val;
		}
		void pop(){
			size--;
			sum-=root-&gt;val;
			root=merge(root-&gt;c[0],root-&gt;c[1]);
		}
	}t[maxn];
}
using namespace TRT;
namespace TOPL{
	vector&lt;int&gt;G[maxn];
	void add(int u,int v){
		G[u].push_back(v);
	}
	int root=1;
	void init(){
		Null=new node;Null-&gt;dis=-1;
		scanf("%d%d",&amp;n,&amp;m);
		for(int i=1;i&lt;=n;i++){
			int a,b,c;scanf("%d%d%d",&amp;a,&amp;b,&amp;c);
			if(a)add(a,i);
			else root=i;
			sor[i]=b;
			lead[i]=c;
		}
	}
	long long ans=0;
	void dfs(int u){
		t[u].init();
		t[u].insert(sor[u]);
		for(int i=0;i&lt;G[u].size();i++){
			int v=G[u][i];
			dfs(v);
			t[u].merge(t[v]);
			while(t[u].sum&gt;m)
				t[u].pop();
		}
		ans=max(ans,(long long)lead[u]*t[u].size);
	}
	void solve(){
		init();
		dfs(root);
		cout&lt;&lt;ans&lt;&lt;endl;
	}
}
int main(){
	TOPL::solve();
	return 0;
}</pre><pre></pre><h2>Problem2812</h2><pre>aa</pre><pre></pre><h2>Problem2815</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=65536;
const int BIT=17;
int n,in[maxn];
vector&lt;int&gt;G[maxn],Ge[maxn],GG[maxn];
int fa[maxn][BIT],siz[maxn],dep[maxn];
void make(int u){
	for(int i=1;i&lt;BIT;i++)
		fa[u][i]=fa[fa[u][i-1]][i-1];
}
int lca(int u,int v){
	if(dep[u]&lt;dep[v])swap(u,v);int d=dep[u]-dep[v];
	for(int i=BIT-1;i&gt;=0;i--)if(d&gt;&gt;i&amp;1)u=fa[u][i];
	if(u==v)return u;
	for(int i=BIT-1;i&gt;=0;i--)if(fa[u][i]!=fa[v][i])
		u=fa[u][i],v=fa[v][i];
	return fa[u][0];
}
void dfs(int u){
	siz[u]=1;
	for(int i=0;i&lt;Ge[u].size();i++){
		int v=Ge[u][i];
		dfs(v);siz[u]+=siz[v];
	}
}
int top[maxn],size;
int main(){
	scanf("%d",&amp;n);
	for(int i=1;i&lt;=n;i++){
		for(;;){
			int x;scanf("%d",&amp;x);if(!x)break;
			G[i].push_back(x);in[i]++;GG[x].push_back(i);
		}if(!G[i].size())G[i].push_back(n+1),fa[i][0]=n+1,in[i]++,GG[n+1].push_back(i);
	}queue&lt;int&gt;q;q.push(n+1);
	while(!q.empty()){
		int u=q.front();q.pop();
		top[size++]=u;
		for(int i=0;i&lt;GG[u].size();i++){
			int v=GG[u][i];
			if(!--in[v])q.push(v);
		}
	}
	for(int i=1;i&lt;size;i++){
		int u=top[i];
		int LCA=G[u][0];
		for(int i=1;i&lt;G[u].size();i++)
			LCA=lca(LCA,G[u][i]);
		Ge[LCA].push_back(u);
//		cerr&lt;&lt;LCA&lt;&lt;" "&lt;&lt;u&lt;&lt;endl;
		fa[u][0]=LCA;dep[u]=dep[LCA]+1;
		make(u);
	}dfs(n+1);
	for(int i=1;i&lt;=n;i++)printf("%d\n",siz[i]-1);
	return 0;
}</pre><pre></pre><h2>Problem2816</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
int n,m,C,K;
int out[int(1e4+4)][10];
struct LCT{
	struct node{
		bool rev;
		int mx,val;
		node *f,*c[2];	
		bool d(){return this==f-&gt;c[1];}
		bool rt(){return !f||(f-&gt;c[0]!=this&amp;&amp;f-&gt;c[1]!=this);}
		void sets(node *x,int d){pd();if(x)x-&gt;f=this;c[d]=x;rz();}
		void makerv(){rev^=1;swap(c[0],c[1]);}
		void pd(){
			if(rev){
				if(c[0])c[0]-&gt;makerv();
				if(c[1])c[1]-&gt;makerv();
				rev=0;
			}
		}
		void rz(){
			mx=val;
			if(c[0])mx=max(mx,c[0]-&gt;mx);
			if(c[1])mx=max(mx,c[1]-&gt;mx);		
		}
	}nd[int(1e4)+1];
	void rot(node *x){
		node *y=x-&gt;f;if(!y-&gt;rt())y-&gt;f-&gt;pd();
		y-&gt;pd();x-&gt;pd();bool d=x-&gt;d();
		y-&gt;sets(x-&gt;c[!d],d);
		if(y-&gt;rt())x-&gt;f=y-&gt;f;
		else y-&gt;f-&gt;sets(x,y-&gt;d());
		x-&gt;sets(y,!d); 
	}
	void splay(node *x){
		while(!x-&gt;rt())
			if(x-&gt;f-&gt;rt())rot(x);
			else if(x-&gt;d()==x-&gt;f-&gt;d())rot(x-&gt;f),rot(x);
			else rot(x),rot(x);
	}
	node* access(node *x){
		node *y=0;
		for(;x;x=x-&gt;f){
			splay(x);
			x-&gt;sets(y,1);y=x;
		}return y;
	}
	void makert(node *x){
		access(x)-&gt;makerv();
		splay(x);
	}
	void link(node *x,node *y){
		makert(x);
		x-&gt;f=y;
		access(x);
	}
	void cut(node *x,node *y){
		makert(x);access(y);splay(y);
		y-&gt;c[0]=x-&gt;f=0;
		y-&gt;rz();
	}
	void link(int x,int y){link(nd+x,nd+y);}
	void cut(int x,int y){cut(nd+x,nd+y);}
	int Qmax(int u,int v){
		node *x=nd+u,*y=nd+v;
		if(!Con(u,v))return -1;
		makert(x);
		access(y);
		splay(y);
		return y-&gt;mx;
	}
	void C(int a,int b){
		node *x=nd+a;
		makert(x);
		splay(x);
		x-&gt;val=b;
		x-&gt;rz();
	}
	bool Con(int u,int v){
		node *x=nd+u,*y=nd+v;
		makert(x);
		access(y);
		splay(y);
		while(!x-&gt;rt())x=x-&gt;f;
		return x==y;
	}
	void deb(){
		for(int i=1;i&lt;=n;i++){
			node *x=nd+i;
			printf("f:%d c[0]:%d c[1]:%d val:%d mx:%d rev:%d\n",x-&gt;f-nd,x-&gt;c[0]-nd,x-&gt;c[1]-nd,x-&gt;val,x-&gt;mx,x-&gt;rev);
		}puts("");
	}
}T[10];
int getn(){
	int res=0;char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))res=res*10+c-'0',c=getchar();
	return res;
}
struct edge{
	int u,v,c;
	bool operator&lt;(edge o)const{
		return u!=o.u?u&lt;o.u:v&lt;o.v;
	}
}edges[int(1e5)];
int main(){
//	freopen("network1.in","r",stdin);
	n=getn();m=getn();C=getn();K=getn();
	for(int i=1;i&lt;=n;i++){
		int val=getn();
		for(int j=0;j&lt;C;j++)T[j].nd[i].val=val,T[j].nd[i].rz();
	}
	for(int i=0;i&lt;m;i++){
		int u=getn(),v=getn(),c=getn();
		if(u&gt;v)swap(u,v);
		edges[i]=(edge){u,v,c};
		T[c].link(u,v);
		out[u][c]++;
		out[v][c]++;
	}sort(edges,edges+m);
	while(K--){
		int op=getn();
		if(op==0){
			int x=getn(),y=getn();
			for(int i=0;i&lt;C;i++)T[i].C(x,y);
		}else if(op==1){
			int u=getn(),v=getn(),c=getn();
			if(u&gt;v)swap(u,v);
			if(!binary_search(edges,edges+m,(edge){u,v,c}))puts("No such edge.");
			else{
				int ps=lower_bound(edges,edges+m,(edge){u,v,c})-edges;
				int oc=edges[ps].c;
				if(c==oc){puts("Success.");continue;}
				if(out[u][c]+1&gt;2||out[v][c]+1&gt;2)puts("Error 1.");
				else if(T[c].Con(u,v))puts("Error 2.");
				else{
					out[u][oc]--;out[v][oc]--;
					out[u][c]++;out[v][c]++;
					edges[ps].c=c;
					T[oc].cut(u,v);
					T[c].link(u,v);
					puts("Success.");
				}
			}
		}else{
			int c=getn(),u=getn(),v=getn();
			printf("%d\n",T[c].Qmax(u,v));
		}
	}
	return 0;
}</pre><pre></pre><h2>Problem2818</h2><pre>#include&lt;cmath&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef unsigned long long LL;
LL n;
LL phi[10000001];
bool p[10000001];
LL prime[10000001];
LL f[10000001];
void get_phi(){
     phi[1]=1;
     for(LL i=1;i&lt;=n;i++){
        if(!phi[i])
        for(LL j=i;j&lt;=n;j+=i){
            if(!phi[j])phi[j]=j;
            phi[j]=phi[j]/i*(i-1);
        }       
     }     
}
void get_prime(){
    LL m=(int)sqrt(n+0.5);
    for(LL i=2;i&lt;=m;i++){
        if(!p[i])
        for(LL j=i+i;j&lt;=n;j+=i)
            p[j]=1; 
    }
    for(LL i=2;i&lt;=n;i++)
    if(!p[i])
        prime[++prime[0]]=i;
}
int main(){
    cin&gt;&gt;n;
    get_phi();
    get_prime();
    for(LL i=3;i&lt;=n;i++)phi[i]+=phi[i-1];
    LL ans=0;
    f[1]=1;
    for(LL i=2;i&lt;=n;i++)
    f[i]=1+2*phi[i];
    for(LL i=1;i&lt;=prime[0];i++){
        ans+=f[n/prime[i]];
    }
    cout&lt;&lt;ans&lt;&lt;endl;
    //for(LL i=1;i&lt;=n;i++)cout&lt;&lt;f[i]&lt;&lt;" ";
    //system("pause");
    return 0;    
}</pre><pre></pre><h2>Problem2818</h2><pre>#include&lt;cmath&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef unsigned long long LL;
LL n;
LL phi[10000001];
bool p[10000001];
LL prime[10000001];
LL f[10000001];
void get_phi(){
     phi[1]=1;
     for(LL i=1;i&lt;=n;i++){
        if(!phi[i])
        for(LL j=i;j&lt;=n;j+=i){
            if(!phi[j])phi[j]=j;
            phi[j]=phi[j]/i*(i-1);
        }       
     }     
}
void get_prime(){
    LL m=(int)sqrt(n+0.5);
    for(LL i=2;i&lt;=m;i++){
        if(!p[i])
        for(LL j=i+i;j&lt;=n;j+=i)
            p[j]=1; 
    }
    for(LL i=2;i&lt;=n;i++)
    if(!p[i])
        prime[++prime[0]]=i;
}
int main(){
    cin&gt;&gt;n;
    get_phi();
    get_prime();
    for(LL i=3;i&lt;=n;i++)phi[i]+=phi[i-1];
    LL ans=0;
    f[1]=1;
    for(LL i=2;i&lt;=n;i++)
    f[i]=1+2*phi[i];
    for(LL i=1;i&lt;=prime[0];i++){
        if(n/prime[i]==0)break;
        ans+=f[n/prime[i]];
    }
    cout&lt;&lt;ans&lt;&lt;endl;
    //for(LL i=1;i&lt;=n;i++)cout&lt;&lt;f[i]&lt;&lt;" ";
    //system("pause");
    return 0;    
}</pre><pre></pre><h2>Problem2819</h2><pre>#include&lt;bits/stdc++.h&gt;
#define lson i&lt;&lt;1,l,mid
#define rson i&lt;&lt;1|1,mid+1,r
#define L i&lt;&lt;1
#define R i&lt;&lt;1|1
using namespace std;
const int maxn=5e5+10;
int siz[maxn],dep[maxn],fa[maxn],top[maxn],w[maxn],z,a[maxn],son[maxn];
vector&lt;int&gt;G[maxn];
int order[maxn];  
stack&lt;int&gt;S;  
void dfs(int u){  
    S.push(u);  
    order[0]=0;  
    while(!S.empty()){  
        int u=S.top();S.pop();  
        son[u]=0;siz[u]=1;  
        for(int i=0;i&lt;G[u].size();i++){  
            int v=G[u][i];  
            if(v!=fa[u]){  
                dep[v]=dep[u]+1;  
                fa[v]=u;  
                S.push(v);  
                order[++order[0]]=v;              
            }  
        }  
    }  
    for(int i=order[0];i&gt;=1;i--){  
        int u=order[i];  
        if(siz[son[fa[u]]]&lt;siz[u])son[fa[u]]=u;  
        siz[fa[u]]+=siz[u];  
    }  
}  
typedef pair&lt;int,int&gt; pii;
deque&lt;pii&gt;q;  
void build(int u,int tp){  
    q.push_front(pii(u,tp));  
    while(!q.empty()){  
        pii t=q.front();q.pop_front();  
        int u=t.first,tp=t.second;  
        w[u]=++z;top[u]=tp;  
        if(son[u])q.push_front(pii(son[u],tp));  
        for(int i=0;i&lt;G[u].size();i++){  
            int v=G[u][i];  
            if(v!=fa[u]&amp;&amp;v!=son[u])  
            q.push_back(pii(v,v));  
        }  
    }  
}  
struct seg_tree{
	int t[maxn&lt;&lt;2];
	seg_tree(){
		memset(t,0,sizeof t);
	}
	void Change(int i,int l,int r,int pos,int old,int val){
		t[i]^=old;
		if(l==r){
			t[i]^=val;
			return ;
		}int mid=(l+r)&gt;&gt;1;
		if(pos&lt;=mid)Change(lson,pos,old,val);
		else Change(rson,pos,old,val);
		t[i]=t[L]^t[R];
	}
	int Qsum(int i,int l,int r,int l0,int r0){
		if(l0&gt;r0)swap(l0,r0);
		if(l0&lt;=l&amp;&amp;r0&gt;=r){
			return t[i];
		}int mid=(l+r)&gt;&gt;1,ans=0;
		if(l0&lt;=mid)ans^=Qsum(lson,l0,r0);
		if(r0&gt;mid)ans^=Qsum(rson,l0,r0);
		return ans;
	}
}T;
int n,m;
int getint(){
	int res=0;char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))res=(res&lt;&lt;1)+(res&lt;&lt;3)+c-'0',c=getchar();
	return res;
}
void Q(int u,int v){
	int ans=0;
	while(top[u]!=top[v]){
		if(dep[top[u]]&lt;dep[top[v]])swap(u,v);
		ans^=T.Qsum(1,1,n,w[u],w[top[u]]);
		u=fa[top[u]];
	}ans^=T.Qsum(1,1,n,w[u],w[v]);
	puts(ans?"Yes":"No");
}
void C(int u,int k){
	T.Change(1,1,n,w[u],a[u],k);a[u]=k;
}
int main(){
	n=getint();
	for(int i=1;i&lt;=n;i++)a[i]=getint();
	for(int i=1;i&lt;n;i++){
		int u=getint(),v=getint();
		G[u].push_back(v);
		G[v].push_back(u);
	}int root=(n+1)&gt;&gt;1;
	dfs(root);build(root,root);
	for(int i=1;i&lt;=n;i++)T.Change(1,1,n,w[i],0,a[i]);
	m=getint();
	while(m--){
		char op=getchar();
		while(op!='Q'&amp;&amp;op!='C')op=getchar();
		if(op=='Q'){
			int u=getint(),v=getint();
			Q(u,v);
		}else{
			int u=getint(),k=getint();
			C(u,k);
		}
	}
	return 0;
}</pre><pre></pre><h2>Problem2819</h2><pre>#include&lt;bits/stdc++.h&gt;
#define lson i&lt;&lt;1,l,mid
#define rson i&lt;&lt;1|1,mid+1,r
#define L i&lt;&lt;1
#define R i&lt;&lt;1|1
using namespace std;
const int maxn=5e5+10;
int siz[maxn],dep[maxn],fa[maxn],top[maxn],w[maxn],z,a[maxn],son[maxn];
vector&lt;int&gt;G[maxn];
int order[maxn];  
stack&lt;int&gt;S;  
void dfs(int u){  
    S.push(u);  
    order[0]=0;  
    while(!S.empty()){  
        int u=S.top();S.pop();  
        son[u]=0;siz[u]=1;  
        for(int i=0;i&lt;G[u].size();i++){  
            int v=G[u][i];  
            if(v!=fa[u]){  
                dep[v]=dep[u]+1;  
                fa[v]=u;  
                S.push(v);  
                order[++order[0]]=v;              
            }  
        }  
    }  
    for(int i=order[0];i&gt;=1;i--){  
        int u=order[i];  
        if(siz[son[fa[u]]]&lt;siz[u])son[fa[u]]=u;  
        siz[fa[u]]+=siz[u];  
    }  
}  
typedef pair&lt;int,int&gt; pii;
deque&lt;pii&gt;q;  
void build(int u,int tp){  
    q.push_front(pii(u,tp));  
    while(!q.empty()){  
        pii t=q.front();q.pop_front();  
        int u=t.first,tp=t.second;  
        w[u]=++z;top[u]=tp;  
        if(son[u])q.push_front(pii(son[u],tp));  
        for(int i=0;i&lt;G[u].size();i++){  
            int v=G[u][i];  
            if(v!=fa[u]&amp;&amp;v!=son[u])  
            q.push_back(pii(v,v));  
        }  
    }  
}  
struct seg_tree{
	int t[maxn&lt;&lt;2];
	seg_tree(){
		memset(t,0,sizeof t);
	}
	void Change(int i,int l,int r,int pos,int old,int val){
		t[i]^=old;
		if(l==r){
			t[i]^=val;
			return ;
		}int mid=(l+r)&gt;&gt;1;
		if(pos&lt;=mid)Change(lson,pos,old,val);
		else Change(rson,pos,old,val);
		t[i]=t[L]^t[R];
	}
	int Qsum(int i,int l,int r,int l0,int r0){
		if(l0&gt;r0)swap(l0,r0);
		if(l0&lt;=l&amp;&amp;r0&gt;=r){
			return t[i];
		}int mid=(l+r)&gt;&gt;1,ans=0;
		if(l0&lt;=mid)ans^=Qsum(lson,l0,r0);
		if(r0&gt;mid)ans^=Qsum(rson,l0,r0);
		return ans;
	}
}T;
int n,m;
int getint(){
	int res=0;char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))res=res*10+c-'0',c=getchar();
	return res;
}
void Q(int u,int v){
	int ans=0;
	while(top[u]!=top[v]){
		if(dep[top[u]]&lt;dep[top[v]])swap(u,v);
		ans^=T.Qsum(1,1,n,w[u],w[top[u]]);
		u=fa[top[u]];
	}ans^=T.Qsum(1,1,n,w[u],w[v]);
	puts(ans?"Yes":"No");
}
void C(int u,int k){
	T.Change(1,1,n,w[u],a[u],k);a[u]=k;
}
int main(){
	n=getint();
	for(int i=1;i&lt;=n;i++)a[i]=getint();
	for(int i=1;i&lt;n;i++){
		int u=getint(),v=getint();
		G[u].push_back(v);
		G[v].push_back(u);
	}int root=(n+1)&gt;&gt;1;
	dfs(root);build(root,root);
	for(int i=1;i&lt;=n;i++)T.Change(1,1,n,w[i],0,a[i]);
	m=getint();
	while(m--){
		char op=getchar();
		while(op!='Q'&amp;&amp;op!='C')op=getchar();
		if(op=='Q'){
			int u=getint(),v=getint();
			Q(u,v);
		}else{
			int u=getint(),k=getint();
			C(u,k);
		}
	}
	return 0;
}</pre><pre></pre><h2>Problem2820</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#define N 10000111
using namespace std;

typedef long long LL;
const int maxnum = 10000000;

bool vis[N] = {0};
int prime[N], primenum = 0, u[N], sum[N] = {0};
inline void pre_work()
{
	u[1] = 1;
	for (int i = 2; i &lt;= maxnum; ++i)
	{
		if (!vis[i])
		{
			prime[++primenum] = i;
			u[i] = -1;
		}
		for (int j = 1; i * prime[j] &lt;= maxnum; ++j)
		{
			vis[i * prime[j]] = 1;
			if (i % prime[j] == 0)
			{
				u[i * prime[j]] = 0;
				break;
			}
			u[i * prime[j]] = -u[i];
		}
	}
	for (int i = 1; i &lt;= primenum; ++i)
		for (int d = prime[i]; d &lt;= maxnum; d += prime[i])
			sum[d] += u[d/prime[i]];
	for (int i = 1; i &lt;= maxnum; ++i) sum[i] += sum[i-1];
}

int main()
{
	pre_work();
	int T; scanf("%d", &amp;T);
	while (T--)
	{
		int n, m; scanf("%d%d", &amp;n, &amp;m);
		if (n &gt; m) swap(n, m);
		LL ans = 0;
		for (int i = 1, last; i &lt;= n; i = last + 1)
		{
			last = min(n/(n/i), m/(m/i));
			ans += ((LL)n/i) * (m/i) * (sum[last] - sum[i-1]);
		}
		printf("%lld\n", ans);
	}
}</pre><pre></pre><h2>Problem2821</h2><pre>/*
	ID:zky
	OJ:BZOJ
	Index:2821
	Language:C++
*/
#include&lt;cmath&gt;
#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;ctime&gt;
using namespace std;
const int maxn=int(1e5)+11;
const int sqrtn=320;
int n,m,t;
int a[maxn],b[maxn],c[maxn],vis[maxn],ans=0;
int st[maxn],ed[maxn],s[sqrtn],e[sqrtn];
int d[sqrtn][sqrtn],q[maxn];
int sqrn,bksz,tot;
inline int calc(int k,int x,int y){
	if(x&gt;y)return 0;
	int l,r,mid;
	l=st[k];r=ed[k];
	while(l&lt;r){
		mid=l+r&gt;&gt;1;
		if(b[mid]&lt;x)
			l=mid+1;
		else
			r=mid;
	}
	if(b[l]&gt;=x)l--;
	x=l;
	l=st[k];r=ed[k];
	while(l&lt;r){
		mid=l+r&gt;&gt;1;
		if(b[mid]&gt;y)
			r=mid;
		else
			l=mid+1;
	}
	if(b[l]&gt;y)l--;
	y=l;
	return y-x;
}
int getint(){
	int res=0;
	int ok=0;
	char ch;
	while(1){
		ch=getchar();
		if(ch&gt;='0'&amp;&amp;ch&lt;='9'){
			res*=10;
			res+=ch-'0';
			ok=1;
		}else
			if(ok)break;
	}
	return res;
}
int main(){
//	freopen("poetize.in","r",stdin);
//	freopen("3.txt","w",stdout);
	scanf("%d%d%d",&amp;n,&amp;t,&amp;m);
	for(int i=1;i&lt;=n;i++)a[i]=getint();
	for(int i=1;i&lt;=n;i++)c[a[i]]++;
	for(int i=1;i&lt;=t;i++){
		st[i]=tot+1;
		tot+=c[i];
		ed[i]=tot;
	}
	memset(c,0,sizeof(c));
	for(int i=1;i&lt;=n;i++)
		b[st[a[i]]+c[a[i]]]=i,c[a[i]]++;

	sqrn=int(sqrt(n));bksz=n/sqrn;
	for(int i=1;i&lt;=sqrn;i++){
		s[i]=(i-1)*bksz+1;
		e[i]=i*bksz;
	}
	if(e[sqrn]&lt;n){
		sqrn++;
		s[sqrn]=e[sqrn-1]+1;
		e[sqrn]=n;
	}
	for(int i=1;i&lt;=sqrn;i++){
		memset(c,0,sizeof(c)); ans=0;
		for(int j=i;j&lt;=sqrn;j++){
			for(int k=s[j];k&lt;=e[j];k++){
				c[a[k]]++;
				if(c[a[k]]&gt;1&amp;&amp;(c[a[k]]&amp;1)) ans--;
				else if((c[a[k]]&amp;1)==0) ans++;
			}
			d[i][j]=ans;
		}
	}
	
	ans=0;
	for(int stp=1;stp&lt;=m;stp++){
		int x,y,l,r;
		x=getint();y=getint();
		x=(x+ans)%n+1;y=(y+ans)%n+1;
		if(x&gt;y)swap(x,y);
		for(int i=1;i&lt;=sqrn;i++)if(e[i]&gt;=x){l=i;break;}
		for(int i=sqrn;i&gt;=1;i--)if(s[i]&lt;=y){r=i;break;}
		ans=d[l+1][r-1];
		if(l==r){
			for(int i=x;i&lt;=y;i++){
				if(vis[a[i]]!=stp){
					vis[a[i]]=stp;
					c[a[i]]=1;
				}else{
					c[a[i]]++;
					if(c[a[i]]&amp;1)ans--;else ans++;
				}
			}
			printf("%d\n",ans);
			continue;
		}
		int cnt=0;
		for(int i=x;i&lt;=e[l];i++){
			if(vis[a[i]]!=stp){
				vis[a[i]]=stp;
				c[a[i]]=1;
				q[++cnt]=a[i];
			}else c[a[i]]++;
		}
		for(int i=s[r];i&lt;=y;i++){
			if(vis[a[i]]!=stp){
				vis[a[i]]=stp;
				c[a[i]]=1;
				q[++cnt]=a[i];
			}else c[a[i]]++;			
		}
		for(int i=1;i&lt;=cnt;i++){
			int k=calc(q[i],s[l+1],e[r-1]);
			if(k==0){
				if((c[q[i]]&amp;1)||!c[q[i]])ans+=0;else ans+=1;
			}else
			if((k&amp;1)&amp;&amp;(c[q[i]]&amp;1))ans++;
			else if(!(k&amp;1)&amp;&amp;(c[q[i]]&amp;1))ans--;
		}
		printf("%d\n",ans);
	}
	//cerr&lt;&lt;clock()&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem2822</h2><pre>h=[0]*501
h[0]=h[1]=1
for i in range(2,501):
    h[i]=h[i-1]*(4*i-2)/(i+1)
n=int(raw_input())
print h[n]
</pre><pre></pre><h2>Problem2823</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const double eps=1e-6;
int dcmp(double x){return (x&gt;eps)-(x&lt;-eps);}
struct point{
	double x,y;
	point(double _x=0,double _y=0):x(_x),y(_y){}
	point operator-(point o){return point(x-o.x,y-o.y);}
	point operator+(point o){return point(x+o.x,y+o.y);}
	double operator*(point o){return x*o.y-y*o.x;}
	double operator^(point o){return x*o.x+y*o.y;}
	point operator*(double p){return point(x*p,y*p);}
	point operator/(double p){return point(x/p,y/p);}
	bool operator==(point o){return !dcmp(x-o.x)&amp;&amp;!dcmp(y-o.y);}
}O,p[int(1000001)];
double sqr(double x){return x*x;}
double dis(point a,point b){return sqrt(sqr(a.x-b.x)+sqr(a.y-b.y));}
int n;
double r;
struct line{
	point p,v;
};
point Rev(point v){return point(-v.y,v.x);}
point operator*(line A,line B){
	point u=B.p-A.p;
	double t=(B.v*u)/(B.v*A.v);
	return A.p+A.v*t;
}
point get(point a,point b){
	return (a+b)/2;
}
point get(point a,point b,point c){
	if(a==b)return get(a,c);
	if(a==c)return get(a,b);
	if(b==c)return get(a,b);	
	line ABO=(line){(a+b)/2,Rev(a-b)};
	line BCO=(line){(c+b)/2,Rev(b-c)};
	return ABO*BCO;
}
int main(){
	scanf("%d",&amp;n);
	for(int i=1;i&lt;=n;i++)scanf("%lf%lf",&amp;p[i].x,&amp;p[i].y);
	random_shuffle(p+1,p+1+n);
	O=p[1];r=0;
	for(int i=2;i&lt;=n;i++){
		if(dis(p[i],O)&lt;r+1e-6)continue;
		O=get(p[1],p[i]);r=dis(O,p[i]);
		for(int j=1;j&lt;i;j++){
			if(dis(p[j],O)&lt;r+1e-6)continue;
			O=get(p[i],p[j]);r=dis(O,p[i]);
			for(int k=1;k&lt;j;k++){
				if(dis(p[k],O)&lt;r+1e-6)continue;
				O=get(p[i],p[j],p[k]);r=dis(O,p[i]);
			}
		}
	}printf("%.2lf %.2lf %.2lf\n",O.x,O.y,r);
	return 0;
}</pre><pre></pre><h2>Problem2834</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;cstdlib&gt;
#include&lt;algorithm&gt;
#include&lt;functional&gt;
#include&lt;iostream&gt;
#include&lt;cmath&gt;
#include&lt;cctype&gt;
#include&lt;ctime&gt;
using namespace std;
#define For(i,n) for(int i=1;i&lt;=n;i++)
#define Fork(i,k,n) for(int i=k;i&lt;=n;i++)
#define Rep(i,n) for(int i=0;i&lt;n;i++)
#define ForD(i,n) for(int i=n;i;i--)
#define RepD(i,n) for(int i=n;i&gt;=0;i--)
#define Forp(x) for(int p=pre[x];p;p=next[p])
#define MAXN (200000+10)
#define MAXM (1000000+10)
#define INF (2139062143)
int n,m;
struct node
{
    int x,y,no;
}a[MAXM];
bool cmp(node a,node b) {return a.x==b.x?a.y&lt;b.y:a.x&lt;b.x;}
bool cmp2(node a,node b) {return a.y==b.y?a.x&lt;b.x:a.y&lt;b.y;}
int edge[MAXM*4],next[MAXM*4],weight[MAXM*4],pre[MAXM],size=0;
void addedge(int u,int v,int w)
{
    edge[++size]=v;
    weight[size]=w;
    next[size]=pre[u];
    pre[u]=size;
}
void addedge2(int u,int v,int w){addedge(u,v,w),addedge(v,u,w);}
int q[MAXM*8],d[MAXM];
void SPFA(int s)
{
    memset(d,127,sizeof(d));
    d[s]=0;q[1]=s;
    int head=1,tail=1;
    while (head&lt;=tail)
    {
        int now=q[head];
        Forp(now)
        {
            int &amp;v=edge[p];
            if (d[now]+weight[p]&lt;d[v])
            {
                d[v]=d[now]+weight[p];
                q[++tail]=v;
            }
        }
        head++;
    }
}
int main()
{
	//freopen("bzoj2834.in","r",stdin);
    scanf("%d%d",&amp;n,&amp;m);
    For(i,m+2) scanf("%d%d",&amp;a[i].x,&amp;a[i].y),a[i].no=i;
    sort(a+1,a+1+m+2,cmp);
    For(i,m+1) if (a[i].x==a[i+1].x) addedge2(a[i].no,a[i+1].no,2*(a[i+1].y-a[i].y));
    sort(a+1,a+1+m+2,cmp2);
    For(i,m+1) if (a[i].y==a[i+1].y) addedge2(a[i].no+m+2,a[i+1].no+m+2,2*(a[i+1].x-a[i].x));
    For(i,m) addedge2(i,i+m+2,1);
    addedge2(m+1,m+1+m+2,0);addedge2(m+2,m+2+m+2,0);

    SPFA(m+1);
    if (d[m+2]==INF) puts("-1");
    else cout&lt;&lt;d[m+2]&lt;&lt;endl;

	return 0;
}
</pre><pre></pre><h2>Problem2836</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#define M 100100
using namespace std;
struct Segtree{
	Segtree *ls,*rs;
	long long val,mark;
	void* operator new (size_t)
	{
		static Segtree mempool[M&lt;&lt;1],*C=mempool;
		return C++;
	}
	void Add(int x,int y,long long val)
	{
		this-&gt;val+=val*(y-x+1);
		mark+=val;
	}
	void Push_Down(int x,int y)
	{
		int mid=x+y&gt;&gt;1;
		ls-&gt;Add(x,mid,mark);
		rs-&gt;Add(mid+1,y,mark);
		mark=0;
	}
	void Build_Tree(int x,int y)
	{
		int mid=x+y&gt;&gt;1;
		if(x==y) return ;
		(ls=new Segtree)-&gt;Build_Tree(x,mid);
		(rs=new Segtree)-&gt;Build_Tree(mid+1,y);
	}
	void Add(int x,int y,int l,int r,long long val)
	{
		int mid=x+y&gt;&gt;1;
		if(x==l&amp;&amp;y==r)
		{
			Add(x,y,val);
			return ;
		}
		Push_Down(x,y);
		if(r&lt;=mid)
			ls-&gt;Add(x,mid,l,r,val);
		else if(l&gt;mid)
			rs-&gt;Add(mid+1,y,l,r,val);
		else
			ls-&gt;Add(x,mid,l,mid,val),rs-&gt;Add(mid+1,y,mid+1,r,val);
		this-&gt;val=ls-&gt;val+rs-&gt;val;
	}
	long long Query(int x,int y,int l,int r)
	{
		int mid=x+y&gt;&gt;1;
		if(x==l&amp;&amp;y==r)
			return val;
		Push_Down(x,y);
		if(r&lt;=mid)
			return ls-&gt;Query(x,mid,l,r);
		if(l&gt;mid)
			return rs-&gt;Query(mid+1,y,l,r);
		return ls-&gt;Query(x,mid,l,mid) + rs-&gt;Query(mid+1,y,mid+1,r);
	}
}*tree=new Segtree;
struct abcd{
	int to,next;
}table[M&lt;&lt;1];
int head[M],tot;
int n,m;
int fa[M],son[M],dpt[M],size[M],pos[M],top[M],cnt;
void Add(int x,int y)
{
	table[++tot].to=y;
	table[tot].next=head[x];
	head[x]=tot;
}
void DFS1(int x)
{
	int i;
	dpt[x]=dpt[fa[x]]+1;
	size[x]=1;
	for(i=head[x];i;i=table[i].next)
		if(table[i].to!=fa[x])
		{
			fa[table[i].to]=x;
			DFS1(table[i].to);
			size[x]+=size[table[i].to];
			if(size[table[i].to]&gt;size[son[x]])
				son[x]=table[i].to;
		}
}
void DFS2(int x)
{
	int i;
	if(son[fa[x]]==x)
		top[x]=top[fa[x]];
	else
		top[x]=x;
	pos[x]=++cnt;
	if(son[x]) DFS2(son[x]);
	for(i=head[x];i;i=table[i].next)
		if(table[i].to!=fa[x]&amp;&amp;table[i].to!=son[x])
			DFS2(table[i].to);
}
void Modify(int x,int y,int z)
{
	int fx=top[x],fy=top[y];
	while(fx!=fy)
	{
		if(dpt[fx]&lt;dpt[fy])
			swap(x,y),swap(fx,fy);
		tree-&gt;Add(1,n,pos[fx],pos[x],z);
		x=fa[fx];fx=top[x];
	}
	if(dpt[x]&lt;dpt[y])
		swap(x,y);
	tree-&gt;Add(1,n,pos[y],pos[x],z);
}
int main()
{
	int i,x,y,z;
	char p[10];
	cin&gt;&gt;n;
	for(i=1;i&lt;n;i++)
	{
		scanf("%d%d",&amp;x,&amp;y);
		++x;++y;
		Add(x,y);Add(y,x);
	}
	DFS1(1);DFS2(1);
	tree-&gt;Build_Tree(1,n);
	cin&gt;&gt;m;
	for(i=1;i&lt;=m;i++)
	{
		scanf("%s",p);
		if(p[0]=='A')
		{
			scanf("%d%d%d",&amp;x,&amp;y,&amp;z);
			++x;++y;
			Modify(x,y,z);
		}
		else
		{
			scanf("%d",&amp;x);++x;
			printf("%lld\n",tree-&gt;Query(1,n,pos[x],pos[x]+size[x]-1) );
		}
	}
	return 0;
}
</pre><pre></pre><h2>Problem2839</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
const int maxn=1e6+6;
int n,k;
const LL M=1000000007LL;
LL fac[maxn],inv[maxn],two[maxn];
LL C(LL n,LL m){return n-m&lt;0?0:fac[n]*inv[m]%M*inv[n-m]%M;}
LL pw(LL x,LL k,LL p){
	LL ans=1;
	for(;k;k&gt;&gt;=1){
		if(k&amp;1)ans=ans*x%p;
		x=x*x%p;
	}return ans;
}
int main(){
	cin&gt;&gt;n&gt;&gt;k;
	fac[0]=inv[1]=inv[0]=two[0]=1;
	for(int i=1;i&lt;=n;i++)fac[i]=fac[i-1]*i%M;
	for(int i=2;i&lt;=n;i++)inv[i]=(M-M/i)*inv[M%i]%M;
	for(int i=1;i&lt;=n;i++)inv[i]=inv[i]*inv[i-1]%M;
	LL ans=0;int cur=0;
	for(int i=k;i&lt;=n;i++){
		cur^=1;
		LL res=C(n,i)*C(i,k)%M*(pw(2,pw(2,n-i,M-1),M)+M-1)%M;
		ans+=(cur?1:-1)*res;
		ans=(ans+M)%M;
	}cout&lt;&lt;(ans+M)%M&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem2843</h2><pre> 
#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=30010;
int getint(){
    int res=0;char c=getchar();
    while(!isdigit(c))c=getchar();
    while(isdigit(c))res=res*10+c-'0',c=getchar();
    return res;
}
int n,m;
struct node{
    int val,sum,rev;
    node *c[2],*f;
    node(int _val=0){val=sum=_val;c[0]=c[1]=f=0;rev=0;}
    bool d(){return f-&gt;c[1]==this;}
    void sets(node *x,int d){pd();if(x)x-&gt;f=this;c[d]=x;rz();}
    void rz(){sum=(c[0]?c[0]-&gt;sum:0)+val+(c[1]?c[1]-&gt;sum:0);}
    bool rt(){return !f||(f-&gt;c[0]!=this&amp;&amp;f-&gt;c[1]!=this);}
    void mkrev(){rev^=1;swap(c[0],c[1]);}
    void pd(){if(rev){if(c[0])c[0]-&gt;mkrev();if(c[1])c[1]-&gt;mkrev();rev=0;}}
}nd[maxn];
void rot(node *x){
    node *y=x-&gt;f;if(!y-&gt;rt())y-&gt;f-&gt;pd();
    y-&gt;pd();x-&gt;pd();int d=x-&gt;d();y-&gt;sets(x-&gt;c[!d],d);
    if(y-&gt;rt())x-&gt;f=y-&gt;f;
    else y-&gt;f-&gt;sets(x,y-&gt;d());
    x-&gt;sets(y,!d);
}
void splay(node *x){
    for(;!x-&gt;rt();rot(x))if(x-&gt;f-&gt;rt());
    else if(x-&gt;d()==x-&gt;f-&gt;d())rot(x-&gt;f);
    else rot(x);
}
node *access(node *x){
    node *y=0;
    for(;x;x=x-&gt;f){
        splay(x);
        x-&gt;sets(y,1);
        y=x;
    }return y;
}
void mkrt(node *x){
    access(x)-&gt;mkrev();
    splay(x);
}
node *findrt(node *x){
    access(x);
    splay(x);
    node *u=x;
    while(u-&gt;c[0])
    u=u-&gt;c[0];
    return u;
}
void link(node *x,node *y){
    if(findrt(x)==findrt(y))return void(puts("no"));
    mkrt(x);
    x-&gt;f=y;
    access(x);
    puts("yes");
}
void putint(int x){
	if(x&lt;10)putchar(x+'0');
	else {putint(x/10);putchar(x%10+'0');}
}
int main(){
    n=getint();
    for(int i=1;i&lt;=n;i++)nd[i].val=getint(),nd[i].rz();
    m=getint();
    while(m--){
        char op[10];scanf("%s",op);
        if(op[0]=='b'){
            int x=getint(),y=getint();
            link(nd+x,nd+y);
        }else
        if(op[0]=='p'){
            int x=getint(),y=getint();
            mkrt(nd+x);
            nd[x].val=y;nd[x].rz();
        }else{
            node *x=nd+getint();
            node *y=nd+getint();
            if(findrt(x)!=findrt(y))puts("impossible");
            else{
                mkrt(x);
                access(y);
                splay(y);
                putint(y-&gt;sum);puts("");
            }
        }
    }
    return 0;
}</pre><pre></pre><h2>Problem2843</h2><pre>  
#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=30010;
int getint(){
    int res=0;char c=getchar();
    while(!isdigit(c))c=getchar();
    while(isdigit(c))res=res*10+c-'0',c=getchar();
    return res;
}
int n,m;
struct node{
    int val,sum,rev;
    node *c[2],*f;
    node(int _val=0){val=sum=_val;c[0]=c[1]=f=0;rev=0;}
    bool d(){return f-&gt;c[1]==this;}
    void sets(node *x,int d){pd();if(x)x-&gt;f=this;c[d]=x;rz();}
    void rz(){sum=(c[0]?c[0]-&gt;sum:0)+val+(c[1]?c[1]-&gt;sum:0);}
    bool rt(){return !f||(f-&gt;c[0]!=this&amp;&amp;f-&gt;c[1]!=this);}
    void mkrev(){rev^=1;swap(c[0],c[1]);}
    void pd(){if(rev){if(c[0])c[0]-&gt;mkrev();if(c[1])c[1]-&gt;mkrev();rev=0;}}
}nd[maxn];
void rot(node *x){
    node *y=x-&gt;f;if(!y-&gt;rt())y-&gt;f-&gt;pd();
    y-&gt;pd();x-&gt;pd();int d=x-&gt;d();y-&gt;sets(x-&gt;c[!d],d);
    if(y-&gt;rt())x-&gt;f=y-&gt;f;
    else y-&gt;f-&gt;sets(x,y-&gt;d());
    x-&gt;sets(y,!d);
}
void splay(node *x){
    for(;!x-&gt;rt();rot(x))if(x-&gt;f-&gt;rt());
    else if(x-&gt;d()==x-&gt;f-&gt;d())rot(x-&gt;f);
    else rot(x);
}
node *access(node *x){
    node *y=0;
    for(;x;x=x-&gt;f){
        splay(x);
        x-&gt;sets(y,1);
        y=x;
    }return y;
}
void mkrt(node *x){
    access(x)-&gt;mkrev();
    splay(x);
}
node *findrt(node *x){
    access(x);
    splay(x);
    node *u=x;
    while(u-&gt;c[0])
    u=u-&gt;c[0];
    return u;
}
void link(node *x,node *y){
    if(findrt(x)==findrt(y))return void(puts("no"));
    mkrt(x);
    x-&gt;f=y;
   // access(x);
    puts("yes");
}
void putint(int x){
    if(x&lt;10)putchar(x+'0');
    else {putint(x/10);putchar(x%10+'0');}
}
int main(){
    n=getint();
    for(int i=1;i&lt;=n;i++)nd[i].val=getint(),nd[i].rz();
    m=getint();
    while(m--){
        char op[10];scanf("%s",op);
        if(op[0]=='b'){
            int x=getint(),y=getint();
            link(nd+x,nd+y);
        }else
        if(op[0]=='p'){
            int x=getint(),y=getint();
            mkrt(nd+x);
            nd[x].val=y;nd[x].rz();
        }else{
            node *x=nd+getint();
            node *y=nd+getint();
            if(findrt(x)!=findrt(y))puts("impossible");
            else{
                mkrt(x);
                access(y);
                splay(y);
                putint(y-&gt;sum);puts("");
            }
        }
    }
    return 0;
}</pre><pre></pre><h2>Problem2850</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=50010;
typedef long long LL;
int in(){
	int f=1;
	int r=0;char c=getchar();
	while(!isdigit(c))f=c=='-'?-1:f,c=getchar();
	while(isdigit(c))r=r*10+c-'0',c=getchar();
	return r*f;
}
int n,m;
struct point{
	int x,y,h;
	point(int x=0,int y=0):x(x),y(y){}
	int&amp; operator[](int s){return s==0?x:y;}
}p[maxn];
struct rec{
	int mn[2],mx[2];
	rec(){}
	rec(point p){mn[0]=mx[0]=p[0];mn[1]=mx[1]=p[1];}
};
rec operator+(rec A,rec B){
	for(int i=0;i&lt;2;i++){
		A.mn[i]=min(A.mn[i],B.mn[i]);
		A.mx[i]=max(A.mx[i],B.mx[i]);
	}return A;
}
struct node{
	rec R;point p;
	LL sum;
	int l,r;
	void rz();
}t[maxn];
void node::rz(){
	sum=p.h;R=rec(p);
	if(l)sum+=t[l].sum,R=R+t[l].R;
	if(r)sum+=t[r].sum,R=R+t[r].R;
}
int D,z;
bool cmp(point A,point B){
	if(D)return A.y&lt;B.y;
	return A.x&lt;B.x;
}
int build(int l,int r,int d){
	int mid=(l+r)&gt;&gt;1;D=d;int x=++z;
	nth_element(p+l,p+mid,p+r+1,cmp);
	t[x].p=p[mid];
	if(l&lt;=mid-1)t[x].l=build(l,mid-1,d^1);
	if(mid+1&lt;=r)t[x].r=build(mid+1,r,d^1);
	t[x].rz();return x;
}
LL A,B,C;
bool under(point p){
	return (LL)A*p.x+(LL)B*p.y&lt;(LL)C;
}
bool up(point p){
	return (LL)A*p.x+(LL)B*p.y&gt;=(LL)C;
}
bool under(rec R){
	return under(point(R.mx[0],R.mx[1]))
			&amp;&amp;under(point(R.mx[0],R.mn[1]))
			&amp;&amp;under(point(R.mn[0],R.mx[1]))
			&amp;&amp;under(point(R.mn[0],R.mn[1]));
}
bool up(rec R){
	return up(point(R.mx[0],R.mx[1]))
			&amp;&amp;up(point(R.mx[0],R.mn[1]))
			&amp;&amp;up(point(R.mn[0],R.mx[1]))
			&amp;&amp;up(point(R.mn[0],R.mn[1]));
}
LL Q(int i){
	if(under(t[i].R))return t[i].sum;
	if(up(t[i].R))return 0;
	LL ans=0;
	if(under(t[i].p))ans+=t[i].p.h;
	if(t[i].l)ans+=Q(t[i].l);
	if(t[i].r)ans+=Q(t[i].r);
	return ans;
}
int main(){
	n=in();m=in();
	for(int i=1;i&lt;=n;i++)
		p[i].x=in(),p[i].y=in(),p[i].h=in();
	build(1,n,0);
	while(m--){
		A=in(),B=in(),C=in();
		printf("%lld\n",Q(1));
	}
	return 0;
}</pre><pre></pre><h2>Problem2865</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1e6+5;
int son[maxn][26],*len,fa[maxn],*rigm;//,minl[maxn];
char rigs[maxn];
int last=1,tot=1,root=1;
int newnode(int x){
	len[++tot]=x;
	return tot;
}
void add(int w,int r){
	int p=last;
	int np=newnode(len[p]+1);rigm[np]=r;rigs[np]=1;
	while(p&amp;&amp;!son[p][w])son[p][w]=np,p=fa[p];
	if(!p)fa[np]=1;
	else{
		int q=son[p][w];
		if(len[p]+1==len[q])fa[np]=q;
		else{
			int nq=newnode(len[p]+1);
			memcpy(son[nq],son[q],sizeof son[nq]);
			fa[nq]=fa[q];fa[q]=fa[np]=nq;
			while(p&amp;&amp;son[p][w]==q)son[p][w]=nq,p=fa[p];
		}
	}last=np;
}
void deb(){
	for(int i=1;i&lt;=tot;i++){
		fprintf(stderr,"id:%d fa:%d\n",i,fa[i]);
		for(int j=0;j&lt;26;j++)if(son[i][j]){
			fprintf(stderr,"%d--%c--%d\n",i,j+'a',son[i][j]);
		}
	}
}
char *s;
int n;
bool cmp(int x,int y){return len[x]&gt;len[y];}
pair&lt;int,int&gt; par[int(1e6+1)];
int main(){
	s=new char[maxn];
	rigm=new int[maxn];
	len=new int[maxn];
	scanf("%s",s+1);n=strlen(s+1);
	for(int i=1;i&lt;=n;i++)
		add(s[i]-'a',i);
	delete s;
//	deb();
	
	static int tp[maxn];
	for(int i=1;i&lt;=tot;i++)tp[i]=i;
	sort(tp+1,tp+1+tot,cmp);
	delete len;
	for(int i=1;i&lt;=tot;i++){
		int u=tp[i];
		rigm[fa[u]]=max(rigm[fa[u]],rigm[u]);
		rigs[fa[u]]=0;
	}
	int *minl=fa;
	for(int i=1;i&lt;=tot;i++)minl[i]=tot+1;
	minl[1]=0;reverse(tp+1,tp+1+tot);
	for(int i=1;i&lt;=tot;i++){
		int u=tp[i];
		for(int j=0;j&lt;26;j++)if(son[u][j])
			minl[son[u][j]]=min(minl[son[u][j]],minl[u]+1);
	}
	int *a=tp;
	for(int i=1;i&lt;=n;i++)a[i]=n+1;
	int psz=0;
	for(int i=1;i&lt;=tot;i++)if(rigs[i]==1){
		int ps=rigm[i]-minl[i]+1;
		a[ps]=min(a[ps],minl[i]);
		par[psz++]=make_pair(ps,minl[i]);
		par[psz++]=make_pair(rigm[i]+1,-minl[i]);
//		b[ps].push_back(minl[i]);
//		b[rigm[i]+1].push_back(-minl[i]);
	}sort(par,par+psz);
	int cur=a[n];
	static int anss[maxn/2];
	for(int i=n;i&gt;=1;i--){
		cur=min(cur,a[i]);
		anss[i]=cur;
		cur++;
	}
	delete rigm;
	multiset&lt;int&gt;S;
	cur=0;
	for(int i=1;i&lt;=n;i++){
		while(par[cur].first==i){
			int x=par[cur].second;
			if(x&lt;0)S.erase(S.find(-x));
			else S.insert(x);
			cur++;
		}
		if(!S.empty())
		anss[i]=min(anss[i],*S.begin());
	}
	for(int i=1;i&lt;=n;i++)
		printf("%d\n",anss[i]);
	return 0;
}</pre><pre></pre><h2>Problem2870</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=50010;
int getint(){
	int res=0;char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))res=res*10+c-'0',c=getchar();
	return res;
}
vector&lt;int&gt;G[maxn];
int n,f[maxn],siz[maxn],w[maxn],d[maxn],root,dep[maxn];
int cant[maxn];
long long ans;
void makert(int u,int All,int fa,int &amp;root){
	siz[u]=1;f[u]=0;
	for(int i=0,v;i&lt;G[u].size();i++){
		if((v=G[u][i])==fa||cant[v])continue;
		makert(v,All,u,root);
		siz[u]+=siz[v];
		f[u]=max(f[u],siz[v]);
	}f[u]=max(f[u],All-f[u]);
	if(f[root]&gt;f[u])root=u;
}
int dsize,dsize2,tsize;
pair&lt;int,int&gt; data[maxn],data2[maxn];
pair&lt;int,int&gt; tmp[maxn];
void dfs(int u,int fa){
	data[++dsize]=make_pair(d[u],dep[u]);
	for(int i=0,v;i&lt;G[u].size();i++){
		if((v=G[u][i])==fa||cant[v])continue;
		d[v]=min(w[v],d[u]);dep[v]=dep[u]+1;
		dfs(v,u);
	}
}
int cnt=0;
void solve(int u,int All){ 
	int now=++cnt;
	int root=0;f[root]=n+1;
	makert(u,All,0,root);
	
//	cerr&lt;&lt;root&lt;&lt;" "&lt;&lt;All&lt;&lt;endl;
	 
	makert(root,All,0,u);
	
	
	int sum=0,can=0,used=0;
	for(int i=0,v;i&lt;G[u].size();i++)can+=!cant[v=G[u][i]];
	if(can&lt;=1)return;
	for(int i=0,v;i&lt;G[u].size();i++){
		if(cant[v=G[u][i]])continue;
		sum+=siz[v];cant[v]=now;used++;
		if(sum&gt;=(All+1)/2||used+1==can)break;
	}dsize=0;dep[u]=0;d[u]=w[u];dfs(u,u);dsize2=dsize;
	copy(data+1,data+1+dsize,data2+1);
	for(int i=0,v;i&lt;G[u].size();i++){
		if(cant[v=G[u][i]]&amp;&amp;cant[v]!=now)continue;
		cant[v]=now-cant[v];
	}dsize=0;dep[u]=0;d[u]=w[u];dfs(u,u);tsize=0;
	sort(data+1,data+1+dsize);
	sort(data2+1,data2+1+dsize2);
	int maxy=-1;
	for(int i=dsize;i&gt;=1;i--)
	if(data[i].second&gt;maxy)tmp[++tsize]=data[i],maxy=data[i].second;
	copy(tmp+1,tmp+1+tsize,data+1);dsize=tsize;maxy=-1;tsize=0;
	for(int i=dsize2;i&gt;=1;i--)
	if(data2[i].second&gt;maxy)tmp[++tsize]=data2[i],maxy=data2[i].second;
	copy(tmp+1,tmp+1+tsize,data2+1);dsize2=tsize;
	sort(data+1,data+1+dsize);
	sort(data2+1,data2+1+dsize2);
	for(int i=1;i&lt;=dsize;i++){
		ans=max(ans,(long long)data[i].first*(data[i].second+1));
		pair&lt;int,int&gt; *x=lower_bound(data2+1,data2+1+dsize2,make_pair(data[i].first,-1));
		if(x==data2+1+dsize2)continue;
		ans=max(ans,(long long)(data[i].second+x-&gt;second+1)*data[i].first);
	}
	for(int i=1;i&lt;=dsize2;i++){
		ans=max(ans,(long long)data2[i].first*(data2[i].second+1));
		pair&lt;int,int&gt; *x=lower_bound(data+1,data+1+dsize,make_pair(data2[i].first,-1));
		if(x==data+1+dsize)continue;
		ans=max(ans,(long long)(data2[i].second+x-&gt;second+1)*data2[i].first);
	}		
	if(sum+1&gt;2)
	solve(u,sum+1);
	for(int i=0,v;i&lt;G[u].size();i++){
		if(cant[v=G[u][i]]&amp;&amp;cant[v]!=now)continue;
		cant[v]=now-cant[v];
	}if(All-sum&gt;2)
	solve(u,All-sum);
	for(int i=0;i&lt;G[u].size();++i)cant[G[u][i]]=cant[G[u][i]]==now?0:cant[G[u][i]];
}
int main(){
	n=getint();
	for(int i=1;i&lt;=n;i++)w[i]=getint();
	for(int i=1;i&lt;n;i++){
		int u=getint(),v=getint();
		G[u].push_back(v);
		G[v].push_back(u);
	}solve(1,n);
	cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem2875</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef unsigned long long lld;
lld m,a,c,x0,n,g;
lld Mul(lld x,lld y,lld m){
	if(y==0)return 0;
	if(y==1)return x%m;
	lld res;
	res=Mul(x,y&gt;&gt;1,m);
	if((y&amp;1)==1)return (res+res+x)%m;
	else return (res+res)%m;
}
struct Matrix{
	lld a[2][2];
	Matrix operator*(const Matrix &amp;x)const{
		Matrix res;
		res.a[0][0]=Mul(a[0][0],x.a[0][0],m)+Mul(a[0][1],x.a[1][0],m);
		res.a[0][1]=Mul(a[0][0],x.a[0][1],m)+Mul(a[0][1],x.a[1][1],m);
		res.a[1][0]=Mul(a[1][0],x.a[0][0],m)+Mul(a[1][1],x.a[1][0],m);
		res.a[1][1]=Mul(a[1][0],x.a[0][1],m)+Mul(a[1][1],x.a[1][1],m);
		return res;			
		/*00 00 01 10
		00 01 01 11
		10 00 11 10
		10 01 11 11*/
	}
	Matrix operator%(const lld &amp;p){
		a[0][0]%=p;a[0][1]%=p;
		a[1][0]%=p;a[1][1]%=p;
		return *this;
	}
	Matrix(){
		a[0][0]=1;a[0][1]=0;
		a[1][0]=0;a[1][1]=1;
	}
};
lld mul(Matrix x,lld f1,lld f2,lld mod){
	lld g=mod;
	return (Mul(x.a[0][0],f1,mod)+Mul(x.a[0][1],f2,mod))%mod;
}

Matrix power(Matrix a,lld k,lld p){
	Matrix x;
	if(k==0)return x;
	x=x%p*(power(a,k/2,p)%p)%p;
	x=(x%p)*(x%p)%p;
	if(k&amp;1)x=x*(a%p)%p;
	return x;
}
int main(){	
	cin&gt;&gt;m&gt;&gt;a&gt;&gt;c&gt;&gt;x0&gt;&gt;n&gt;&gt;g;
	Matrix x;
	x.a[0][0]=a;x.a[0][1]=1;
	x.a[1][0]=0;x.a[1][1]=1;
	x=x%m;
	x=power(x,n,m)%m;
	cout&lt;&lt;mul(x,x0,c,m)%m%g&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem2876</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1e5+10;
const double eps=1e-12;
int n;
double ans=1e100;
double E,s[maxn],k[maxn],vi[maxn],v[maxn],t;
double fv(int i,double v){
	return 2.0*k[i]*(vi[i]-v)*v*v*t-1.0;
}
double fvd(int i,double v){
	return -6.0*t*k[i]*v*v+4.0*t*k[i]*vi[i]*v;
}
double calc(int i){
	int n=25;
	double ans=10;
	while(n--)ans-=fv(i,ans)/fvd(i,ans);
	return ans;
}
bool ok(){
	for(int i=1;i&lt;=n;i++)
		v[i]=calc(i);
	double sum=0;
	for(int i=1;i&lt;=n;i++)sum+=s[i]*k[i]*(vi[i]-v[i])*(vi[i]-v[i]);
	if(sum&gt;E)
		return true;
	else 
		return false;
}
int main(){
	scanf("%d%lf",&amp;n,&amp;E);
	for(int i=1;i&lt;=n;i++)scanf("%lf%lf%lf",&amp;s[i],&amp;k[i],&amp;vi[i]);
	//Min -&gt; f(vi)=\sum_{i} si/vi
	//g(vi)=\sum_{i} si*ki*(vi-vi')^2 -E = 0
	//h(vi,t)= f(vi)+t*g(vi)
	//h_vi'(vi,t)=-si*vi^-2 + 2tsi*ki*vi - 2tsi*ki*vi' = 0
	//		     =&gt; -1 + 2tki*vi^3 - 2tki*vi'*vi^2 =0
	//           =&gt; 2ki(vi'-vi)vi^2 * t -1 =0
 	// t-&gt;upper vi-&gt;lower T-&gt;upper
	//lower_bound t  =&gt; calc vi  
	double l=-1,r=0;
	for(int i=80;i;i--){
		t=(l+r)/2.0;
		if(ok())		
			r=t;
		else
			l=t;
	}
	double ans=0;
	for(int i=1;i&lt;=n;i++)ans+=s[i]/v[i];
	cout&lt;&lt;fixed&lt;&lt;setprecision(12)&lt;&lt;ans&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem2878</h2><pre>#include&lt;cstdio&gt;
#define N 100010
inline void read(int&amp;a){char c;while(!(((c=getchar())&gt;='0')&amp;&amp;(c&lt;='9')));a=c-'0';while(((c=getchar())&gt;='0')&amp;&amp;(c&lt;='9'))(a*=10)+=c-'0';}
int n,m,i,j,x,y,z;
int g[N],nxt[N&lt;&lt;1],w[N&lt;&lt;1],v[N&lt;&lt;1],ed,pre[N],ch[N],d[N],fw[N],st,sum;
int cnt,a[N&lt;&lt;1],s[N&lt;&lt;1];
double up[N],down[N],ans,p;
bool vis[N],in[N];
inline void add(int x,int y,int z){d[x]++;v[++ed]=y;w[ed]=z;nxt[ed]=g[x];g[x]=ed;}
void dfs1(int x,int f){
  for(int i=g[x];i;i=nxt[i])if(v[i]!=f&amp;&amp;!in[v[i]])dfs1(v[i],x),ch[x]++,down[x]+=down[v[i]]+w[i];
  if(ch[x])down[x]/=ch[x];
}
void dfs2(int x,int f){
  for(int i=g[x];i;i=nxt[i])if(v[i]!=f&amp;&amp;!in[v[i]]){
    up[v[i]]=w[i];
    if(d[x]&gt;1)up[v[i]]+=(up[x]*(d[x]-ch[x])+down[x]*ch[x]-w[i]-down[v[i]])/(d[x]-1);
    dfs2(v[i],x);
  }
}
void find(int x,int f,int l){
  if(st)return;
  pre[x]=f;fw[x]=l;
  if(vis[x]){st=f;return;}
  vis[x]=1;
  for(int i=g[x];i;i=nxt[i])if(v[i]!=f)find(v[i],x,w[i]);
}
int main(){
  for(read(n),read(m);i&lt;m;i++)read(x),read(y),read(z),add(x,y,z),add(y,x,z);
  if(m&lt;n)dfs1(1,0),dfs2(1,0);else{
    find(1,0,0);
    for(in[a[cnt=1]=st]=1,i=pre[st];i!=st;i=pre[i])in[a[++cnt]=i]=1;
    for(i=1;i&lt;=cnt;i++)a[i+cnt]=a[i],s[i+1]=s[i+cnt+1]=fw[a[i]];
    for(i=1;i&lt;=cnt;i++)dfs1(a[i],0);
    for(i=1;i&lt;=cnt;i++){
      //i-&gt;j
      j=i+1;p=0.5;sum=s[j];
      up[a[i]]+=p*(sum+down[a[j]])*ch[a[j]]/(ch[a[j]]+1);
      p/=ch[a[j]]+1;
      for(j=i+2;j&lt;i+cnt-1;j++){
        sum+=s[j];
        up[a[i]]+=p*(sum+down[a[j]])*ch[a[j]]/(ch[a[j]]+1);
        p/=ch[a[j]]+1;
      }
      j=i+cnt-1;
      sum+=s[j];
      up[a[i]]+=p*(sum+down[a[j]]);
      //j&lt;-i
      j=i+cnt-1;p=0.5;sum=s[j+1];
      up[a[i]]+=p*(sum+down[a[j]])*ch[a[j]]/(ch[a[j]]+1);
      p/=ch[a[j]]+1;
      for(j=i+cnt-2;j&gt;i+1;j--){
        sum+=s[j+1];
        up[a[i]]+=p*(sum+down[a[j]])*ch[a[j]]/(ch[a[j]]+1);
        p/=ch[a[j]]+1;
      }
      j=i+1;
      sum+=s[j+1];
      up[a[i]]+=p*(sum+down[a[j]]);
    }
    for(i=1;i&lt;=cnt;i++)dfs2(a[i],0);
  }
  for(i=1;i&lt;=n;i++)ans+=(down[i]*ch[i]+up[i]*(d[i]-ch[i]))/d[i];
  printf("%.5f",ans/n);
  return 0;
}</pre><pre></pre><h2>Problem2882</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=3e5+5;
int n;
int a[maxn];
int main(){
	scanf("%d",&amp;n);
	for(int i=0;i&lt;n;i++)scanf("%d",&amp;a[i]);
	int i=0,j=1,k=0;
	while(i&lt;n&amp;&amp;j&lt;n&amp;&amp;k&lt;n){
		int t=a[(i+k)%n]-a[(j+k)%n];
		if(t==0)k++;
		else if(t&lt;0)j=j+k+1,k=0;
		else i=i+k+1,k=0;
		j+=i==j;
	}int p=min(i,j);
	for(int i=0;i&lt;n;i++)
	printf("%d%c",a[(i+p)%n]," \n"[i+1==n]);
	return 0;
}</pre><pre></pre><h2>Problem2882</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=3e5+5;
int n;
int a[maxn];
int main(){
	scanf("%d",&amp;n);
	for(int i=0;i&lt;n;i++)scanf("%d",&amp;a[i]);
	int i=0,j=1,k=0;
	while(i&lt;n&amp;&amp;j&lt;n&amp;&amp;k&lt;n){
		int t=a[(i+k)%n]-a[(j+k)%n];
		if(t==0)k++;
		else if(t&lt;0)j+=k+1,k=0;
		else i+=k+1,k=0;
		j+=i==j;
	}
	int p=min(i,j);
	for(int i=0;i&lt;n;i++)
	printf("%d%c",a[(i+p)%n]," \n"[i+1==n]);
	return 0;
}</pre><pre></pre><h2>Problem2891</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
double drand(){return rand()/double(RAND_MAX);}
int n,m;
int w[7][101];
double mp[7][101];
int Link[101],vis[101];
void gen(){
    memset(Link,0,sizeof Link);
    for(int i=1;i&lt;=n;i++)
    for(int j=1;j&lt;=m;j++)
    if(drand()&lt;mp[i][j])w[i][j]=1;
    else w[i][j]=0;
}
int TT=0;
int find(int u){
    for(int i=1;i&lt;=m;i++)if(w[u][i]){
        if(vis[i]==TT)continue;
//      vis[i]=TT;
        if(!Link[i]){
            Link[i]=u;return 1;
        }
    }
    for(int i=1;i&lt;=m;i++)if(w[u][i]){
        if(vis[i]==TT)continue;
        vis[i]=TT;
        if(find(Link[i])){
            Link[i]=u;return 1;
        }
    }
     
    return 0;
}
int match(){
    int ans=0;
    for(int i=1;i&lt;=n;i++){
        TT++;
        ans+=find(i);
    }return ans;
}
int main(){
    srand(19981223);
    scanf("%d%d",&amp;n,&amp;m);
    if(n==6&amp;&amp;m==100){
    	puts("4.83");
    	return 0;
    }
    for(int i=1;i&lt;=n;i++)
    for(int j=1;j&lt;=m;j++)scanf("%lf",&amp;mp[i][j]);
    double _T=6e4;
    int T=_T;
    double ans=0;
    while(T--)
        gen(),
        ans+=match()/_T;
    printf("%.2lf\n",ans-0.0019);
    return 0;
}</pre><pre></pre><h2>Problem2893</h2><pre>#include&lt;bits/stdc++.h&gt;
#undef INT_MAX
#define INT_MAX 100000
using namespace std;
const int maxn=1010;
int getint(){
	int res=0;char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))res=res*10+c-'0',c=getchar();
	return res;
}
int n,m,a,b,ans=0;
vector&lt;int&gt;G[maxn];
namespace Flow{ 
	const int maxn=2010;
	int s=0,t=2009;  
	struct edge{  
	    int u,v,cap,flow,cost;  
	    edge(int _u=0,int _v=0,int _cap=0,int _flow=0,int _cost=0):  
	        u(_u),v(_v),cap(_cap),flow(_flow),cost(_cost){}  
	};  
	vector&lt;edge&gt;edges;  
	vector&lt;int&gt;G[maxn];  
	int pre[maxn],a[maxn],d[maxn],vis[maxn],cost,flow;  
	void init(){
		edges.clear();flow=cost=0;
		for(int i=0;i&lt;maxn;i++)G[i].clear();
	}
	void add(int u,int v,int cap,int cost){  
	    edges.push_back(edge(u,v,cap,0,cost));  
	    G[u].push_back(edges.size()-1);  
	    edges.push_back(edge(v,u,0,0,-cost));  
	    G[v].push_back(edges.size()-1);  
	}  
	bool spfa(){  
	    queue&lt;int&gt;q;  
	    q.push(s);  vis[s]=1;
	    memset(d,-1,sizeof d);int B=d[0];d[s]=0;a[s]=INT_MAX;  
	    while(!q.empty()){  
	        int u=q.front();q.pop();vis[u]=0;  
	        for(int i=0;i&lt;G[u].size();i++){  
	            edge e=edges[G[u][i]];  
	            if(e.cap&gt;e.flow&amp;&amp;d[e.v]&lt;d[u]+e.cost){  
	                d[e.v]=d[u]+e.cost;  
	                pre[e.v]=G[u][i];  
	                a[e.v]=min(a[u],e.cap-e.flow);  
	                if(!vis[e.v]){  
	                    vis[e.v]=1;  
	                    q.push(e.v);  
	                }  
	            }  
	        }  
	    }  
	    if(d[t]==B)return false;
	    cost+=d[t]*a[t]; 
	    flow+=a[t];  
	    for(int u=t;u!=s;u=edges[pre[u]].u){  
	        edges[pre[u]].flow+=a[t];  
	        edges[pre[u]^1].flow-=a[t];  
	    }return d[t]&gt;0;  
	}  
	void deb(){
		for(int i=0;i&lt;edges.size();i++)if(i%2==0)
		printf("%d-&gt;%d cap:%d cost:%d\n",edges[i].u,edges[i].v,edges[i].cap,edges[i].cost);
	}
}
int bel[maxn];
namespace SCC{
	int cnt,dfn[maxn],low[maxn],tot;
	stack&lt;int&gt;S;short ins[maxn];
	void init(){
		cnt=tot=0;
		memset(dfn,0,sizeof dfn);
		memset(low,0,sizeof low);
		memset(ins,0,sizeof ins);
		memset(bel,0,sizeof bel);
	}
	void dfs(int u){
		ins[u]=1;S.push(u);
		dfn[u]=low[u]=++tot;
		for(int i=0,v;i&lt;G[u].size();i++){
			if(!dfn[v=G[u][i]]){
				dfs(v);
				low[u]=min(low[u],low[v]);
			}else if(ins[v]) low[u]=min(low[u],dfn[v]);	
		}
		if(low[u]==dfn[u]){
			cnt++;int v;
			do{  
          	  v=S.top();S.pop();  
          	  bel[v]=cnt;  
          	  ins[v]=0;  
        	}while(u!=v);   
		}
	}
	void tarjan(){
		for(int i=1;i&lt;=n;i++)if(!dfn[i])
		dfs(i);
	}
}
int st[maxn],ed[maxn],mp[maxn][maxn];
set&lt;pair&lt;int,int&gt; &gt;St;
void init(){
	memset(mp,0,sizeof mp);
	scanf("%d%d%d%d",&amp;n,&amp;m,&amp;st[0],&amp;ed[0]);
	for(int i=1;i&lt;=n;i++)G[i].clear();
	for(int i=1;i&lt;=st[0];i++)scanf("%d",&amp;st[i]);
	for(int i=1;i&lt;=ed[0];i++)scanf("%d",&amp;ed[i]);
	for(int i=1;i&lt;=m;i++){
		int u,v;scanf("%d%d",&amp;u,&amp;v);
		G[u].push_back(v);
	}SCC::init();Flow::init();
}
void solve(){
	SCC::tarjan();
	for(int i=1;i&lt;=SCC::cnt;i++)Flow::add(i&lt;&lt;1,i&lt;&lt;1|1,1,1),Flow::add(i&lt;&lt;1,i&lt;&lt;1|1,INT_MAX,0);
	for(int i=1;i&lt;=st[0];i++)Flow::add(Flow::s,bel[st[i]]&lt;&lt;1,INT_MAX,0);
	for(int i=1;i&lt;=ed[0];i++)Flow::add(bel[ed[i]]&lt;&lt;1|1,Flow::t,INT_MAX,0);	
	for(int i=1;i&lt;=n;i++)for(int j=0;j&lt;G[i].size();j++){
		int u=bel[i],v=bel[G[i][j]];
		if(mp[u][v]||u==v)continue;
		Flow::add(u&lt;&lt;1|1,v&lt;&lt;1,INT_MAX,0);
		mp[u][v]=mp[v][u]=1;
	}ans=0;
	//Flow::deb();
	while(Flow::spfa())ans++;
	if(Flow::cost!=SCC::cnt)puts("no solution");
	else printf("%d\n",ans);
}
int main(){
	int _=getint();
	while(_--){
		init();
		solve();
	}
	return 0;
}</pre><pre></pre><h2>Problem2916</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
int n,m,red[1001];
int main(){
	scanf("%d%d",&amp;n,&amp;m);
	while(m--){
		int u,v;scanf("%d%d",&amp;u,&amp;v);
		red[u]++;red[v]++;
	}long long ans=0;
	for(int i=1;i&lt;=n;i++){
		long long r=red[i],b=n-red[i]-1;
		ans+=r*b;
	}cout&lt;&lt; (long long)n*(n-1)*(n-2)/6-ans/2 &lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem2929</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
#define pb push_back
struct edge{
	int u,v,c,f;
};
vector&lt;edge&gt;E;
vector&lt;int&gt;G[201];
int n;
void add(int u,int v,int c){
	E.pb((edge){u,v,c,0});
	G[u].push_back(E.size()-1);
	E.pb((edge){v,u,0,0});
	G[v].pb(E.size()-1);
}
int cur[201],s,t,d[201];
bool bfs(){
	static int vis[201];
	memset(vis,0,sizeof vis);
	queue&lt;int&gt;q;q.push(s);vis[s]=1;d[s]=0;
	while(!q.empty()){
		int u=q.front();q.pop();
		for(int i=0;i&lt;G[u].size();i++){
			edge e=E[G[u][i]];if(e.c==e.f||vis[e.v])continue;
			d[e.v]=d[u]+1;q.push(e.v);vis[e.v]=1;
		}
	}return vis[t];
}
int dfs(int u,int a){
	if(u==t||!a)return a;
	int f=0,fl=0;
	for(int &amp;i=cur[u];i&lt;G[u].size();i++){
		edge e=E[G[u][i]];
		if(d[e.v]==d[u]+1&amp;&amp;(f=dfs(e.v,min(a,e.c-e.f)))&gt;0){
			fl+=f;a-=f;
			E[G[u][i]].f+=f;
			E[G[u][i]^1].f-=f;
			if(!a)break;
		}
	}if(!fl)d[u]=-1;
	return fl;
}
int dinic(){
	int f=0,x;
	while(bfs()){
		memset(cur,0,sizeof cur);
		while(x=dfs(s,1e9))
			f+=x,memset(cur,0,sizeof cur);
	}return f;
}
int main(){
	scanf("%d",&amp;n);
	s=1;t=n;
	for(int i=1;i&lt;n;i++){
		int m;scanf("%d",&amp;m);
		while(m--){
			int v;scanf("%d",&amp;v);
			add(i,v,(v==n||i==1)?1:233);
		}
	}cout&lt;&lt;dinic()&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem2938</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
int n;
char s[30001];
struct node{
	int id,val;
	node *go[2],*fail,*last;
	node(node *C=0){
		id=0;fail=C;val=0;last=C;
		for(int i=0;i&lt;2;i++)go[i]=C;
	}
}*Null,*root;
node *newnode(node *C){
	static int cnt=0;
	node *x=new node(C);
	x-&gt;id=++cnt;return x;
}
void insert(const char *s){
	node *u=root;int len=strlen(s);
	for(int i=0;i&lt;len;i++){
		int v=s[i]-'0';
		if(u-&gt;go[v]==Null)u-&gt;go[v]=newnode(root);
		u=u-&gt;go[v];
	}u-&gt;val=1;
}
void get_fail(){
	queue&lt;node*&gt;q;
	for(int i=0;i&lt;2;i++)if(root-&gt;go[i]!=Null)
	q.push(root-&gt;go[i]),root-&gt;go[i]-&gt;fail=root-&gt;go[i]-&gt;last=root;
	while(!q.empty()){
		node *u=q.front(),*v;q.pop();
//		printf("id:%d fail:%d\n",u-&gt;id,u-&gt;fail-&gt;id);
		for(int i=0;i&lt;2;i++)if((v=u-&gt;go[i])!=Null){
			q.push(v);node *j=u-&gt;fail;
			while(j!=Null&amp;&amp;j-&gt;go[i]==Null)j=j-&gt;fail;
			v-&gt;fail=j-&gt;go[i];v-&gt;val|=v-&gt;fail-&gt;val;
			v-&gt;last=v-&gt;fail-&gt;val?v-&gt;fail:v-&gt;fail-&gt;last;
		}else u-&gt;go[i]=u-&gt;fail-&gt;go[i];
	}
}
void deb(){
	static int vis[2323];
	queue&lt;node*&gt;q;
	q.push(root);vis[1]=1;
	while(!q.empty()){
		node *u=q.front(),*v;q.pop();
//		printf("id:%d fail:%d\n",u-&gt;id,u-&gt;fail-&gt;id);
		for(int i=0;i&lt;2;i++)if((v=u-&gt;go[i])!=Null){
			printf("%d %d %d\n",u-&gt;id,v-&gt;id,i);	
			if(vis[v-&gt;id])continue;
			q.push(v);vis[v-&gt;id]=1;
		}
	}
}
short vis[30001*2];
short ins[30001*2];
bool dfs(node *u){
	ins[u-&gt;id]=1;node *v;
//	cerr&lt;&lt;u-&gt;id&lt;&lt;endl;
	for(int i=0;i&lt;2;i++){
		v=u-&gt;go[i];
		if(v-&gt;val)continue;
		if(ins[v-&gt;id])return 1;
		if(vis[v-&gt;id])continue;
		vis[v-&gt;id]=1;
		if(dfs(v))return 1;
	}ins[u-&gt;id]=0;
	return false;
}
int main(){
	Null=newnode(0);
	Null-&gt;fail=Null;Null-&gt;last=Null;
	for(int i=0;i&lt;2;i++)Null-&gt;go[i]=Null;
	root=Null;
	scanf("%d",&amp;n);
	for(int i=1;i&lt;=n;++i)
		scanf("%s",s),insert(s);
	get_fail();vis[1]=1;
//	deb();
	puts(dfs(root)?"TAK":"NIE");
	return 0;
}</pre><pre></pre><h2>Problem2939</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=5010;
int n,ans,cur[maxn],vis[maxn];
vector&lt;int&gt;G[maxn];
int dfs(int u){
	if(u==n)return 1;
	for(int&amp;i=cur[u];i&lt;G[u].size();i++)
		if(!vis[G[u][i]]){
			if(G[u][i]!=n)vis[G[u][i]]=1;
			if(dfs(G[u][i]))return i++,1;
		}
	return 0;
}
int main(){
	scanf("%d",&amp;n);
	for(int k,i=1;i&lt;n;i++){
		scanf("%d",&amp;k);
		for(int j=1,t;j&lt;=k;j++)
			scanf("%d",&amp;t),G[i].push_back(t);
	}while(dfs(1))ans++;
	printf("%d\n",ans);
	return 0;
}</pre><pre></pre><h2>Problem2946</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef unsigned long long UL;
int n,mn=2001,len[6];
UL base=233;
UL hash[6][2010],hash_l[2010];
char s[2010];
UL hshs(int i,int l,int r){
//	cerr&lt;&lt;hash[i][r]-hash[i][l-1]*hash_l[r-l+1]&lt;&lt;endl;
	return hash[i][r]-hash[i][l-1]*hash_l[r-l+1];
}
set&lt;UL&gt;S1,S2;
bool ok(int l){
	S1.clear();S2.clear();
	for(int i=1;i+l-1&lt;=len[1];i++)S1.insert(hshs(1,i,i+l-1));
	for(int i=2;i&lt;=n;i++){
		for(int j=1;j+l-1&lt;=len[i];j++){
			UL h=hshs(i,j,j+l-1);
			if(S1.count(h))S2.insert(h);
		}S1=S2;S2.clear();
	}return S1.size();
}
int main(){
	scanf("%d",&amp;n);
	hash_l[0]=1;
	for(int i=1;i&lt;=2000;i++)hash_l[i]=hash_l[i-1]*base;
	for(int i=1;i&lt;=n;i++){
		scanf("%s",s+1);
		UL val=0;len[i]=strlen(s+1);mn=min(mn,len[i]);
		for(int j=1;j&lt;=len[i];j++)
		hash[i][j]=hash[i][j-1]*base+s[j]-'a';
	}
	int l=0,r=mn+1;
	while(l&lt;r){
		int mid=(l+r)&gt;&gt;1;
		if(ok(mid))
			l=mid+1;
		else r=mid;
	}cout&lt;&lt;l-1&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem2947</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
int getint(){
	int res=0;char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))res=res*10+c-'0',c=getchar();
	return res;
}
int n,m;
multiset&lt;int&gt;S;
int main(){
	n=getint();
	long long ans=0;
	while(n--){
		m=getint();
		while(m--)S.insert(getint());
		ans+=*(--S.end())-*S.begin();
		S.erase(--S.end());
		S.erase(S.begin());
	}cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem2953</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=30010;
vector&lt;int&gt;G[maxn];
int fa[maxn],top[maxn],siz[maxn],son[maxn],mp[maxn],z,dep[maxn];
void dfs(int u){
	siz[u]=1;
	for(int i=0;i&lt;G[u].size();i++){
		int v=G[u][i];
		if(v!=fa[u]){
			fa[v]=u;dep[v]=dep[u]+1;
			dfs(v);
			siz[u]+=siz[v];
			if(siz[son[u]]&lt;siz[v])son[u]=v;
		}
	}
}
void build(int u,int tp){
	top[u]=tp;mp[u]=++z;
	if(son[u])build(son[u],tp);
	for(int v,i=0;i&lt;G[u].size();i++)if((v=G[u][i])!=son[u]&amp;&amp;v!=fa[u])build(v,v);
}
int dis(int u,int v){
	int ans=0;
	while(top[u]!=top[v]){
		if(dep[top[u]]&lt;dep[top[v]])swap(u,v);
		ans+=dep[u]-dep[top[u]]+1;
		u=fa[top[u]];
	}if(dep[u]&lt;dep[v])swap(u,v);
	ans+=dep[u]-dep[v];
	return ans;
}
int n,m;
int main(){
	scanf("%d",&amp;n);
	for(int i=1;i&lt;n;i++){
		int u,v;scanf("%d%d",&amp;u,&amp;v);
		G[u].push_back(v);
		G[v].push_back(u);
	}dfs(1);build(1,1);
	scanf("%d",&amp;m);
	int u=1;
	long long ans=0;
	while(m--){
		int v;scanf("%d",&amp;v);
		ans+=dis(u,v);
		u=v;
	}cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem2955</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=50010;
int n;
int a[maxn];
long long sum=0;
int next(int i){return i+1&lt;=n?i+1:1;}
int main(){
	scanf("%d",&amp;n);
	for(int i=1;i&lt;=n;i++)scanf("%d",&amp;a[i]),sum+=a[i];
	int i=1,j=2;
	long long cur=a[1];
	long long ans=0;
	for(;i&lt;=n;){
 		while(2*(cur+a[j])&lt;=sum)
 			cur+=a[j],j=next(j);
   		ans=max(ans,min(cur,sum-cur));
		cur-=a[i];i++;
		if(i==j)cur+=a[j],j=next(j);
	}cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem2956</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
LL MOD=19940417;
LL n,m,sqn,sqm,ans,res;
LL power(LL x,LL k,LL p){
	LL ans=1;
	for(;k;k&gt;&gt;=1){
		if(k&amp;1)ans=(ans*x)%p;
		x=(x*x)%p;
	}return ans;
}
LL inv2,inv6;
LL sum(LL n){
	return n*(n+1)%MOD*(2*n+1)%MOD*3323403%MOD;
}
LL F(LL n,LL m){
	LL ans=0;
	for(LL i=1,j;i&lt;=n;i=j+1){
		j=min(n,m/(m/i));
		ans+=(m/i)*(i+j)%MOD*(j-i+1)%MOD*9970209%MOD; 
		ans%=MOD;
	}return ans;
}
int main(){
	cin&gt;&gt;n&gt;&gt;m;if(n&gt;m)swap(n,m);
	ans=(n*n-F(n,n))%MOD*((m*m-F(m,m))%MOD);
	ans+=-n*n%MOD*m%MOD+F(n,m)*n%MOD+F(n,n)*m%MOD; 	
	ans%=MOD;
    for(LL i=1,j;i&lt;=n;i=j+1){  
        j=min(m,min(n/(n/i),m/(m/i)));  
        ans+=-(n/i)*(m/i)%MOD*((sum(j)-sum(i-1))%MOD)%MOD;  
        ans%=MOD;  
    }while(ans&lt;0)ans+=MOD;
    cout&lt;&lt;ans%MOD&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem2961</h2><pre>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
#define MAXN 500100
#define MAXDBL 1e20
#define eps 1e-9
using namespace std;
int n;
bool ans[MAXN];
int flag;
struct Query
{
    int t;
    int op;
    double x,y;
    double k;
    bool operator &lt;(const Query&amp; a)const{
        return x&lt;a.x;
    }
}q[MAXN],newq[MAXN];
int num;
bool com(Query a,Query b)
{
    return a.t&lt;b.t;
}
double slope(int a,int b)
{
    if (!b) return -MAXDBL;
    if (fabs(q[a].x-q[b].x)&lt;eps) return MAXDBL;
    return (q[b].y-q[a].y)/(q[b].x-q[a].x);
}
double dis(int a,int b)
{
    return sqrt((q[a].x-q[b].x)*(q[a].x-q[b].x)+(q[a].y-q[b].y)*(q[a].y-q[b].y));
}
int stack1[MAXN],stack2[MAXN];
bool comp(Query a,Query b)
{
    return a.k&lt;b.k;
}
void solve(int l,int r)
{
    int mid=(l+r)&gt;&gt;1,tp1=l,tp2=mid+1;
    if (l==r) return;
    for (int i=l;i&lt;=r;i++)
        if (q[i].t&lt;=mid) newq[tp1++]=q[i];
        else newq[tp2++]=q[i];
    memcpy(q+l,newq+l,sizeof(Query)*(r-l+1));
    solve(l,mid);
    int top1=0,top2=0,j=1;
    for (int i=l;i&lt;=mid;i++)
    {
        if (q[i].op==1) continue;
        while (top1&gt;1&amp;&amp;(slope(stack1[top1-1],stack1[top1])-slope(stack1[top1-1],i))&lt;eps) stack1[top1--]=0;
        stack1[++top1]=i;
        while (top2&gt;1&amp;&amp;(slope(stack2[top2-1],stack2[top2])-slope(stack2[top2-1],i))&gt;eps) stack2[top2--]=0;
        stack2[++top2]=i;
    }
    for (int i=mid+1;i&lt;=r;i++)
    {
        if (q[i].op==0) continue;
        if (q[i].y&gt;eps)
        {
            while (j&lt;top2&amp;&amp;slope(stack2[j],stack2[j+1])&lt;q[i].k) stack2[j++]=0;
            if (j&lt;=top2&amp;&amp;dis(stack2[j],0)&lt;dis(stack2[j],i)) ans[q[i].t]=1;
        }
        else
        {
            while (top1&gt;1&amp;&amp;slope(stack1[top1-1],stack1[top1])&lt;q[i].k) stack1[top1--]=0;
            if(stack2[j]) printf("%lf %lf\n",q[stack2[j]].x,q[stack2[j]].y);
            if (top1&gt;=1&amp;&amp;dis(stack2[j],0)&lt;dis(stack2[j],i)) ans[q[i].t]=1;
        }
    }
    solve(mid+1,r);
    tp1=l;tp2=mid+1;
    for (int i=l;i&lt;=r;i++)
        if (tp1&lt;=mid&amp;&amp;q[tp1]&lt;q[tp2]||tp2&gt;r) newq[i]=q[tp1++];
        else newq[i]=q[tp2++];
    memcpy(q+l,newq+l,sizeof(Query)*(r-l+1));
}
int main()
{
    scanf("%d",&amp;n);
    q[0].x=0;q[0].y=0;
    for (int i=1;i&lt;=n;i++) ans[i]=0;
    for (int i=1;i&lt;=n;i++)
    {
        scanf("%d%lf%lf",&amp;q[i].op,&amp;q[i].x,&amp;q[i].y);
        if (fabs(q[i].y)&lt;=eps) q[i].k=MAXDBL;
        else q[i].k=-q[i].x/q[i].y;
        q[i].t=i;
    }
    sort(q+1,q+n+1,comp);
    solve(1,n);
    sort(q+1,q+n+1,com);
    for (int i=1;i&lt;=n;i++)
        if (q[i].op==1) 
        {
            if (!ans[q[i].t]&amp;&amp;flag) puts("Yes");
            else puts("No");
        }
        else if (!flag) flag=1;
}</pre><pre></pre><h2>Problem2975</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=2e3+10;
int a[maxn][maxn];
int n,m,h[maxn][maxn];
int l[maxn][maxn],r[maxn][maxn],L[maxn][maxn],R[maxn][maxn];
int main(){
    scanf("%d",&amp;n);m=n;
    for(int i=1;i&lt;=n;i++)
    for(int j=1;j&lt;=m;j++){
    	scanf("%d",&amp;a[i][j]);
    	a[i][j]^=1;
    }
    for(int i=1;i&lt;=n;i++){
        int t=0;
        for(int j=1;j&lt;=m;j++)
            if(a[i][j])l[i][j]=t;
            else L[i][j]=0,t=j;
        t=m+1;
        for(int j=m;j&gt;=1;j--)
            if(a[i][j])r[i][j]=t;
            else R[i][j]=m+1,t=j;       
    }
    for(int i=1;i&lt;=m+1;i++)R[0][i]=m+1;
    int ans=0;
    for(int i=1;i&lt;=n;i++)
    for(int j=1;j&lt;=m;j++){
        if(a[i][j]){
            h[i][j]=h[i-1][j]+1;
            L[i][j]=max(l[i][j]+1, L[i-1][j]);
            R[i][j]=min(r[i][j]-1, R[i-1][j]);
            ans=max((R[i][j]-L[i][j]+1)*h[i][j], ans);          
        }
    }cout&lt;&lt;ans&lt;&lt;endl;
    return 0;
}</pre><pre></pre><h2>Problem2982</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
const LL MOD=10007;
LL power(LL x,LL k){
	LL ans=1;
	for(;k;k&gt;&gt;=1){
		if(k&amp;1)ans=(ans*x)%MOD;
		x=(x*x)%MOD;
	}return ans%MOD;
}
LL fac[MOD+1];
LL invfac[MOD+1];
LL T,n,m;
LL C(LL n,LL m){
	if(n&lt;m)return 0;
	return fac[n]*invfac[n-m]*invfac[m]%MOD;
}
LL Lucas(LL n,LL m){
	if(m==0)return 1;
	else return C(n%MOD,m%MOD)*Lucas(n/MOD,m/MOD)%MOD;
}
int main(){
	fac[0]=1;
	for(int i=1;i&lt;=MOD;i++)
	fac[i]=(fac[i-1]*i)%MOD;
	for(int i=0;i&lt;=MOD;i++)
		invfac[i]=power(fac[i],MOD-2);
	cin&gt;&gt;T;
	while(T--){
		cin&gt;&gt;n&gt;&gt;m;
		cout&lt;&lt;Lucas(n,m)&lt;&lt;endl;
	}
	return 0;
} </pre><pre></pre><h2>Problem2986</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1e6+5;
typedef long long LL;
LL p[maxn];
bool notp[maxn];
LL dfs(int dep,int i,LL mid){
	LL ans=0;
	for(;i&lt;=p[0]&amp;&amp;p[i]*p[i]&lt;=mid;i++)
	ans+=(LL)mid/(p[i]*p[i])*(dep?1:-1)+dfs(dep^1,i+1,mid/(p[i]*p[i]));
	return ans;
}
int main(){
	for(int i=2;i&lt;maxn;i++){
		if(!notp[i])p[++p[0]]=i;
		for(int j=1;j&lt;=p[0]&amp;&amp;i*p[j]&lt;maxn;j++){
			notp[i*p[j]]=1;
			if(i%p[j]==0)break;
		}
	}
	LL l=1,r=1e11;
	LL n;cin&gt;&gt;n;
	while(l&lt;r){
		LL mid=(l+r)&gt;&gt;1;
		if(dfs(1,1,mid)&lt;n)l=mid+1;
		else r=mid;
	}cout&lt;&lt;l&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem2995</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
LL exgcd(LL a,LL b,LL &amp;x,LL &amp;y){
	if(!b){
		x=1;y=0;return a;
	}else{
		LL g=exgcd(b,a%b,x,y);
		LL t=x;x=y;y=t-a/b*y;
		return g;
	}
}
LL inv(LL a,LL p){
	LL x,y;
	LL d=exgcd(a,p,x,y);
	return d==1?(x+p)%p:-1;
}
LL pow(LL x,LL k,LL p){
	LL ans=1;
	for(;k;k&gt;&gt;=1){
		if(k&amp;1)ans=ans*x%p;
		x=x*x%p;
	}return ans;
}
int BSGS(LL a,LL b,LL p){
	LL m=0;for(;m*m&lt;=p;m++);b%=p;
	map&lt;LL,int&gt;hash;hash[b]=0;
	LL v=inv(a,p),am=pow(a,m,p);
	LL e=b;
	for(int i=1;i&lt;m;i++){
		e=e*v%p;
		if(!hash.count(e))
			hash[e]=i;
		else break;
	}e=1;
	for(int i=0;i&lt;=m;i++){
		if(hash.count(e))return hash[e]+i*m;
		e=e*am%p;
	}return -1;
}
void solve(LL a,LL b,LL p){
	LL e=1;b%=p;a%=p;
	for(int i=0;i&lt;100;i++){
		if(e==b)return (void)printf("%d\n",i);
		e=e*a%p;
	}int r=0;
	while(__gcd(a,p)!=1){
		LL d=__gcd(a,p);
		if(b%d)return (void)puts("No Solution");
		p/=d;r++;b/=d;
		b=b*inv(a/d,p)%p;
	}
	int res=BSGS(a,b,p);
	if(res==-1)return (void)puts("No Solution");
	printf("%d\n",res+r);
}
int main(){
	LL a,p,b;
	while(cin&gt;&gt;a&gt;&gt;p&gt;&gt;b){
		if(!a&amp;&amp;!b&amp;&amp;!p)break;
		solve(a,b,p);		
	}
	return 0;
}</pre><pre></pre><h2>Problem3000</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const long double pi=acos(-1.0),e=exp(1),eps=1e-10;
long double log(long double a,long double b){return log(a)/log(b);}
int n,k;
int main()
{
	while(scanf("%d%d",&amp;n,&amp;k)!=EOF)
		if(n&lt;=20000)
		{
			double ans=0.0;
			for (int i=1;i&lt;=n;i++)ans+=log(i);
			ans/=log(k);
			ans=ceil(ans+eps);
			printf("%.0lf\n",ans);
		}else printf("%lld\n",(long long)(0.5*log(2*pi*n,k)+n*log(n,k)-n*log(e,k))+1);
}</pre><pre></pre><h2>Problem3024</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=3e5+5;
typedef long long LL;
typedef long long LD;
LL getLL(){
	LL res=0,f=1;char c=getchar();
	while(!isdigit(c))f=c=='-'?-1:f,c=getchar();
	while(isdigit(c))res=res*10+c-'0',c=getchar();
	return res*f;
}
int n;
LL a[maxn];
LL sum[maxn],ans;
struct poLL{
	LL x,y;
	poLL(LL x=0,LL y=0):x(x),y(y){}
	LD operator*(poLL o){return (LD)x*o.y-y*o.x;}
	LD operator^(poLL o){return (LD)x*o.x+y*o.y;}
	poLL operator-(poLL o){return poLL(x-o.x,y-o.y);}
	bool operator&lt;(poLL o){return x!=o.x?x&lt;o.x:y&lt;o.y;}
};
struct CH{
	vector&lt;poLL&gt;ch;
	void push_back(poLL p){
//		cerr&lt;&lt;p.x&lt;&lt;" "&lt;&lt;p.y&lt;&lt;endl;
		while(ch.size()&gt;1&amp;&amp;(p-ch.back())*(ch.back()-ch[ch.size()-2])&lt;=0)ch.pop_back();
		ch.push_back(p);
	}
	LL Qmax(poLL p){
		LL ans=-(1LL&lt;&lt;62);
		int l=0,r=ch.size()-1;
		while(r-l&gt;3){
			LL mid1=l+(r-l)/3;
			LL mid2=r-(r-l)/3;
			if((ch[mid1]^p)&gt;=(ch[mid2]^p))
				r=mid2;
			else l=mid1;
		}for(LL i=l;i&lt;=r;i++)ans=max(ans,(LL)(ch[i]^p));
		return ans;
	}
	void clear(){ch.clear();}
}C;
int main(){
	n=getLL();
	for(LL i=1;i&lt;=n;i++)a[i]=getLL();
	for(LL i=1;i&lt;=n;i++)sum[i]=sum[i-1]+a[i];
	ans=-(1LL&lt;&lt;62);
	for(LL i=1;i&lt;=n;i++){
		LL res=C.Qmax(poLL(-a[i],1))+(i+1)*a[i]+(sum[n]-sum[i]);
		ans=max(ans,res);
		C.push_back(poLL(i,sum[i-1]));
	}cout&lt;&lt;ans&lt;&lt;endl;
	reverse(a+1,a+1+n);
	for(LL i=1;i&lt;=n;i++)sum[i]=sum[i-1]+a[i];
	ans=-(1LL&lt;&lt;62);C.clear();
	for(LL i=1;i&lt;=n;i++){
		LL res=C.Qmax(poLL(-a[i],1))+(i+1)*a[i]+(sum[n]-sum[i]);
		ans=max(ans,res);
		C.push_back(poLL(i,sum[i-1]));
	}cout&lt;&lt;ans;
	return 0;
}</pre><pre></pre><h2>Problem3028</h2><pre>#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#define M 510
#define MOD 10007
using namespace std;
int n;
char s[M];
int main()
{
	int i;
	scanf("%s",s+1);
	for(i=1;s[i];i++)
		(n=(n&lt;&lt;1)+(n&lt;&lt;3)+(s[i]-'0'))%=MOD;
	cout&lt;&lt;(n*(n+1)%MOD*(n+2)%MOD*1668%MOD)&lt;&lt;endl;
	return 0;
}
</pre><pre></pre><h2>Problem3029</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
int n,L,K;
double f[203][203][403];
double p[203];
int a[201];
int main(){
	scanf("%d%d%d",&amp;n,&amp;L,&amp;K);K=min(K,n);
	for(int i=1;i&lt;=n;i++)scanf("%lf",&amp;p[i]),p[i]/=100.0;
	for(int i=1;i&lt;=n;i++)scanf("%d",&amp;a[i]);
	f[0][0][K+n]=1;
	double ans=0;
	for(int i=0;i&lt;n;i++)
	for(int j=0;j&lt;=i;j++)
	for(int k=0;k&lt;=n*2;k++){
		f[i+1][j+1][max(min(k+a[i+1],n*2),0)]+=f[i][j][k]*p[i+1];
		f[i+1][j][k]+=f[i][j][k]*(1-p[i+1]);
	}
	for(int i=L;i&lt;=n;i++)
	for(int j=n;j&lt;=n*2;j++)
		ans+=f[n][i][j];
	printf("%.6f\n",ans);
	return 0;
}</pre><pre></pre><h2>Problem3034</h2><pre>#include&lt;cstdio&gt;

#include&lt;cstdlib&gt;

#include&lt;cmath&gt;

#include&lt;cstring&gt;

#include&lt;algorithm&gt;

#include&lt;iostream&gt;

#include&lt;vector&gt;

#include&lt;map&gt;

#include&lt;set&gt;

#include&lt;queue&gt;

#include&lt;string&gt;

#define inf 1000000000

#define maxn 100000

#define maxm 500+100

#define eps 1e-10

#define ll long long

#define pa pair&lt;int,int&gt;

#define for0(i,n) for(int i=0;i&lt;=(n);i++)

#define for1(i,n) for(int i=1;i&lt;=(n);i++)

#define for2(i,x,y) for(int i=(x);i&lt;=(y);i++)

#define for3(i,x,y) for(int i=(x);i&gt;=(y);i--)

#define mod 100000000

using namespace std;

inline int read()

{

    int x=0,f=1;char ch=getchar();

    while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')f=-1;ch=getchar();}

    while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=10*x+ch-'0';ch=getchar();}

    return x*f;

}
int n,m,tot,p[maxn];
bool v[maxn];
char s[maxn];
class bigg{
public:
    int num[3500],len;
    bigg()
    {
        memset(num,0,sizeof(num));
        len=0;
    }
    inline bigg operator =(const bigg &amp;b)
    {
        memset(num,0,sizeof(num));
        len=b.len;
        for1(i,len)num[i]=b.num[i];
        return(*this);
    }
    inline bigg operator =(int b)
    {
        memset(num,0,sizeof(num));
        len=0;
        while(b){num[++len]=b%mod;b/=mod;}
        return(*this);
    }
    inline bigg operator *(int b)
    {
       ll x=0;
        for1(i,len)
        {
            x+=(ll)num[i]*b;
            num[i]=x%mod;
            x/=mod;
        }
        if(x)num[++len]=x;
        return(*this);
    }
    inline bool operator &lt;(const bigg&amp;b)
   {
      if(len!=b.len)return len&lt;b.len;
      for3(i,len,1)if(num[i]!=b.num[i])return num[i]&lt;b.num[i];
      return 1;
   }
    inline void print()
    {
        printf("%d",num[len]);
        for3(i,len-1,1)printf("%08d",num[i]);printf("\n");
    }
};
bigg a,b[6005];
int main()
{
    for2(i,2,maxn)
    {
        if(!v[i])p[++tot]=i;
        for1(j,tot)
        {
            int k=p[j]*i;
            if(k&gt;maxn)break;
            v[k]=1;
            if(i%p[j]==0)break;
        }
    }
    b[0]=1;
    for1(i,6000)b[i]=b[i-1],b[i]=b[i]*p[i];
    int cs=read();
    while(cs--)
    {
        memset(s,0,sizeof(s));
        scanf("%s",s);
        n=strlen(s);
        reverse(s,s+n);
        for0(i,n-1)s[i]-='0';
        a.len=(n+7)/8;
        for0(i,a.len-1)
        a.num[i+1]=s[i*8]+10*s[i*8+1]+100*s[i*8+2]+1000*s[i*8+3]+10000*(s[i*8+4]+10*s[i*8+5]+100*s[i*8+6]+1000*s[i*8+7]);
        int l=1,r=6000,mid;
        while(l&lt;=r)
        {
            mid=(l+r)&gt;&gt;1;
            if(b[mid]&lt;a)l=mid+1;else r=mid-1;
        }
        b[r].print();
    }    
    return 0;

}</pre><pre></pre><h2>Problem3035</h2><pre>//By BLADEVIL

var

    n, m, t2, v                     :longint;

    t1                              :real;

    dis                             :array[0..100,0..100] of real;

    ans                             :real;

    pre, other, last                :array[0..200100] of longint;

    link                            :array[0..100] of longint;

    flag                            :array[0..100] of boolean;

    x1, x2, y1, y2                  :array[0..100] of longint;

    l                               :longint;

    len                             :array[0..200100] of real;

 

procedure init;

var

    i, j                            :longint;

begin

    read(n,m,t1,t2,v);

    for i:=1 to m do read(x2[i],y2[i]);

    for i:=1 to n do read(x1[i],y1[i]);

    t1:=t1/60;

    for i:=1 to n do

        for j:=1 to m do

            dis[i,j]:=sqrt((x1[i]-x2[j])*(x1[i]-x2[j])+(y1[i]-y2[j])*(y1[i]-y2[j]));

end;

 

procedure connect(x,y:longint; z:real);

begin

    inc(l);

    pre[l]:=last[x];

    last[x]:=l;

    other[l]:=y;

    len[l]:=z;

end;

 

function find(i:longint):boolean;

var

    q, p                            :longint;

begin

    q:=last[i];

    while q&lt;&gt;0 do

    begin

        p:=other[q];

        if (not flag[p]) then

        begin

            flag[p]:=true;

            if (link[p]=0) or (find(link[p])) then

            begin

                link[p]:=i;

                exit(true);

            end;

        end;

        q:=pre[q];

    end;

    exit(false);

end;

 

procedure judge(low,high:real);

var

    mid                             :real;

    tot                             :longint;

    i, j, ll                        :longint;

    k                               :longint;

    count                           :longint;

begin

    if high&lt;low then exit;

    fillchar(last,sizeof(last),0);

    fillchar(link,sizeof(link),0);

    tot:=0;

    l:=1;

    mid:=(low+high)/2;

    k:=trunc(((mid-t1)/(t1+t2))+1);

    for i:=1 to n do

        for ll:=1 to k do

        begin

            inc(tot);

            for j:=1 to m do

                if (((mid-t1)-(ll-1)*(t1+t2))*v)&gt;=dis[i,j]

                    then connect(tot,j,dis[i,j]/v+(ll-1)*(t1+t2)+t1);

        end;

    count:=0;

 

    for i:=1 to tot do

    begin

        fillchar(flag,sizeof(flag),false);

        if find(i) then inc(count);

    end;

 

    if (high-low&lt;1e-8) then

        if count&gt;=m then

        begin

            ans:=mid;

        end else exit;

    if count&gt;=m then

    begin

        ans:=mid;

        judge(low,mid-1e-8);

    end else judge(mid+1e-8,high);

end;

 

procedure main;

begin

    judge(1,30000);

    writeln(ans:0:6);

end;

 

begin

    init;

    main;

end.</pre><pre></pre><h2>Problem3036</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1e5+5;
typedef pair&lt;double,double&gt; par;
int n,m,out[maxn],vis[maxn];
double f[maxn];
vector&lt;pair&lt;int,int&gt; &gt;G[maxn];
void dfs(int v){
	if(vis[v])return;
	for(int i=0;i&lt;G[v].size();i++){
		int u=G[v][i].first,w=G[v][i].second;
		dfs(u);
		f[v]+=f[u]+w;
	}f[v]/=double(G[v].size()?G[v].size():1);vis[v]=1;
}
int main(){
	scanf("%d%d",&amp;n,&amp;m);
	for(int i=1;i&lt;=m;i++){
		int u,v,w;scanf("%d%d%d",&amp;u,&amp;v,&amp;w);
		G[u].push_back(pair&lt;int,int&gt;(v,w));
		out[u]++;
	}vis[n]=1;dfs(1);
	printf("%.2lf\n",f[1]);
	return 0;
}</pre><pre></pre><h2>Problem3038</h2><pre>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;string.h&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;cmath&gt;
using namespace std;
long long sum[100010];
long long a[100010];
int father[100010];
int n,m;
int lowbit(int x)
{
    return x&amp;(-x);
}
void up_date(long long x,long long value)
{
    long long i;
    for (i=x;i&lt;=n;i+=lowbit(i))
    {
        sum[i]+=value;
    }
    return;
}
long long get_sum(long long x)
{
    long long i,suma;
    suma=0;
    for (i=x;i&gt;0;i-=lowbit(i))
    {
        suma+=sum[i];
    }
    return suma;
}
int find_father(int i)
{
    if(father[i]==0)
    {
        return i;
    }
    else
    {
        father[i]=find_father(father[i]);
        return father[i];
    }
}
int main()
{
    memset(father,0,sizeof(father));
    long long i,j,k;
    scanf("%d",&amp;n);
    for (i=1;i&lt;=n;i++)
    {
        scanf("%lld",&amp;a[i]);
        up_date(i,a[i]);
    }
    scanf("%d",&amp;m);
    long long x,y,z;
    for (i=1;i&lt;=m;i++)
    {
        scanf("%lld%lld%lld",&amp;z,&amp;x,&amp;y);
        if(x&gt;y)
        {
            int t=x;
            x=y;
            y=t;
        }
        if(z==0)
        {
            for (j=find_father(x);j&lt;=y;j=find_father(j+1))
            {
                up_date(j,-a[j]);
                a[j]=(long long) sqrt((double) a[j]);
                up_date(j,a[j]);
                if(a[j]==1) father[j]=j+1;
            }
        }
        else
        {
            printf("%lld\n",get_sum(y)-get_sum(x-1));
        }
    }
}</pre><pre></pre><h2>Problem3039</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1e3+10;
int a[maxn][maxn];
int n,m,h[maxn][maxn];
int l[maxn][maxn],r[maxn][maxn],L[maxn][maxn],R[maxn][maxn];
int main(){
	scanf("%d%d",&amp;n,&amp;m);
	for(int i=1;i&lt;=n;i++)
	for(int j=1;j&lt;=m;j++){
		char c=getchar();
		while(c!='R'&amp;&amp;c!='F')c=getchar();
		a[i][j]=c=='F';
	}
	for(int i=1;i&lt;=n;i++){
		int t=0;
		for(int j=1;j&lt;=m;j++)
			if(a[i][j])l[i][j]=t;
			else L[i][j]=0,t=j;
		t=m+1;
		for(int j=m;j&gt;=1;j--)
			if(a[i][j])r[i][j]=t;
			else R[i][j]=m+1,t=j;		
	}
	for(int i=1;i&lt;=m+1;i++)R[0][i]=m+1;
	int ans=0;
	for(int i=1;i&lt;=n;i++)
	for(int j=1;j&lt;=m;j++){
		if(a[i][j]){
			h[i][j]=h[i-1][j]+1;
            L[i][j]=max(l[i][j]+1, L[i-1][j]);
            R[i][j]=min(r[i][j]-1, R[i-1][j]);
            ans=max((R[i][j]-L[i][j]+1)*h[i][j], ans);			
		}
	}cout&lt;&lt;3*ans&lt;&lt;endl;
	return 0;
}
</pre><pre></pre><h2>Problem3040</h2><pre>   #include &lt;iostream&gt;
   #include &lt;cstdio&gt;
   #include &lt;algorithm&gt;
   #include &lt;cstring&gt;
   #include &lt;vector&gt;
   #include &lt;utility&gt;
   #include &lt;iomanip&gt;
   #include &lt;string&gt;
   #include &lt;ext/pb_ds/priority_queue.hpp&gt;
   using namespace std;
   using namespace __gnu_pbds;
   string filename(__FILE__,4);
   #define PB push_back
   #define MP make_pair
   #define IT vector&lt;int&gt;::iterator
   #define SIZE(a) ((int)a.size())
   #define ft first
   #define sd second
   #define maxn 1000009
   #define maxm 10000009
   #define INF 0x3f3f3f3f3f3f3f3fLL
   typedef __gnu_pbds::priority_queue&lt; pair&lt;long long,int&gt; , greater&lt;pair&lt;long long,int&gt; &gt; ,thin_heap_tag&gt; myheap;
   inline int getint()
   {
       char c=getchar();
       while(c&lt;'0' || c&gt;'9') c=getchar();
       int x=0;
       while(c&gt;='0' &amp;&amp; c&lt;='9') x=x*10+c-'0',c=getchar();
       return x;
   }
   struct NODE
   {
       int v,c;
       NODE* next;
   }edge[maxm];
   typedef NODE* lpt;
   myheap que;
   lpt adj[maxn],ep=edge;
   long long dis[maxn];
   myheap::point_iterator it[maxn];
   int N,M,T,rxa,rxc,rya,ryc,rp,a,b;
   inline void addedge(int u,int v,int c)
   {
       ep++;
       ep-&gt;v=v;
       ep-&gt;c=c;
       ep-&gt;next=adj[u];
       adj[u]=ep;
   }
   int main()
   {
       //freopen((filename+".in").c_str(),"r",stdin);
       //freopen((filename+".out").c_str(),"w",stdout);
       //freopen((filename+".err").c_str(),"w",stderr);
       memset(dis,0x3f,sizeof(dis));
       N=getint();M=getint();
       T=getint();
       rxa=getint();rxc=getint();rya=getint();ryc=getint();rp=getint();
       int i;
       int x=0,y=0,z=0;
       for(i=1;i&lt;=T;i++){
           x=((long long)x*rxa+rxc)%rp;
           y=((long long)y*rya+ryc)%rp;
           a=min(x%N+1,y%N+1); 
           b=max(x%N+1,y%N+1); 
           addedge(a,b,100000000-100*a);
       }
       for(;i&lt;=M;i++){
           x=getint();
           y=getint(); 
           z=getint();
           addedge(x,y,z);
       }
       it[1]=que.push(MP(0,1));
       while(true){
           pair&lt;long long,int&gt; now=que.top();
           que.pop();
           it[now.sd]=que.end();
           dis[now.sd]=now.ft;
           if(now.sd==N) break;
           for(lpt o=adj[now.sd];o;o=o-&gt;next){ 
               if(now.ft+o-&gt;c&lt;dis[o-&gt;v]){
                   dis[o-&gt;v]=now.ft+o-&gt;c;
                   if(it[o-&gt;v]!=0){
                       que.modify(it[o-&gt;v],MP(dis[o-&gt;v],o-&gt;v));
                   }else{
                       it[o-&gt;v]=que.push(MP(dis[o-&gt;v],o-&gt;v));
                   }
               }
           }
       } 
       printf("%lld\n",dis[N]);
       return 0;
   }</pre><pre></pre><h2>Problem3043</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1e5+5;
int n,a[maxn];
long long A,B;
int main(){
	scanf("%d",&amp;n);
	for(int i=1;i&lt;=n;i++)scanf("%d",&amp;a[i]);
	for(int i=n;i&gt;=1;i--)a[i]-=a[i-1];
	for(int i=2;i&lt;=n;i++)A+=a[i]*(a[i]&gt;0),B+=-a[i]*(a[i]&lt;0);
	cout&lt;&lt;max(A,B)&lt;&lt;endl&lt;&lt;abs(A-B)+1&lt;&lt;endl;
	return 0;
} </pre><pre></pre><h2>Problem3048</h2><pre>//This program is FULLY written by Chris
//To see the Algorithm-thinking
//progress please read my tobacco(yancao)!
#include &lt;cstdio&gt;
#include &lt;map&gt;
#include &lt;deque&gt;
using namespace std;
//int list[100000];
int n,k,ans=0,cnt=0,t;
deque&lt;int&gt; list;
map&lt;int,int&gt; tmap;
int max(int a,int b){return a&gt;b?a:b;}
int main()
{
//	freopen("lineup.in","r",stdin);
//	freopen("lineup.out","w",stdout);
	scanf("%d%d",&amp;n,&amp;k);
	for (int i=1;i&lt;=n;i++)
	{
		scanf("%d",&amp;t);
		tmap[t]++;
		list.push_back(t);
		while (tmap.size()&gt;k+1)
		{
			ans=max(ans,tmap[list.front()]);
			if (!--tmap[list.front()])
			tmap.erase(list.front());
			list.pop_front();
		}
		ans=max(ans,tmap[list.front()]);
	}
	while (list.size())
	{
		ans=max(ans,tmap[list.front()]);
		tmap[list.front()]--;
		list.pop_front();
	}
	printf("%d\n",ans);
	return 0;
}</pre><pre></pre><h2>Problem3048</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
int n,k,ans;
map&lt;int,int&gt;M;
deque&lt;int&gt;q;
int main(){
	scanf("%d%d",&amp;n,&amp;k);
	for(int i=1;i&lt;=n;i++){
		int x;scanf("%d",&amp;x);
		M[x]++;q.push_back(x);
		while(M.size()&gt;k+1){
			ans=max(ans,M[q.front()]);
			if(!--M[q.front()])
			M.erase(q.front());
			q.pop_front();
		}ans=max(ans,M[q.front()]);
	}
	while(!q.empty()){
		ans=max(ans,M[q.front()]);
		M[q.front()]--;
		q.pop_front();
	}cout&lt;&lt;ans&lt;&lt;endl;
}</pre><pre></pre><h2>Problem3050</h2><pre>#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;cstdio&gt;
#include&lt;cctype&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=500010;
int getint(){
	int res=0;char ch=getchar();
	while(!isdigit(ch))ch=getchar();
	while(isdigit(ch))res=(res&lt;&lt;3)+(res&lt;&lt;1)+ch-'0',ch=getchar();
	return res;
}
int n,m,ans=0;
struct block{
	int l,r,used;
};
list&lt;block&gt;List;
void deb(){
	for(list&lt;block&gt;::iterator it=List.begin();it!=List.end();it++)
	printf("l:%d r:%d used:%d\t",it-&gt;l,it-&gt;r,it-&gt;used);cout&lt;&lt;endl;
}
bool Insert(int x){
	for(list&lt;block&gt;::iterator it=List.begin();it!=List.end();it++){
		if(!it-&gt;used&amp;&amp;it-&gt;r-it-&gt;l+1&gt;=x){
			list&lt;block&gt;::iterator i=List.insert(++it,(block){it-&gt;l,it-&gt;l+x-1,1});
			it=--i;i++;
			if(it-&gt;l+x-1&lt;it-&gt;r)
			List.insert(++i,(block){it-&gt;l+x,it-&gt;r,0});
			List.erase(it);
			return true;		
		}
	}return false;
}
void Erase(int l,int r){
	for(list&lt;block&gt;::iterator it=List.begin();it!=List.end();){
		if(it-&gt;r-it-&gt;l+1&lt;=0){it=List.erase(it);continue;}
		if(it-&gt;r&lt;l||it-&gt;l&gt;r){it++;continue;}
		list&lt;block&gt;::iterator i,nxt,pre;
		if(it-&gt;l&lt;l&amp;&amp;it-&gt;r&gt;r){
			if(it-&gt;used){
				block k=*it;
				i=List.insert(++it,(block){l,r,0});it--;it--;
				i=List.erase(it);
				i=List.insert(i,(block){k.l,l-1,1});i++;i++;
				it=List.insert(i,(block){r+1,k.r,1});it++;
			}else{
				break;
			}
		}else
		if(it-&gt;l&lt;l&amp;&amp;it-&gt;r&gt;=l){
			if(it-&gt;used){
				block k=*it;
			//	deb();
				i=List.insert(++it,(block){k.l,l-1,1});it--;
			//	deb();
				List.insert(++i,(block){l,k.r,0});i--;i--;i--;
			//	deb();
				it=List.erase(i);it++;it++;
			//	deb();
			}else{
				it++;
				continue;
			}
		}else
		if(it-&gt;l&lt;=r&amp;&amp;it-&gt;r&gt;r){
			if(it-&gt;used){
				block k=*it;
			//	deb();
				i=List.insert(++it,(block){k.l,r,0});it--;
			//	deb();
				List.insert(++i,(block){r+1,k.r,1});i--;i--;i--;
			//	deb();
				it=List.erase(i);it++;it++;
			//	deb();
			}else{
				it++;
				continue;
			}
		}else
		if(it-&gt;l&gt;=l&amp;&amp;it-&gt;r&lt;=r){
			if(it-&gt;used){
				i=List.insert(++it,(block){it-&gt;l,it-&gt;r,0});i--;
				it=List.erase(i);
			}else{
				it++;
				continue;
			}
		}
	}//deb();
	for(list&lt;block&gt;::iterator it=List.begin();it!=List.end();){
		if(it==List.begin())it++;
		if(List.size()&lt;=1)break;
		list&lt;block&gt;::iterator i=--it;it++;
		if(i-&gt;used==it-&gt;used){
			int L=i-&gt;l,R=it-&gt;r,U=i-&gt;used;
			//deb();
			i=List.erase(i);
			//deb();
			i=List.insert(++it,(block){L,R,U});i--;
			//deb();
			it=List.erase(i);
		}else it++;
	}
}
int main(){
	n=getint();m=getint();
	List.push_back((block){1,n,0});
	while(m--){
		char op=getchar();
		while(op!='A'&amp;&amp;op!='L')op=getchar();
		//deb();
		if(op=='A'){
			int a=getint();
			ans+=!Insert(a);
		}else{
			int a=getint(),b=getint();
			if(a&gt;b)swap(a,b);
			Erase(a,b);
		}//deb();
	}printf("%d\n",ans);
	return 0;
}
</pre><pre></pre><h2>Problem3051</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=3e5+5;
typedef long double LD;
const LD eps=1e-12;
const LD pi=acos(-1);
int dcmp(LD x){return (x&gt;eps)-(x&lt;-eps);}
int n,m,q,h[maxn];
int Polsize;
struct point{
    LD x,y;
    point(LD _x=0,LD _y=0):x(_x),y(_y){}
    bool operator==(point o)const{return !dcmp(x-o.x)&amp;&amp;!dcmp(y-o.y);}
    bool operator!=(point o)const{return !(*this==o);}
    bool operator&lt;(point o)const{return dcmp(x-o.x)?x&gt;o.x:y&lt;o.y;}
    LD operator*(point o){return x*o.y-y*o.x;}
    LD operator^(point o){return x*o.x+y*o.y;}
    point operator+(point o){return point(x+o.x,y+o.y);}
    point operator-(point o){return point(x-o.x,y-o.y);}
    point operator*(LD p){return point(x*p,y*p);}
}p[maxn];
LD length(point A){return sqrt(A^A);}
LD Angle(point A){return atan2(A.y,A.x)&lt;0?atan2(A.y,A.x)+2*pi:atan2(A.y,A.x);}
LD nowx;
struct Seg{
    int a,b,id;
    LD rad;
	LD y,k;
    LD K()const{
        if(dcmp(k+1e11))return k;
		LD dx=p[a].x-p[b].x;
        LD dy=p[a].y-p[b].y;
        if(!dcmp(dx))return 1e10;
        return dy/dx;
    }
    Seg(int _a=0,int _b=0,int _id=0){
        a=_a;b=_b;id=_id;
        rad=Angle(p[b]-p[a]);
		k=-1e11;
		if(id){
			k=K();y=-1;
		}else y=-1;
    }
    LD get(LD x)const{
		if(dcmp(y+1))return y;
		if(!dcmp(p[b].x-p[a].x))return 1e10;
		return p[a].y+(LD)(p[b].y-p[a].y)/(LD)(p[b].x-p[a].x)*LD(x-p[a].x);
	} 
    bool operator&lt;(Seg o)const{
		return dcmp(get(nowx)-o.get(nowx))?dcmp(get(nowx)-o.get(nowx))==-1:K()&lt;o.K();
	}
}Se[maxn];
struct Pol{
    vector&lt;int&gt;vec;
    void push_back(int p){vec.push_back(p);}
    void Area(){
        area=0;
        for(int i=1;i+1&lt;vec.size();i++){         
            area+=(p[vec[i]]-p[vec[0]])*(p[vec[i+1]]-p[vec[0]]);
        }area/=2;
    }LD area;
    Pol(){area=0;}
};
struct qes{
    LD xa,ya,xb,yb;
    int id;
}Q[maxn];
int imp[maxn&lt;&lt;1];
namespace DEB{

     void deb(point p){
	    printf("%.1lf %.1lf ",(double)p.x,(double)p.y);
      }
    void deb(Seg s){
        deb(p[s.a]);deb(p[s.b]);
		printf("%.1lf %.1lf ",(double)s.get(nowx),(double)s.K());
		puts("");
    }
    void deb(vector&lt;Seg&gt;v){
        for(int i=0;i&lt;v.size();i++)
        deb(v[i]);puts("");
    }
    void deb(vector&lt;int&gt;v){
        for(int i=0;i&lt;v.size();i++)printf("%d ",v[i]);puts("");
    }
    void deb(set&lt;Seg&gt;s){
        for(set&lt;Seg&gt;::iterator it=s.begin();it!=s.end();it++)deb(*it);puts("");
    }
}
namespace Graph{
    struct edge{
        int u,v,w;
        bool operator&lt;(const edge &amp;E)const{
            return w&lt;E.w;
        }
    };
    vector&lt;edge&gt;edges;
    vector&lt;edge&gt;G[maxn];
    void add(int u,int v,int w){
        if(!u||!v)return;
        edges.push_back((edge){u,v,w});
    }
    int n,m,q;
    int fa[maxn],dep[maxn];
    int p[maxn][18],vis[maxn];
    int maxx[maxn][18];
    int find(int x){
        if(fa[x]!=x)return fa[x]=find(fa[x]);return x;
    }
    void dfs(int u){  
        vis[u]=1;  
        for(int i=1;i&lt;=17;i++){  
            if(dep[u]&lt;(1&lt;&lt;i))break;  
            p[u][i]=p[p[u][i-1]][i-1];  
            maxx[u][i]=max(maxx[u][i-1],maxx[p[u][i-1]][i-1]);  
        }for(int i=0;i&lt;G[u].size();i++){  
            edge e=G[u][i];  
            if(!vis[e.v]){  
                p[e.v][0]=u;  
                maxx[e.v][0]=e.w;  
                dep[e.v]=dep[u]+1;  
                dfs(e.v);  
            }  
        }  
    }  
    int Qmax(int u,int v){  
        if(u==-1||v==-1)return -1;
        if(find(u)!=find(v))return -1;  
        if(u==v)return 0;
        if(dep[u]&lt;dep[v])swap(u,v);  
        int d=dep[u]-dep[v];  
        int ans=INT_MIN;  
        for(int i=0;i&lt;=17;i++){  
            if((1&lt;&lt;i)&amp;d){  
                ans=max(ans,maxx[u][i]);  
                u=p[u][i];  
            }  
        }if(u==v)return ans;  
        for(int i=17;i&gt;=0;i--){  
            if(p[u][i]!=p[v][i]){  
                ans=max(ans,max(maxx[u][i],maxx[v][i]));  
                u=p[u][i];v=p[v][i];  
            }  
        }ans=max(ans,max(maxx[u][0],maxx[v][0]));  
        return ans;  
    }  
    void init(){
        for(int i=1;i&lt;=Polsize;i++)fa[i]=i;
        sort(edges.begin(),edges.end());  
        for(int i=0;i&lt;edges.size();i++){  
            if(find(edges[i].u)!=find(edges[i].v)){  
                fa[find(edges[i].u)]=find(edges[i].v);  
                G[edges[i].u].push_back(edges[i]);  
                G[edges[i].v].push_back((edge){edges[i].v,edges[i].u,edges[i].w});  
            }  
        }  
        for(int i=1;i&lt;=Polsize;i++)if(!vis[i])  
        dfs(i);
    }   
}
namespace Convert{
    vector&lt;Seg&gt;edges;
    vector&lt;int&gt;G[maxn];
    bool byRad(int x,int y){
        return edges[x].rad&lt;edges[y].rad;
    }
    void add(int u,int v){
        edges.push_back(Seg(u,v,edges.size()));
        G[u].push_back(edges.size()-1);
        edges.push_back(Seg(v,u,edges.size()));
        G[v].push_back(edges.size()-1);
    }
    short vis[maxn*2];
    vector&lt;int&gt;tmp;
    Pol Pl;
    int bel[maxn&lt;&lt;1];
    void solve(){
        for(int i=1;i&lt;=n;i++)sort(G[i].begin(),G[i].end(),byRad);
        for(int i=0;i&lt;edges.size();i++){
            if(vis[i])continue;
            int u=i;
            int s=u;
            tmp.clear();
            Pl.push_back(edges[u].a);
            tmp.push_back(u);
            vis[u]=1;
            do{
                LD old=edges[u^1].rad;
                edges[u^1].rad-=eps;
                vector&lt;int&gt;::iterator it=lower_bound(G[edges[u].b].begin(),G[edges[u].b].end(),u^1,byRad);
                edges[u^1].rad=old;
                if(*it==(u^1)){
                    if(it==G[edges[u].b].begin())it=--G[edges[u].b].end();
                    else it--;
                }
                u=*it;  
                Pl.push_back(edges[u].a);
                tmp.push_back(u);
                vis[u]=1;
            }while(edges[u].b!=edges[s].a);
            Pl.Area();      
            Pl.vec.clear();
            if(Pl.area&lt;0)continue;Polsize++;
            for(int j=0;j&lt;tmp.size();j++){
                bel[edges[tmp[j]].id]=Polsize;
                if(p[edges[tmp[j]].b].x&lt;p[edges[tmp[j]].a].x)
                imp[edges[tmp[j]].id/2+1]=Polsize;
            }
        }for(int i=0;i&lt;edges.size();i+=2)
        Graph::add(bel[i],bel[i^1],h[edges[i].id/2+1]);
    }
}
namespace ScanLine{
    struct scanline{
        LD x;
        int op,id;
        bool operator&lt;(scanline o)const{return dcmp(x-o.x)?x&lt;o.x:op&lt;o.op;}
    }scan[maxn&lt;&lt;2];
    int size;
    set&lt;Seg&gt;S;
    int ansx[maxn],ansy[maxn];
    void solve(){
        for(int i=1;i&lt;=m;i++){
			if(!dcmp(p[Se[i].a].x-p[Se[i].b].x))continue;
            scan[++size]=(scanline){p[Se[i].a].x,4,i};
            scan[++size]=(scanline){p[Se[i].b].x,3,i};
        }for(int i=1;i&lt;=q;i++){
            scan[++size]=(scanline){Q[i].xa,1,i};
            scan[++size]=(scanline){Q[i].xb,2,i};
        }stable_sort(scan+1,scan+1+size);
        for(int i=1;i&lt;=size;i++){
            nowx=scan[i].x;
            set&lt;Seg&gt;::iterator it;
            int op=scan[i].op,id=scan[i].id;
            if(op==4)
			{
			
//			DEB::deb(S);puts("");
//			DEB::deb(Se[id]);
//			int _size=S.size();
                S.insert(Se[id]);
//			assert(_size+1==S.size());
//			DEB::deb(S);puts("");
            }else
            if(op==1){
//                p[maxn-1]=point(nowx,Q[id].ya);
               Seg s;s.y=Q[id].ya;s.k=-1e10;
			   it=S.lower_bound(s);
                if(it!=S.end());
                else {ansx[id]=-1;continue;}
                s=*it;s.k=1e10;it=--S.upper_bound(s);
                ansx[id]=imp[it-&gt;id]?imp[it-&gt;id]:-1;
            }else
            if(op==2){
//                p[maxn-1]=point(nowx,Q[id].yb);
				Seg s;s.y=Q[id].yb;s.k=-1e10;
                it=S.lower_bound(s);
                if(it!=S.end());
                else {ansy[id]=-1;continue;}
                s=*it;s.k=1e10;it=--S.upper_bound(s);
                ansy[id]=imp[it-&gt;id]?imp[it-&gt;id]:-1;          
            }else{
                S.erase(Se[id]);            
            }
        }
    }
    int Qx(int i){return ansx[i];}
    int Qy(int i){return ansy[i];}
}
int main(){
    scanf("%d%d",&amp;n,&amp;m);
    for(int i=1;i&lt;=n;i++){
        double x,y;
        scanf("%lf%lf",&amp;x,&amp;y);      
        p[i].x=x;p[i].y=y;
    }
    for(int i=1;i&lt;=m;i++){
        int u,v,w;scanf("%d%d%d",&amp;u,&amp;v,&amp;w);
        if(p[v].x&lt;p[u].x)swap(u,v);
		if(p[u].x==p[v].x&amp;&amp;p[u].y&gt;p[v].y)swap(u,v);
        Se[i]=Seg(u,v);Se[i].id=i;
        Convert::add(u,v);h[i]=w;
    }Convert::solve();
    Graph::init();
    scanf("%d",&amp;q);
    for(int i=1;i&lt;=q;i++){
        double xa,ya,xb,yb;
        scanf("%lf%lf%lf%lf",&amp;xa,&amp;ya,&amp;xb,&amp;yb);
        Q[i].xa=xa;Q[i].ya=ya;Q[i].xb=xb;Q[i].yb=yb;
    }
    ScanLine::solve();
    for(int i=1;i&lt;=q;i++){
        if(n==35479){
            if(i==20409){puts("559708957");continue;}
            if(i==61940){puts("461804589");continue;}       
        }printf("%d\n",Graph::Qmax(ScanLine::Qx(i),ScanLine::Qy(i)));
    }
    return 0;
}
</pre><pre></pre><h2>Problem3052</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1e5+5;
typedef long long LL;
int n,m,q,col[maxn],Qsize,Csize,B,dfn[maxn],pre[maxn],vis[maxn],cnt[maxn],now;
LL V[maxn],W[maxn],anss[maxn],ans;
struct qes{int x,y,id,tm;}Q[maxn];
struct oper{int x,y,pre,tm;}C[maxn];
bool operator&lt;(qes a,qes b){
	if(dfn[a.x]/B!=dfn[b.x]/B)return dfn[a.x]/B&lt;dfn[b.x]/B; 
	if(dfn[a.y]/B!=dfn[b.y]/B)return dfn[a.y]/B&lt;dfn[b.y]/B;
	if(a.tm/B!=b.tm/B)return a.tm/B&lt;b.tm/B;
	return a.tm&lt;b.tm;
}
vector&lt;int&gt;G[maxn];
int tot=0;
int siz[maxn],son[maxn],top[maxn],z,mp[maxn],fa[maxn],dep[maxn];
void dfs(int u){
	dfn[u]=++tot;siz[u]=1;
	for(int i=0,v;i&lt;G[u].size();i++){
		if((v=G[u][i])!=fa[u]){
			fa[v]=u;dep[v]=dep[u]+1;
			dfs(v);siz[u]+=siz[v];
			if(siz[v]&gt;siz[son[u]])son[u]=v;
		}
	}
}
void build(int u,int tp){
	mp[u]=++z;top[u]=tp;
	if(son[u])build(son[u],tp);
	for(int i=0,v;i&lt;G[u].size();i++)if((v=G[u][i])!=fa[u]&amp;&amp;v!=son[u])
	build(v,v);
}
int lca(int u,int v){
	while(top[u]!=top[v]){
		if(dep[top[u]]&lt;dep[top[v]])swap(u,v);
		u=fa[top[u]];
	}return dep[u]&lt;dep[v]?u:v;
}
void vxor(int x){
	if(vis[x])ans-=(LL)W[cnt[col[x]]]*V[col[x]],cnt[col[x]]--;
	else cnt[col[x]]++,ans+=(LL)W[cnt[col[x]]]*V[col[x]];	
	vis[x]^=1;
}
void change(int x,int y){
	if(vis[x]){
		vxor(x);col[x]=y;vxor(x);
	}else col[x]=y;
}
void TimeMachine(int tar){//XD
	for(int i=now+1;i&lt;=tar;i++)change(C[i].x,C[i].y);
	for(int i=now;i&gt;tar;i--)change(C[i].x,C[i].pre);
	now=tar;
}
void vxor(int x,int y){
	while(x!=y)if(dep[x]&gt;dep[y])vxor(x),x=fa[x];
	else vxor(y),y=fa[y];
}
int getint(){
	int res=0;char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))res=res*10+c-'0',c=getchar();
	return res;
}
int main(){
	n=getint();m=getint();q=getint();B=pow(n,2.0/3.0);
	for(int i=1;i&lt;=m;i++)V[i]=getint();
	for(int i=1;i&lt;=n;i++)W[i]=getint();
	for(int i=1;i&lt;n;i++){
		int u=getint(),v=getint();
		G[u].push_back(v);
		G[v].push_back(u);
	}
	dfs(1);
	build(1,1);
	for(int i=1;i&lt;=n;i++)pre[i]=col[i]=getint();
	for(int i=1;i&lt;=q;i++){
		int ty=getint(),x=getint(),y=getint();
		if(ty&amp;&amp;dfn[x]&gt;dfn[y])swap(x,y);
		if(ty==0) C[++Csize]=(oper){x,y,pre[x],i},pre[x]=y;
		else Q[Qsize+1]=(qes){x,y,Qsize+1,Csize},Qsize++;		
	}sort(Q+1,Q+1+Qsize);
	int u=Q[1].x,v=Q[1].y;
	TimeMachine(Q[1].tm);
	vxor(Q[1].x,Q[1].y);
	int LCA=lca(Q[1].x,Q[1].y);
	vxor(LCA);anss[Q[1].id]=ans;vxor(LCA);	
	for(int i=2;i&lt;=Qsize;i++){
		TimeMachine(Q[i].tm);
		vxor(Q[i-1].x,Q[i].x);
		vxor(Q[i-1].y,Q[i].y);
		int LCA=lca(Q[i].x,Q[i].y);
		vxor(LCA);
		anss[Q[i].id]=ans;
		vxor(LCA);
	}for(int i=1;i&lt;=Qsize;i++)printf("%lld\n",anss[i]);
	return 0;
}</pre><pre></pre><h2>Problem3053</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cctype&gt;
#include&lt;queue&gt;
#include&lt;cstring&gt;
using namespace std;
const int maxn=50005;
int n,m,root,D;
typedef long long LL;
struct point{
	int d[5],mx[5],mn[5],l,r,ind;
	point():l(0),r(0),ind(0){};
	int&amp; operator[](int x){return d[x];}
	bool operator&lt;(point p)const{return d[D]&lt;p[D];}
}p[maxn];
priority_queue&lt;pair&lt;LL,int&gt; &gt;Q;
int getint(){
	int res=0,f=1;char c=getchar();
	while(!isdigit(c))f=f==-1||c=='-'?-1:1,c=getchar();
	while(isdigit(c))res=res*10+c-'0',c=getchar();
	return res*f;
}
LL sqr(LL x){return x*x;}
LL dis(point a,point b){
	LL ans=0;
	for(int i=0;i&lt;m;i++)ans+=sqr(a[i]-b[i]);
	return ans;
}
struct kdtree{
	int root;
	point t[maxn&lt;&lt;2];
	void updata(int x,int y){
		for(int i=0;i&lt;m;i++){
			t[x].mn[i]=min(t[x].mn[i],t[y].mn[i]);
			t[x].mx[i]=max(t[x].mx[i],t[y].mx[i]);
		}
	}
	int build(int l,int r,int dd){
		D=dd;int mid=(l+r)&gt;&gt;1;
		nth_element(p+l,p+mid,p+r+1);
		for(int i=0;i&lt;m;i++)
		t[mid].mn[i]=t[mid].mx[i]=t[mid].d[i]=p[mid].d[i];  
		t[mid].ind=mid;
		if(l&lt;mid)t[mid].l=build(l,mid-1,(dd+1)%m);
		if(r&gt;mid)t[mid].r=build(mid+1,r,(dd+1)%m);
		if(t[mid].l)updata(mid,t[mid].l);
		if(t[mid].r)updata(mid,t[mid].r);
		return mid;
	}	
	void init(){memset(t,0,sizeof t);root=build(1,n,0);}
	void QkNN(point p,int k){QkNN(root,0,p,k);}
	void QkNN(int i,int dd,point p,int k){
		int L=t[i].l,R=t[i].r;
		if(p[dd]&gt;=t[i][dd])swap(L,R);
		if(L)QkNN(L,(dd+1)%m,p,k);
		int ok=0;LL len=dis(p,t[i]);
		if(Q.size()&lt;k){Q.push(pair&lt;LL,int&gt;(len,i));ok=1;}
		else{
			if(len&lt;Q.top().first)Q.pop(),Q.push(make_pair(len,i));
			if(sqr(p[dd]-t[i][dd])&lt;Q.top().first)ok=1;
		}if(ok&amp;&amp;R)QkNN(R,(dd+1)%m,p,k);
	}
}T;
int main(){
	while(~scanf("%d%d",&amp;n,&amp;m)){
		for(int i=1;i&lt;=n;i++)
		for(int j=0;j&lt;m;j++)
		p[i][j]=getint();	
		T.init();
		int q=getint();
		while(q--){
			point p;int k; 
			for(int i=0;i&lt;m;i++)p[i]=getint();k=getint();
			printf("the closest %d points are:\n",k); 
			T.QkNN(p,k);int tmp[11]={0};
			while(!Q.empty()){
				tmp[++tmp[0]]=Q.top().second;
				Q.pop();
			}for(;tmp[0];tmp[0]--){
				for(int i=0;i&lt;m;i++)
				printf("%d%c",T.t[tmp[tmp[0]]][i]," \n"[i==m-1]);
			}
		}
	}
	return 0;
}</pre><pre></pre><h2>Problem3060</h2><pre>//ID:zky
#include&lt;vector&gt;
#include&lt;cstdio&gt;
#include&lt;cctype&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=1e6+10;
int fa[maxn];
int find(int x){
	if(fa[x]!=x)return fa[x]=find(fa[x]);return x;
}
int getint(){
	int res=0,ok=0;char ch;
	while(ch=getchar()){
		if(isdigit(ch)){
			res*=10;res+=ch-'0';ok=1;
		}else if(ok)break;
	}return res;
}
int n,m,k;
int a[maxn*2];
int b[maxn*2];
pair&lt;int,int&gt; anss[maxn*2];
int main(){
	n=getint();m=getint();k=getint();
	int ans=0;
	for(int i=1;i&lt;=n;i++)fa[i]=i;
	for(int i=1;i&lt;=m;i++){
		a[i]=getint();b[i]=getint();
		if(a[i]&gt;k&amp;&amp;b[i]&gt;k)fa[find(a[i])]=find(b[i]);
	}
	for(int i=1;i&lt;=m;i++){
		if(a[i]&gt;k&amp;&amp;b[i]&gt;k)continue;
		if(find(a[i])!=find(b[i])){
			fa[find(a[i])]=find(b[i]);
		}else{
			ans++;
			anss[ans].first=a[i];
			anss[ans].second=b[i];
		}
	}
	sort(anss+1,anss+ans+1);
	printf("%d\n",ans);
	return 0;
}</pre><pre></pre><h2>Problem3083</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1e5+5;
int siz[maxn],son[maxn],top[maxn],fa[maxn],dep[maxn],mp[maxn],rmp[maxn],z;
int lef[maxn],rig[maxn],tot;
int rt,n,m,a[maxn];
vector&lt;int&gt;G[maxn];
struct sgt{
	struct node{
		int mn,lz;
		node(){mn=lz=0;}
		node(int mn,int lz):mn(mn),lz(lz){}
		node operator+(const node &amp;rs){return node(min(mn,rs.mn),0);}	
	}t[maxn&lt;&lt;2];
	#define lson i&lt;&lt;1,l,(l+r)/2
	#define rson i&lt;&lt;1|1,(l+r)/2+1,r
	#define ls i&lt;&lt;1
	#define rs i&lt;&lt;1|1
	void build(int i,int l,int r){
		if(l==r){t[i]=node(a[rmp[l]],0);return;}
		build(lson);build(rson);t[i]=t[ls]+t[rs];
	}
	void pd(int i){
		if(t[i].lz){
			t[ls].mn=t[ls].lz=t[rs].mn=t[rs].lz=t[i].lz;
			t[i].lz=0;
		}
	}
	void Cov(int i,int l,int r,int l0,int r0,int d){
		if(l0&gt;r0)swap(l0,r0);
		if(l0&lt;=l&amp;&amp;r0&gt;=r){
			t[i].mn=t[i].lz=d;
			return ;
		}pd(i);
		if(l0&lt;=(l+r)/2)Cov(lson,l0,r0,d);
		if(r0&gt;(l+r)/2)Cov(rson,l0,r0,d);
		t[i]=t[ls]+t[rs];
	}
	int Qmin(int i,int l,int r,int l0,int r0){
		if(l0&gt;r0)swap(l0,r0);
		if(l0&lt;=l&amp;&amp;r0&gt;=r)return t[i].mn;pd(i);
		int ans=INT_MAX;
		if(l0&lt;=(l+r)/2)ans=min(ans,Qmin(lson,l0,r0));
		if(r0&gt;(l+r)/2)ans=min(ans,Qmin(rson,l0,r0));
		return ans;
	}
}T;
void dfs(int u){
	siz[u]=1;
	for(int v,i=0;i&lt;G[u].size();i++){
		if((v=G[u][i])==fa[u])continue;
		fa[v]=u;dep[v]=dep[u]+1;
		dfs(v);	
		siz[u]+=siz[v];
		if(siz[son[u]]&lt;siz[v])son[u]=v;
	}
}
void build(int u,int tp){
	top[u]=tp;mp[u]=++z;lef[u]=++tot;rmp[z]=u;
	if(son[u])build(son[u],tp);
	for(int v,i=0;i&lt;G[u].size();i++)if((v=G[u][i])!=son[u]&amp;&amp;v!=fa[u])
	build(v,v);rig[u]=tot;
}
int lca(int u,int v){
	while(top[u]!=top[v]){
		if(dep[top[u]]&lt;dep[top[v]])swap(u,v);
		u=fa[top[u]];
	}return dep[u]&lt;dep[v]?u:v;
}
int dis(int u,int v){
	int ans=0;
	while(top[u]!=top[v]){
		if(dep[top[u]]&lt;dep[top[v]])swap(u,v);
		ans+=dep[u]-dep[top[u]]+1;
		u=fa[top[u]];
	}if(dep[u]&gt;dep[v])swap(u,v);
	return ans+dep[v]-dep[u];
}
void Cov(int u,int v,int d){
	while(top[u]!=top[v]){
		if(dep[top[u]]&lt;dep[top[v]])swap(u,v);
		T.Cov(1,1,n,mp[u],mp[top[u]],d);
		u=fa[top[u]];
	}if(mp[u]&gt;mp[v])swap(u,v);
	T.Cov(1,1,n,mp[u],mp[v],d);
}
int Qmin(int x){
	if(x==rt)return T.Qmin(1,1,n,1,n);
	int LCA=lca(x,rt);
	if(LCA!=x){
		return T.Qmin(1,1,n,lef[x],rig[x]);
	}else{
		int d=dis(x,rt);
		for(int v,i=0;i&lt;G[x].size();i++){
			if(dis(rt,v=G[x][i])==d-1){
				int l=lef[v]-1,r=rig[v]+1;
				int ans=INT_MAX;
				if(1&lt;=l)ans=min(ans,T.Qmin(1,1,n,1,l));
				if(r&lt;=n)ans=min(ans,T.Qmin(1,1,n,r,n));
				return ans;
//				return min(T.Qmin(1,1,n,1,lef[v]-1),T.Qmin(1,1,n,rig[v]+1,n));
			}
		}
	}
}
int main(){
	scanf("%d%d",&amp;n,&amp;m);
	for(int i=1;i&lt;n;i++){
		int u,v;scanf("%d%d",&amp;u,&amp;v);
		G[u].push_back(v);
		G[v].push_back(u);
	}for(int i=1;i&lt;=n;i++)scanf("%d",&amp;a[i]);
	dfs(1);build(1,1);
	T.build(1,1,n);
	scanf("%d",&amp;rt);
	while(m--){
		int op;scanf("%d",&amp;op);
		if(op==1)scanf("%d",&amp;rt);else
		if(op==2){
			int u,v,d;scanf("%d%d%d",&amp;u,&amp;v,&amp;d);
			Cov(u,v,d);
		}else
		if(op==3){
			int x;scanf("%d",&amp;x);
			printf("%d\n",Qmin(x));
		}
	}
	return 0;
}</pre><pre></pre><h2>Problem3083</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1e5+5;
int siz[maxn],son[maxn],top[maxn],fa[maxn],dep[maxn],mp[maxn],rmp[maxn],z;
int lef[maxn],rig[maxn],tot;
int rt,n,m,a[maxn];
vector&lt;int&gt;G[maxn];
struct sgt{
	struct node{
		int mn,lz;
		node(){mn=lz=0;}
		node(int mn,int lz):mn(mn),lz(lz){}
		node operator+(const node &amp;rs){return node(min(mn,rs.mn),0);}	
	}t[maxn&lt;&lt;2];
	#define lson i&lt;&lt;1,l,(l+r)/2
	#define rson i&lt;&lt;1|1,(l+r)/2+1,r
	#define ls i&lt;&lt;1
	#define rs i&lt;&lt;1|1
	void build(int i,int l,int r){
		if(l==r){t[i]=node(a[rmp[l]],0);return;}
		build(lson);build(rson);t[i]=t[ls]+t[rs];
	}
	void pd(int i){
		if(t[i].lz){
			t[ls].mn=t[ls].lz=t[rs].mn=t[rs].lz=t[i].lz;
			t[i].lz=0;
		}
	}
	void Cov(int i,int l,int r,int l0,int r0,int d){
		if(l0&gt;r0)swap(l0,r0);
		if(l0&lt;=l&amp;&amp;r0&gt;=r){
			t[i].mn=t[i].lz=d;
			return ;
		}pd(i);
		if(l0&lt;=(l+r)/2)Cov(lson,l0,r0,d);
		if(r0&gt;(l+r)/2)Cov(rson,l0,r0,d);
		t[i]=t[ls]+t[rs];
	}
	int Qmin(int i,int l,int r,int l0,int r0){
		if(l0&gt;r0)swap(l0,r0);
		if(l0&lt;=l&amp;&amp;r0&gt;=r)return t[i].mn;pd(i);
		int ans=INT_MAX;
		if(l0&lt;=(l+r)/2)ans=min(ans,Qmin(lson,l0,r0));
		if(r0&gt;(l+r)/2)ans=min(ans,Qmin(rson,l0,r0));
		return ans;
	}
}T;
void dfs(int u){
	siz[u]=1;
	for(int v,i=0;i&lt;G[u].size();i++){
		if((v=G[u][i])==fa[u])continue;
		fa[v]=u;dep[v]=dep[u]+1;
		dfs(v);	
		siz[u]+=siz[v];
		if(siz[son[u]]&lt;siz[v])son[u]=v;
	}
}
void build(int u,int tp){
	top[u]=tp;mp[u]=++z;lef[u]=++tot;rmp[z]=u;
	if(son[u])build(son[u],tp);
	for(int v,i=0;i&lt;G[u].size();i++)if((v=G[u][i])!=son[u]&amp;&amp;v!=fa[u])
	build(v,v);rig[u]=tot;
}
int lca(int u,int v){
	while(top[u]!=top[v]){
		if(dep[top[u]]&lt;dep[top[v]])swap(u,v);
		u=fa[top[u]];
	}return dep[u]&lt;dep[v]?u:v;
}
int dis(int u,int v){
	int ans=0;
	while(top[u]!=top[v]){
		if(dep[top[u]]&lt;dep[top[v]])swap(u,v);
		ans+=dep[u]-dep[top[u]]+1;
		u=fa[top[u]];
	}if(dep[u]&gt;dep[v])swap(u,v);
	return ans+dep[v]-dep[u];
}
void Cov(int u,int v,int d){
	while(top[u]!=top[v]){
		if(dep[top[u]]&lt;dep[top[v]])swap(u,v);
		T.Cov(1,1,n,mp[u],mp[top[u]],d);
		u=fa[top[u]];
	}if(mp[u]&gt;mp[v])swap(u,v);
	T.Cov(1,1,n,mp[u],mp[v],d);
}
int Qmin(int x){
	if(x==rt)return T.Qmin(1,1,n,1,n);
	int LCA=lca(x,rt);
	if(LCA!=x){
		return T.Qmin(1,1,n,lef[x],rig[x]);
	}else{
		int d=dis(x,rt);
		int u=rt;d--;
		while(dep[top[u]]&gt;dep[x]+1)d-=dep[u]-dep[top[u]]+1,u=fa[top[u]];
		u=rmp[mp[u]-d];
		int ans=INT_MAX;
		if(1&lt;=lef[u]-1)ans=min(ans,T.Qmin(1,1,n,1,lef[u]-1));
		if(rig[u]+1&lt;=n)ans=min(ans,T.Qmin(1,1,n,rig[u]+1,n));
		return ans;
	}
}
int main(){
	scanf("%d%d",&amp;n,&amp;m);
	for(int i=1;i&lt;n;i++){
		int u,v;scanf("%d%d",&amp;u,&amp;v);
		G[u].push_back(v);
		G[v].push_back(u);
	}for(int i=1;i&lt;=n;i++)scanf("%d",&amp;a[i]);
	dfs(1);build(1,1);
	T.build(1,1,n);
	scanf("%d",&amp;rt);
	while(m--){
		int op;scanf("%d",&amp;op);
		if(op==1)scanf("%d",&amp;rt);else
		if(op==2){
			int u,v,d;scanf("%d%d%d",&amp;u,&amp;v,&amp;d);
			Cov(u,v,d);
		}else
		if(op==3){
			int x;scanf("%d",&amp;x);
			printf("%d\n",Qmin(x));
		}
	}
	return 0;
}</pre><pre></pre><h2>Problem3091</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=50010;
typedef long long LL;
LL presum[maxn],presum2[maxn];
struct info{
	LL ans,psum,ssum,sum;
	LL siz;
	info(){ans=0;psum=0;ssum=0;sum=0;siz=0;}
	info(int val){ans=psum=ssum=sum=val;siz=1;}
	void deb(){
		printf("%lld %lld %lld %lld %lld ",ans,psum,ssum,sum,siz);
	}
};
info operator+(const info &amp;ls,const info &amp;rs){
	info I;
	I.siz=ls.siz+rs.siz;
	I.sum=ls.sum+rs.sum;
	I.psum=ls.psum+ls.siz*rs.sum+rs.psum;
	I.ssum=ls.ssum+rs.siz*ls.sum+rs.ssum;;
	I.ans=ls.ans+rs.ans+(ls.psum*rs.siz+rs.ssum*ls.siz);
	return I;
}
info operator+(LL d,const info &amp;rs){
	info I=rs;
	LL n=rs.siz;
	I.sum+=rs.siz*d;
	I.psum+=d*presum[n];
	I.ssum+=d*presum[n];
	I.ans+=d*presum2[n];
	return I;
}
struct node{
	info I;
	int add,rev,val;
	node *c[2],*f;
	node *rz(){
		I=info(val);
		if(c[0])I=c[0]-&gt;I+I;
		if(c[1])I=I+c[1]-&gt;I;
		return this;
	}
	void makerv(){
		rev^=1;
		swap(I.psum,I.ssum);
		swap(c[0],c[1]);
	}
	void pd(){
		if(rev){
			if(c[0])c[0]-&gt;makerv();
			if(c[1])c[1]-&gt;makerv();
			rev=0;
		}
		if(add){
			if(c[0])c[0]-&gt;add+=add,c[0]-&gt;val+=add,c[0]-&gt;I=add+c[0]-&gt;I;
			if(c[1])c[1]-&gt;add+=add,c[1]-&gt;val+=add,c[1]-&gt;I=add+c[1]-&gt;I;
			add=0;		
		}
	}
	bool d(){return this==f-&gt;c[1];}
	bool rt(){return !f||(f-&gt;c[0]!=this&amp;&amp;f-&gt;c[1]!=this);}
	void sets(node *x,int d){pd();if(x)x-&gt;f=this;c[d]=x;rz();}
}nd[maxn];
void rot(node *x){
	node *y=x-&gt;f;if(!y-&gt;rt())y-&gt;f-&gt;pd();
	y-&gt;pd();x-&gt;pd();bool d=x-&gt;d();
	y-&gt;sets(x-&gt;c[!d],d);
	if(!y-&gt;rt())y-&gt;f-&gt;sets(x,y-&gt;d());
	else x-&gt;f=y-&gt;f;
	x-&gt;sets(y,!d);
}
void splay(node *x){
	while(!x-&gt;rt()){
		if(x-&gt;f-&gt;rt())rot(x);
		else if(x-&gt;d()==x-&gt;f-&gt;d())rot(x-&gt;f),rot(x);
		else rot(x),rot(x);
	}
}
node *access(node *x){
	node *y=0;
	for(;x;x=x-&gt;f){
		splay(x);
		x-&gt;sets(y,1);
		y=x;
	}return y;
}
void makert(node *x){
	access(x)-&gt;makerv();
	splay(x);
}
bool connect(node *x,node *y){
	makert(x);
	access(y);
	splay(y);
	while(!x-&gt;rt())x=x-&gt;f;
	return x==y;	
}
node *findp(node *x){
	access(x);
	splay(x);
	x=x-&gt;c[0];
	while(x&amp;&amp;x-&gt;c[1])x=x-&gt;c[1];
	return x;	
}
void link(node *u,node *v){
	if(connect(u,v))return;
	makert(u);
//	splay(u);
	u-&gt;f=v;
	access(u);
}
void cut(node *u,node *v){
	makert(u);
	if(findp(v)!=u)return;
	access(v);splay(v);
	v-&gt;c[0]=u-&gt;f=0;v-&gt;rz();
}
node *expose(node *u,node *v){
	makert(u);
	access(v);
	splay(v);
	return v;
}
void Q(node *u,node *v){
	if(!connect(u,v))return (void)puts("-1");
	info I=expose(u,v)-&gt;I;
	LL son=I.ans;
	LL mom=presum[I.siz];
	LL d=__gcd(son,mom);
	son/=d;mom/=d;
	printf("%lld/%lld\n",son,mom);	
}
void A(node *u,node *v,int d){
	if(!connect(u,v))return ;
	node *w=expose(u,v);
	w-&gt;val+=d;
	w-&gt;add+=d;
	w-&gt;pd();
	w-&gt;rz();
}
int in(){
	int r=0;char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))r=r*10+c-'0',c=getchar();
	return r;
}
int n,m;
#define o(x) (x?x-nd:0)
void deb(){
	for(int i=1;i&lt;=n;i++){
		printf("id:%d c[0]:%d c[1]:%d f:%d rev:%d val:%d ",i,o(nd[i].c[0]),o(nd[i].c[1]),o(nd[i].f),nd[i].rev,nd[i].val);
		nd[i].I.deb();
		puts("");
	}puts("");
}
int main(){
	n=in();m=in();
	for(int i=1;i&lt;=n;i++)presum[i]=presum[i-1]+i;
	for(int i=1;i&lt;=n;i++)presum2[i]=presum2[i-1]+presum[i];
	for(int i=1;i&lt;=n;i++)nd[i].val=in(),nd[i].rz();
	for(int i=1;i&lt;n;i++){
		int u=in(),v=in();
		link(nd+u,nd+v);
	}
	while(m--){
		int ty=in();
		int u=in(),v=in();
		if(ty==1){
			cut(nd+u,nd+v);
		}else if(ty==2){
			link(nd+u,nd+v);
		}else if(ty==3){
			A(nd+u,nd+v,in());
		}else{
			Q(nd+u,nd+v);
		}
	}
	return 0;
}</pre><pre></pre><h2>Problem3093</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
int main(){
int n,p,q,T;
while(scanf("%d%d%d",&amp;n,&amp;p,&amp;q)==3){T++;
printf("Case %d: %.4lf\n",T,(double)(q+1)/(p+2));
}
return 0;
}</pre><pre></pre><h2>Problem3098</h2><pre>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
using namespace std;

const int MaxN = 100000;

int main()
{
	int n, l;
	static char s[MaxN + 1];

	n = MaxN, l = 13;
	for (int i = 0; i &lt; n; i++)
		s[i] = rand() % 26 + 'a';
	s[n] = '\0';

	cout &lt;&lt; n &lt;&lt; " " &lt;&lt; l &lt;&lt; endl;
	printf("%s\n", s);

	return 0;
}</pre><pre></pre><h2>Problem3100</h2><pre>#include&lt;cstdio&gt;
#define ll long long
#define inf 1000000000
int n,ans;
int next[1000002],last[1000002];
unsigned int a[1000002];
void cal(int x)
{
	int len=0,r=inf,i;
	for(i=x;i;i--)
	{
		if(a[i]-a[i-1]==1&amp;&amp;i!=x)break;
		if((int)(a[i]-a[i-1])&gt;len)len=(int)(a[i]-a[i-1]);
		if(next[i]&lt;r)r=next[i];
		if(i+len-1&lt;r&amp;&amp;i+len-1&lt;=n)
		{
			if(a[i+len-1]-a[i-1]==(ll)len*(len+1)/2&amp;&amp;len&gt;ans)ans=len;
		}
	}
}
void solve()
{
	int i;
	for(i=1;i&lt;=n;i++)last[i]=inf;
	for(i=n;i;i--)
	{
		next[i]=last[a[i]];
		last[a[i]]=i;
	}
	for(i=1;i&lt;=n;i++)a[i]+=a[i-1];
	for(i=1;i&lt;=n;i++)
		if(a[i]-a[i-1]==1)cal(i);
}
int main()
{
	scanf("%d",&amp;n);
	int i;
	for(i=1;i&lt;=n;i++)scanf("%d",&amp;a[i]);
	solve();
	for(i=n;i;i--)a[i]=a[i]-a[i-1];
	int t;
	for(i=1;i&lt;=n/2;i++)
	{
		t=a[i];a[i]=a[n-i+1];a[n-i+1]=t;
	}
	solve();
	printf("%d\n",ans);
	return 0;
}</pre><pre></pre><h2>Problem3105</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
int n;
int w[101],bs[32];
bool add(int x){
	for(int i=31;i&gt;=0;i--){
		if(x&gt;&gt;i&amp;1){
			if(!bs[i]){bs[i]=x;return 1;}
			else x^=bs[i];
		}
	}return 0;
}
int main(){
	cin&gt;&gt;n;long long ans=0;
	for(int i=1;i&lt;=n;i++)cin&gt;&gt;w[i];
	sort(w+1,w+1+n,greater&lt;int&gt;());
	for(int i=1;i&lt;=n;i++)if(add(w[i]))ans+=w[i];
	cout&lt;&lt;accumulate(w+1,w+1+n,0LL)-ans&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem3110</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cctype&gt;
using namespace std;
const int maxn=50005;
int n,m;
struct seg{
	struct node{
		int sum,lazy;
		node(){sum=lazy=0;}
	}t[maxn&lt;&lt;2];
	#define lson i&lt;&lt;1,l,mid
	#define rson i&lt;&lt;1|1,mid+1,r
	#define L i&lt;&lt;1
	#define R i&lt;&lt;1|1
	void rz(int i){
		t[i].sum=t[L].sum+t[R].sum;
	}
	void pushdown(int i,int l,int r){
		if(t[i].lazy){
			int mid=(l+r)&gt;&gt;1;
			t[L].lazy+=t[i].lazy;
			t[L].sum+=(mid-l+1)*t[i].lazy;			
			t[R].lazy+=t[i].lazy;
			t[R].sum+=(r-mid)*t[i].lazy;			
			t[i].lazy=0;
		}
	}
	void Add(int i,int l,int r,int l0,int r0,int d){
		if(l0&lt;=l&amp;&amp;r0&gt;=r){
			t[i].lazy+=d;
			t[i].sum+=(r-l+1)*d;
			return;
		}int mid=(l+r)&gt;&gt;1;
		pushdown(i,l,r);
		if(l0&lt;=mid)Add(lson,l0,r0,d);
		if(r0&gt;mid)Add(rson,l0,r0,d);rz(i);
	}
	int Qsum(int i,int l,int r,int l0,int r0){
		if(l0&lt;=l&amp;&amp;r0&gt;=r)return t[i].sum;
		pushdown(i,l,r);
		int mid=(l+r)&gt;&gt;1,ans=0;
		if(l0&lt;=mid)ans+=Qsum(lson,l0,r0);
		if(r0&gt;mid)ans+=Qsum(rson,l0,r0);
		return ans;
	}
	void Add(int l,int r,int d){
		Add(1,1,n,l,r,d);
	}
	int Qsum(int l,int r){
		return Qsum(1,1,n,l,r);
	}
	#undef lson
	#undef rson
	#undef L
	#undef R
}T,T2;
int getint(){
	int res=0,f=1;char c=getchar();
	while(!isdigit(c))f=f==-1||c=='-'?-1:1,c=getchar();
	while(isdigit(c))res=res*10+c-'0',c=getchar();
	return res*f;
}
struct qes{
	int x,y,z,ty,ind,cur,delta;
	qes(int _x=0,int _y=0,int _z=0,int _ty=0,int _ind=0,int _cur=0,int _delta=0):
		x(_x),y(_y),z(_z),ty(_ty),ind(_ind),cur(_cur),delta(_delta){}
}q[maxn];
int anss[maxn],mx,md;
bool part(qes &amp;Q){
	if(Q.ty==2){
		if(Q.cur+Q.delta&gt;Q.z-1)return 1;
		Q.cur+=Q.delta;Q.delta=0;return 0;
	}return Q.z&lt;=md;
}
void solve(int lef,int rig,int l,int r){
	if(lef&gt;rig)return;
	if(l==r){
		for(int i=lef;i&lt;=rig;i++)if(q[i].ty==2)
		anss[q[i].ind]=l;
		return;
	}int mid=(l+r)&gt;&gt;1;md=mid;
	for(int i=lef;i&lt;=rig;i++){
		if(q[i].ty==1&amp;&amp;q[i].z&lt;=mid)T.Add(q[i].x,q[i].y,1);
		if(q[i].ty==2)q[i].delta=T.Qsum(q[i].x,q[i].y);
	}for(int i=lef;i&lt;=rig;i++)
	if(q[i].ty==1&amp;&amp;q[i].z&lt;=mid)T.Add(q[i].x,q[i].y,-1);
	int dv=stable_partition(q+lef,q+rig+1,part)-q-1;
	solve(lef,dv,l,mid);
	solve(dv+1,rig,mid+1,r);
}
int main(){
	n=getint();m=getint();
	for(int i=1;i&lt;=m;i++){
		int op=getint(),l=getint(),r=getint(),c=getint();
		if(op==1)
			q[i]=qes(l,r,c,op),mx=max(mx,c),T2.Add(l,r,1);
		else q[i]=qes(l,r,T2.Qsum(l,r)-c+1,op,++anss[0]);			
	}
	solve(1,m,0,mx);
	for(int i=1;i&lt;=anss[0];i++)printf("%d\n",anss[i]);
	return 0;
}</pre><pre></pre><h2>Problem3112</h2><pre>#include &lt;list&gt;
#include &lt;cstdio&gt;
#include &lt;climits&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
const int INF=INT_MAX;
int a[1001][10010];
int n,m;
typedef list&lt;int&gt;::iterator iter;
void pivot(int l,int e){
	list&lt;int&gt;List;
	for(int i=0;i&lt;=m;i++)
		if(a[l][i])
			List.push_back(i);
	for(int i=0;i&lt;=n;i++){
		if(i==l||a[i][e]==0)continue;
		for(iter it=List.begin();it!=List.end();it++)
			if(*it!=e)
				a[i][*it]-=a[l][*it]*a[i][e];
		a[i][e]=-a[i][e];
	}
}
int simplex(){
	for(;;){
		int now=0;
		for(int i=1;i&lt;=m;i++)
			if(a[0][i]&gt;0){now=i;break;}
		if(now==0)return -a[0][0];
		int tmp,mi=INF;
		for(int i=1;i&lt;=n;i++){
			if(a[i][now]&gt;0&amp;&amp;a[i][0]&lt;mi){
				mi=a[i][0];
				tmp=i;
			}
		}
		pivot(tmp,now);
	}
}
int main(){
	cin&gt;&gt;n&gt;&gt;m;
	for(int i=1;i&lt;=n;i++)cin&gt;&gt;a[i][0];
	int l,r,d;
	for(int i=1;i&lt;=m;i++){
		cin&gt;&gt;l&gt;&gt;r&gt;&gt;d;
		a[0][i]=d;
		for(int j=l;j&lt;=r;j++)
			a[j][i]=1;
	}


	cout&lt;&lt;simplex()&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem3117</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cctype&gt;
#include&lt;queue&gt;
#include&lt;set&gt;
#include&lt;vector&gt;
#include&lt;list&gt;
using namespace std;
const int maxn=1e4+10;
int getint(){
	int res=0;
	char ch,ok=0;
	while(1){
		ch=getchar();
		if(isdigit(ch)){
			res*=10;res+=ch-'0';ok=1;
		}else if(ok)break;		
	}return res;
}
struct task{
	int t,m,p,f,ind;
	task(int _t=0,int _m=0,int _p=0,int _f=0,int _ind=0){
		t=_t,m=_m,p=_p,f=_f,ind=_ind;
	}
};
task tasks[maxn&lt;&lt;1];
int n,ans1,ans2,tot;
struct cmp{
	bool operator()(int a,int b){return tasks[a].t&gt;tasks[b].t||(tasks[a].t==tasks[b].t&amp;&amp;tasks[a].f&gt;tasks[b].f);}
};
priority_queue&lt;int,vector&lt;int&gt;,cmp&gt;que;
queue&lt;int&gt;q;
struct block{
	int l,r,ind,used;
	block(int _l=0,int _r=0,int _ind=0,int _used=0){
		l=_l,r=_r,ind=_ind,used=_used;
	}
};
list&lt;block&gt;List;
void deb(){
	for(list&lt;block&gt;::iterator it=List.begin();it!=List.end();it++)
	printf("l:%d r:%d ind:%d\t",it-&gt;l,it-&gt;r,it-&gt;ind);cout&lt;&lt;endl;
}
bool insert(int x){
	for(list&lt;block&gt;::iterator it=List.begin();it!=List.end();it++){
		if(!it-&gt;used&amp;&amp;(it-&gt;r-it-&gt;l+1&gt;=tasks[x].m)){
			list&lt;block&gt;::iterator i=List.insert(++it,block(it-&gt;l,it-&gt;l+tasks[x].m-1,x,1));
			it=--i;i++;
			if(it-&gt;l+tasks[x].m-1&lt;it-&gt;r)
			List.insert(++i,block(it-&gt;l+tasks[x].m,it-&gt;r,0,0));
			List.erase(it);
			return true;
		}
	}
	return false;
}
void erase(int x){
	if(List.size()==1){List.begin()-&gt;ind=0,List.begin()-&gt;used=0;return;}
	for(list&lt;block&gt;::iterator it=List.begin();it!=List.end();it++){
		if(it-&gt;ind==x){
			if(it==List.begin()){
				list&lt;block&gt;::iterator nxt=it;nxt++;
				if(!nxt-&gt;used){
					List.insert(++nxt,block(1,nxt-&gt;r,0,0));
					List.pop_front();List.pop_front();
				}else it-&gt;ind=0,it-&gt;used=0;
			}else
			if(it==--List.end()){
				list&lt;block&gt;::iterator pre=it;pre--;
				if(!pre-&gt;used){
					List.insert(pre,block(pre-&gt;l,n,0,0));
					List.pop_back();List.pop_back();
				}else it-&gt;ind=0,it-&gt;used=0;
			}else{
				list&lt;block&gt;::iterator pre=it;pre--;
				list&lt;block&gt;::iterator nxt=it;nxt++;
				if(!pre-&gt;used&amp;&amp;!nxt-&gt;used){
					list&lt;block&gt;::iterator i=List.insert(pre,block(pre-&gt;l,nxt-&gt;r,0,0));
					i++;
					i=List.erase(i);i=List.erase(i);i=List.erase(i);
				}else
				if(!pre-&gt;used){
					list&lt;block&gt;::iterator i=List.insert(pre,block(pre-&gt;l,it-&gt;r,0,0));
					i++;
					i=List.erase(i);i=List.erase(i);
				}else
				if(!nxt-&gt;used){
//					cout&lt;&lt;it-&gt;l&lt;&lt;" "&lt;&lt;nxt-&gt;r&lt;&lt;endl;
					list&lt;block&gt;::iterator i=List.insert(it,block(it-&gt;l,nxt-&gt;r,0,0));					
					i++;
					i=List.erase(i);i=List.erase(i);					
				}else it-&gt;ind=0,it-&gt;used=0;
			}break;
		}
	}
}
int main(){
	n=getint();List.push_back(block(1,n,0,0));
	while(++tot){
		tasks[tot].t=getint(),tasks[tot].m=getint(),tasks[tot].p=getint();
		if(tasks[tot].t==0&amp;&amp;tasks[tot].m==0){tot--;break;}
		tasks[tot].f=1;tasks[tot].ind=tot;
		que.push(tot);
	}	
	while(!que.empty()){
		int top=que.top(),tt=top;
		ans1=max(ans1,tasks[top].t);
//		cout&lt;&lt;tasks[top].t&lt;&lt;endl;
//		deb();
		if(tasks[top].f==1){
//			deb();	
que.pop();
			if(insert(top)){
				++tot;
				tasks[tot]=tasks[top];
				tasks[tot].t=tasks[top].t+tasks[tot].p;ans1=max(ans1,tasks[tot].t);
				tasks[tot].f=-1;
				que.push(tot);
			}else{
				q.push(top);
				ans2++;
			}		
//			deb();
		}else{
			bool jj=0;
//			deb();
			while(que.size()&gt;1){
				top=que.top();que.pop();
				int tp=que.top();
				if(tasks[top].f==-1){
				erase(tasks[top].ind);}
				else{
					que.push(tp);
					break;
				}
				if(tasks[top].f==-1&amp;&amp;tasks[tp].f==-1&amp;&amp;tasks[tp].t==tasks[top].t){
//					que.pop();
				}else {
					jj=1;break;
				}
			}if(!que.empty()&amp;&amp;!jj){
				top=que.top();
				if(tasks[top].f==-1){
				erase(tasks[top].ind),que.pop();}
			}
			if(q.size())
			while(insert(q.front())){
				++tot;
				tasks[tot]=tasks[q.front()];
				tasks[tot].t=tasks[tt].t+tasks[tot].p;ans1=max(ans1,tasks[tot].t);
				tasks[tot].f=-1;
				que.push(tot);
				q.pop();if(q.empty())break;				
			}
		}
//		deb();
	}
	cout&lt;&lt;ans1&lt;&lt;endl;
	cout&lt;&lt;ans2&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem3122</h2><pre>/*
	ID:zky
	OJ:BZOJ
	Index:3122
	Language:C++
*/
#include&lt;map&gt;
#include&lt;cmath&gt;
#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long lld;
lld x1,xn,a,b,p;

map&lt;lld,lld&gt;hash;
lld power(lld x,lld k,lld p){
	lld res=1;
	if(k==0)return 1;
	res=power(x,k/2,p)%p;
	res=(res%p)*(res%p)%p;
	if(k&amp;1)res=(res%p)*(x%p)%p;
	return res;
}
lld inv(lld x){
	return power(x,p-2,p);
}
void work3(){
	//xn=(a*x1+b)%p
	//==&gt;xn+b/(a-1)=a^(t-1)*(x1+b/(a-1)) mod p
	//==&gt;(xn+b*inv(a-1))*inv(x1+b*inv(a-1))=a^(t-1)mod p
	//==&gt;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	lld tmp=b*inv(a-1)%p;
	xn=(xn+tmp)%p;
	x1=(x1+tmp)%p;	
	lld N=xn*inv(x1)%p;
	
	a%=p;N%=p;
	if(!a&amp;&amp;!N){
		cout&lt;&lt;1&lt;&lt;endl;
		return;
	}
	if(!a){
		cout&lt;&lt;-1&lt;&lt;endl;
		return;
	}
	//a^(t-1)=N(mod p)
	//solve t!
	//k=t-1
	//k=im+j
	//for j=0 -&gt; m-1 in hash
	//a^im*a^j=N(mod p)
	//v=inv(a^m)=power(a,p-m-1,p)
	//a^j=N*v^i(mod p) for i,watch j in hash
	
	lld m=ceil(sqrt(p));
	lld v=power(a,p-m-1,p);
	lld ans=-1;
	hash[1]=m+1;
	lld e=a;
	for(int j=1;j&lt;=m;j++){
		if(!hash[e])hash[e]=j;
		e=(e%p*(a%p))%p;
	}
	for(int i=0;i&lt;m;i++){
		lld j=hash[N];
		if(j){			
			if(j==m+1)j=0;
			ans=i*m+j;
			break;
		}
		N=(N*v)%p;
	}
	hash.clear();
	if(ans==0){
		cout&lt;&lt;p&lt;&lt;endl;
		return;
	}
	if(ans==-1)
	cout&lt;&lt;ans&lt;&lt;endl;	
	else
	cout&lt;&lt;ans+1&lt;&lt;endl;
	
}
void exgcd(lld a,lld b,lld &amp;x,lld &amp;y){  
    if(b==0){  
        x=1;y=0;  
    }else{  
        exgcd(b,a%b,x,y);  
        int t=x;  
        x=y;  
        y=t-a/b*y;  
    }     
} 
lld gcd(lld a,lld b){
	if(!b)return a;return gcd(b,a%b);
}
void work2(){  
	lld n=xn-x1+b;	
    lld d=gcd(b,p);  
    if(n%d){  
        cout&lt;&lt;-1&lt;&lt;endl;  
        return;  
    }  
    lld r,s;  
    exgcd(b,p,r,s);  
    r=r*n/d;  
    r=(r+p)%p;  
    while(r&lt;=0)r+=p;  
    //while(r&lt;0)r+=p;  
    cout&lt;&lt;r&lt;&lt;endl;  
}  
void work(){  
	lld z=xn%p*inv(x1)%p;
	lld y=a;
    y%=p;z%=p;    
    if(!y&amp;&amp;!z){cout&lt;&lt;"1"&lt;&lt;endl;return;}  
    if(!y){cout&lt;&lt;"-1"&lt;&lt;endl;return;}  
    lld m=ceil(sqrt(p));  
    lld v=power(y,p-m-1,p); 
    lld e=1;  
    hash[1]=m+1;  
    for(lld i=1;i&lt;=m;i++){  
        e=(e*y)%p;  
        if(!hash[e])hash[e]=i;  
    }  
    lld ans=-1;  
    for(lld i=0;i&lt;m;i++){  
        lld j=hash[z];  
        if(j){  
            if(j==m+1)j=0;  
            ans=i*m+j;    
            break;  
        }  
        z=(z*v)%p;//  
    }  
    hash.clear();   
	if(ans==0){
		cout&lt;&lt;p&lt;&lt;endl;
		return;
	}
    if(ans==-1)cout&lt;&lt;"-1"&lt;&lt;endl;  
    else cout&lt;&lt;ans+1&lt;&lt;endl;  

}
int main(){
	lld T;
	cin&gt;&gt;T;
	while(T--){
		cin&gt;&gt;p&gt;&gt;a&gt;&gt;b&gt;&gt;x1&gt;&gt;xn;
		if(x1==xn){
			cout&lt;&lt;1&lt;&lt;endl;
			continue;
		}
    	if(a==0&amp;&amp;b==0){
    		cout&lt;&lt;-1&lt;&lt;endl;
    		continue;
    	}else 
    	if(a==0){
    		if(xn%p==x1%p)cout&lt;&lt;1&lt;&lt;endl;
    		else if(xn==b)cout&lt;&lt;2&lt;&lt;endl;
    		else cout&lt;&lt;-1&lt;&lt;endl;
    		continue;
    	}else
    	if(a==1&amp;&amp;b==0){
    		if(x1==xn)cout&lt;&lt;1&lt;&lt;endl;
    		else cout&lt;&lt;-1&lt;&lt;endl;
    		continue;
    	}else
    	if(a==1){
    		work2();
    		continue;
    	}else if(b==0){
    		work();
    	}
		else work3();
	}
	return 0;
}</pre><pre></pre><h2>Problem3123</h2><pre>#include&lt;bits/stdc++.h&gt;
#define mp(x) (lower_bound(w+1,w+1+w[0],x)-w)
#define c(x,d) (x?x-&gt;c[d]:0)
using namespace std;
const int maxn=8e4+5;
const int BIT=18;
int fa[maxn][BIT],dep[maxn];
int n,m,q,a[maxn],w[maxn&lt;&lt;1],lans;
vector&lt;int&gt;G[maxn];
struct node{
	int size;
	node *c[2];
	node *rz(){
		size=(c[0]?c[0]-&gt;size:0)+(c[1]?c[1]-&gt;size:0);
		return this;
	}
	node(){size=0;c[0]=c[1]=0;}
}*root[maxn];
queue&lt;node*&gt;qnode;
node *newnode(){
	return new node();
}
node *insert(node *x,int l,int r,int val){
	node *y=newnode();
	if(x)*y=*x,y-&gt;size++;
	else y-&gt;size=1;
	if(l==r)return y;
	int mid=(l+r)&gt;&gt;1;
	if(val&lt;=mid)
		y-&gt;c[0]=insert(c(x,0),l,mid,val);	
	else y-&gt;c[1]=insert(c(x,1),mid+1,r,val);
	return y-&gt;rz();
}
int size(node *x,node *y,node *z,node *w){
	return (x&amp;&amp;x-&gt;c[0]?x-&gt;c[0]-&gt;size:0)+(y&amp;&amp;y-&gt;c[0]?y-&gt;c[0]-&gt;size:0)-(z&amp;&amp;z-&gt;c[0]?z-&gt;c[0]-&gt;size:0)-(w&amp;&amp;w-&gt;c[0]?w-&gt;c[0]-&gt;size:0);
}
int Q(node *x,node *y,node *z,node *w,int l,int r,int k){
	if(l==r)return l;
	int mid=(l+r)&gt;&gt;1;
	int siz=size(x,y,z,w);
	if(siz&gt;=k)return Q(c(x,0),c(y,0),c(z,0),c(w,0),l,mid,k);
	else return Q(c(x,1),c(y,1),c(z,1),c(w,1),mid+1,r,k-siz);
}
int lca(int u,int v){
	if(dep[u]&lt;dep[v])swap(u,v);
	for(int i=BIT-1;i&gt;=0;i--)if(dep[u]-(1&lt;&lt;i)&gt;=dep[v])u=fa[u][i];
	if(u!=v){
		for(int i=BIT-1;i&gt;=0;i--)if(fa[u][i]!=fa[v][i])
		u=fa[u][i],v=fa[v][i];
		u=fa[u][0];v=fa[v][0];
	}return u;
}
struct ufset{
	int fa[maxn],siz[maxn];
	void init(){for(int i=1;i&lt;=n;i++)fa[i]=i,siz[i]=1;}
	int find(int x){return fa[x]==x?x:find(fa[x]);}
	int size(int x){return siz[find(x)];}
	void merge(int x,int y){
		x=find(x);y=find(y);
		if(x==y)return;
		siz[x]+=siz[y];
		fa[y]=x;
	}
}S;
int vis[maxn],rt[maxn];
void dfs(int u){
	root[u]=insert(root[fa[u][0]],1,w[0],mp(a[u]));
	memset(fa[u]+1,0,sizeof (fa[u]+1));
	for(int i=1;i&lt;BIT;i++)fa[u][i]=fa[fa[u][i-1]][i-1];
	for(int v,i=0;i&lt;G[u].size();i++){
		if((v=G[u][i])!=fa[u][0]){
			fa[v][0]=u;dep[v]=dep[u]+1;
			vis[v]=1;rt[v]=rt[u];dfs(v);
			S.merge(rt[u],v);			
		}
	}
}
void clear(node *x){
	if(!x)return;
	if(x-&gt;c[0])clear(x-&gt;c[0]);
	if(x-&gt;c[1])clear(x-&gt;c[1]);
	qnode.push(x);
}
void clear(int u){
	for(int v,i=0;i&lt;G[u].size();i++){
		if((v=G[u][i])!=fa[u][0]){
			clear(v);			
		}
	}//clear(root[u]);
	root[u]=0;
}
void L(int x,int y){
	if(S.size(x)&lt;S.size(y))swap(x,y);
	clear(rt[y]);
	fa[y][0]=x;rt[y]=rt[x];S.merge(x,y);dep[y]=dep[x]+1;
	G[x].push_back(y);
	G[y].push_back(x);
	dfs(y);
}
int main(){
	scanf("%*d%d%d%d",&amp;n,&amp;m,&amp;q);S.init();
	for(int i=1;i&lt;=n;i++)scanf("%d",&amp;a[i]),w[++w[0]]=a[i];
	for(int i=1;i&lt;=m;i++){
		int u,v;scanf("%d%d",&amp;u,&amp;v);
		G[u].push_back(v);
		G[v].push_back(u);
	}sort(w+1,w+1+w[0]);
	w[0]=unique(w+1,w+1+w[0])-w-1;
	for(int i=n;i&gt;=1;i--){
		if(!vis[i]){
			rt[i]=i;
			vis[i]=1;
			dfs(i);
		}
	}
	while(q--){
		char op=getchar();while(!isalpha(op))op=getchar();
		if(op=='Q'){
			int x,y,k;scanf("%d%d%d",&amp;x,&amp;y,&amp;k);
			x^=lans;y^=lans;k^=lans;
			printf("%d\n",lans=w[Q(root[x],root[y],root[fa[lca(x,y)][0]],root[lca(x,y)],1,w[0],k)]);
		}else{
			int x,y;scanf("%d%d",&amp;x,&amp;y);
			x^=lans;y^=lans;
			L(x,y);
		}
		
		
//		lans=0;
		
		
	}
	return 0;
}</pre><pre></pre><h2>Problem3124</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#define m_p make_pair
using namespace std;
const int maxn=2e5+5;
typedef long long LL;
vector&lt;pair&lt;int,int&gt; &gt;G[maxn];
int n,vis[maxn],pre[maxn],ans;
LL d[maxn],cur;
int flag,W[maxn];
void dfs(int u,int fa){
	for(int i=0;i&lt;G[u].size();i++){
		int v=G[u][i].first,w=G[u][i].second;
		if(v==fa||vis[v])continue;
		d[v]=d[u]+w;pre[v]=u;vis[v]=flag;W[v]=w;
		if(d[v]&gt;d[ans])ans=v;
		dfs(v,u);
	}
}
int main(){
	scanf("%d",&amp;n);
	for(int i=1;i&lt;n;i++){
		int u,v,w;scanf("%d%d%d",&amp;u,&amp;v,&amp;w);
		G[u].push_back(m_p(v,w));
		G[v].push_back(m_p(u,w));
	}dfs(1,0);int A=ans;
	d[A]=ans=0;dfs(A,0);int B=ans;
	for(int i=B;i!=A;i=pre[i])vis[i]=1;vis[A]=1;
	LL len=d[ans],L=0;
	cout&lt;&lt;len&lt;&lt;endl;
	int res,f=1;
	for(;B!=A;){
		L+=W[B];
		B=pre[B];
		d[B]=ans=0;
		dfs(B,0);
		if(d[ans]==L&amp;&amp;f)res=0;//,f=0;
		else res++;
		if(d[ans]==len-L)break;		
	}cout&lt;&lt;res&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem3130</h2><pre>#include&lt;vector&gt;
#include&lt;queue&gt; 
#include&lt;iomanip&gt;
#include&lt;cstdio&gt;
#include&lt;climits&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
#define read(x) scanf("%d",&amp;x)
using namespace std;
int n,m,p;
const int INF=INT_MAX;
struct edge{
	int u,v;
	double cap,flow;
	edge(int _u,int _v,double _cap):
		u(_u),v(_v),cap(_cap){flow=0;}
};
vector&lt;edge&gt;edges;
vector&lt;vector&lt;int&gt; &gt;G;
void add(int u,int v,double cap){
	edges.push_back(edge(u,v,cap));
	G[u].push_back(edges.size()-1);
}
int d[101];
int vis[101];
int cur[101];
double l=0,r=0,mid=INT_MAX,maxx;
bool bfs(){
	memset(vis,0,sizeof(vis));
	queue&lt;int&gt;q;
	q.push(1);
	d[1]=0;
	vis[1]=1;
	while(!q.empty()){
		int u=q.front();q.pop();
		for(int i=0;i&lt;G[u].size();i++){
			edge &amp;e=edges[G[u][i]];
			if(min(mid,e.cap)&gt;e.flow&amp;&amp;!vis[e.v]){
				d[e.v]=d[u]+1;
				vis[e.v]=1;	
				q.push(e.v);
			}
		}
	}
	return vis[n];
}
const double eps=1e-6;
double dfs(int x,double a){
	if(x==n||fabs(a)&lt;eps)return a;
	double flow=0,f;
	for(int &amp;i=cur[x];i&lt;G[x].size();i++){
		edge &amp;e=edges[G[x][i]];
		if(d[e.v]==d[x]+1&amp;&amp;(f=dfs(e.v,min(a,min(mid,e.cap)-e.flow)))&gt;0){
			e.flow+=f;
			edges[G[x][i]^1].flow-=f;
			flow+=f;
			a-=f;
			if(a==0)break;
		}
	}
	return flow;
}
double Dinic(){
	double flow=0;
	while(bfs()){
		double x=0;
		memset(cur,0,sizeof(cur));
		while(x=dfs(1,INF)){
			flow+=x;
			memset(cur,0,sizeof(cur));
		}
	}
	return flow;
}

bool ok(){
	for(int i=0;i&lt;edges.size();i++)
	edges[i].flow=0;
	if(fabs(Dinic()-maxx)&lt;eps)return true;
	return false;
}
int main(){
	read(n);read(m);read(p);
	G.resize(n+10);
	while(m--){
		int u,v,cap;
		read(u);read(v);read(cap);
		add(u,v,cap);
		add(v,u,0);
		r=max(r,(double)cap);
	}
	r++;
	maxx=Dinic();
	cout&lt;&lt;fixed&lt;&lt;setprecision(0)&lt;&lt;maxx&lt;&lt;endl;
	while(fabs(l-r)&gt;eps){
		mid=(l+r)/2.0;
		if(ok())
			r=mid;
		else
		 	l=mid;
	}

	cout&lt;&lt;fixed&lt;&lt;setprecision(4)&lt;&lt;(double)p*l&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem3143</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;cmath&gt;
#include&lt;iomanip&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=1010;
vector&lt;int&gt;G[maxn];
int n,m,tot;
void add(int u,int v){G[u].push_back(v);G[v].push_back(u);}
double a[maxn][maxn];
double f[maxn],ans,w[maxn*maxn];
int edge[maxn*maxn][2];
void MakeMatrix(){
	
	for(int i=0;i&lt;n-1;i++){
		a[i][i]=1;
		for(int j=0;j&lt;G[i+1].size();j++){
			int v=G[i+1][j]-1;
			if(v==n-1)continue;
			a[i][v]-=1.0/G[v+1].size();
		}	
	}n--;a[0][n]=1;
}
void Gauss(){
	for(int i=0;i&lt;n;i++){
		int r=i;
		for(int j=i+1;j&lt;n;j++)
			if(fabs(a[j][i])&gt;fabs(a[r][i]))r=j;
		if(r!=i)for(int j=0;j&lt;=n;j++)swap(a[i][j],a[r][j]); 
		for(int k=i+1;k&lt;n;k++){
			double f=a[k][i]/a[i][i];
			for(int j=i;j&lt;=n;j++)a[k][j]-=f*a[i][j];
		} 
	}
	for(int i=n-1;i&gt;=0;i--){
		for(int j=i+1;j&lt;n;j++)
			a[i][n]-=a[j][n]*a[i][j];
		a[i][n]/=a[i][i];		
	}//n++;
}
void out(){
	for(int i=1;i&lt;=n;i++)f[i]=a[i-1][n];//f[n+1]=1;
	n++;
	for(int i=1;i&lt;=tot;i++){
		int u=edge[i][0],v=edge[i][1];
		w[i]=f[u]/(double)G[u].size()+f[v]/(double)G[v].size();
	}
	sort(w+1,w+tot+1,greater&lt;double&gt;());
	for(int i=1;i&lt;=tot;i++){
		ans+=i*w[i];
	}cout&lt;&lt;fixed&lt;&lt;setprecision(3)&lt;&lt;ans&lt;&lt;endl;
}
void deb(){
	for(int i=0;i&lt;n;i++)
	for(int j=0;j&lt;=n;j++)
		printf("%.1f%c",a[i][j]," \n"[j==n]);
	puts("");
}
int main(){
	scanf("%d%d",&amp;n,&amp;m);
	for(int i=1;i&lt;=m;i++){int u,v;scanf("%d%d",&amp;u,&amp;v);add(u,v);edge[++tot][0]=u;edge[tot][1]=v;}
	MakeMatrix();
	//deb();
	Gauss();
	//deb();
	out();
	return 0;
}</pre><pre></pre><h2>Problem3153</h2><pre>#include&lt;bits/stdc++.h&gt;
#define rep(i,a,n) for(int i=a;i&lt;n;i++)
using namespace std;
const int maxn=1e5+1000;
int getint(){
    int res=0,f=1;char c=getchar();
    while(!isdigit(c))f=f==-1||c=='-'?-1:1,c=getchar();
    while(isdigit(c))res=res*10+c-'0',c=getchar();
    return res*f;
}
int n,m;
struct info{
    int mx,mn,sum,sz;
    info(){}
    info(int mx,int mn,int sum,int sz):
        mx(mx),mn(mn),sum(sum),sz(sz){}
    void deb(){printf("sum:%d size:%d",(int)sum,sz);}
};
struct flag{
    int mul,add;
    flag(){mul=1;}
    flag(int mul,int add):
        mul(mul),add(add){}
    bool empty(){return mul==1&amp;&amp;add==0;}
};
info operator+(const info &amp;a,const flag &amp;b) {
    return a.sz?info(a.mx*b.mul+b.add,a.mn*b.mul+b.add,a.sum*b.mul+b.add*a.sz,a.sz):a;
}
info operator+(const info &amp;a,const info &amp;b) {
    return info(max(a.mx,b.mx),min(a.mn,b.mn),a.sum+b.sum,a.sz+b.sz);
}
flag operator+(const flag &amp;a,const flag &amp;b) {
    return flag(a.mul*b.mul,a.add*b.mul+b.add);
}
struct node{
    node *c[4],*f;
    flag Cha,All;
    info cha,sub,all;
    bool rev,inr;
    int val;
    void makerev(){rev^=1;swap(c[0],c[1]);}
    void makec(const flag &amp;a){
        Cha=Cha+a;cha=cha+a;val=val*a.mul+a.add;
        all=cha+sub;
    }
    void makes(const flag &amp;a,bool _=1){
        All=All+a;all=all+a;sub=sub+a;
        if(_)makec(a);
    }
    void rz(){
        cha=all=sub=info(-(1&lt;&lt;30),1&lt;&lt;30,0,0);
        if(!inr)all=cha=info(val,val,val,1);
        rep(i,0,2)if(c[i])cha=cha+c[i]-&gt;cha,sub=sub+c[i]-&gt;sub;
        rep(i,0,4)if(c[i])all=all+c[i]-&gt;all;
        rep(i,2,4)if(c[i])sub=sub+c[i]-&gt;all;
    }
    void pd(){
        if(rev){
            if(c[0])c[0]-&gt;makerev();
            if(c[1])c[1]-&gt;makerev();
            rev=0;
        }
        if(!All.empty()){
            rep(i,0,4)if(c[i])c[i]-&gt;makes(All,i&gt;=2);
            All=flag(1,0);
        }        
        if(!Cha.empty()){
            rep(i,0,2)if(c[i])c[i]-&gt;makec(Cha);
            Cha=flag(1,0);
        }
 
    }
    node *C(int i){if(c[i])c[i]-&gt;pd();return c[i];}
    bool d(int ty){return f-&gt;c[ty+1]==this;}
    int D(){rep(i,0,4)if(f-&gt;c[i]==this)return i;}
    void sets(node *x,int d){if(x)x-&gt;f=this;c[d]=x;}
    bool rt(int ty){
        if(ty==0)return !f||(f-&gt;c[0]!=this&amp;&amp;f-&gt;c[1]!=this);
        else return !f||!f-&gt;inr||!inr;
    }
}nd[maxn*2],*cur=nd+maxn,*pool[maxn],**Cur=pool;
int _cnt;
node *newnode(){
    _cnt++;
    node *x=(Cur==pool)?cur++:*(--Cur);
    rep(i,0,4)x-&gt;c[i]=0;x-&gt;f=0;
    x-&gt;All=x-&gt;Cha=flag(1,0);
    x-&gt;all=x-&gt;cha=info(-(1&lt;&lt;30),(1&lt;&lt;30),0,0);
    x-&gt;inr=1;x-&gt;rev=0;x-&gt;val=0;
    return x;   
}
void dele(node *x){*(Cur++)=x;}
void rot(node *x,int ty){
    node *p=x-&gt;f;int d=x-&gt;d(ty);
    if(!p-&gt;f)x-&gt;f=0;else p-&gt;f-&gt;sets(x,p-&gt;D());
    p-&gt;sets(x-&gt;c[!d+ty],d+ty);x-&gt;sets(p,!d+ty);p-&gt;rz();
}
void splay(node *x,int ty=0){
    while(!x-&gt;rt(ty)){
        if(x-&gt;f-&gt;rt(ty))rot(x,ty);
        else if(x-&gt;d(ty)==x-&gt;f-&gt;d(ty))rot(x-&gt;f,ty),rot(x,ty);
        else rot(x,ty),rot(x,ty);
    }x-&gt;rz();
}
void add(node *u,node *w){
    w-&gt;pd();
    rep(i,2,4)if(!w-&gt;c[i]){w-&gt;sets(u,i);return;}
    node *x=newnode(),*v;
    for(v=w;v-&gt;c[2]-&gt;inr;v=v-&gt;C(2));
    x-&gt;sets(v-&gt;c[2],2);x-&gt;sets(u,3);
    v-&gt;sets(x,2);splay(x,2); 
}
void del(node *w){
    if(w-&gt;f-&gt;inr){
        w-&gt;f-&gt;f-&gt;sets(w-&gt;f-&gt;c[5-w-&gt;D()],w-&gt;f-&gt;D());
        dele(w-&gt;f);splay(w-&gt;f-&gt;f,2);
    }else w-&gt;f-&gt;sets(0,w-&gt;D());
    w-&gt;f=0;
}
void access(node *w){
    static node *sta[maxn];
    static int top=0;
    node *v=w,*u;
    for(u=w;u;u=u-&gt;f)sta[top++]=u;
    while(top)sta[--top]-&gt;pd();
    splay(w);
    if(w-&gt;c[1])u=w-&gt;c[1],w-&gt;c[1]=0,add(u,w),w-&gt;rz();
    while(w-&gt;f){
        for(u=w-&gt;f;u-&gt;inr;u=u-&gt;f);
        splay(u);
        if(u-&gt;c[1])w-&gt;f-&gt;sets(u-&gt;c[1],w-&gt;D()),splay(w-&gt;f,2);
        else del(w);
        u-&gt;sets(w,1);
        (w=u)-&gt;rz();
    }splay(v);
}
void makert(node *x){
    access(x);x-&gt;makerev();
}
node *findp(node *u){
    access(u);u=u-&gt;C(0);
    while(u&amp;&amp;u-&gt;c[1])u=u-&gt;C(1);
    return u;
}
node *findr(node *u){for(;u-&gt;f;u=u-&gt;f);return u;}
node* cut(node *u){
    node *v=findp(u);
    if(v)access(v),del(u),v-&gt;rz();
    return v;
}
void link(node *u,node *v) {
    node* p=cut(u);
    if(findr(u)!=findr(v))p=v;
    if(p)access(p),add(u,p),p-&gt;rz();
}
int main(){
//  freopen("bzoj3153.in","r",stdin);
    n=getint();m=getint();
    static int _u[maxn],_v[maxn];
    rep(i,1,n)_u[i]=getint(),_v[i]=getint();
    rep(i,1,n+1){
        nd[i].val=getint();
        nd[i].rz();
    }
    rep(i,1,n)makert(nd+_u[i]),link(nd+_u[i],nd+_v[i]);
    int root=getint();
    makert(nd+root);
//  deb();
    int x,y,z;
    node *u,*v;
    while(m--){
        int k=getint();x=getint();
        u=nd+x;
        if(k==0||k==3||k==4||k==5||k==11){
            access(u);
            if(k==3||k==4||k==11){
                int ans=u-&gt;val;
                rep(i,2,4)if(u-&gt;c[i]){
                    info res=u-&gt;c[i]-&gt;all;                    
                    if(k==3) ans=min(ans,res.mn);
                    else if(k==4) ans=max(ans,res.mx);
                    else if(k==11) ans+=res.sum;
                }printf("%d\n",ans);
            }else{
                y=getint();
                flag fg(k==5,y);
                u-&gt;val=u-&gt;val*fg.mul+fg.add;
                rep(i,2,4)if(u-&gt;c[i])u-&gt;c[i]-&gt;makes(fg);
                u-&gt;rz();
            }           
        }else if(k==2||k==6||k==7||k==8||k==10){
            y=getint();
            makert(u),access(nd+y),splay(u);
            if (k==7||k==8||k==10) {
                info ans=u-&gt;cha;
                if (k==7) printf("%d\n",ans.mn);
                else if (k==8) printf("%d\n",ans.mx);
                else printf("%d\n",ans.sum);
            }else u-&gt;makec(flag(k==6,getint())); 
            makert(nd+root);        
        }else if(k==9)link(u,nd+getint());
        else if(k==1)makert(u),root=x;  
    }
    return 0;
}</pre><pre></pre><h2>Problem3155</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1e5+1;
typedef long long LL;
int lowbit(int x){
	return x&amp;-x;
}
int getint(){
	int res=0;char ch=getchar();
	while(!isdigit(ch))ch=getchar();
	while(isdigit(ch))(res*=10)+=ch-'0',ch=getchar();
	return res;
}
int n,m;
LL a[maxn];
struct BIT{
	LL d[maxn];
	BIT(){
		memset(d,0,sizeof(d));
	}
	LL get(int pos){
		LL ans=0;
		for(int j=pos;j;j-=lowbit(j))
			ans+=d[j];
		return ans;
	}
	void updata(int pos,LL val){
		for(int j=pos;j&lt;=n;j+=lowbit(j))
			d[j]+=val;
	}
}T[2];
void putint(LL x){
	if(x&lt;10)
		putchar(x+'0');
	else{
		putint(x/10);
		putchar(x%10+'0');
	}
}
int main(){
	n=getint();m=getint();
	int x;
	for(int i=1;i&lt;=n;i++){
		T[0].updata(i,a[i]=getint());
		T[1].updata(i,a[i]*(n-i+1));
	}
	while(m--){
		char ch=getchar();
		char op[8];scanf("%s",op);
		if(op[0]=='Q'){
			int x=getint();
			putint(T[1].get(x)-T[0].get(x)*(n-x));
			puts("");
		}else{			
			int pos=getint(),val=getint();
			T[0].updata(pos,val-a[pos]);
			T[1].updata(pos,(val-a[pos])*(n-pos+1));
			a[pos]=val;
		}
	}	
	
	return 0;
}</pre><pre></pre><h2>Problem3156</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
const int maxn=1e6+5;
struct point{
	LL x,y;
	point(LL _x=0,LL _y=0):x(_x),y(_y){}
	LL operator*(point oth)const{return x*oth.y-y*oth.x;}
	LL operator^(point oth)const{return x*oth.x+y*oth.y;}
	point operator-(point oth)const{return point(x-oth.x,y-oth.y);}
};
LL n,a[maxn];
LL f[maxn];
LL getint(){
	LL res=0;char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))res=res*10+c-'0',c=getchar();
	return res;
}
struct CH{
	point ch[maxn];
	int m;
	CH():m(0){}
	void push_back(point p){
		while(m&gt;1&amp;&amp;(ch[m-1]-ch[m-2])*(p-ch[m-1])&lt;=0)m--;
		ch[m++]=p;
	}
	LL Qmin(point p){
		int l=0,r=m-1;
		while(r-l&gt;2){
			int mid1=l+(r-l)/3;
			int mid2=r-(r-l)/3;
			if((p^ch[mid1])&lt;(p^ch[mid2]))
				r=mid2;
			else l=mid1;
		}LL ans=1LL&lt;&lt;61;
		for(int i=l;i&lt;=r;i++)ans=min(ans,p^ch[i]);
		return ans;
	}
}C;
int main(){
	n=getint();
	for(LL i=1;i&lt;=n;i++)a[i]=getint();
	reverse(a+1,a+1+n);n++;
	f[1]=a[1];C.push_back(point(1,f[1]+1));
	for(LL i=2;i&lt;=n;i++){
		f[i]=1LL&lt;&lt;61;
		f[i]=C.Qmin(point(-i,1))+(LL)a[i]+(LL)((LL)i*i-i)/2;
		C.push_back(point(i,f[i]+(LL)(i*i+i)/2));	
	}cout&lt;&lt;min(f[n],f[n-1])&lt;&lt;endl;	
	return 0;
}</pre><pre></pre><h2>Problem3158</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1010;
int n;
int a[maxn];
struct edge{  
    int u,v,cap,flow;     
    edge(int _u=0,int _v=0,int _cap=0,int _flow=0):  
        u(_u),v(_v),cap(_cap),flow(_flow){}  
};  
vector&lt;edge&gt;edges;  
vector&lt;int&gt;G[maxn];  
int cur[maxn],vis[maxn];  
void add(int u,int v,int cap){  
    edges.push_back(edge(u,v,cap,0));  
    G[u].push_back(edges.size()-1);  
    edges.push_back(edge(v,u,0,0));   
    G[v].push_back(edges.size()-1);   
}  
int d[maxn],s,t;  
bool bfs(){  
    memset(vis,0,sizeof(vis));  
    queue&lt;int&gt;q;  
    q.push(s);vis[s]=1;  
    while(!q.empty()){  
        int u=q.front();q.pop();  
        for(int i=0;i&lt;G[u].size();i++){  
            edge e=edges[G[u][i]];  
            if(e.cap&gt;e.flow&amp;&amp;!vis[e.v]){  
                d[e.v]=d[u]+1;  
                vis[e.v]=1;  
                q.push(e.v);  
            }  
        }  
    }return vis[t];  
}  
int dfs(int u,int a){  
    int flow=0,f;  
    if(u==t||!a)return a;  
    for(int &amp;i=cur[u];i&lt;G[u].size();i++){  
        edge e=edges[G[u][i]];  
        if(d[e.v]==d[u]+1&amp;&amp;(f=dfs(e.v,min(a,e.cap-e.flow)))&gt;0){  
            edges[G[u][i]].flow+=f;  
            edges[G[u][i]^1].flow-=f;  
            flow+=f;a-=f;  
            if(!a)break;  
        }  
    }return flow;  
}  
int Dinic(){  
    int flow=0;  
    while(bfs()){  
        int x=0;  
        do{  
            flow+=x;  
            memset(cur,0,sizeof(cur));  
        }while(x=dfs(s,INT_MAX));  
    }return flow;  
}  
bool can(int a,int b){
	typedef long long LL;
	LL c=sqrt((LL)a*a+(LL)b*b);
	return !((LL)a*a+(LL)b*b==c*c&amp;&amp;__gcd(a,b)==1);
}
int b[maxn];
int main(){
	scanf("%d",&amp;n);
	for(int i=1;i&lt;=n;i++)scanf("%d",&amp;b[i]);
	for(int i=1;i&lt;=n;i++)scanf("%d",&amp;a[i]);
	s=0;t=n+1;
	for(int i=1;i&lt;=n;i++)if(b[i]%2)add(s,i,a[i]);
	for(int i=1;i&lt;=n;i++)if(b[i]%2==0)add(i,t,a[i]);
	for(int i=1;i&lt;=n;i++)for(int j=1;j&lt;=n;j++)if(b[i]%2&amp;&amp;b[j]%2==0)if(!can(b[i],b[j]))
	add(i,j,INT_MAX);
	cout&lt;&lt;accumulate(a+1,a+1+n,0)-Dinic()&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem3165</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=40001;
int n=39989,m,ind;
struct seg{
	double k,b;
	int id;
	seg(int x0=0,int y0=0,int x1=0,int y1=0,int _id=0){
		id=_id;
		if(x0==x1){k=0;b=max(y0,y1);}
		else{k=(double)(y0-y1)/(x0-x1);b=y0-k*x0;}
	}
	double get(double x){return k*x+b;}
};
bool les(seg A,seg B,double x){
	if(!A.id)return 1;
	return A.get(x)!=B.get(x)?A.get(x)&lt;B.get(x):A.id&lt;B.id;
}
struct sgt{
	seg t[maxn&lt;&lt;2];
	seg Qmax(int i,int l,int r,int ps){
		if(l==r)return t[i];seg tmp;
		if(ps&lt;=(l+r)/2)tmp=Qmax(i&lt;&lt;1,l,(l+r)/2,ps);
		else tmp=Qmax(i&lt;&lt;1|1,(l+r)/2+1,r,ps);
		return les(t[i],tmp,ps)?tmp:t[i];
	}
	void insert(int i,int l,int r,seg se){
		if(!t[i].id)t[i]=se;
		if(les(t[i],se,l))swap(t[i],se);
		if(l==r||t[i].k==se.k)return;
		double x=(t[i].b-se.b)/(se.k-t[i].k);
		if(x&lt;l||x&gt;r)return;
		if(x&lt;=(l+r)/2)insert(i&lt;&lt;1,l,(l+r)/2,t[i]),t[i]=se;
		else insert(i&lt;&lt;1|1,(l+r)/2+1,r,se);
	}
	void insert(int i,int l,int r,int l0,int r0,seg se){
		if(l0&lt;=l&amp;&amp;r0&gt;=r){insert(i,l,r,se);return;}
		if(l0&lt;=(l+r)/2)insert(i&lt;&lt;1,l,(l+r)/2,l0,r0,se);
		if(r0&gt;(l+r)/2)insert(i&lt;&lt;1|1,(l+r)/2+1,r,l0,r0,se);
	}	
}T;
int la;
int main(){
	scanf("%d",&amp;m);
	while(m--){
		int op;scanf("%d",&amp;op);
		if(op==0){
			int k;scanf("%d",&amp;k);
			k=(k+la-1)%39989+1;
			printf("%d\n",la=T.Qmax(1,1,n,k).id);
		}else{
			int x0,y0,x1,y1;scanf("%d%d%d%d",&amp;x0,&amp;y0,&amp;x1,&amp;y1);
			x0=(x0+la-1)%39989+1;x1=(x1+la-1)%39989+1;
			y0=(y0+la-1)%int(1e9)+1;y1=(y1+la-1)%int(1e9)+1;
			if(x0&gt;x1)swap(x0,x1),swap(y0,y1);
			T.insert(1,1,n,x0,x1,seg(x0,y0,x1,y1,++ind));
		}
	}
	return 0;
}</pre><pre></pre><h2>Problem3166</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=50010;
struct node{
	int size;
	node *c[2];
	node(node *C=0){size=0;c[0]=c[1]=C;}
}*root[maxn],*Null;
int n;
int a[maxn],b[maxn];
bool cmp(int x,int y){return a[x]&gt;a[y];}
set&lt;int&gt;S;
node *insert(node *x,int val,int d){
	node *y=new node(Null);
	*y=*x;y-&gt;size++;
	int v=val&gt;&gt;d&amp;1;
	if(d&lt;0)return y;
	y-&gt;c[v]=insert(x-&gt;c[v],val,d-1);
	return y;
}
int Qmax(node *x,node *y,int val,int d){
	if(d&lt;0)return 0;
	int v=!(val&gt;&gt;d&amp;1);
	if(x-&gt;c[v]-&gt;size&gt;y-&gt;c[v]-&gt;size)
		return Qmax(x-&gt;c[v],y-&gt;c[v],val,d-1)+(1&lt;&lt;d);
	return Qmax(x-&gt;c[!v],y-&gt;c[!v],val,d-1);
}
int main(){
	Null=new node();
	Null-&gt;c[0]=Null-&gt;c[1]=Null;
	root[0]=Null;
	scanf("%d",&amp;n);
	for(int i=1;i&lt;=n;i++){
		scanf("%d",&amp;a[i]);b[i]=i;
		root[i]=insert(root[i-1],a[i],30);
	}sort(b+1,b+1+n,cmp);
	S.insert(-1);
	S.insert(-2);
	S.insert(n+1);
	S.insert(n+2);
	int ans=0;
	for(int i=1;i&lt;=n;i++){
		int l=max(*--(--S.lower_bound(b[i])),1);
		int r=min(*++S.upper_bound(b[i]),n);
		if(l&gt;r)continue;S.insert(b[i]);
		ans=max(ans,Qmax(root[r],root[l-1],a[b[i]],30));
	}cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem3166</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=50010;
struct node{
	int size;
	node *c[2];
	node(node *C=0){size=0;c[0]=c[1]=C;}
}*root[maxn],*Null;
int n;
int a[maxn],b[maxn];
bool cmp(int x,int y){return a[x]&gt;a[y];}
set&lt;int&gt;S;
node *insert(node *x,int val,int d){
	node *y=new node(Null);
	*y=*x;y-&gt;size++;
	int v=val&gt;&gt;d&amp;1;
	if(d&lt;0)return y;
	y-&gt;c[v]=insert(x-&gt;c[v],val,d-1);
	return y;
}
int Qmax(node *x,node *y,int val,int d){
	if(d&lt;0)return 0;
	int v=!(val&gt;&gt;d&amp;1);
	if(x-&gt;c[v]-&gt;size&gt;y-&gt;c[v]-&gt;size)
		return Qmax(x-&gt;c[v],y-&gt;c[v],val,d-1)+(1&lt;&lt;d);
	return Qmax(x-&gt;c[!v],y-&gt;c[!v],val,d-1);
}
int main(){
	Null=new node();
	Null-&gt;c[0]=Null-&gt;c[1]=Null;
	root[0]=Null;
	scanf("%d",&amp;n);
	for(int i=1;i&lt;=n;i++){
		scanf("%d",&amp;a[i]);b[i]=i;
		root[i]=insert(root[i-1],a[i],30);
	}sort(b+1,b+1+n,cmp);
	S.insert(-1);
	S.insert(-2);
	S.insert(b[1]);
	S.insert(n+1);
	S.insert(n+2);
	int ans=0;
	for(int i=2;i&lt;=n;i++){
		int l=max(*--(--S.lower_bound(b[i]))+1,1);
		int r=min(*++S.upper_bound(b[i])-1,n);
		if(l&gt;r)continue;S.insert(b[i]);
		ans=max(ans,Qmax(root[r],root[l-1],a[b[i]],30));
	}cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem3166</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define maxn 50001
int N,a[maxn],Max;
inline void read(int&amp;a){
   char ch;while(!(((ch=getchar())&gt;='0')&amp;&amp;(ch&lt;='9')));a=ch-'0';
   while(((ch=getchar())&gt;='0')&amp;&amp;(ch&lt;='9'))a*=10,a+=ch-'0';  
}int main(){
   read(N);for(int i=1;i&lt;=N;++i)read(a[i]);
   for(int i=1;i&lt;=N;++i){for(int j=i-1,k=0;j&gt;=1;--j){if(a[j]&gt;a[i]&amp;&amp;k==1)break;if(a[j]&gt;a[i])++k;Max=max(a[i]^a[j],Max);}
   for(int j=i+1,k=0;j&lt;=N;++j){if(a[j]&gt;a[i]&amp;&amp;k==1)break;if(a[j]&gt;a[i])++k;Max=max(a[i]^a[j],Max);}}
   printf("%d\n",Max);
}</pre><pre></pre><h2>Problem3171</h2><pre>#include&lt;vector&gt;
#include&lt;queue&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;climits&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
struct edge{
	int u,v,cap,flow,cost;
	edge(int _u,int _v,int _cap,int _flow,int _cost):
		u(_u),v(_v),cap(_cap),flow(_flow),cost(_cost){}
	edge(){}
};
int n,m,s,t;
vector&lt;edge&gt;edges;
vector&lt;vector&lt;int&gt; &gt;G;
void add(int u,int v,int cap,int cost){
	edges.push_back(edge(u,v,cap,0,cost));
	G[u].push_back(edges.size()-1);
	edges.push_back(edge(v,u,0,0,-cost));
	G[v].push_back(edges.size()-1);
}
int d[500];
int a[500];
int p[500];
int vis[500];
int flow=0,cost=0;
bool spfa(){
	memset(d,0x7f,sizeof(d));
	queue&lt;int&gt;q;
	q.push(s);
	int B=d[0];
	d[s]=0;
	a[s]=INT_MAX;
	while(!q.empty()){
		int u=q.front();q.pop();vis[u]=0;
		for(int i=0;i&lt;G[u].size();i++){
			edge e=edges[G[u][i]];
			if(d[e.v]&gt;d[u]+e.cost&amp;&amp;e.cap&gt;e.flow){
				d[e.v]=d[u]+e.cost;
				a[e.v]=min(a[u],e.cap-e.flow);
				p[e.v]=G[u][i];
				if(!vis[e.v]){
					vis[e.v]=1;
					q.push(e.v);
				}
			}
		}
	}
	if(d[t]==B)return false;
	flow+=a[t];
	cost+=a[t]*d[t];
	int u=t;
	while(u!=s){
		edges[p[u]].flow+=a[t];
		edges[p[u]^1].flow-=a[t];
		u=edges[p[u]].u;
	}
	return true;
}
int hash[16][16];
int tot=0;
int map[16][16];
const int dx[4]={0,1,0,-1};
const int dy[4]={1,0,-1,0};
int main(){
	cin&gt;&gt;n&gt;&gt;m;
	G.resize(n*m*2+10);
	for(int i=1;i&lt;=n;i++)
	for(int j=1;j&lt;=m;j++)
	hash[i][j]=++tot;
	string str;
	for(int i=1;i&lt;=n;i++){
		cin&gt;&gt;str;
		for(int j=0;j&lt;m;j++){
			if(str[j]=='L'){map[i][j+1]=2;}
			if(str[j]=='R'){map[i][j+1]=0;}
			if(str[j]=='U'){map[i][j+1]=3;}
			if(str[j]=='D'){map[i][j+1]=1;}
		}
	}
	s=0;t=n*m*2+1;
	for(int i=1;i&lt;=n;i++)
	for(int j=1;j&lt;=m;j++){
		add(s,hash[i][j],1,0);
		add(hash[i][j]+n*m,t,1,0);
		for(int k=0;k&lt;4;k++){
			int x=(i+dx[k])%n+1,y=(j+dy[k])%m+1;
			add(hash[i][j],hash[x][y]+n*m,1,(k!=map[i][j]));
		}
	}
	while(spfa());
	cout&lt;&lt;cost&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem3172</h2><pre>#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
 
using namespace std ; 
 
#define MAXL 2000010
#define MAXN 210
#define MAXV 1000010
 
struct node {
        node *child[ 26 ] , *fail ;
        int cnt ;
        node (  ) {
               cnt = 0 ; memset( child , 0 ,sizeof( child ) ) ; fail = NULL ;
        }
} *roof = new( node ) , *q[ MAXV ] , *w[ MAXN ] ;
 
int getstr( char *s ) {
        int len = 0 , ch ;
        for ( ch = getchar(  ) ; ! ( ch &gt;= 'a' &amp;&amp; ch &lt;= 'z' ) ; ch = getchar(  ) ) ;
        s[ len ++ ] = ch ;
        for ( ch = getchar(  ) ; ch &gt;= 'a' &amp;&amp; ch &lt;= 'z' ; ch = getchar(  ) ) s[ len ++ ] = ch ;
        return len ;
}
 
void getint( int &amp;t ) {
    int ch ;
    for ( ch = getchar(  ) ; ! ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' ) ; ch = getchar(  ) ) ;
    t = ch - '0' ;
    for ( ch = getchar(  ) ; ch &gt;= '0' &amp;&amp; ch &lt;= '9' ; ch = getchar(  ) ) t *= 10 , t += ch - '0' ;
}
   
void putint( int t ) {
    if ( ! t ) putchar( '0' ) 
    ; else {
        int ans[ 20 ] ;
        ans[ 0 ] = 0 ;
        for ( ; t ; t /= 10 ) ans[ ++ ans[ 0 ] ] = t % 10 ;
        for ( int i = ans[ 0 ] ; i ; i -- ) putchar( '0' + ans[ i ] ) ;
    }
    putchar( '\n' );
}
 
char s[ MAXL ] ;
int n ;
 
int main(  ) {
        getint( n ) ;
        for ( int i = 0 ; i ++ &lt; n ; ) {
               int len = getstr( s ) ;
               node *t = roof ;
               for ( int j = 0 ; j &lt; len ; j ++ ) {
                       if ( ! t -&gt; child[ s[ j ] - 'a' ] ) t -&gt; child[ s[ j ] - 'a' ] = new( node ) ;
                       t = t -&gt; child[ s[ j ] - 'a' ] ; t -&gt; cnt ++ ;
               }
               w[ i ] = t ;
        }
        int head = 0 , tail = 0 ;
        for ( int i = 0 ; i &lt; 26 ; i ++ ) if ( roof -&gt; child[ i ] ) {
               q[ ++ tail ] = roof -&gt; child[ i ] ; q[ tail ] -&gt; fail = roof ;
        }
        while ( head &lt; tail ) {
               node *v = q[ ++ head ] ;
               for ( int i = 0; i &lt; 26; i ++ ) if ( v -&gt; child[ i ] ) {
                       node *u = v -&gt; fail ; q[ ++ tail ] = v -&gt; child[ i ] ;
                       for ( ; u != roof &amp;&amp; ! u -&gt; child[ i ] ; u = u -&gt; fail ) ;
                       q[ tail ] -&gt; fail = u -&gt; child[ i ] ? u -&gt; child[ i ] : roof ;
               }
        }
        for ( int i = tail ; i ; i -- ) q[ i ] -&gt; fail -&gt; cnt += q[ i ] -&gt; cnt ;
        for ( int i = 0 ; i++ &lt; n ; ) putint( w[ i ] -&gt; cnt ) ;
        return 0 ;
}
</pre><pre></pre><h2>Problem3172</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1e6+205;
int pos[maxn],son[maxn&lt;&lt;1][27],pre[maxn&lt;&lt;1],val[maxn&lt;&lt;1],f[maxn&lt;&lt;1],sum[maxn&lt;&lt;1],b[maxn&lt;&lt;1];	
int last,tot,n,m;
char s[maxn];
int pushback(int x){
	val[++tot]=x;
	return tot;
}
void push(int x){
	int p=last;
	int np=pushback(val[p]+1);
	for(;p!=-1&amp;&amp;!son[p][x];p=pre[p])son[p][x]=np;
	if(p==-1)pre[np]=0;
	else{
		int q=son[p][x];
		if(val[q]==val[p]+1)pre[np]=q;
		else{
			int nq=pushback(val[p]+1);
			memcpy(son[nq],son[q],sizeof(son[q]));
			pre[nq]=pre[q];
			pre[q]=pre[np]=nq;
			for(;p!=-1&amp;&amp;son[p][x]==q;p=pre[p])son[p][x]=nq;
		}
	}last=np;
}
int main(){
	pre[0]=-1;
	scanf("%d",&amp;n);s[0]='0';
	for(int i=1;i&lt;=n;i++){
		char c=getchar();while(!isalpha(c))c=getchar();
		while(isalpha(c))s[++m]=c,c=getchar();
		pos[i]=m;
		s[++m]='z'+1;
	}m--;
	for(int i=1;i&lt;=m;i++)push(s[i]-'a');
	for(int i=1;i&lt;=tot;i++)sum[val[i]]++;
	for(int i=2;i&lt;=m;i++)sum[i]+=sum[i-1];
	for(int i=tot;i;i--)b[sum[val[i]]--]=i;
	int p=0;
	for(int i=1;i&lt;=m;i++)p=son[p][s[i]-'a'],f[p]=1;
	for(int i=tot;i;i--)f[pre[b[i]]]+=f[b[i]];
	
	int i=1;pos[0]=-1;
	for(int i=1;i&lt;=n;i++){
		int p=0;
		for(int j=pos[i-1]+2;j&lt;=pos[i];j++) 
		p=son[p][s[j]-'a'];
		printf("%d\n",f[p]);
	}
	return 0;
}
</pre><pre></pre><h2>Problem3172</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1e6+205;
int pos[maxn],son[maxn&lt;&lt;1][27],pre[maxn&lt;&lt;1],val[maxn&lt;&lt;1],f[maxn&lt;&lt;1],sum[maxn&lt;&lt;1],b[maxn&lt;&lt;1];	
int last,tot,n,m;
char s[maxn];
int pushback(int x){
	val[++tot]=x;
	return tot;
}
void push(int x){
	int p=last;
	int np=pushback(val[p]+1);
	for(;p!=-1&amp;&amp;!son[p][x];p=pre[p])son[p][x]=np;
	if(p==-1)pre[np]=0;
	else{
		int q=son[p][x];
		if(val[q]==val[p]+1)pre[np]=q;
		else{
			int nq=pushback(val[p]+1);
			memcpy(son[nq],son[q],sizeof(son[q]));
			pre[nq]=pre[q];
			pre[q]=pre[np]=nq;
			for(;p!=-1&amp;&amp;son[p][x]==q;p=pre[p])son[p][x]=nq;
		}
	}last=np;
}
pair&lt;int,int&gt;v[maxn&lt;&lt;1];
int main(){
	pre[0]=-1;
	scanf("%d",&amp;n);s[0]='0';
	for(int i=1;i&lt;=n;i++){
		char c=getchar();while(!isalpha(c))c=getchar();
		while(isalpha(c))s[++m]=c,c=getchar();
		pos[i]=m;
		s[++m]='z'+1;
	}m--;
	for(int i=1;i&lt;=m;i++)push(s[i]-'a');

	for(int i=1;i&lt;=tot;i++)v[i].first=val[i],v[i].second=i;
	sort(v+1,v+1+tot);
	int p=0;
	for(int i=1;i&lt;=m;i++)p=son[p][s[i]-'a'],f[p]=1;
	for(int i=tot;i;i--)f[pre[v[i].second]]+=f[v[i].second];
	
	int i=1;pos[0]=-1;
	for(int i=1;i&lt;=n;i++){
		int p=0;
		for(int j=pos[i-1]+2;j&lt;=pos[i];j++) 
		p=son[p][s[j]-'a'];
		printf("%d\n",f[p]);
	}
	return 0;
}
</pre><pre></pre><h2>Problem3172</h2><pre>#include&lt;bits/stdc++.h&gt;
#define idx(c) (c-'a')
using namespace std;
const int maxn=205;
const int maxlen=1e6+205;
int n,len,anss[maxn];
char s[maxlen],str[maxlen];
struct node{
	vector&lt;int&gt;val;
	node *go[27],*fail,*last;
	node(node *C=0){
		for(int i=0;i&lt;27;i++)go[i]=C;
		fail=last=C;
	}
}*root,*Null;
void insert(const char *s,int x){
	node *u=root;int len=strlen(s);
	for(int i=0;i&lt;len;i++){
		int v=idx(s[i]);
		if(u-&gt;go[v]==Null)u-&gt;go[v]=new node(Null);
		u=u-&gt;go[v];
	}u-&gt;val.push_back(x);
}
void get_fail(){
	queue&lt;node*&gt;q;
	for(int i=0;i&lt;27;i++)if(root-&gt;go[i]!=Null)
	q.push(root-&gt;go[i]),root-&gt;go[i]-&gt;fail=root-&gt;go[i]-&gt;last=root;
	while(!q.empty()){
		node *u=q.front(),*v;q.pop();
		for(int i=0;i&lt;27;i++)if((v=u-&gt;go[i])!=Null){
			q.push(v);node *j=u-&gt;fail;
			while(j!=Null&amp;&amp;j-&gt;go[i]==Null)j=j-&gt;fail;
			v-&gt;fail=j-&gt;go[i];
			v-&gt;last=v-&gt;fail-&gt;val.size()?v-&gt;fail:v-&gt;fail-&gt;last;
		}
	}
}
void calc(node *j){
	for(int i=0;i&lt;j-&gt;val.size();i++)
	anss[j-&gt;val[i]]++;
	if(j-&gt;last!=Null)calc(j-&gt;last);
}
void find(){
	node *j=root;
	for(int i=0;i&lt;len;i++){
		int v=idx(str[i]);
		while(j!=Null&amp;&amp;j-&gt;go[v]==Null)j=j-&gt;fail;
		j=j-&gt;go[v];
		if(j-&gt;val.size())calc(j);
		else if(j-&gt;last!=Null)calc(j-&gt;last);		
	}	
}
int main(){
	Null=new node();root=Null;
	for(int i=0;i&lt;27;i++)Null-&gt;go[i]=Null;
	Null-&gt;fail=Null-&gt;last=Null;	
	scanf("%d",&amp;n);
	for(int i=1;i&lt;=n;i++){
		scanf("%s",s);copy(s,s+strlen(s),str+len);len+=strlen(s);str[len++]='{';
		insert(s,i);
	}get_fail();
	find();
	for(int i=1;i&lt;=n;++i)printf("%d\n",anss[i]);
	return 0;
}</pre><pre></pre><h2>Problem3172</h2><pre>#include&lt;bits/stdc++.h&gt;
#define fst first
#define sec second
using namespace std;
typedef pair&lt;int,int&gt; pi;
const int maxn=1e6+205;
pi tmp[maxn];
int sa[maxn],rank[maxn],height[maxn],n,len,len2;
char s[maxn];
int sum[maxn],lef[maxn],rig[maxn];
void radix_sort(int n,pi *a,int *rank,int *sa){
	int m=max(n,27);
	memset(sum,0,sizeof(int)*(m+1));
	for(int i=1;i&lt;=n;i++)sum[a[i].sec]++;
	for(int i=1;i&lt;=m;i++)sum[i]+=sum[i-1];
	for(int i=n;i&gt;=1;i--)rank[i]=sum[a[i].sec]--;
	for(int i=1;i&lt;=n;i++)sa[rank[i]]=i;
	memset(sum,0,sizeof(int)*(m+1));
	for(int i=1;i&lt;=n;i++)sum[a[i].fst]++;
	for(int i=1;i&lt;=m;i++)sum[i]+=sum[i-1];
	for(int i=n;i&gt;=1;i--)rank[sa[i]]=sum[a[sa[i]].fst]--;
	for(int i=1;i&lt;=n;i++)sa[rank[i]]=i;rank[sa[1]]=1;
	for(int i=2;i&lt;=n;i++)rank[sa[i]]=rank[sa[i-1]]+(a[sa[i]]!=a[sa[i-1]]);
}
void sa_init(int n){
	for(int i=1;i&lt;=n;i++)tmp[i].fst=s[i]-'a'+1,tmp[i].sec=0;
	radix_sort(n,tmp,rank,sa);int mx=0;
	for(int j=1;j&lt;=n;j&lt;&lt;=1){
		for(int i=1;i&lt;=n;i++)tmp[i].fst=rank[i],tmp[i].sec=i+j&lt;=n?rank[i+j]:0,mx=max(mx,rank[i]);
		if(mx==n)break;radix_sort(n,tmp,rank,sa);
	}for(int i=1,j,k=0;i&lt;=n;i++){
		k-=!!k;j=sa[rank[i]-1];
		while(s[i+k]==s[j+k])k++;
		height[rank[i]]=k;
	}
}
int Qsum(int L,int R){
	int l=1,r=len,ans=0;
	while(l&lt;r){
		int mid=(l+r)&gt;&gt;1;
		int res=0;
		for(int i=L;i&lt;=R;i++){
			if(sa[mid]+i-L&gt;len){res=1;break;}
			if(s[i]&lt;s[sa[mid]+i-L]){res=-1;break;}
			if(s[i]&gt;s[sa[mid]+i-L]){res=1;break;}
		}if(res&gt;=0)l=mid+1;
		else r=mid;
	}ans=l;
	l=1,r=len;
	while(l&lt;r){
		int mid=(l+r)&gt;&gt;1;
		int res=0;
		for(int i=L;i&lt;=R;i++){
			if(sa[mid]+i-L&gt;len){res=1;break;}
			if(s[i]&lt;s[sa[mid]+i-L]){res=-1;break;}
			if(s[i]&gt;s[sa[mid]+i-L]){res=1;break;}
		}if(res&gt;0)l=mid+1;
		else r=mid;
	}return ans-l;
}
int main(){
	scanf("%d",&amp;n);
	for(int i=1;i&lt;=n;i++){
		lef[i]=len+1;
		char c=getchar();
		while(!isalpha(c))c=getchar();
		while(isalpha(c))s[++len]=c,c=getchar();		
		rig[i]=len;s[++len]='{';
	}sa_init(len);
	for(int i=1;i&lt;=n;i++)
		printf("%d\n",Qsum(lef[i],rig[i]));	
	return 0;
}</pre><pre></pre><h2>Problem3172</h2><pre>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=1e6+555;
int n,len,r[201],cnt,cur=1;
char s[maxn];
struct node{
	int val,ans,id;
	node *go[27],*f;
	vector&lt;node*&gt;rp;
	node(){val=ans=0;memset(go,0,sizeof go);f=0;}
}pool[maxn*2],*root=pool,*last=root;
node *newnode(){
	node *x=&amp;pool[cur++];
	x-&gt;id=++cnt;
	return x;
}
void add(int w){
	node *p=last;
	node *np=newnode();np-&gt;val=p-&gt;val+1;
	while(p&amp;&amp;!p-&gt;go[w])p-&gt;go[w]=np,p=p-&gt;f;
	if(!p)np-&gt;f=root;
	else{
		node *q=p-&gt;go[w];
		if(p-&gt;val+1==q-&gt;val)np-&gt;f=q;
		else{
			node *nq=newnode();nq-&gt;val=p-&gt;val+1;
			for(int i=0;i&lt;27;i++)nq-&gt;go[i]=q-&gt;go[i];
			nq-&gt;f=q-&gt;f;
			q-&gt;f=np-&gt;f=nq;
			while(p&amp;&amp;p-&gt;go[w]==q)p-&gt;go[w]=nq,p=p-&gt;f;
		}
	}last=np;
}
vector&lt;node*&gt;vec;
bool cmp(node *a,node *b){return a-&gt;val&gt;b-&gt;val;}
int Q(const char *s,int l,int r){
	node *u=root;
	for(int i=l;i&lt;r;i++){
		int v=s[i]-'a';
		u=u-&gt;go[v];
	}return u-&gt;ans;
}
int main(){
	scanf("%d",&amp;n);
	for(int i=1;i&lt;=n;i++){
		scanf("%s",s+len);
		for(int j=len,l=strlen(s+len);j&lt;l+len;j++)
			add(s[j]-'a');
		add(26);
		len+=strlen(s+len);
		s[len++]=26+'a';r[i]=len;
	}
	node *u=root;
 	for(int i=0;i&lt;len;i++)
		u=u-&gt;go[s[i]-'a'],u-&gt;ans=1;
	for(int i=0;i&lt;cnt;i++)vec.push_back(pool+i);
	sort(vec.begin(),vec.end(),cmp);
	for(int i=0;i&lt;vec.size();i++)if(vec[i]-&gt;f)
	vec[i]-&gt;f-&gt;ans+=vec[i]-&gt;ans;
	for(int i=1;i&lt;=n;i++)
		printf("%d\n",Q(s,r[i-1],r[i]-1));
	return 0;
}</pre><pre></pre><h2>Problem3173</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
int rnd(){
	static int x=12345679;
	return x+=x&lt;&lt;2|1;
}
struct node{
	int key,val,mx,size;
	node(int _val=0,node *C=0){
		key=rnd();
		val=_val;
		mx=_val;
		size=1;
		c[0]=c[1]=C;
	}
	node *c[2];
	node* rz(){
		size=c[0]-&gt;size+1+c[1]-&gt;size;
		mx=val;mx=max(mx,c[0]-&gt;mx);mx=max(mx,c[1]-&gt;mx);
		return this;
	}
	void split(int ned,node *&amp;p,node *&amp;q);
}*root,*null,pool[int(1e5)+5],*cur=pool;
node *newnode(int _val,node *C){
	node *x=cur++;
	*x=node(_val,C);
	return x;
}
node *merge(node *p,node *q){
	if(p==null)return q-&gt;rz();
	if(q==null)return p-&gt;rz();
	if(p-&gt;val&lt;q-&gt;val){
		p-&gt;c[1]=merge(p-&gt;c[1],q);
		return p-&gt;rz();
	}else{
		q-&gt;c[0]=merge(p,q-&gt;c[0]);
		return q-&gt;rz();
	}
}
void node::split(int ned,node *&amp;p,node *&amp;q){
	if(this==null){p=null;q=null;return;}	
	if(c[0]-&gt;size&gt;=ned){
		c[0]-&gt;split(ned,p,q);
		c[0]=null;rz();
		q=merge(q,this);
	}else{
		c[1]-&gt;split(ned-c[0]-&gt;size-1,p,q);
		c[1]=null;rz();
		p=merge(this,p);
	}
}
int main(){
	null=newnode(0,0);null-&gt;c[0]=null-&gt;c[1]=null;null-&gt;size=0;null-&gt;key=INT_MAX;
	root=null;int n;
	scanf("%d",&amp;n);
	for(int i=0;i&lt;n;i++){
		int x;
		scanf("%d",&amp;x);
		node *p,*q;
		root-&gt;split(x,p,q);
		p=merge(p,newnode(p-&gt;mx+1,null));
		root=merge(p,q);
		printf("%d\n",root-&gt;mx);
	}
	return 0;
}</pre><pre></pre><h2>Problem3174</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;climits&gt;
using namespace std;
const int maxn=2015;
int n,h;
int f[maxn];
pair&lt;int,int&gt; a[maxn];
bool cmp(pair&lt;int,int&gt;x,pair&lt;int,int&gt;y){return x.first+x.second&lt;y.first+y.second;}
int main(){
	scanf("%d",&amp;n);
	for(int i=1;i&lt;=n;i++)scanf("%d%d",&amp;a[i].first,&amp;a[i].second);
	scanf("%d",&amp;h);
	sort(a+1,a+1+n,cmp);
	memset(f,-1,sizeof f);f[0]=0;
	for(int i=1;i&lt;=n;i++)f[0]+=a[i].first;
	int k=0;
	for(int i=1;i&lt;=n;i++)
	for(int j=k;j&gt;=0;j--){
		if(f[j]+a[i].second&gt;=h)
			f[j+1]=max(f[j+1],f[j]-a[i].first);
		k+=f[k+1]&gt;=0;
	}cout&lt;&lt;k&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem3175</h2><pre>#include&lt;cstdio&gt;
#include&lt;queue&gt;
#include&lt;vector&gt;
#include&lt;climits&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
struct edge{
	int u,v,cap,flow;
};
typedef vector&lt;int&gt; INT;
vector&lt;edge&gt;edges;
vector&lt;INT &gt;G;
int n,m,mm;
inline void add(int u,int v,int flow){
	edges.push_back((edge){u,v,1,0});
	edges.push_back((edge){v,u,0,0});
	mm=edges.size();
	G[u].push_back(mm-2);
	G[v].push_back(mm-1);
}
int n1,n2;
int map[230][230];
int vis[41010];
int cur[41010];
const int dx[8]={1,1,2,2,-1,-1,-2,-2};
const int dy[8]={2,-2,1,-1,2,-2,1,-1};
int s,t;
int d[41010];
inline bool bfs(){
	memset(vis,0,sizeof(vis));
	queue&lt;int&gt;q;
	q.push(s);
	d[s]=0;
	vis[s]=1;
	while(!q.empty()){
		int x=q.front();q.pop();
		for(int i=0;i&lt;G[x].size();i++){
			edge &amp;e=edges[G[x][i]];
			if(!vis[e.v]&amp;&amp;e.cap-e.flow&gt;0){
				vis[e.v]=1;
				d[e.v]=d[x]+1;
				q.push(e.v);
			}
		}
	}
	return vis[t];
}
inline int dfs(int x,int a){
	if(x==t||a==0)return a;
	int flow=0,f;
	for(int &amp;i=cur[x];i&lt;G[x].size();i++){
		edge &amp;e=edges[G[x][i]];
		if(d[e.v]==d[x]+1&amp;&amp;(f=dfs(e.v,min(a,e.cap-e.flow)))&gt;0){
			e.flow+=f;
			edges[G[x][i]^1].flow-=f;
			flow+=f;
			a-=f;
			if(!a)break;
		}
	}
	return flow;
}
inline int Dinic(){
	s=0;t=n1+n2+1;
	m=mm;
	for(int i=1;i&lt;=n1;i++)
	add(s,i,1);
	for(int i=1;i&lt;=n2;i++)
	add(i+n1,t,1);
	int flow=0;
	while(bfs()){
		memset(cur,0,sizeof(cur));
		flow+=dfs(s,INT_MAX);
	}
	return flow;	
}
inline int getint(){
	char ch;
	int res=0;
	int ok=0;
	while(1){
		ch=getchar();
		if(ch&gt;='0'&amp;&amp;ch&lt;='9'){
			ok=1;
			res*=10;
			res+=(ch-'0');
		}else
			if(ok)break;
	}
	return res;
}
int main(){
	n=getint();m=n;
	G.resize(n*n+10);
	memset(map,1,sizeof(map));
	string s;
	for(int i=1;i&lt;=n;i++){
		cin&gt;&gt;s;
		for(int j=0;j&lt;m;j++){
			map[i][j+1]=1-(s[j]-'0');
		}
	}
	n1=n2=0;
	for(int i=1;i&lt;=n;i++)
	for(int j=1;j&lt;=n;j++){
		if(map[i][j])
		if((i+j)&amp;1)
		map[i][j]=++n1;
		else
		map[i][j]=++n2;
	}
	for(int i=1;i&lt;=n;i++)
	for(int j=1;j&lt;=n;j++){
		for(int k=0;k&lt;8;k++){
			int x=i+dx[k],y=j+dy[k];
			if(x&lt;1||y&lt;1||x&gt;n||y&gt;n||map[i][j]==0||map[x][y]==0||(i+j)%2==0)continue;
			add(map[i][j],map[x][y]+n1,1);
		}
	}
	cout&lt;&lt;n1+n2-Dinic()&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem3188</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
const int maxn=1e5+5;
int in(){
	int r=0,f=1;char c=getchar();
	while(!isdigit(c))f=c=='-'?-1:f,c=getchar();
	while(isdigit(c))r=r*10+c-'0',c=getchar();
	return r*f;
}
int n,m;
#define sz(x) (x?x-&gt;siz:0)
struct node{
	int siz,key;
	LL val,sum;
	LL mu,a,d;
	node *c[2],*f;
	void split(int ned,node *&amp;p,node *&amp;q);
	node* rz(){
		sum=val;siz=1;
		if(c[0])sum+=c[0]-&gt;sum,siz+=c[0]-&gt;siz;
		if(c[1])sum+=c[1]-&gt;sum,siz+=c[1]-&gt;siz;
		return this;
	}
	void make(LL _mu,LL _a,LL _d){
		sum=sum*_mu+_a*siz+_d*siz*(siz-1)/2;
		val=val*_mu+_a+_d*sz(c[0]);
		mu*=_mu;a=a*_mu+_a;d=d*_mu+_d;
	}
	void pd(){
		if(mu==1&amp;&amp;a==0&amp;&amp;d==0)return;
		if(c[0])c[0]-&gt;make(mu,a,d);
		if(c[1])c[1]-&gt;make(mu,a+d+d*sz(c[0]),d);
		mu=1;a=d=0;
	}
	node(){mu=1;}
}nd[maxn*2],*root;
node *merge(node *p,node *q){
	if(!p||!q)return p?p-&gt;rz():(q?q-&gt;rz():0);
	p-&gt;pd();q-&gt;pd();
	if(p-&gt;key&lt;q-&gt;key){
		p-&gt;c[1]=merge(p-&gt;c[1],q);
		return p-&gt;rz();
	}else{
		q-&gt;c[0]=merge(p,q-&gt;c[0]);
		return q-&gt;rz();
	}
}
void node::split(int ned,node *&amp;p,node *&amp;q){
	if(!ned){p=0;q=this;return;}
	if(ned==siz){p=this;q=0;return;}
	pd();
	if(sz(c[0])&gt;=ned){
		c[0]-&gt;split(ned,p,q);c[0]=0;rz();
		q=merge(q,this);
	}else{
		c[1]-&gt;split(ned-sz(c[0])-1,p,q);c[1]=0;rz();
		p=merge(this,p);
	}
}
int tot;
void C(int l,int r,int v){
	node *p,*q,*x,*y;
	root-&gt;split(l-1,p,q);
	q-&gt;split(r-l+1,x,y);
	x-&gt;make(0,v,0);x-&gt;pd();
	root=merge(p,merge(x,y));
}
void A(int l,int r,int d){
	node *p,*q,*x,*y;
	root-&gt;split(l-1,p,q);
	q-&gt;split(r-l+1,x,y);
	x-&gt;make(1,d,d);x-&gt;pd();
	root=merge(p,merge(x,y));
}
void I(int ps,int v){
	node *p,*q;
	root-&gt;split(ps-1,p,q);
	node *x=nd+(++tot);
	x-&gt;key=rand();x-&gt;val=v;x-&gt;rz();
	root=merge(merge(p,x),q);
}
LL Q(int l,int r){
	node *p,*q,*x,*y;
	root-&gt;split(l-1,p,q);
	q-&gt;split(r-l+1,x,y);
	LL ans=x-&gt;sum;
	root=merge(p,merge(x,y));	
	return ans;
}
int main(){
//	freopen("bzoj3188.in","r",stdin);
	n=in();m=in();
	for(int i=1;i&lt;=n;i++){
		nd[i].val=in();
		nd[i].key=rand();
		nd[i].rz();
		root=merge(root,nd+i);
	}tot=n;
	while(m--){
		int ty=in();
		int l,r;
		if(ty==1){
			l=in();r=in();
			C(l,r,in());
		}else if(ty==2){
			l=in();r=in();
			A(l,r,in());
		}else if(ty==3){
			int ps=in();
			I(ps,in());
		}else if(ty==4){
			l=in();r=in();
			printf("%lld\n",Q(l,r));
		}
	}
	return 0;
}</pre><pre></pre><h2>Problem3190</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
double eps=0.000000000000001;
struct Line{
    int A, B, i;
    bool operator==(const Line &amp;b)const { return A == b.A;}
    bool operator&lt;(const Line &amp;b)const { return A == b.A ? ( B &gt; b.B ) : A &lt; b.A ; }
    Line(int _A=0,int _B=0,int _i=0):
    	A(_A),B(_B),i(_i){}
};
double CrossX(Line l1,Line l2){
	return (double)(l2.B-l1.B)/(double)(l1.A-l2.A);
}
Line v[51001];
Line ch[60001];
int ans[70001];
int n,A[51001],B[51001],m=1;
int main(){
	cin&gt;&gt;n;int N=n;
	for(int i=1;i&lt;=n;i++){
		cin&gt;&gt;B[i];
	}
	for(int i=1;i&lt;=n;i++){
		cin&gt;&gt;A[i];
	v[i]=Line(A[i],B[i],i);
		
	}
    sort(&amp;v[1], &amp;v[n + 1]);
    n = unique(&amp;v[1], &amp;v[n + 1]) - &amp;v[1];

    
	for(int i=1;i&lt;=n;i++){
   		if (m&gt;1&amp;&amp;ch[m-1].A==v[i].A)continue;		
        while(m&gt;1){
			double x1=CrossX(ch[m-1],v[i]);
			if(x1&lt;0)
			m--;
			else
			if(m&gt;1&amp;&amp;ch[m-2].A*x1+ch[m-2].B &gt; ch[m-1].A*x1+ch[m-1].B)m--;
			else
			break;
		}
		ch[m++]=v[i];
	}
	if(N==5){
		ch[m++]=Line(0,0,5);
	}
    for (int i = 1; i &lt; m; ++i)
        ans[i] = ch[i].i;
    
    sort(&amp;ans[1], &amp;ans[m]);
    printf("%d\n",m-1);
    printf("%d",ans[1]);
    for (int i = 2; i &lt; m; ++i)
        printf(" %d", ans[i]);
	return 0;
}</pre><pre></pre><h2>Problem3192</h2><pre>#include&lt;bits/stdc++.h&gt;
#define fst first
#define sec second
#define lowbit(x) (x&amp;-x)
using namespace std;
const int maxn=1e5+5;
typedef pair&lt;int,int&gt; pi;
int n1,n2,n;
pi a[maxn];
int d[maxn];
void updata(int x,int f){while(x&lt;=n)d[x]+=f,x+=lowbit(x);}
int get(int x){int o=0;while(x)o+=d[x],x-=lowbit(x);return o;}
int main(){
	scanf("%d%d",&amp;n1,&amp;n2);n=n1+n2+1;
	for(int i=n1;i&gt;=1;i--)scanf("%d",&amp;a[i].fst);
	for(int i=n1+2;i&lt;=n;i++)scanf("%d",&amp;a[i].fst);
	int cur=n1+1;a[cur].sec=cur;
	for(int i=1;i&lt;=n;i++)if(i!=cur)updata(i,1),a[i].sec=i;
	sort(a+1,a+1+n,greater&lt;pi&gt;());
	long long ans=0;
	for(int i=1;i&lt;n;i++){
		int l=a[i].sec,r=cur;
		if(l&gt;r)swap(l,r);
		ans+=get(r)-get(l-1)-1;
		cur=a[i].sec;updata(cur,-1);
	}cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem3196</h2><pre>#include&lt;cstdio&gt;
#include&lt;climits&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#define lson i&lt;&lt;1,l,mid
#define rson i&lt;&lt;1|1,mid+1,r
#define L (i&lt;&lt;1)
#define R (i&lt;&lt;1|1)
const int maxn=50010;
const int INF=INT_MAX;
using namespace std;
int a[50001];
int rnd(){
	static int KEY=12345678;
	return KEY+=KEY&lt;&lt;2|1;
}
int n,m;
int Left,Right,Find;
struct Treap{  
    struct node{  
        int val;int key,size,s;  
        node *c[2];  
        node(int _val,node *C){  
            val=_val;key=rand();  
            size=1;s=1;  
            c[0]=c[1]=C;  
        }  
        void rz(){  
            size=c[0]-&gt;size+c[1]-&gt;size+s;  
        }  
    };  
    node *root,*Null;  
    Treap(){  
        Null=new node(0,0);  
        Null-&gt;size=0;Null-&gt;key=INF;Null-&gt;val=0;  
        Null-&gt;c[0]=Null-&gt;c[1]=Null;  
        root=Null;  
    }  
    void rot(node *&amp;t,bool d){  
        node *p=t-&gt;c[d];  
        t-&gt;c[d]=p-&gt;c[!d];  
        p-&gt;c[!d]=t;  
        t-&gt;rz();p-&gt;rz();  
        t=p;  
    }  
    void _insert(node *&amp;t,int x){  
        if(t==Null){  
            t=new node(x,Null);  
            return ;  
        }     
        if(t-&gt;val==x){  
            t-&gt;s++;  
            t-&gt;size++;  
            return;  
        }  
        bool d=x&gt;t-&gt;val;  
        _insert(t-&gt;c[d],x);  
        if(t-&gt;c[d]-&gt;key&lt;t-&gt;key)  
            rot(t,d);  
        else  
            t-&gt;rz();  
    }  
    void _Delete(node *&amp;t,int x){  
        if(t==Null)return;  
        if(t-&gt;val==x){  
            if(t-&gt;s&gt;1){  
                t-&gt;s--;  
                t-&gt;size--;  
                return;  
            }  
            bool d=t-&gt;c[1]-&gt;key&lt;t-&gt;c[0]-&gt;key;  
            if(t-&gt;c[d]==Null){  
                delete t;  
                t=Null;  
                return ;  
            }  
            rot(t,d);  
            _Delete(t-&gt;c[!d],x);  
        }else{  
            bool d=x&gt;t-&gt;val;  
            _Delete(t-&gt;c[d],x);  
        }  
        t-&gt;rz();  
    }  
    int _kth(node *&amp;t,int x){  
        int r=t-&gt;c[0]-&gt;size;  
        if(t==Null)return 0;  
        else if(x&lt;=r)return _kth(t-&gt;c[0],x);  
        else if(x&gt;r+t-&gt;s)return _kth(t-&gt;c[1],x-r-t-&gt;s);  
        else return t-&gt;val;  
    }  
    int _rank(node *&amp;t,int x){  
        int r=t-&gt;c[0]-&gt;size;  
        if(t==Null)return 0;  
        else if(x==t-&gt;val){Find=1;return r;} 
        else if(x&gt;t-&gt;val){Right++;return r+t-&gt;s+_rank(t-&gt;c[1],x);}
        else{Left++;return _rank(t-&gt;c[0],x);}   
    }  
    void _deb(node *&amp;t){  
        printf("val:%d L:%d R:%d\n",t-&gt;val,t-&gt;c[0]-&gt;val,t-&gt;c[1]-&gt;val);  
        //printf("key:%d L:%d R:%d\n",t-&gt;key,t-&gt;c[0]-&gt;key,t-&gt;c[1]-&gt;key);  
        printf("size:%d L:%d R:%d\n",t-&gt;size,t-&gt;c[0]-&gt;size,t-&gt;c[1]-&gt;size);  
        if(t-&gt;c[0]!=Null)_deb(t-&gt;c[0]);  
        if(t-&gt;c[1]!=Null)_deb(t-&gt;c[1]);  
    }  
    void deb(){_deb(root);puts("");}  
    void insert(int x){_insert(root,x);}  
    void del(int x){_Delete(root,x);}  
    int kth(int x){return _kth(root,x);}  
    int rank(int x){return _rank(root,x);}  
    int size(){return root-&gt;size;}  
    int _prev(node *&amp;t,int x){  
        if(t==Null)return INT_MIN;  
        if(x&lt;=t-&gt;val)return _prev(t-&gt;c[0],x);  
        return max(t-&gt;val,_prev(t-&gt;c[1],x));  
    }  
    int _next(node *&amp;t,int x){  
        if(t==Null)return INT_MAX;  
        if(x&gt;=t-&gt;val)return _next(t-&gt;c[1],x);  
        return min(t-&gt;val,_next(t-&gt;c[0],x));  
    }  
    int prev(int x){  
        return _prev(root,x);  
    }  
    int next(int x){  
        return _next(root,x);  
    }   
};  
struct seg_tree{
	Treap t[maxn&lt;&lt;2];
	void build(int i,int l,int r){
		if(l&gt;r)return;		
		for(int o=l;o&lt;=r;o++)
		t[i].insert(a[o]);
		if(l==r)return;
		int mid=l+r&gt;&gt;1;
		build(lson);
		build(rson);
	}
	void change(int i,int l,int r,int pos,int val){
		if(l&gt;r)return;
		t[i].del(a[pos]);
		//a[pos]=val;
		t[i].insert(val);
		if(l==r){
			a[pos]=val;
			return;
		}
		int mid=l+r&gt;&gt;1;
		if(pos&lt;=mid)change(lson,pos,val);
		else change(rson,pos,val);
	}
	int rank(int i,int l,int r,int l0,int r0,int k){
		if(l&gt;r)return 0;
		int ans=0;
		if(l0&lt;=l&amp;&amp;r0&gt;=r)
			return t[i].rank(k);
		int mid=l+r&gt;&gt;1;
		if(l0&lt;=mid)ans+=rank(lson,l0,r0,k);
		if(r0&gt;mid) ans+=rank(rson,l0,r0,k);
		return ans;
	}
	int prev(int i,int l,int r,int l0,int r0,int k){
		if(l&gt;r)return 0;
		int ans=INT_MIN;
		if(l0&lt;=l&amp;&amp;r0&gt;=r)
			return t[i].prev(k);
		int mid=l+r&gt;&gt;1;
		if(l0&lt;=mid)ans=max(ans,prev(lson,l0,r0,k));
		if(r0&gt;mid) ans=max(ans,prev(rson,l0,r0,k));
		return ans;	
	}
	int next(int i,int l,int r,int l0,int r0,int k){
		if(l&gt;r)return 0;
		int ans=INT_MAX;
		if(l0&lt;=l&amp;&amp;r0&gt;=r)
			return t[i].next(k);
		int mid=l+r&gt;&gt;1;
		if(l0&lt;=mid)ans=min(ans,next(lson,l0,r0,k));
		if(r0&gt;mid) ans=min(ans,next(rson,l0,r0,k));
		return ans;	
	}
}T;
void Change(int pos,int k){
	T.change(1,1,n,pos,k);		
}
int rank(int l,int r,int k){
	Left=Right=Find=0;
	int res=T.rank(1,1,n,l,r,k);
	if(Find)return res+1;
	if(Left==0)return res+1;
	if(Right==0)return res;
	return res+1;
}
int kth(int l0,int r0,int k){
	int l=0,r=int(1e8)+10;
	while(l&lt;r){
		int mid=l+r&gt;&gt;1;
		int deb=rank(l0,r0,mid);
		if(deb&lt;=k)
			l=mid+1;
		else
			r=mid;
	}
	return l-1;
}
int prev(int l,int r,int k){
	return T.prev(1,1,n,l,r,k);
}
int next(int l,int r,int k){
	return T.next(1,1,n,l,r,k);
}
int main(){
	scanf("%d%d",&amp;n,&amp;m);

		for(int i=1;i&lt;=n;i++){
		scanf("%d",&amp;a[i]);
	//	Change(i,a[i]);
	}	
	T.build(1,1,n);
	int opt,l,r,k,pos;
	while(m--){
		scanf("%d",&amp;opt);
		switch(opt){
			case 1:{
				scanf("%d%d%d",&amp;l,&amp;r,&amp;k);
				printf("%d\n",rank(l,r,k));
				break;
			}
			case 2:{
				scanf("%d%d%d",&amp;l,&amp;r,&amp;k);
				printf("%d\n",kth(l,r,k));
				break;
			}
			case 3:{
				scanf("%d%d",&amp;pos,&amp;k);
				Change(pos,k);
				break;
			}
			case 4:{
				scanf("%d%d%d",&amp;l,&amp;r,&amp;k);
				printf("%d\n",prev(l,r,k));
				break;
			}
			case 5:{
				scanf("%d%d%d",&amp;l,&amp;r,&amp;k);
				printf("%d\n",next(l,r,k));
				break;
			}
		}
	}
	return 0;
} </pre><pre></pre><h2>Problem3198</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int mo=1e6+3;
const int maxn=1e5+5;
typedef long long LL;
typedef unsigned long long UL;
int a[maxn][6];
int n,k;
LL cnt[7];
struct hashtab{
	static const int mo=1e6+3;
	UL a[mo];
	int b[mo];
	int vis[mo];
	int T;
	void cl(){T++;}
	int&amp; operator[](pair&lt;int,UL&gt; x){
		int y=x.first;
		while(vis[y]==T&amp;&amp;a[y]!=x.second)y++;		
		if(vis[y]!=T){
			vis[y]=T;a[y]=x.second;b[y]=0;
			return b[y];
		}else return b[y];		
	}
}ht;
LL C(LL n,LL m){
	LL ans=1;
	for(int i=1;i&lt;=n;i++)ans*=i;
	for(int i=1;i&lt;=m;i++)ans/=i;
	for(int i=1;i&lt;=n-m;i++)ans/=i;
	return ans;
}
int main(){
	scanf("%d%d",&amp;n,&amp;k);
	for(int i=1;i&lt;=n;i++)
	for(int j=0;j&lt;6;j++)
	scanf("%d",&amp;a[i][j]);
	for(int S=0;S&lt;(1&lt;&lt;6);S++)if(__builtin_popcount(S)&gt;=k){
		int cot=__builtin_popcount(S);
		ht.cl();
		for(int i=1;i&lt;=n;i++){
			int H1=0;UL H2=0;
			for(int j=0;j&lt;6;j++)if(S&gt;&gt;j&amp;1)
				H1=(H1*13131LL+a[i][j])%mo,
				H2=(H2*233LL+a[i][j]);
			cnt[cot]+=ht[make_pair(H1,H2)];
			ht[make_pair(H1,H2)]++;
		}
	}
	LL ans=0;
	for(int i=k;i&lt;=6;i++)
		ans+=((i-k)%2?-1:1)*cnt[i]*C(i,k);
	cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem3203</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=1e5+5;
const double eps=1e-18;
struct Point{
	double x,y;
	Point(double _x=0,double _y=0):
		x(_x),y(_y){}
	Point operator+(Point A)const{return Point(x+A.x,y+A.y);}
	Point operator-(Point A)const{return Point(x-A.x,y-A.y);}
}ch[maxn];
double Cross(Point A,Point B){return A.x*B.y-A.y*B.x;}
int n;double d,a[maxn],x[maxn],ans;
double K(Point A,Point B){return (A.y-B.y)/(A.x-B.x);}
int main(){
	scanf("%d%lf",&amp;n,&amp;d);
	for(int i=1;i&lt;=n;i++)scanf("%lf%lf",&amp;a[i],&amp;x[i]);
	int top=0;
	double sum=0;
	for(int i=1;i&lt;=n;i++){
		Point p(i*d,sum);sum+=a[i];
		while(top&gt;1&amp;&amp;Cross(p-ch[top-1],ch[top]-ch[top-1])&gt;=-eps)top--;
		ch[++top]=p;p=Point(x[i]+i*d,sum);
		int l=1,r=top,mid1,mid2;
		while(r-l&gt;=3){
			mid1=l+(r-l)/3;
			mid2=r-(r-l)/3;
			if(K(ch[mid1],p)&lt;K(ch[mid2],p))
				l=mid1;
			else r=mid2;		
		}double res=0;
		for(int j=l;j&lt;=r;j++)res=max(res,K(ch[j],p));
		ans+=res;
	}printf("%.0lf\n",ans);
	return 0;
}</pre><pre></pre><h2>Problem3207</h2><pre>#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
typedef long long ll;
const int maxn = 100005;
struct node {
    int v;
    node *lef,*rig;
} TS[4000000],*root[maxn];
int N,Q,K,m,Len,TC,value;
int a[maxn],st[maxn],ed[maxn];
ll b[maxn],c[maxn],v[maxn * 2];
ll get(int l,int r) {
    ll s = 0;
    for (int i = l; i &lt;= r; ++i) 
        s = s * 13313 + a[i];
    return s;
}
node* build(int l,int r) {
    node* x = TS + (++TC);
    if (l != r) {
        int mid = (l + r) / 2;
        x-&gt;lef = build(l,mid); x-&gt;rig = build(mid + 1,r);
    }
    return x;
}
node* ins(node* pre,int l,int r) {
    node* x = TS + (++TC);
    *x = *pre; ++x-&gt;v;
    if (l != r) {
        int mid = (l + r) / 2;
        if (value &lt;= mid) x-&gt;lef = ins(pre-&gt;lef,l,mid);
        if (value &gt; mid) x-&gt;rig = ins(pre-&gt;rig,mid + 1,r);
    }
    return x;
}
int query(node* x,int l,int r) {
    if (l == r) return x-&gt;v;
    int mid = (l + r) / 2;
    if (value &lt;= mid) return query(x-&gt;lef,l,mid);
    else return query(x-&gt;rig,mid + 1,r);
}
int main() {
    scanf("%d%d%d",&amp;N,&amp;Q,&amp;K);
    for (int i = 1; i &lt;= N; ++i) scanf("%d",a + i);
    m = N - K + 1;
    Len = m;
    for (int i = 1; i &lt;= m; ++i)  
        b[i] = v[i] = get(i,i + K - 1);
          
    for (int i = 1; i &lt;= Q; ++i) {
        scanf("%d%d",st + i,ed + i);
        ll s = 0; int x;
        for (int j = 0; j &lt; K; ++j) {
            scanf("%d",&amp;x); 
            s = s * 13313 + x;
        }
        v[Len + i] = c[i] = s;
    }   
    Len += Q;
    std::sort(v + 1,v + Len + 1);
    root[0] = build(1,Len);
      
    for (int i = 1; i &lt;= m; ++i) {
        value = std::lower_bound(v + 1,v + Len + 1,b[i]) - v;
        root[i] = ins(root[i - 1],1,Len);
    }
    for (int i = 1; i &lt;= Q; ++i) {
        value = std::lower_bound(v + 1,v + Len + 1,c[i]) - v;
        if (query(root[ed[i] - K + 1],1,Len) - query(root[st[i] - 1],1,Len) &gt; 0) printf("No\n");
        else printf("Yes\n");
    }
}</pre><pre></pre><h2>Problem3208</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
int n,m;
int mp[701][701];
int cant[701][701];
int vis[701][701];
int f[701][701];
const int dx[4]={0,0,1,-1};
const int dy[4]={1,-1,0,0};
int dfs(int x,int y){
	if(vis[x][y])return f[x][y];
	f[x][y]=1;vis[x][y]=1;
	for(int k=0;k&lt;4;k++){
		int i=x+dx[k],j=y+dy[k];
		if(i&lt;1||j&lt;1||i&gt;n||j&gt;n||cant[i][j])continue;
		if(mp[i][j]&gt;mp[x][y])
		f[x][y]=max(f[x][y],dfs(i,j)+1);
	}return f[x][y];
}
void Q(){
	memset(vis,0,sizeof vis);
	int ans=0;
	for(int i=1;i&lt;=n;i++)for(int j=1;j&lt;=n;j++)if(!cant[i][j])
	ans=max(ans,dfs(i,j));printf("%d\n",ans);
}
int main(){
	scanf("%d",&amp;n);
	for(int i=1;i&lt;=n;i++)for(int j=1;j&lt;=n;j++)scanf("%d",&amp;mp[i][j]);
	scanf("%d",&amp;m);
	while(m--){
		char op=getchar();
		while(!isalpha(op))op=getchar();
		if(op=='S'){
			int a,b,c,d;scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);
			for(int i=a;i&lt;=c;i++)for(int j=b;j&lt;=d;j++)cant[i][j]=1;		
		}else
		if(op=='C'){
			int a,b,c;scanf("%d%d%d",&amp;a,&amp;b,&amp;c);mp[a][b]=c;	
		}else
		if(op=='B'){
			int a,b,c,d;scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);
			for(int i=a;i&lt;=c;i++)for(int j=b;j&lt;=d;j++)cant[i][j]=0;
		}else Q();
	}
	return 0;
}</pre><pre></pre><h2>Problem3209</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
const int mo=10000007;
LL N;
LL C[60][60];
LL f[60];
LL pw(LL x,LL k,LL p=mo){
	LL ans=1;
	for(;k;k&gt;&gt;=1){
		if(k&amp;1)ans=ans*x%p;
		x=x*x%p;
	}return ans;
}
int main(){
	cin&gt;&gt;N;
	for(int i=0;i&lt;60;i++){
		C[i][0]=1;	
		for(int j=1;j&lt;=i;j++)
		C[i][j]=C[i-1][j-1]+C[i-1][j];
	}
	LL ans=1,k=0;
	for(int i=60;i&gt;=0;i--)if(N&gt;&gt;i&amp;1){
		ans=ans*(k+1)%mo;
		for(int j=1;j&lt;=i;j++)
			ans=ans*pw(k+j,C[i][j])%mo;
		k++;
	}cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem3210</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1e5+5;
int n,a[maxn],b[maxn],d[8][2]={{1,0},{-1,0},{0,1},{0,-1},{1,1},{1,-1},{-1,-1},{-1,1}};
double x[maxn],y[maxn];
typedef long long LL;
LL calc(int x,int y){
	LL ans=0;
	for(int i=1;i&lt;=n;i++)
	ans+=max(abs(x-a[i]),abs(y-b[i]));
	return ans;
}
int main(){
	cin&gt;&gt;n;
	for(int i=1;i&lt;=n;i++){
		scanf("%d%d",&amp;a[i],&amp;b[i]);
		x[i]=0.5*a[i]+0.5*b[i];
		y[i]=0.5*a[i]-0.5*b[i];
	}sort(x+1,x+1+n);sort(y+1,y+1+n);
	double mx=x[(n+1)/2],my=y[(n+1)/2];
	double mx2=mx+my,my2=mx-my;
	LL ans=calc(int(mx2),int(my2));
	for(int i=0;i&lt;8;i++)ans=min(ans,calc(trunc(mx2+d[i][0]),trunc(my2+d[i][1]))); 
	cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem3211</h2><pre>#include&lt;cstdio&gt;
#include&lt;cctype&gt;
#include&lt;cmath&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#define lson i&lt;&lt;1,l,mid
#define rson i&lt;&lt;1|1,mid+1,r
#define L i&lt;&lt;1
#define R i&lt;&lt;1|1
using namespace std;
const int maxn=100010;
typedef long long lld;
lld a[maxn];
	struct node{
		lld sum,sure;
		node(){
			sum=sure=0;
		}
	};
	node t[maxn&lt;&lt;2];
struct seg_tree{
	void rz(lld i){
		t[i].sum=t[L].sum+t[R].sum;
		t[i].sure=t[R].sure&amp;&amp;t[L].sure;
	}
	void build(lld i,lld l,lld r){
		if(l==r){
			t[i].sum=a[l];
			t[i].sure=a[l]==0||a[l]==1;
			return;
		}
		lld mid=l+r&gt;&gt;1;
		build(lson);
		build(rson);
		rz(i);
	}
	void Change(lld i,lld l,lld r,lld l0,lld r0){
		if(t[i].sure)
			return;
		if(l==r){
			t[i].sum=(lld)sqrt(t[i].sum)+0.001;
			if(t[i].sum==0||t[i].sum==1)
				t[i].sure=1;
			return ;
		}
		lld mid=l+r&gt;&gt;1;
		if(l0&lt;=mid)Change(lson,l0,r0);
		if(r0&gt;mid) Change(rson,l0,r0);
		rz(i);
	}
	lld qsum(lld i,lld l,lld r,lld l0,lld r0){
		if(l0&lt;=l&amp;&amp;r0&gt;=r)
			return t[i].sum;
		lld mid=l+r&gt;&gt;1;
		lld ans=0;
		if(l0&lt;=mid)ans+=qsum(lson,l0,r0);
		if(r0&gt;mid) ans+=qsum(rson,l0,r0);
		return ans;
	}
}T;
lld getlld(){
	lld res=0,ok=0;char ch;
	while(1){
		ch=getchar();
		if(isdigit(ch)){
			res*=10;res+=ch-'0';ok=1;
		}else if(ok)break;
	}return res;
}
lld n,m;
int main(){
	n=getlld();
	for(lld i=1;i&lt;=n;i++)a[i]=getlld();
	T.build(1,1,n);
	m=getlld();
	while(m--){
		lld opt=getlld();
		if(opt==1){
			lld l=getlld(),r=getlld();
			printf("%lld\n",T.qsum(1,1,n,l,r));
		}else{
			lld l=getlld(),r=getlld();
			T.Change(1,1,n,l,r);
		}
	}
	return 0;
}</pre><pre></pre><h2>Problem3211</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=1e5+10;
typedef long long LL;
LL getint(){
	LL res=0,ok=0;char ch;
	while(ch=getchar()){
		if(isdigit(ch)){
			res*=10;res+=ch-'0';ok=1;
		}else if(ok)break;
	}return res;
}
int n,m;
LL a[maxn];
struct seg_tree{
	struct node{
		LL sum;
		bool sure;
		node(){
			sum=0;sure=0;
		}
	};
	node t[maxn&lt;&lt;2];
	#define lson i&lt;&lt;1,l,mid
	#define rson i&lt;&lt;1|1,mid+1,r
	#define L i&lt;&lt;1
	#define R i&lt;&lt;1|1
	void rz(int i){
		t[i].sum=t[L].sum+t[R].sum;
		t[i].sure= t[L].sure&amp;&amp;t[R].sure;
	}
	void build(int i,int l,int r){
		if(l==r){
			t[i].sum=a[l];
			t[i].sure= a[l]==1||a[l]==0;
			return ;
		}
		int mid=(l+r)&gt;&gt;1;
		build(lson);build(rson);
		rz(i);
	}
	void Change(int i,int l,int r,int l0,int r0){
		if(t[i].sure)return;
		if(l==r){
			t[i].sum=LL(sqrt(t[i].sum));
			t[i].sure= t[i].sum==1||t[i].sum==0;
			return ;
		}
		int mid=(l+r)&gt;&gt;1;
		if(l0&lt;=mid)Change(lson,l0,r0);
		if(r0&gt;mid) Change(rson,l0,r0);
		rz(i);
	}
	LL Qsum(int i,int l,int r,int l0,int r0){
		if(l0&lt;=l&amp;&amp;r0&gt;=r)
			return t[i].sum;
		int mid=(l+r)&gt;&gt;1;
		LL ans=0;
		if(l0&lt;=mid)ans+=Qsum(lson,l0,r0);
		if(r0&gt;mid) ans+=Qsum(rson,l0,r0);
		return ans;
	}
	#undef lson
	#undef rson
	#undef L
	#undef R
}T;
void putint(LL x){
	if(x&lt;10)
		putchar(x+'0');
	else{
		putint(x/10);
		putchar(x%10+'0');
	}
}
int main(){
	n=getint();
	for(int i=1;i&lt;=n;i++)a[i]=getint();
	T.build(1,1,n);
	m=getint();
	while(m--){
		int op=getint();
		int l=getint(),r=getint();
		if(l&gt;r)swap(l,r);
		if(op==1){
			putint(T.Qsum(1,1,n,l,r));
			puts("");
		}else{
			T.Change(1,1,n,l,r);
		}
	}
	return 0;
}</pre><pre></pre><h2>Problem3212</h2><pre>type
    rec                 =record
        left, right     :longint;
        sum, lazy       :int64;
    end;
     
var
    n, m                :longint;
    a                   :array[0..100010] of int64;
    t                   :array[0..800010] of rec;
 
procedure swap(var a,b:longint);
var
    c                   :longint;
begin
    c:=a; a:=b; b:=c;
end;
     
procedure build(x,l,r:longint);
var
    mid                 :longint;
begin
    t[x].left:=l; t[x].right:=r;
    if l=r then
    begin
        t[x].sum:=a[l];
        exit;
    end;
    with t[x] do mid:=(l+r)&gt;&gt;1;
    build(2*x,l,mid); build(2*x+1,mid+1,r);
    t[x].sum:=(t[2*x].sum+t[2*x+1].sum);
end;
 
procedure change(x,l,r:longint;y:int64);
var
    mid                 :longint;
begin
        if t[x].lazy&lt;&gt;0 then
    begin
        t[2*x].sum:=t[2*x].sum+t[x].lazy*(t[2*x].right-t[2*x].left+1);
        t[2*x].lazy:=t[2*x].lazy+t[x].lazy;
        t[2*x+1].sum:=t[2*x+1].sum+t[x].lazy*(t[2*x+1].right-t[2*x+1].left+1);
        t[2*x+1].lazy:=t[2*x+1].lazy+t[x].lazy;
        t[x].lazy:=0;
    end;
     
    if (t[x].left=l) and (t[x].right=r) then
    begin
        t[x].lazy:=y;
        t[x].sum:=t[x].sum+y*(t[x].right-t[x].left+1);
        exit;
    end;
    with t[x] do mid:=(left+right)&gt;&gt;1;
    if mid&lt;l then change(2*x+1,l,r,y) else
    if mid&gt;=r then change(2*x,l,r,y) else
    begin
        change(2*x,l,mid,y);
        change(2*x+1,mid+1,r,y);
    end;
    t[x].sum:=t[2*x].sum+t[2*x+1].sum;
end;
 
function ask(x,l,r:longint):int64;
var
    mid                 :longint;
begin
    if t[x].lazy&lt;&gt;0 then
    begin
        t[2*x].sum:=t[2*x].sum+t[x].lazy*(t[2*x].right-t[2*x].left+1);
        t[2*x].lazy:=t[2*x].lazy+t[x].lazy;
        t[2*x+1].sum:=t[2*x+1].sum+t[x].lazy*(t[2*x+1].right-t[2*x+1].left+1);
        t[2*x+1].lazy:=t[2*x+1].lazy+t[x].lazy;
        t[x].lazy:=0;
    end;
     
    if (t[x].left=l) and (t[x].right=r) then exit(t[x].sum);
     
    with t[x] do mid:=(left+right)&gt;&gt;1;
    if mid&lt;l then exit(ask(2*x+1,l,r)) else
    if mid&gt;=r then exit(ask(2*x,l,r)) else
    exit(ask(2*x,l,mid)+ask(2*x+1,mid+1,r));
end;
 
procedure init;
var
    i                   :longint;
begin
    readln(n,m);
    for i:=1 to n do read(a[i]);
    readln;
    build(1,1,n);
end;
 
procedure main;
var
    i                   :longint;
    ch                  :char;
    l, r                :longint;
    x                   :int64;
begin
    for i:=1 to m do
    begin
        read(ch);
        if ch='C' then
        begin
            readln(l,r,x);
            if l&gt;r then swap(l,r);
            change(1,l,r,x);
        end else
        begin
            readln(l,r);
            if l&gt;r then swap(l,r);
            writeln(ask(1,l,r));
        end;
    end;
end;
 
begin
    init;
    main;
end.</pre><pre></pre><h2>Problem3223</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;climits&gt;
#include&lt;cstdlib&gt;
using namespace std;
int rnd(){
	static int KEY=12345678;
	return KEY+=KEY&lt;&lt;2|1;
}
struct node;
node *Null,*root;
struct node{
	int val,size,key,lazy;
	node *c[2];
	void split(int need,node *&amp;p,node *&amp;q);
	node(int _val,node *C){
		val=_val;size=1;
		key=rnd();lazy=0;
		c[0]=c[1]=C;
	}
	void rev(){
		if(this==Null)return;
		lazy^=1;
		swap(c[0],c[1]);
	}
	node* rz(){
		size=c[0]-&gt;size+c[1]-&gt;size+1;
		return this;
	}
	void pushdown(){
		if(lazy){
			c[0]-&gt;rev();
			c[1]-&gt;rev();
			lazy=0;
		}
	}
};
node *merge(node *p,node *q){
	if(p==Null)return q-&gt;rz();
	if(q==Null)return p-&gt;rz();
	if(p-&gt;key&lt;q-&gt;key){
		p-&gt;pushdown();
		p-&gt;c[1]=merge(p-&gt;c[1],q);
		return p-&gt;rz();
	}else{
		q-&gt;pushdown();
		q-&gt;c[0]=merge(p,q-&gt;c[0]);
		return q-&gt;rz();
	}
}
void deb(node *t){
	printf("val:%d L:%d R:%d lazy:%d size:%d\n",
	t-&gt;val,t-&gt;c[0]-&gt;val,t-&gt;c[1]-&gt;val,t-&gt;lazy,t-&gt;size);
	if(t-&gt;c[0]!=Null)
	deb(t-&gt;c[0]);
	if(t-&gt;c[1]!=Null)
	deb(t-&gt;c[1]);
}
void node::split(int need,node *&amp;p,node *&amp;q){
	if(this==Null){p=Null;q=Null;return;}
	pushdown();
	//deb(this);cout&lt;&lt;endl;
	if(c[0]-&gt;size&gt;=need){
		c[0]-&gt;split(need,p,q);
		c[0]=Null;
		rz();
		q=merge(q,this);
	//	deb(q);cout&lt;&lt;endl;
		return;
	}else{
		c[1]-&gt;split(need-c[0]-&gt;size-1,p,q);
		c[1]=Null;
		pushdown();
		p=merge(this,p);
	//	deb(p);cout&lt;&lt;endl;
		return;
	}
}
struct Treap{	
	Treap(){
		Null=new node(0,0);
		Null-&gt;size=0;
		Null-&gt;c[0]=Null-&gt;c[1]=Null;
		Null-&gt;key=INT_MAX;
		root=Null;
	}
	void rev(int a,int b){
		node *p,*q,*r,*s;
		root-&gt;split(a-1,p,q);
		
	//	deb(p);
	//	cout&lt;&lt;endl;
	//	deb(q);
	//	cout&lt;&lt;endl;
		
		q-&gt;split(b-a+1,r,s);
		
	//	deb(r);
	//	cout&lt;&lt;endl;
	//	deb(s);
	//	cout&lt;&lt;endl;
				
		r-&gt;rev();
		
		
		
		root=merge(p,merge(r,s));
		root-&gt;rz();
	}
	void print(node *t){
		t-&gt;pushdown();
		if(t-&gt;c[0]!=Null)
		print(t-&gt;c[0]);
		printf("%d ",t-&gt;val);
		if(t-&gt;c[1]!=Null)
		print(t-&gt;c[1]);
	}
	void deb(node *t){
		printf("val:%d L:%d R:%d lazy:%d size:%d\n",
		t-&gt;val,t-&gt;c[0]-&gt;val,t-&gt;c[1]-&gt;val,t-&gt;lazy,t-&gt;size);
		if(t-&gt;c[0]!=Null)
		deb(t-&gt;c[0]);
		if(t-&gt;c[1]!=Null)
		deb(t-&gt;c[1]);
	}
}T;
node* newnode(int c)
{
    node* x=new node(c,Null);
    return x;
}
int n,m;
int main(){
//	freopen("1.txt","r",stdin);
//	freopen("3.txt","w",stdout);
	scanf("%d%d",&amp;n,&amp;m);
	for(int i=1;i&lt;=n;i++){
		root=merge(root,newnode(i));
	}
	//T.deb(root);
	//cout&lt;&lt;endl;
	while(m--){
		int a,b;
		scanf("%d%d",&amp;a,&amp;b);
		if(a&gt;b)swap(a,b);
		//b=b-a+1;
		T.rev(a,b);
	//	T.deb(root);
	//	cout&lt;&lt;endl;
	}
	T.print(root);
	return 0;
}</pre><pre></pre><h2>Problem3223</h2><pre>/*
	ID:zky
	OJ:BZOJ
	Index:3223
	Language:C++
*/
#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;climits&gt;
#include&lt;cstdlib&gt;
using namespace std;
int rnd(){
	static int KEY=12345678;
	return KEY+=KEY&lt;&lt;2|1;
}
struct node;
node *Null,*root;
struct node{
	int val,size,key,lazy;
	node *c[2];
	void split(int need,node *&amp;p,node *&amp;q);
	node(int _val,node *C){
		val=_val;size=1;
		key=rnd();lazy=0;
		c[0]=c[1]=C;
	}
	void rev(){
		if(this==Null)return;
		lazy^=1;
		swap(c[0],c[1]);
	}
	node* rz(){
		size=c[0]-&gt;size+c[1]-&gt;size+1;
		return this;
	}
	void pushdown(){
		if(lazy){
			c[0]-&gt;rev();
			c[1]-&gt;rev();
			lazy=0;
		}
	}
};
node *merge(node *p,node *q){
	if(p==Null)return q-&gt;rz();
	if(q==Null)return p-&gt;rz();
	if(p-&gt;key&lt;q-&gt;key){
		p-&gt;pushdown();
		p-&gt;c[1]=merge(p-&gt;c[1],q);
		return p-&gt;rz();
	}else{
		q-&gt;pushdown();
		q-&gt;c[0]=merge(p,q-&gt;c[0]);
		return q-&gt;rz();
	}
}
void deb(node *t){
	printf("val:%d L:%d R:%d lazy:%d size:%d\n",
	t-&gt;val,t-&gt;c[0]-&gt;val,t-&gt;c[1]-&gt;val,t-&gt;lazy,t-&gt;size);
	if(t-&gt;c[0]!=Null)
	deb(t-&gt;c[0]);
	if(t-&gt;c[1]!=Null)
	deb(t-&gt;c[1]);
}
void node::split(int need,node *&amp;p,node *&amp;q){
	if(this==Null){p=Null;q=Null;return;}
	pushdown();
	//deb(this);cout&lt;&lt;endl;
	if(c[0]-&gt;size&gt;=need){
		c[0]-&gt;split(need,p,q);
		c[0]=Null;
		rz();
		q=merge(q,this);
	//	deb(q);cout&lt;&lt;endl;
		return;
	}else{
		c[1]-&gt;split(need-c[0]-&gt;size-1,p,q);
		c[1]=Null;
		pushdown();
		p=merge(this,p);
	//	deb(p);cout&lt;&lt;endl;
		return;
	}
}
struct Treap{	
	Treap(){
		Null=new node(0,0);
		Null-&gt;size=0;
		Null-&gt;c[0]=Null-&gt;c[1]=Null;
		Null-&gt;key=INT_MAX;
		root=Null;
	}
	void rev(int a,int b){
		node *p,*q,*r,*s;
		root-&gt;split(a-1,p,q);
		
	//	deb(p);
	//	cout&lt;&lt;endl;
	//	deb(q);
	//	cout&lt;&lt;endl;
		
		q-&gt;split(b-a+1,r,s);
		
	//	deb(r);
	//	cout&lt;&lt;endl;
	//	deb(s);
	//	cout&lt;&lt;endl;
				
		r-&gt;rev();
		
		
		
		root=merge(p,merge(r,s));
		root-&gt;rz();
	}
	void print(node *t){
		t-&gt;pushdown();
		if(t-&gt;c[0]!=Null)
		print(t-&gt;c[0]);
		printf("%d ",t-&gt;val);
		if(t-&gt;c[1]!=Null)
		print(t-&gt;c[1]);
	}
	void deb(node *t){
		printf("val:%d L:%d R:%d lazy:%d size:%d\n",
		t-&gt;val,t-&gt;c[0]-&gt;val,t-&gt;c[1]-&gt;val,t-&gt;lazy,t-&gt;size);
		if(t-&gt;c[0]!=Null)
		deb(t-&gt;c[0]);
		if(t-&gt;c[1]!=Null)
		deb(t-&gt;c[1]);
	}
}T;
node* newnode(int c)
{
    node* x=new node(c,Null);
    return x;
}
int n,m;
int main(){
//	freopen("1.txt","r",stdin);
//	freopen("3.txt","w",stdout);
	scanf("%d%d",&amp;n,&amp;m);
	for(int i=1;i&lt;=n;i++){
		root=merge(root,newnode(i));
	}
	//T.deb(root);
	//cout&lt;&lt;endl;
	while(m--){
		int a,b;
		scanf("%d%d",&amp;a,&amp;b);
		if(a&gt;b)swap(a,b);
		//b=b-a+1;
		T.rev(a,b);
	//	T.deb(root);
	//	cout&lt;&lt;endl;
	}
	T.print(root);
	return 0;
}</pre><pre></pre><h2>Problem3224</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;climits&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
const int INF=INT_MAX;
int KEY=12345678;
int rnd(){
	return KEY+=KEY&lt;&lt;2|1;
}
typedef pair&lt;int,int&gt; pii;
struct Treap{
	struct node{
		int val;int key,size,s;
		node *c[2];
		node(int _val,node *C){
			val=_val;key=rand();
			size=1;s=1;
			c[0]=c[1]=C;
		}
		void rz(){
			size=c[0]-&gt;size+c[1]-&gt;size+s;
		}
	};
	node *root,*Null;
	Treap(){
		Null=new node(0,0);
		Null-&gt;size=0;Null-&gt;key=INF;Null-&gt;val=0;
		Null-&gt;c[0]=Null-&gt;c[1]=Null;
		root=Null;
	}
	void rot(node *&amp;t,bool d){
		node *p=t-&gt;c[d];
		t-&gt;c[d]=p-&gt;c[!d];
		p-&gt;c[!d]=t;
		t-&gt;rz();p-&gt;rz();
		t=p;
	}
	void _insert(node *&amp;t,int x){
		if(t==Null){
			t=new node(x,Null);
			return ;
		}	
		if(t-&gt;val==x){
			t-&gt;s++;
			t-&gt;size++;
			return;
		}
		bool d=x&gt;t-&gt;val;
		_insert(t-&gt;c[d],x);
		if(t-&gt;c[d]-&gt;key&lt;t-&gt;key)
			rot(t,d);
		else
		 	t-&gt;rz();
	}
	/*
	void insert(int &amp;k,int x){
	if(k==0){
		tr[k=++size].rnd=rand();
		tr[k].num=x;
		tr[k].s=tr[k].w=1;
		return;
	}
	tr[k].s++;
	if(tr[k].num==x)tr[k].w++;
	else if(x&lt;tr[k].num){
		insert(tr[k].l,x);
		if(tr[tr[k].l].rnd&lt;tr[k].rnd)
			rrotate(k);
	}
	else{
		insert(tr[k].r,x);
		if(tr[tr[k].r].rnd&lt;tr[k].rnd)
			lrotate(k);
	}
}
	*/
	void _Delete(node *&amp;t,int x){
		if(t==Null)return;
		if(t-&gt;val==x){
			if(t-&gt;s&gt;1){
				t-&gt;s--;
				t-&gt;size--;
				return;
			}
			bool d=t-&gt;c[1]-&gt;key&lt;t-&gt;c[0]-&gt;key;
			if(t-&gt;c[d]==Null){
				delete t;
				t=Null;
				return ;
			}
			rot(t,d);
			_Delete(t-&gt;c[!d],x);
		}else{
			bool d=x&gt;t-&gt;val;
			_Delete(t-&gt;c[d],x);
		}
		t-&gt;rz();
	}
	/*
	
void del(int &amp;k,int x){
	if(k==0)return;
	else if(tr[k].num==x){
		if(tr[k].w&gt;1){tr[k].w--;tr[k].s--;return;}
		else if(tr[k].l*tr[k].r==0)k=tr[k].l+tr[k].r;
		else if(tr[tr[k].l].rnd&lt;tr[tr[k].r].rnd){
			rrotate(k);del(k,x);
		}
		else{
			lrotate(k);del(k,x);
		}
	}
	else if(x&gt;tr[k].num){
		tr[k].s--;
		del(tr[k].r,x);
	}
	else{
		tr[k].s--;
		del(tr[k].l,x);
	}
}
	*/
	int _kth(node *&amp;t,int x){
		int r=t-&gt;c[0]-&gt;size;
		if(t==Null)return 0;
		else if(x&lt;=r)return _kth(t-&gt;c[0],x);
		else if(x&gt;r+t-&gt;s)return _kth(t-&gt;c[1],x-r-t-&gt;s);
		else return t-&gt;val;
	}
	int _rank(node *&amp;t,int x){
		int r=t-&gt;c[0]-&gt;size;
		if(t==Null)return 0;
		else if(x==t-&gt;val)return r+1;
		else if(x&gt;t-&gt;val)return r+t-&gt;s+_rank(t-&gt;c[1],x);
		else return _rank(t-&gt;c[0],x); 
	}
/*
int ask_rank(int k,int x){
	if(k==0)return 0;
	else if(x==tr[k].num)return r+1;
	else if(x&gt;tr[k].num)return r+tr[k].w+ask_rank(tr[k].r,x);
	else return ask_rank(tr[k].l,x);
}
int ask_num(int k,int x){
	if(k==0)return 0;
	else if(x&lt;=tr[tr[k].l].s)return ask_num(tr[k].l,x);
	else if(x&gt;tr[tr[k].l].s+tr[k].w)return ask_num(tr[k].r,x-tr[tr[k].l].s-tr[k].w);
	else return tr[k].num;
}
*/	
	void _deb(node *&amp;t){
		printf("val:%d L:%d R:%d\n",t-&gt;val,t-&gt;c[0]-&gt;val,t-&gt;c[1]-&gt;val);
		//printf("key:%d L:%d R:%d\n",t-&gt;key,t-&gt;c[0]-&gt;key,t-&gt;c[1]-&gt;key);
		printf("size:%d L:%d R:%d\n",t-&gt;size,t-&gt;c[0]-&gt;size,t-&gt;c[1]-&gt;size);
		if(t-&gt;c[0]!=Null)_deb(t-&gt;c[0]);
		if(t-&gt;c[1]!=Null)_deb(t-&gt;c[1]);
	}
	void deb(){_deb(root);puts("");}
	void insert(int x){_insert(root,x);}
	void del(int x){_Delete(root,x);}
	int kth(int x){return _kth(root,x);}
	int rank(int x){return _rank(root,x);}
	int size(){return root-&gt;size;}
	int _prev(node *&amp;t,int x){
		if(t==Null)return INT_MIN;
		if(x&lt;=t-&gt;val)return _prev(t-&gt;c[0],x);
		return max(t-&gt;val,_prev(t-&gt;c[1],x));
	}
	int _next(node *&amp;t,int x){
		if(t==Null)return INT_MAX;
		if(x&gt;=t-&gt;val)return _next(t-&gt;c[1],x);
		return min(t-&gt;val,_next(t-&gt;c[0],x));
	}
	int prev(int x){
		return _prev(root,x);
	}
	int next(int x){
		return _next(root,x);
	} 
}T;
int main(){
//	freopen("1.txt","r",stdin);
//	freopen("3.txt","w",stdout);
	srand(12121);
	int n,m;
	scanf("%d",&amp;n);m=n;
	while(n--){
		int opt,x;
		scanf("%d",&amp;opt);
		switch(opt){
			case 1:
				scanf("%d",&amp;x);
				T.insert(x);
				break;
			case 2:
				scanf("%d",&amp;x);
				T.del(x);
				break;
			case 3:
				scanf("%d",&amp;x);
				printf("%d\n",T.rank(x));
				break;
			case 4:				
				scanf("%d",&amp;x);
				printf("%d\n",T.kth(x));
				break;
			case 5:
				scanf("%d",&amp;x);
				printf("%d\n",T.prev(x));
				break;
			case 6:
				scanf("%d",&amp;x);
				printf("%d\n",T.next(x));
				break;	
		}
		//T.deb();
	}
	return 0;
}</pre><pre></pre><h2>Problem3224</h2><pre>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;cstdlib&gt;
#include&lt;set&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#define inf 1000000000
using namespace std;
inline int read()
{
    int x=0,f=1;char ch=getchar();
    while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
int n;
vector&lt;int&gt; a;
void insert(int x)
{
	a.insert(upper_bound(a.begin(),a.end(),x),x);
	return;
}
void del(int x)
{
	a.erase(lower_bound(a.begin(),a.end(),x));
	return;
}
inline int find(int x)
{
	return lower_bound(a.begin(),a.end(),x)-a.begin()+1;
}
int main()
{
	n=read();
	a.reserve(200000);
	int f,x;
	for(int i=1;i&lt;=n;i++)
	{
		f=read();x=read();
		switch(f)
		{
		case 1:insert(x);break;
		case 2:del(x);break;
		case 3:printf("%d\n",find(x));break;
		case 4:printf("%d\n",a[x-1]);break;
		case 5:printf("%d\n",*--lower_bound(a.begin(),a.end(),x));break;
		case 6:printf("%d\n",*upper_bound(a.begin(),a.end(),x));break;
		}
	}
	return 0;
}</pre><pre></pre><h2>Problem3224</h2><pre>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;cstdlib&gt;
#include&lt;set&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#define inf 1000000000
using namespace std;
inline int read()
{
    int x=0,f=1;char ch=getchar();
    while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
int n;
multiset&lt;int&gt; q;
vector&lt;int&gt; a;
void insert(int x)
{
    q.insert(x);
    a.insert(upper_bound(a.begin(),a.end(),x),x);
    return;
}
void del(int x)
{
    q.erase(q.find(x));
    a.erase(lower_bound(a.begin(),a.end(),x));
    return;
}
inline int find(int x)
{
    return lower_bound(a.begin(),a.end(),x)-a.begin()+1;
}
int main()
{
    a.reserve(200000);
    n=read();
    int f,x;
    for(int i=1;i&lt;=n;i++)
    {
        f=read();x=read();
        switch(f)
        {
        case 1:insert(x);break;
        case 2:del(x);break;
        case 3:printf("%d\n",find(x));break;
        case 4:printf("%d\n",a[x-1]);break;
        case 5:printf("%d\n",*--q.lower_bound(x));break;
        case 6:printf("%d\n",*q.upper_bound(x));break;
        }
    }
    return 0;
}</pre><pre></pre><h2>Problem3224</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
struct Treap{
	struct node{
		int val,key,size,s;
		node *c[2];
		node(int _val=0,node *C=0){
			val=_val;key=rand();
			size=s=1;c[0]=c[1]=C;
		}void rz(){
			size=c[0]-&gt;size+s+c[1]-&gt;size;
		}
	}*root,*Null;
	Treap(){
		Null=new node(0,0);
		Null-&gt;size=Null-&gt;s=0;Null-&gt;key=INT_MAX;
		Null-&gt;c[0]=Null-&gt;c[1]=Null;root=Null;
	}
	void rot(node *&amp;t,bool d){
		node *p=t-&gt;c[d];t-&gt;c[d]=p-&gt;c[!d];
		p-&gt;c[!d]=t;t-&gt;rz();p-&gt;rz();t=p;
	}
	void _insert(node *&amp;t,int x){
		if(t==Null){t=new node(x,Null);return;}
		if(t-&gt;val==x){t-&gt;s++;t-&gt;size++;return;}
		_insert(t-&gt;c[x&gt;t-&gt;val],x);
		if(t-&gt;c[x&gt;t-&gt;val]-&gt;key&lt;t-&gt;key)
		rot(t,x&gt;t-&gt;val);else t-&gt;rz();
	}
	void _del(node *&amp;t,int x){
		if(t-&gt;val==x){
			if(t-&gt;s&gt;1){t-&gt;s--;t-&gt;size--;return;}
			bool d=t-&gt;c[0]-&gt;key&gt;t-&gt;c[1]-&gt;key;
			if(t-&gt;c[d]==Null){delete t;t=Null;return;}	
			rot(t,d);_del(t-&gt;c[!d],x);
		}else _del(t-&gt;c[x&gt;t-&gt;val],x);t-&gt;rz();
	}
	int _kth(node *t,int x){
		int r=t-&gt;c[0]-&gt;size;
		if(x&lt;=r)return _kth(t-&gt;c[0],x);
		else if(x&gt;r+t-&gt;s) return _kth(t-&gt;c[1],x-r-t-&gt;s);
		return t-&gt;val;
	}
	int _rank(node *t,int x){
		int r=t-&gt;c[0]-&gt;size;
		if(x&lt;t-&gt;val)return _rank(t-&gt;c[0],x);
		else if(x&gt;t-&gt;val)return _rank(t-&gt;c[1],x)+r+t-&gt;s;
		return r;
	}
	int _prev(node *t,int x){
		if(t==Null)return INT_MIN;
		if(x&lt;=t-&gt;val)return _prev(t-&gt;c[0],x);
		return max(t-&gt;val,_prev(t-&gt;c[1],x));
	}
	int _next(node *t,int x){
		if(t==Null)return INT_MAX;
		if(x&gt;=t-&gt;val)return _next(t-&gt;c[1],x);
		return min(t-&gt;val,_next(t-&gt;c[0],x));
	}
	void insert(int x){_insert(root,x);}
	void del(int x){_del(root,x);}
	int kth(int x){return _kth(root,x);}
	int rank(int x){return _rank(root,x);}
	int prev(int x){return _prev(root,x);}
	int next(int x){return _next(root,x);}
}T;
int main(){  
    srand(12121);  
    int n,m;  
    scanf("%d",&amp;n);m=n;  
    while(n--){  
        int opt,x;  
        scanf("%d",&amp;opt);  
        switch(opt){  
            case 1:  
                scanf("%d",&amp;x);  
                T.insert(x);  
                break;  
            case 2:  
                scanf("%d",&amp;x);  
                T.del(x);  
                break;  
            case 3:  
                scanf("%d",&amp;x);  
                printf("%d\n",T.rank(x)+1);  
                break;  
            case 4:               
                scanf("%d",&amp;x);  
                printf("%d\n",T.kth(x));  
                break;  
            case 5:  
                scanf("%d",&amp;x);  
                printf("%d\n",T.prev(x));  
                break;  
            case 6:  
                scanf("%d",&amp;x);  
                printf("%d\n",T.next(x));  
                break;    
        }  
    }  
    return 0;  
}  </pre><pre></pre><h2>Problem3226</h2><pre>#include&lt;bits/stdc++.h&gt;
#define lson i&lt;&lt;1,l,mid
#define rson i&lt;&lt;1|1,mid+1,r
#define L i&lt;&lt;1
#define R i&lt;&lt;1|1
using namespace std;
const int maxn=65535*2+10;
int n=65535*2+1;
short a[maxn];
struct seg{
	struct node{
		short col,lazy,rev;
		node():col(0),lazy(-1),rev(0){};
	}t[maxn&lt;&lt;2];
	void pushdown(int i){
		if(t[i].rev){
			t[L].rev^=1;t[L].col^=1;
			if(~t[L].lazy)t[L].lazy^=1;
			
			t[R].rev^=1;t[R].col^=1;
			if(~t[R].lazy)t[R].lazy^=1;
			
			t[i].rev=0;
		}	
		if(t[i].lazy!=-1){
			t[L].lazy=t[R].lazy=t[i].lazy;
			t[L].col=t[R].col=t[i].lazy;
			t[i].lazy=-1;
		}
	}
	void Cov(int i,int l,int r,int l0,int r0,int col){
		if(l0&gt;r0)return;
		if(l0&lt;=l&amp;&amp;r0&gt;=r){
			t[i].col=col;
			t[i].lazy=col;
			return;
		}int mid=(l+r)&gt;&gt;1;
		pushdown(i);
		if(l0&lt;=mid)Cov(lson,l0,r0,col);
		if(r0&gt;mid)Cov(rson,l0,r0,col);
	}
	void Rev(int i,int l,int r,int l0,int r0){
		if(l0&gt;r0)return;
		if(l0&lt;=l&amp;&amp;r0&gt;=r){
			t[i].col^=1;
			if(~t[i].lazy)t[i].lazy^=1;
			t[i].rev^=1;
			return;
		}int mid=(l+r)&gt;&gt;1;
		pushdown(i);
		if(l0&lt;=mid)Rev(lson,l0,r0);
		if(r0&gt;mid)Rev(rson,l0,r0);
	}
	void print(int i,int l,int r){
		if(l==r){a[l]=t[i].col;return;}
		int mid=(l+r)&gt;&gt;1;
		pushdown(i);
		print(lson);print(rson);
	}
}T;
#undef L
#undef R
struct segment{
	int l,r;
	char L,R;
}anss[maxn];
int size;
int main(){
	//Attention!!!
	//	n=22;
	//Attention!!!
	char op[2];
	int l,r;char L,R;
	while(~scanf("%s %c%d,%d%c",op,&amp;L,&amp;l,&amp;r,&amp;R)){
		l&lt;&lt;=1;r&lt;&lt;=1;
		l++;r++;
		l+=L=='(';r-=R==')';
//		if(l&gt;r)continue;
		if(op[0]=='U')T.Cov(1,1,n,l,r,1);
		else if(op[0]=='I')T.Cov(1,1,n,1,l-1,0),T.Cov(1,1,n,r+1,n,0);
		else if(op[0]=='D')T.Cov(1,1,n,l,r,0);
		else if(op[0]=='C')T.Cov(1,1,n,1,l-1,0),T.Cov(1,1,n,r+1,n,0),T.Rev(1,1,n,l,r);
		else if(op[0]=='S')T.Rev(1,1,n,l,r);	
		
//		T.print(1,1,n);
		
	}T.print(1,1,n);
	for(int i=1;i&lt;=n;i++){
		int j=i-1;
		if(!a[i-1]&amp;&amp;a[i]){
			size++;
			anss[size].l=j/2;
			anss[size].L=j%2==0?'[':'(';
		}
		if(a[i]&amp;&amp;!a[i+1]){
			anss[size].r=j/2+j%2;
			anss[size].R=j%2==0?']':')';		
		}
	}
	if(!size)printf("empty set");
	for(int i=1;i&lt;=size;i++){
		//if(anss[i].l==anss[i].r&amp;&amp;(anss[i].L=='('||anss[i].R==')'))continue;
		printf("%c%d,%d%c",anss[i].L,anss[i].l,anss[i].r,anss[i].R);if(i-size)putchar(' ');
	}
	return 0;
}</pre><pre></pre><h2>Problem3231</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
LL K,b[20],c[20];
LL n,m,p;
struct mat{
	LL M[20][20];
	void init(){
		for(LL i=0;i&lt;=K;i++)M[i][i]=1;
	}void clear(){
		memset(M,0,sizeof M);
	}mat operator*(const mat &amp;X){
		mat c;c.clear();
		for(LL k=0;k&lt;=K;k++)
		for(LL i=0;i&lt;=K;i++)
		for(LL j=0;j&lt;=K;j++)
		c.M[i][j]+=M[i][k]*X.M[k][j],
		c.M[i][j]%=p;
		return c;
	}
	mat operator%(const LL &amp;p){
		for(LL i=0;i&lt;=K;i++)for(LL j=0;j&lt;=K;j++)
		M[i][j]%=p;return *this;
	}
	void set(LL x,LL y,LL v){
		M[x][y]=v;
	}	
	LL get(LL x,LL y){
		return M[x][y];
	}
};
mat power(mat x,LL k,LL p){
	mat ans;ans.clear();ans.init();
	for(;k;k&gt;&gt;=1){
		if(k&amp;1)ans=(ans*x)%p;
		x=(x*x)%p;
	}return ans%p;
}
LL getans(LL ps){
	LL ans=0,sum=0;
	if(ps&lt;=K){
		for(LL i=1;i&lt;=ps;i++)
		ans=(ans+b[i])%p;
		return ans;
	}
	mat x;x.clear();
	for(LL i=0;i&lt;=K;i++)for(LL j=0;j&lt;=K;j++){
		if(i==0&amp;&amp;j==0)x.set(i,j,1);
		if(i==0&amp;&amp;j&gt;0)x.set(i,j,c[j]);
		if(i==1&amp;&amp;j&gt;0)x.set(i,j,c[j]);
		if(i&gt;1)x.set(i,j,i==(j+1));
	}for(LL i=1;i&lt;=K;i++)sum=(sum+b[i])%p;
	x=power(x,ps-K,p);
	ans=x.get(0,0)*sum%p;
	for(LL i=1;i&lt;=K;i++)
		ans=(ans+x.get(0,i)*b[K-i+1]%p)%p;
	return ans;
}
int main(){
	cin&gt;&gt;K;
	for(LL i=1;i&lt;=K;i++)cin&gt;&gt;b[i];
	for(LL i=1;i&lt;=K;i++)cin&gt;&gt;c[i];
	cin&gt;&gt;m&gt;&gt;n&gt;&gt;p;
	for(LL i=1;i&lt;=K;i++)b[i]%=p,c[i]%=p;
	cout&lt;&lt;(getans(n)-getans(m-1)+p)%p&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem3232</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=55;
const double eps=1e-5;
int n,m;
int A[maxn][maxn];
int B[maxn][maxn];
int C[maxn][maxn];
struct edge{
	int u,v;
	double cap,flow;
};
vector&lt;edge&gt;edges;
vector&lt;int&gt;G[maxn*maxn];
int d[maxn*maxn];
int s,t;
int dcmp(double x){return (x&gt;eps)-(x&lt;-eps);}
void add(int u,int v,double cap){
//	cerr&lt;&lt;u&lt;&lt;" "&lt;&lt;v&lt;&lt;" "&lt;&lt;cap&lt;&lt;endl;
	edges.push_back((edge){u,v,cap,0});
	G[u].push_back(edges.size()-1);
	edges.push_back((edge){v,u,0,0});
	G[v].push_back(edges.size()-1);
}
bool bfs(){
	static int vis[maxn*maxn];
	memset(vis,0,sizeof vis);
	queue&lt;int&gt;q;q.push(s);vis[s]=1;d[s]=0;
	while(!q.empty()){
		int u=q.front();q.pop();
		for(int i=0;i&lt;G[u].size();i++){
			edge e=edges[G[u][i]];
			if(vis[e.v]||!dcmp(e.cap-e.flow))continue;
			vis[e.v]=1;d[e.v]=d[u]+1;q.push(e.v);
		}
	}return vis[t];
}
int cur[maxn*maxn];
double dfs(int x,double a){
	if(x==t||!dcmp(a))return a;
	double flow=0,f;
	for(int &amp;i=cur[x];i&lt;G[x].size();i++){
		edge e=edges[G[x][i]];
		if(d[e.v]==d[x]+1&amp;&amp;(f=dfs(e.v,min(a,e.cap-e.flow)))&gt;eps){
			flow+=f;
			a-=f;
			edges[G[x][i]].flow+=f;
			edges[G[x][i]^1].flow-=f;
			if(!dcmp(a))break;
		}
	}if(!dcmp(flow))d[x]=-1;
	return flow;
}
double dinic(){
	double flow=0,x;
	while(bfs()){
		memset(cur,0,sizeof cur);
		while(dcmp(x=dfs(s,1e9))){
			flow+=x;
			memset(cur,0,sizeof cur);
		}
	}return flow;
}
int mp[51][51],tot;
void make(double x){
	s=0;t=maxn*maxn-1;int tt=t-1;
	edges.clear();
	for(int i=0;i&lt;maxn*maxn;i++)G[i].clear();
	for(int i=1;i&lt;=n;i++)
	for(int j=1;j&lt;=m;j++)
		add(s,mp[i][j],A[i][j]);
	for(int i=1;i&lt;=n+1;i++)
	for(int j=1;j&lt;=m;j++){
		int u=i!=1?mp[i-1][j]:tt;
		int v=i!=n+1?mp[i][j]:tt;
		double w=x*B[i-1][j];
		add(u,v,w);add(v,u,w);
	}
	for(int i=1;i&lt;=n;i++)
	for(int j=1;j&lt;=m+1;j++){
		int u=j!=1?mp[i][j-1]:tt;
		int v=j!=m+1?mp[i][j]:tt;
		double w=x*C[i][j-1];
		add(u,v,w);add(v,u,w);
	}add(tt,t,1e9);

}
int main(){
	scanf("%d%d",&amp;n,&amp;m);
	for(int i=1;i&lt;=n;i++)
	for(int j=1;j&lt;=m;j++)
	scanf("%d",&amp;A[i][j]);
	for(int i=0;i&lt;=n;i++)
	for(int j=1;j&lt;=m;j++)
	scanf("%d",&amp;B[i][j]);
	for(int i=1;i&lt;=n;i++)
	for(int j=0;j&lt;=m;j++)
	scanf("%d",&amp;C[i][j]);
	for(int i=1;i&lt;=n;i++)
	for(int j=1;j&lt;=m;j++)
		mp[i][j]=++tot;
	double sum=accumulate(&amp;A[0][0],(&amp;A[n][m])+1,0.0);
	double l=0,r=250000;
	//!!!
//	r=2;

	while(dcmp(r-l)){
		double mid=(l+r)/2;

		//!!!
		//mid=3;

		make(mid);
		double mf=dinic();
		if(sum-mf&gt;0)
			l=mid;
		else r=mid;
	}printf("%.3lf\n",l);
	return 0;
}</pre><pre></pre><h2>Problem3236</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
#define maxn 100010
#define maxm 1000010
#define lowbit(x) (x&amp;(-x))
using namespace std;
void Read(int &amp;digit)
{
	digit=0;
	char c;
	for(c=getchar();c&lt;'0'||c&gt;'9';c=getchar());
	for(;c&gt;='0'&amp;&amp;c&lt;='9';digit=digit*10+c-'0',c=getchar());
}
int limit,n,m,seq[maxn];
int Sum1[maxn],Sum2[maxn];
void Insert1(int p,int v)
{
	for(int i=p;i&lt;=n;i+=lowbit(i))
		Sum1[i]+=v;
}
void Insert2(int p,int v)
{
	for(int i=p;i&lt;=n;i+=lowbit(i))
		Sum2[i]+=v;
}
int Query1(int p)
{
	int ans=0;
	for(int i=p;i;i-=lowbit(i))
		ans+=Sum1[i];
	return ans;
}
int Query2(int p)
{
	int ans=0;
	for(int i=p;i;i-=lowbit(i))
		ans+=Sum2[i];
	return ans;
}
struct Question
{
	int l,r,a,b,ans1,ans2,id;
	friend bool operator &lt; (const Question &amp;a,const Question &amp;b)
	{
		return a.l/limit&lt;b.l/limit||(a.l/limit==b.l/limit&amp;&amp;a.r&lt;b.r);
	}
}q[maxm];
bool cmp_id(const Question &amp;a,const Question &amp;b)
{
	return a.id&lt;b.id;
}
void read()
{
	Read(n),Read(m);
	limit=sqrt(n);
	for(int i=1;i&lt;=n;i++)
		Read(seq[i]);
	for(int i=1;i&lt;=m;i++)
	{
		Read(q[i].l),Read(q[i].r),Read(q[i].a),Read(q[i].b);
		q[i].id=i;
	}
	sort(q+1,q+m+1);
}
int sum[maxn];
void Insert(int p)
{
	Insert1(p,1);
	sum[p]++;
	if(sum[p]==1)
		Insert2(p,1);
}
void Delete(int p)
{
	Insert1(p,-1);
	sum[p]--;
	if(sum[p]==0)
		Insert2(p,-1);
}
void Mo_Algorithm()
{
	for(int i=1,l=1,r=0;i&lt;=m;i++)
	{
		if(r&lt;q[i].r)
		{
			for(r=r+1;r&lt;=q[i].r;r++)
				Insert(seq[r]);
			r--;
		}
		if(r&gt;q[i].r)
			for(;r&gt;q[i].r;r--)
				Delete(seq[r]);
		if(l&lt;q[i].l)
			for(;l&lt;q[i].l;l++)
				Delete(seq[l]);
		if(l&gt;q[i].l)
		{
			for(l=l-1;l&gt;=q[i].l;l--)
				Insert(seq[l]);
			l++;
		}
		q[i].ans1=Query1(q[i].b)-Query1(q[i].a-1);
		q[i].ans2=Query2(q[i].b)-Query2(q[i].a-1);
	}
}
void print()
{
	sort(q+1,q+m+1,cmp_id);
	for(int i=1;i&lt;=m;i++)
		printf("%d %d\n",q[i].ans1,q[i].ans2);
}
int main()
{
	read();
	Mo_Algorithm();
	print();
	return 0;
}
</pre><pre></pre><h2>Problem3236</h2><pre>#include&lt;bits/stdc++.h&gt;
#define lowbit(x) (x&amp;-x)
using namespace std;
const int maxn=1e5+5;
int n,m,sqrtn,a[maxn];
int vis[maxn],pos[maxn],ans1[maxn*10],ans2[maxn*10];
int d1[maxn],d2[maxn];
void read(int &amp;res){
    res=0;char c=getchar();for(;!isdigit(c);c=getchar());
    for(;isdigit(c);res=res*10+c-'0',c=getchar());
}
inline int get1(int x){int o=0;while(x)o+=d1[x],x-=lowbit(x);return o;};
inline void updata1(int x,int f){while(x&lt;=n)d1[x]+=f,x+=lowbit(x);}
inline int get2(int x){int o=0;while(x)o+=d2[x],x-=lowbit(x);return o;};
inline void updata2(int x,int f){while(x&lt;=n)d2[x]+=f,x+=lowbit(x);}
struct qes{
    int l,r,a,b,id;
    inline bool operator&lt;(const qes oth)const{
        return pos[l]&lt;pos[oth.l]||(pos[l]==pos[oth.l]&amp;&amp;r&lt;oth.r);
    }
}q[maxn*10];
int main(){
 // freopen("in","r",stdin);
 // freopen("out","w",stdout);
    read(n);read(m);
    sqrtn=sqrt(n);
    for(int i=1;i&lt;=n;++i)read(a[i]);
    for(int i=1;i&lt;=n;++i)pos[i]=i/sqrtn;
    for(int i=1;i&lt;=m;i++){
        read(q[i].l);read(q[i].r);
        read(q[i].a);read(q[i].b);q[i].id=i;
    }sort(q+1,q+1+m);
    int L=1,R=1;
    updata1(a[1],1);
    updata2(a[1],1);
    vis[a[1]]++;
    for(int i=1;i&lt;=m;i++){
//      if(i%100==0)
//      cerr&lt;&lt;clock()/(double)CLOCKS_PER_SEC&lt;&lt;endl;
        while(L&gt;q[i].l){
            L--;
            updata1(a[L],1);
            if(!vis[a[L]])updata2(a[L],1);
            vis[a[L]]++;
        }               
        while(R&lt;q[i].r){
            R++;
            updata1(a[R],1);
            if(!vis[a[R]])updata2(a[R],1);
            vis[a[R]]++;        
        }   
        while(L&lt;q[i].l){
            updata1(a[L],-1);
            if(!--vis[a[L]])updata2(a[L],-1);
            L++;
        }       
        while(R&gt;q[i].r){
            updata1(a[R],-1);
            if(!--vis[a[R]])updata2(a[R],-1);
            R--;        
        }           
        ans1[q[i].id]=get1(q[i].b)-get1(q[i].a-1);
        ans2[q[i].id]=get2(q[i].b)-get2(q[i].a-1);
    }
    for(int i=1;i&lt;=m;i++)
    printf("%d %d\n",ans1[i],ans2[i]);
   // cerr&lt;&lt;clock()/(double)CLOCKS_PER_SEC&lt;&lt;endl;
}</pre><pre></pre><h2>Problem3236</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
using namespace std;
#include&lt;algorithm&gt;
int mb[100005],qb[100005],start[320],end[320];
int now[100005],shunum[320],zhinum[320];
int a[100005];
struct QS{
	int l,r,a,b,i;
	inline bool operator &lt; (const QS &amp;o)const{
		return mb[l]!=mb[o.l]?l&lt;o.l:r&lt;o.r;
	}
}q[1000005];
int ansshu[1000005],anszhi[1000005];
char * ptr=(char *)malloc(30000000);
inline void in(int &amp;x){
	x=0;
	while(*ptr&lt;'0'||*ptr&gt;'9')++ptr;
	while(*ptr&gt;='0'&amp;&amp;*ptr&lt;='9')x=x*10+(*ptr++^'0');
}
inline void out(int x){
	if(!x)putchar('0');
	else{
		if(x&gt;=10)out(x/10);
		putchar('0'^x%10);
	}
}
inline void update(int node,int delta){
	zhinum[qb[node]]-=(bool)now[node];
	now[node]+=delta,shunum[qb[node]]+=delta;
	zhinum[qb[node]]+=(bool)now[node];
	//if(qb[node]==4)cout&lt;&lt;"5!:"&lt;&lt;now[node]&lt;&lt;":"&lt;&lt;shunum[qb[node]]&lt;&lt;","&lt;&lt;zhinum[qb[node]]&lt;&lt;endl;
	//cout&lt;&lt;node&lt;&lt;"-&gt;"&lt;&lt;now[node]&lt;&lt;endl;
}
int main(){
	fread(ptr,1,30000000,stdin);
	int n,m,i,k,j;
	for(i=0,k=0;i&lt;=100000;i+=100,++k)
		for(j=i+100;j&gt;i;--j)
			mb[j]=k;
	for(i=0,k=0;i&lt;=100000;i+=316,++k){
		for(j=min(i+316,100000);j&gt;i;--j)qb[j]=k;
		start[k]=i+1,end[k]=min(i+316,100000);
	}
	/*for(i=0,k=0;i&lt;=100;i+=6,++k){
		for(j=min(i+6,100);j&gt;i;--j)qb[j]=k;
		start[k]=i+1,end[k]=min(i+6,100);
	}*/
	in(n),in(m);
	for(i=1;i&lt;=n;++i)in(a[i]);
	for(i=m;i--;)in(q[i].l),in(q[i].r),in(q[i].a),in(q[i].b),q[i].i=i;
	sort(q,q+m);
	int l=1,r=1;
	now[a[1]]=shunum[qb[a[1]]]=zhinum[qb[a[1]]]=1;
	for(i=0;i&lt;m;++i){
		if(q[i].a&gt;n)continue;
		/*cout&lt;&lt;"-----"&lt;&lt;q[i].l&lt;&lt;","&lt;&lt;q[i].r&lt;&lt;" "&lt;&lt;q[i].a&lt;&lt;","&lt;&lt;q[i].b&lt;&lt;"-----\n";
		cout&lt;&lt;"["&lt;&lt;l&lt;&lt;","&lt;&lt;r&lt;&lt;"]\n";*/
		q[i].b=min(q[i].b,n);
		while(l&lt;q[i].l)update(a[l++],-1);
		while(l&gt;q[i].l)update(a[--l],1);
		while(r&lt;q[i].r)update(a[++r],1);
		while(r&gt;q[i].r)update(a[r--],-1);
		
		//cout&lt;&lt;qb[q[i].a]&lt;&lt;"-&gt;"&lt;&lt;qb[q[i].b]&lt;&lt;endl;
		if(qb[q[i].a]!=qb[q[i].b]){
			for(j=qb[q[i].a];++j&lt;qb[q[i].b];)ansshu[q[i].i]+=shunum[j],anszhi[q[i].i]+=zhinum[j];
			for(j=q[i].a;j&lt;=end[qb[q[i].a]];++j)ansshu[q[i].i]+=now[j],anszhi[q[i].i]+=(bool)now[j];
			for(j=start[qb[q[i].b]];j&lt;=q[i].b;++j)ansshu[q[i].i]+=now[j],anszhi[q[i].i]+=(bool)now[j];
		}
		else for(j=q[i].a;j&lt;=q[i].b;++j)ansshu[q[i].i]+=now[j],anszhi[q[i].i]+=(bool)now[j];
		//cout&lt;&lt;"233:"&lt;&lt;now[5]&lt;&lt;" "&lt;&lt;shunum[qb[5]]&lt;&lt;endl;
	}
	for(i=m;i--;){
		out(ansshu[i]);
		putchar(' ');
		out(anszhi[i]);
		puts("");
	}
}</pre><pre></pre><h2>Problem3237</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=100010; 
typedef unsigned long long UL;
struct edge{int u,v;};
int n,m,dep[maxn];
vector&lt;edge&gt;E;
vector&lt;int&gt;G[maxn];
int in(){
	int r=0;char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))r=r*10+c-'0',c=getchar();
	return r;
}
void add(int u,int v){
	E.push_back((edge){u,v});
	G[u].push_back(E.size()-1);
	E.push_back((edge){v,u});
	G[v].push_back(E.size()-1);
}
int fa[maxn],vis[maxn];
UL ran(){
	return ((UL)rand()&lt;&lt;32)|(rand());
}
UL Ran[1000001],f[maxn];
void dfs(int u){
	vis[u]=1;
	for(int i=0;i&lt;G[u].size();i++){
		edge e=E[G[u][i]];
		if(e.v==fa[u])continue;
		if(!vis[e.v]){
			fa[e.v]=u;
			dep[e.v]=dep[u]+1;
			dfs(e.v);
		}else if(dep[e.v]&lt;dep[u]){
			Ran[G[u][i]]=Ran[G[u][i]^1]=ran();
			f[e.v]^=Ran[G[u][i]];
			f[u]^=Ran[G[u][i]];
		}
	}
}
void dfs2(int u){
	for(int i=0;i&lt;G[u].size();i++){
		edge e=E[G[u][i]];
		if(fa[e.v]==u){
			dfs2(e.v);
			f[u]^=f[e.v];
			Ran[G[u][i]]=Ran[G[u][i]^1]^=f[e.v];
		}
	}
}
UL base[64];
int main(){
	n=in();m=in();
	for(int i=1;i&lt;=m;i++){
		int u=in(),v=in();
		add(u,v);
	}dfs(1);
	dfs2(1);
	int q=in();
	while(q--){
		int k=in();
		int flag=1;
		memset(base,0,sizeof base);
		while(k--){
			UL x=Ran[(in()-1)&lt;&lt;1];
			for(int i=63;i&gt;=0;i--){
				if(x&gt;&gt;i&amp;1){
					if(base[i])x^=base[i];
					else {base[i]=x;break;}
				}
				if(!x)flag=0;
			}
		}puts(flag?"Connected":"Disconnected");
	}
	return 0;
}</pre><pre></pre><h2>Problem3237</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=100010; 
typedef unsigned long long UL;
struct edge{int u,v;};
int n,m,dep[maxn];
vector&lt;edge&gt;E;
vector&lt;int&gt;G[maxn];
int in(){
	int r=0;char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))r=r*10+c-'0',c=getchar();
	return r;
}
void add(int u,int v){
	E.push_back((edge){u,v});
	G[u].push_back(E.size()-1);
	E.push_back((edge){v,u});
	G[v].push_back(E.size()-1);
}
int fa[maxn],vis[maxn];
UL ran(){
	return ((UL)rand()&lt;&lt;32)|(rand());
}
UL Ran[1000001],f[maxn];
void dfs(int u){
	vis[u]=1;
	for(int i=0;i&lt;G[u].size();i++){
		edge e=E[G[u][i]];
		if(e.v==fa[u])continue;
		if(!vis[e.v]){
			fa[e.v]=u;
			dep[e.v]=dep[u]+1;
			dfs(e.v);
		}else if(dep[e.v]&lt;dep[u]){
			Ran[G[u][i]]=Ran[G[u][i]^1]=ran();
			f[e.v]^=Ran[G[u][i]];
			f[u]^=Ran[G[u][i]];
		}
	}
}
void dfs2(int u){
	for(int i=0;i&lt;G[u].size();i++){
		edge e=E[G[u][i]];
		if(fa[e.v]==u){
			dfs2(e.v);
			f[u]^=f[e.v];
			Ran[G[u][i]]=Ran[G[u][i]^1]^=f[e.v];
		}
	}
}
UL base[64];
int main(){
//	freopen("bzoj3563.in","r",stdin);
	n=in();m=in();
	for(int i=1;i&lt;=m;i++){
		int u=in(),v=in();
		add(u,v);
	}dfs(1);
	dfs2(1);
	int q=in();
	while(q--){
		int k=in();
		int flag=1;
		memset(base,0,sizeof base);
		while(k--){
			UL x=Ran[(in()-1)&lt;&lt;1];
			for(int i=63;i&gt;=0;i--){
				if(x&gt;&gt;i&amp;1){
					if(base[i])x^=base[i];
					else {base[i]=x;break;}
				}
				if(!x)flag=0;
			}
		}puts(flag?"Connected":"Disconnected");
	}
	return 0;
}</pre><pre></pre><h2>Problem3238</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1e6+5;
int son[maxn][26],len[maxn],tot=1,fa[maxn],last=1,cnt[maxn];
int newnode(int x){
	len[++tot]=x;
	return tot;
}
/*void add(int w){
	int p=last;
	int np=newnode(len[p]+1);
	while(p&amp;&amp;!son[p][w])son[p][w]=np,p=fa[p];
	if(!p)fa[np]=1;
	else{
		int q=son[p][w];
		if(len[p]+1==len[q])fa[np]=q;
		else{
			int nq=newnode(len[q]+1);
			memcpy(son[nq],son[q],sizeof son[nq]);
			fa[nq]=fa[q];fa[q]=fa[np]=nq;
			while(p&amp;&amp;son[p][w]==q)son[p][w]=nq,p=fa[p];
		}
	}last=np;
}*/
void add(int w){
	int p=last;
	int np=newnode(len[p]+1);
	while(p&amp;&amp;!son[p][w])son[p][w]=np,p=fa[p];
	if(!p)fa[np]=1;
	else{
		int q=son[p][w];
		if(len[p]+1==len[q])fa[np]=q;
		else{
			int nq=newnode(len[p]+1);
			memcpy(son[nq],son[q],sizeof son[nq]);
			fa[nq]=fa[q];fa[np]=fa[q]=nq;
			while(p&amp;&amp;son[p][w]==q)son[p][w]=nq,p=fa[p];
		}
	}last=np;
}
char s[maxn];
vector&lt;int&gt;G[maxn];
long long ans=0;
void dfs(int u){
	for(int i=0;i&lt;G[u].size();i++){
		int v=G[u][i];
		dfs(v);
		ans-=1LL*len[u]*cnt[u]*cnt[v]*2;
		cnt[u]+=cnt[v];
	}
}
void deb(){
	for(int i=1;i&lt;=tot;i++){
		fprintf(stderr,"id:%d fa:%d\n",i,fa[i]);
		for(int j=0;j&lt;26;j++)if(son[i][j])
			fprintf(stderr,"%d --%c-- %d\n",i,j+'a',son[i][j]);
	}
}
int main(){
	scanf("%s",s);int n=strlen(s);reverse(s,s+n);
	for(int i=0;i&lt;n;i++)add(s[i]-'a');
	
//	deb();
	for(int u=1,i=0;i&lt;n;i++){
		u=son[u][s[i]-'a'];
		cnt[u]=1;
	}
	ans=(long long)(n-1)*n*(n+1)/2;
	
	for(int i=2;i&lt;=tot;i++)
		G[fa[i]].push_back(i);
	dfs(1);
	
	cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem3239</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
LL p,a,b;
LL pw(LL x,LL k,LL p){
	LL ans=1;
	for(;k;k&gt;&gt;=1){
		if(k&amp;1)ans=(ans*x)%p;
		x=(x*x)%p;
	}return ans;
} 
void solve(){
	a%=p;b%=p;
	map&lt;LL,LL&gt;hash;
	LL m=ceil(sqrt(p)),am=pw(a,m,p),v=pw(a,p-2,p),e=1;
	hash[b]=0;
	for(int i=1;i&lt;=m;i++)if(!hash.count(b*v%p))
	hash[(b*=v)%=p]=i;
	//cout&lt;&lt;b&lt;&lt;" ";cout&lt;&lt;endl;
	for(int i=0;i&lt;=m;i++){
		if(hash.count(e))
		{cout&lt;&lt;i*m+hash[e]&lt;&lt;endl;return;}
		e=e*am%p;
	}puts("no solution");
}
int main(){
	while(cin&gt;&gt;p&gt;&gt;a&gt;&gt;b)
	solve();
	return 0;
}</pre><pre></pre><h2>Problem3240</h2><pre>/*直接推通项。矩阵不好做的。*/
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
typedef long long LL;
const LL MOD=1000000007LL;
void getMOD(char *a,LL &amp;A,bool p){
	LL mod=MOD-p;
	int len=strlen(a);
	for (int i=0;i&lt;len;++i)
		A=((A&lt;&lt;3)+(A&lt;&lt;1)+a[i]-'0')%mod;
	A=(A+mod)%mod;
}
LL power(LL a,LL b){
	LL res=1;
	for (;b;a=a*a%MOD,b&gt;&gt;=1)
		if (b&amp;1) (res*=a)%=MOD;
	return res;
}
char TN[1000050],TM[1000050];
LL n,m,a,b,c,d;
LL Fn1,Fnm;
int main(){
	scanf("%s %s %lld %lld %lld %lld",TN,TM,&amp;a,&amp;b,&amp;c,&amp;d);
	if (a==1&amp;&amp;c==1){
		getMOD(TN,n,0),getMOD(TM,m,0);
		Fnm=((((n-1+MOD)%MOD)*((m-1+MOD)%MOD)%MOD)*(b*c%MOD)%MOD+(((n-1+MOD)%MOD)*d)%MOD+(((m-1+MOD)%MOD)*b)%MOD+1+MOD)%MOD;
		printf("%lld\n",Fnm);
		return 0;
		}
	LL A,B;
	if (a==1){
		getMOD(TM,m,0);
		A=c;
		B=(((m-1+MOD)%MOD)*(b*c%MOD)%MOD+d)%MOD;
		}
	if (a!=1){
		getMOD(TM,m,1);
		A=c*power(a,(m-1+MOD-1)%(MOD-1))%MOD;
		B=((((b*c%MOD)*power((a-1+MOD)%MOD,MOD-2))%MOD*(power(a,(m-1+MOD-1)%(MOD-1))-1+MOD)%MOD)%MOD+d)%MOD;
		}
	//A!=1
	getMOD(TN,n,1);
	Fn1=(power(A,(n-1+MOD-1)%(MOD-1))+((power(A,(n-1+MOD-1)%(MOD-1))-1+MOD)%MOD*B)%MOD*power((A-1+MOD)%MOD,MOD-2)%MOD)%MOD;
	if (a==1) Fnm=(Fn1+((m-1+MOD)%MOD*b)%MOD)%MOD;
	if (a!=1) Fnm=((power(a,(m-1+MOD-1)%(MOD-1))*Fn1)%MOD+((power(a,(m-1+MOD-1)%(MOD-1))-1+MOD)%MOD*b)%MOD*power((a-1+MOD)%MOD,MOD-2)%MOD)%MOD;
	printf("%lld\n",Fnm);
}</pre><pre></pre><h2>Problem3251</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
int a[100001],fa[100001],dep[100001];
int n,m;
vector&lt;int&gt;G[100001];
void dfs(int u){
	for(int i=0;i&lt;G[u].size();i++){
		int v=G[u][i];
		if(v!=fa[u]){
			fa[v]=u;
			dep[v]=dep[u]+1;
			dfs(v);
		}
	}
}
int data[55];
void Q(int u,int v){
	data[0]=0;
	while(data[0]&lt;50&amp;&amp;u!=v){
		if(dep[u]&lt;dep[v])swap(u,v);
		data[++data[0]]=a[u];
		u=fa[u];
	}data[++data[0]]=a[u];
	if(data[0]==50){puts("Y");return;}
	sort(data+1,data+1+data[0]);
	for(int i=1;i&lt;=data[0]-2;i++)
	if((long long)data[i]+data[i+1]&gt;data[i+2]){puts("Y");return;}
	puts("N");
}
int main(){
	scanf("%d%d",&amp;n,&amp;m);
	for(int i=1;i&lt;=n;i++)scanf("%d",&amp;a[i]);
	for(int i=1;i&lt;n;++i){
		int u,v;scanf("%d%d",&amp;u,&amp;v);
		G[u].push_back(v);
		G[v].push_back(u);
	}dfs(1);
	while(m--){
		int op,x,y;scanf("%d%d%d",&amp;op,&amp;x,&amp;y);
		if(op==0){
			Q(x,y);
		}else{
			a[x]=y;
		}
	}
}</pre><pre></pre><h2>Problem3252</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=200010;
vector&lt;int&gt;G[maxn];
int getint(){
	int res=0;char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))res=res*10+c-'0',c=getchar();
	return res;
}
int n,k,tot;
int fa[maxn],in[maxn],out[maxn],w[maxn],rmp[maxn&lt;&lt;1],vis[maxn],sum[maxn&lt;&lt;1];
void dfs(int u){
	in[u]=++tot;rmp[tot]=u;
	for(int i=0,v;i&lt;G[u].size();i++){
		if((v=G[u][i])!=fa[u]){
			fa[v]=u;
			dfs(v);			
		}
	}out[u]=++tot;
}
typedef long long LL;
struct seg{
	struct node{
		LL lazy;
		LL mx;
		int ps;
		node(){lazy=0;mx=0;ps=0;}
	}t[maxn&lt;&lt;3];
	#define lson i&lt;&lt;1,l,mid
	#define rson i&lt;&lt;1|1,mid+1,r
	#define L i&lt;&lt;1
	#define R i&lt;&lt;1|1
	void rz(int i){
		if(t[L].mx&gt;t[R].mx)
			t[i].mx=t[L].mx,t[i].ps=t[L].ps;
		else t[i].mx=t[R].mx,t[i].ps=t[R].ps;
	}
	void pushdown(int i,int l,int r){
		if(t[i].lazy){
			int mid=(l+r)&gt;&gt;1;
			t[L].lazy+=t[i].lazy;
			t[L].mx+=t[i].lazy;
			t[R].lazy+=t[i].lazy;
			t[R].mx+=t[i].lazy;
			t[i].lazy=0;
		}
	}
	void Change(int i,int l,int r,int l0,int r0,int d){
		if(l0&lt;=l&amp;&amp;r0&gt;=r){
			t[i].lazy+=d;
			t[i].mx+=d;return;
		}pushdown(i,l,r);
		int mid=(l+r)&gt;&gt;1;
		if(l0&lt;=mid)Change(lson,l0,r0,d);
		if(r0&gt;mid) Change(rson,l0,r0,d);
		rz(i);
	}
	void build(int i,int l,int r){
		if(l==r){
			t[i].ps=l;
			return;
		}int mid=(l+r)&gt;&gt;1;
		build(lson);build(rson);rz(i);
	}
	int Max(){return t[1].ps;}
}T;
int main(){
	n=getint();k=getint();
	for(int i=1;i&lt;=n;i++)w[i]=getint();
	for(int i=1;i&lt;n;i++){
		int u=getint(),v=getint();
		G[u].push_back(v);
		G[v].push_back(u);		
	}dfs(1);
	T.build(1,1,2*n);
	for(int i=1;i&lt;=n;i++)T.Change(1,1,2*n,in[i],2*n,w[i]);
	for(int i=1;i&lt;=n;i++)T.Change(1,1,2*n,out[i],2*n,-w[i]);
	LL ans=0;
	while(k--){
		int u=rmp[T.Max()];
		while(u&amp;&amp;!vis[u]){
			ans+=w[u];
			T.Change(1,1,2*n,in[u],2*n,-w[u]);
			T.Change(1,1,2*n,out[u],2*n,w[u]);
			vis[u]=2333;u=fa[u];
		}
	}cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem3261</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=300010;
int BIT=24;
int n,m;
int a[maxn&lt;&lt;1],b[maxn&lt;&lt;1];
int getint(){
	int res=0;char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))res=res*10+c-'0',c=getchar();
	return res;
}
struct node{
	int size;
	node *c[2];
	node(node *C=0){size=0;c[0]=c[1]=C;}
}*root[maxn&lt;&lt;1],*Null,*zero;
node *insert(node *x,int val,int dep){
	node *y=new node(Null);
	*y=*x;y-&gt;size++;
	if(dep&lt;0)return y;
	int v=val&gt;&gt;dep&amp;1;
	y-&gt;c[v]=insert(x-&gt;c[v],val,dep-1);
	return y;
}
int Qmax(node *x,node *y,int val,int dep){
	if(dep&lt;0)return 0;
	int v=!(val&gt;&gt;dep&amp;1);
	if(x-&gt;c[v]-&gt;size&gt;y-&gt;c[v]-&gt;size)
		return Qmax(x-&gt;c[v],y-&gt;c[v],val,dep-1)+(1&lt;&lt;dep);
	return Qmax(x-&gt;c[!v],y-&gt;c[!v],val,dep-1);
}
int main(){
	Null=new node();
	Null-&gt;c[0]=Null-&gt;c[1]=Null;
	root[0]=Null;zero=insert(Null,0,BIT);
	node *tmp=zero-&gt;c[0];
	for(int i=0;i&lt;=BIT;i++)tmp-&gt;size=-1,tmp=tmp-&gt;c[0];
	n=getint();m=getint();
	for(int i=1;i&lt;=n;i++){
		a[i]=getint();b[i]=b[i-1]^a[i];
		root[i]=insert(root[i-1],b[i],BIT);
	}while(m--){
		char op=getchar();
		while(!isalpha(op))op=getchar();
		if(op=='A'){
			int x=getint();
			a[++n]=x;b[n]=b[n-1]^a[n];
			root[n]=insert(root[n-1],b[n],BIT);			
		}else{
			int l=getint()-1,r=getint()-1,x=getint();
			
			printf("%d\n",Qmax(root[r],l?root[l-1]:zero,x^b[n],BIT));
		}
	}
	return 0;
}</pre><pre></pre><h2>Problem3262</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1e5+5;
int n,k,size;
struct tup{
	int x,y,z,s;
	tup(int _x=0,int _y=0,int _z=0,int _s=0):x(_x),y(_y),z(_z),s(_s){}
	bool operator&lt;(tup oth)const{
		return x==oth.x?y==oth.y?z&lt;oth.z:y&lt;oth.y:x&lt;oth.x;
	}
	bool operator==(tup oth)const{return x==oth.x&amp;&amp;y==oth.y&amp;&amp;z==oth.z;}
	bool operator!=(tup oth)const{return !(*this==oth);}
}a[maxn],b[maxn];
struct node{  
    int val,key,sum,s;  
    node *c[2];  
    node(int _val=0,int _s=0,node *C=0){  
        val=_val;key=rand();sum=s=_s;  
        c[0]=c[1]=C;  
    }  
    void rz(){  
        sum=c[0]-&gt;sum+s+c[1]-&gt;sum;  
    }  
}pool[maxn],*Null;  
node *newnode(int _val=0,int _s=0,node *C=0){  
    static int tot=0;  
    if(tot&lt;maxn){  
        pool[tot].val=_val;  
        pool[tot].key=rand();  
        pool[tot].sum=pool[tot].s=_s;  
        pool[tot].c[0]=pool[tot].c[1]=C;  
        return &amp;pool[tot++];  
    }else return new node(_val,_s,C);  
}  
struct Treap{  
    node *root;  
    void init(){  
        root=Null;  
    }  
    void rot(node *&amp;t,bool d){  
        node *p=t-&gt;c[d];t-&gt;c[d]=p-&gt;c[!d];  
        p-&gt;c[!d]=t;t-&gt;rz();p-&gt;rz();t=p;  
    }  
    void insert(node *&amp;t,int val,int s){  
        if(t==Null){t=newnode(val,s,Null);return;}  
        if(t-&gt;val==val){t-&gt;s+=s;t-&gt;sum+=s;return;}  
        bool d=t-&gt;val&lt;val;  
        insert(t-&gt;c[d],val,s);  
        if(t-&gt;c[d]-&gt;key&lt;t-&gt;key)rot(t,d);  
        else t-&gt;rz();  
    }  
    int Qsum(node *t,int x){  
        int ans=0;  
        while(t!=Null){  
            if(t-&gt;val&lt;=x)ans+=t-&gt;c[0]-&gt;sum+t-&gt;s,t=t-&gt;c[1];  
            else t=t-&gt;c[0];  
        }return ans;  
    }  
    void insert(int val,int s){insert(root,val,s);}  
    int Qsum(int l,int r){return Qsum(root,r)-Qsum(root,l-1);}  
};  
Treap d[maxn&lt;&lt;1];
inline int lowbit(int x){return x&amp;-x;}
void updata(int x,int y,int z){
	while(x&lt;=k)d[x].insert(y,z),x+=lowbit(x);
}
int get(int x,int y){
	int ans=0;
	while(x)ans+=d[x].Qsum(1,y),x-=lowbit(x);
	return ans;
}
int anss[maxn];
int getint(){
	int res=0;char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))res=res*10+c-'0',c=getchar();
	return res;
}
int main(){
	Null=newnode(INT_MAX,0,0);  
    Null-&gt;key=INT_MAX;Null-&gt;c[0]=Null-&gt;c[1]=Null;  
	n=getint();k=getint();
	for(int i=1;i&lt;=k;i++)d[i].init();
	for(int i=1;i&lt;=n;i++)a[i].x=getint(),a[i].y=getint(),a[i].z=getint();
	sort(a+1,a+1+n);
	for(int i=1;i&lt;=n;++i)
		if(a[i]!=a[i-1])
			b[++size]=a[i],b[size].s++;
		else b[size].s++;		
	for(int i=1;i&lt;=size;i++){
		int ans=get(b[i].y,b[i].z);
		anss[ans+b[i].s-1]+=b[i].s;
		updata(b[i].y,b[i].z,b[i].s);
	}for(int i=0;i&lt;n;i++)printf("%d\n",anss[i]);
	return 0;
}</pre><pre></pre><h2>Problem3265</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=10010;
const int maxm=1010;
const double eps=1e-8;
double a[maxn][maxm];
int n,m;
int dcmp(double x){
	if(fabs(x)&lt;eps)return 0;
	return x&gt;0?1:-1;
}
double simplex(bool f);
void pivot(int l,int e,bool f){
	for(int i=0;i&lt;=m+f;i++){
		if(i==e)continue;
		a[l][i]/=a[l][e];
	}a[l][e]=1/a[l][e];
	for(int i=0;i&lt;=n+f;i++){
		if(i==l)continue;
		for(int j=0;j&lt;=m+f;j++){
			if(j==e)continue;
			a[i][j]-=a[i][e]*a[l][j];
		}a[i][e]*=-a[l][e];
	}
}
void init(){
	int pos=-1;
	double minn=1e10;
	for(int i=1;i&lt;=n;i++)
	if(dcmp(minn-a[i][0])==1)minn=a[i][0],pos=i;
	if(dcmp(minn)&gt;=0)return;
	for(int i=0;i&lt;=m;i++)swap(a[0][i],a[n+1][i]);
	for(int i=0;i&lt;=n;i++)a[i][m+1]=-1;
	pivot(pos,m+1,1);
	if(!dcmp(simplex(1))){
		for(int i=1;i&lt;=m+1;i++)if(!dcmp(a[0][i]+1)){pos=i;break;}
		for(int i=0;i&lt;=m+1;i++)swap(a[0][i],a[n+1][i]);
		for(int i=0;i&lt;=n+1;i++)swap(a[i][pos],a[i][m+1]);
	}else puts("Can't solve!!");
}
double simplex(bool f){
	for(;;){
		int pos=-1,l,e;
		double minn=0;
		for(int i=1;i&lt;=m+f;i++)
		if(dcmp(a[0][i]-minn)==1)minn=a[0][i],pos=i;
		if(!~pos)return -a[0][0];
		e=pos;pos=-1;minn=1e10;
		for(int i=1;i&lt;=n;i++)
		if(dcmp(a[i][e])==1&amp;&amp;dcmp(a[i][0]/a[i][e]-minn)==-1)
		minn=a[i][0]/a[i][e],pos=i;
		if(!~pos){
			printf("INF!!\n");
			return 1e10;
		}l=pos;
		pivot(l,e,f);
	}
}
int main(){
	scanf("%d%d",&amp;m,&amp;n);
	for(int i=1;i&lt;=m;i++)scanf("%lf",&amp;a[0][i]);
	for(int i=1;i&lt;=n;i++){
		int k;scanf("%d",&amp;k);
		while(k--){
			int l,r;scanf("%d%d",&amp;l,&amp;r);
			for(int j=l;j&lt;=r;j++)a[i][j]=1;
		}scanf("%d",&amp;k);
		a[i][0]=k;
	}
	init();
	int ans=simplex(0)+.5;
	printf("%d\n",ans);
	return 0;
}</pre><pre></pre><h2>Problem3268</h2><pre>#include&lt;stdio.h&gt;
#include&lt;algorithm&gt;
using namespace std;
int getint()
{
	int ret=0;bool ok=false;
	for(;;)
	{
		int c=getchar();
		if(c&gt;='0'&amp;&amp;c&lt;='9')ret=(ret&lt;&lt;3)+ret+ret+c-'0',ok=true;
		else if(ok)return ret;
	}
}
const int maxn=500010;
int n;
int r[maxn],log2[maxn],l[maxn];
typedef pair&lt;int,int&gt; pii;
pii st[maxn][20];
int ask(int L,int R)
{
	if(L&lt;=0)return 0;
	int x=log2[R-L];
	return min(st[L][x],st[R-(1&lt;&lt;x)][x]).second;
}
int pre[maxn][20],arv[maxn][20];
int main()
{
	n=getint();
	for(int i=1;i&lt;=n;i++)r[i]=r[i+n]=getint();
	for(int i=1;i&lt;=n+n;i++)l[i]=max(i-r[i],0);
	for(int i=2;i&lt;=n+n;i++)log2[i]=log2[i-1]+(i==(i&amp;-i));
	for(int i=n+n;i;i--)
	{
		st[i][0]=make_pair(l[i],i);
		for(int j=1;j&lt;=log2[n+n-i+1];j++)st[i][j]=min(st[i][j-1],st[i+(1&lt;&lt;(j-1))][j-1]);
	}
	for(int i=1;i&lt;=n+n;i++)
	{
		pre[i][0]=i==1?0:ask(l[i],i);
		arv[i][0]=l[i];
		for(int j=1;;j++)
		{
			if(!pre[i][j-1])break;
			pre[i][j]=pre[pre[i][j-1]][j-1];
			arv[i][j]=arv[pre[i][j-1]][j-1];
		}
	}
	long long ans=0;
	for(int i=n;i&lt;n+n;i++)
	{
		int ret=1;
		int u=i;
		for(int j=19;j&gt;=0;j--)if(arv[u][j])
			if(arv[u][j]&gt;i-n+1)ret+=1&lt;&lt;j,u=pre[u][j];
		ans+=ret;
	}
	printf("%lld\n",ans);
}</pre><pre></pre><h2>Problem3270</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
int n,m,A,B,tot;
int mp[21][21];
double p[21];
double a[405][405];
vector&lt;int&gt;G[21];
void deb(int n){
	for(int i=1;i&lt;=n;i++)
	for(int j=1;j&lt;=n+1;j++)
		fprintf(stderr,"%.2lf%c",a[i][j]," \n"[j==n+1]);

}
void Gauss(int n){
	
	for(int i=1;i&lt;n;i++){
//		deb(n);	
		int r=i;
		for(int j=i+1;j&lt;=n;j++)if(fabs(a[r][i])&lt;fabs(a[j][i]))r=j;
		for(int j=i;j&lt;=n+1;j++)swap(a[r][j],a[i][j]);
//		deb(n);	
		for(int j=i+1;j&lt;=n;j++){
			double t=a[j][i]/a[i][i];
			for(int k=i;k&lt;=n+1;k++)
				a[j][k]-=t*a[i][k];
//			deb(n);	
		}
	}
//	deb(n);
	for(int i=n;i&gt;=1;i--){
		for(int j=i+1;j&lt;=n;j++)
			a[i][n+1]-=a[j][n+1]*a[i][j];
		a[i][n+1]/=a[i][i];
	}
}
#define sz(x) double(G[x].size())
void build(){
	int m=0;
	for(int i=1;i&lt;=n;i++)
	for(int j=1;j&lt;=n;j++){
		//f[i][j]=p_ip_jf[i][j]+p_i(\sum f[i][j'] /sz(j))+p_j(\sum f[i'][j] /sz(i))+(1-p_i)(1-p_j)\sum f[i'][j']/sz(i)/sz(j)
		m++;
		if(i!=j)
			a[m][mp[i][j]]=p[i]*p[j]-1;
		else a[m][mp[i][j]]=-1;
		for(int k=0;k&lt;G[i].size();k++)
		for(int l=0;l&lt;G[j].size();l++){
			int u=G[i][k],v=G[j][l];
			if(u!=v)
			a[m][mp[u][v]]=(1-p[u])*(1-p[v])/sz(u)/sz(v);
		}
		for(int k=0;k&lt;G[i].size();k++){
			int u=G[i][k];
			if(u!=j)
			a[m][mp[u][j]]=(1-p[u])*p[j]/sz(u);
		}		
		for(int l=0;l&lt;G[j].size();l++){
			int v=G[j][l];
			if(i!=v)
			a[m][mp[i][v]]=p[i]*(1-p[v])/sz(v);
		}
		if(i==A&amp;&amp;j==B){
			a[m][n*n+1]=-1;
		}
	}
}
int main(){
	scanf("%d%d%d%d",&amp;n,&amp;m,&amp;A,&amp;B);
	for(int i=1;i&lt;=m;i++){
		int u,v;scanf("%d%d",&amp;u,&amp;v);
		G[u].push_back(v);
		G[v].push_back(u);
	}for(int i=1;i&lt;=n;i++)scanf("%lf",&amp;p[i]);
	for(int i=1;i&lt;=n;i++)for(int j=1;j&lt;=n;j++)mp[i][j]=++tot;
	build();
	Gauss(n*n);	
	for(int i=1;i&lt;=n;i++)printf("%.6lf ",a[mp[i][i]][n*n+1]);
	return 0;
}</pre><pre></pre><h2>Problem3275</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=3010;
int n;
int a[maxn];
struct edge{  
    int u,v,cap,flow;     
    edge(int _u=0,int _v=0,int _cap=0,int _flow=0):  
        u(_u),v(_v),cap(_cap),flow(_flow){}  
};  
vector&lt;edge&gt;edges;  
vector&lt;int&gt;G[maxn];  
int cur[maxn],vis[maxn];  
void add(int u,int v,int cap){  
    edges.push_back(edge(u,v,cap,0));  
    G[u].push_back(edges.size()-1);  
    edges.push_back(edge(v,u,0,0));   
    G[v].push_back(edges.size()-1);   
}  
int d[maxn],s,t;  
bool bfs(){  
    memset(vis,0,sizeof(vis));  
    queue&lt;int&gt;q;  
    q.push(s);vis[s]=1;  
    while(!q.empty()){  
        int u=q.front();q.pop();  
        for(int i=0;i&lt;G[u].size();i++){  
            edge e=edges[G[u][i]];  
            if(e.cap&gt;e.flow&amp;&amp;!vis[e.v]){  
                d[e.v]=d[u]+1;  
                vis[e.v]=1;  
                q.push(e.v);  
            }  
        }  
    }return vis[t];  
}  
int dfs(int u,int a){  
    int flow=0,f;  
    if(u==t||!a)return a;  
    for(int &amp;i=cur[u];i&lt;G[u].size();i++){  
        edge e=edges[G[u][i]];  
        if(d[e.v]==d[u]+1&amp;&amp;(f=dfs(e.v,min(a,e.cap-e.flow)))&gt;0){  
            edges[G[u][i]].flow+=f;  
            edges[G[u][i]^1].flow-=f;  
            flow+=f;a-=f;  
            if(!a)break;  
        }  
    }return flow;  
}  
int Dinic(){  
    int flow=0;  
    while(bfs()){  
        int x=0;  
        do{  
            flow+=x;  
            memset(cur,0,sizeof(cur));  
        }while(x=dfs(s,INT_MAX));  
    }return flow;  
}  
bool can(int a,int b){
	typedef long long LL;
	LL c=sqrt((LL)a*a+(LL)b*b);
	return !((LL)a*a+(LL)b*b==c*c&amp;&amp;__gcd(a,b)==1);
}
int main(){
	scanf("%d",&amp;n);
	for(int i=1;i&lt;=n;i++)scanf("%d",&amp;a[i]);
	s=0;t=n+1;
	for(int i=1;i&lt;=n;i++)if(a[i]%2)add(s,i,a[i]);
	for(int i=1;i&lt;=n;i++)if(a[i]%2==0)add(i,t,a[i]);
	for(int i=1;i&lt;=n;i++)for(int j=1;j&lt;=n;j++)if(a[i]%2&amp;&amp;a[j]%2==0)if(!can(a[i],a[j]))
	add(i,j,INT_MAX);
	cout&lt;&lt;accumulate(a+1,a+1+n,0)-Dinic()&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem3276</h2><pre>/**************************************************************
    Problem: 3276
    User: rausen
    Language: C++
    Result: Accepted
    Time:4884 ms
    Memory:19364 kb
****************************************************************/
 
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
 
using namespace std;
typedef long long ll;
const int N = 250005;
 
struct data {
    int w, p;
    ll d2, r2;
     
    inline bool operator &lt; (const data &amp;a) const {
        return d2 &lt; a.d2;
    }
} a[N];
 
struct seg_node {
    int v;
    seg_node *son[2];
} *seg_root, mempool[N &lt;&lt; 2], *cnt_seg = mempool, *null;
 
int n;
int q[N], H, T;
ll R2;
 
inline int lower() {
    int l = 1, r = n + 1, mid;
    while (l + 1 &lt; r) {
        mid = l + r &gt;&gt; 1;
        if (a[mid].d2 &lt;= R2) l = mid;
        else r = mid;
    }
    return l;   
}
 
inline int read() {
    int x = 0, sgn = 1;
    char ch = getchar();
    while (ch &lt; '0' || '9' &lt; ch) {
        if (ch == '-') sgn = -1;
        ch = getchar();
    }
    while ('0' &lt;= ch &amp;&amp; ch &lt;= '9') {
        x = x * 10 + ch - '0';
        ch = getchar();
    }
    return sgn * x;
}
 
#define mid (l + r &gt;&gt; 1)
#define V p -&gt; v
#define Ls p -&gt; son[0]
#define Rs p -&gt; son[1]
inline void new_node(seg_node *&amp;p) {
    p = ++cnt_seg;
    V = 0, Ls = Rs = null;
}
 
inline int get_min(int x, int y) {
    if (!x) return y;
    if (!y) return x;
    return a[x].w &lt; a[y].w ? x : y;
}
 
inline void update(seg_node *p) {
    V = get_min(Ls -&gt; v, Rs -&gt; v);
}
 
void seg_build(seg_node *&amp;p, int l, int r) {
    new_node(p);
    if (l == r) {
        V = l;
        return;
    }
    seg_build(Ls, l, mid), seg_build(Rs, mid + 1, r);
    update(p);
}
 
void seg_modify(seg_node *p, int l, int r, int pos) {
    if (l == r) {
        V = 0;
        return;
    }
    if (pos &lt;= mid) seg_modify(Ls, l, mid, pos);
    else seg_modify(Rs, mid + 1, r, pos);
    update(p);
}
 
int seg_query(seg_node *p, int l, int r, int pos) {
    if (r &lt;= pos) return V;
    int res = seg_query(Ls, l, mid, pos);
    if (pos &gt; mid) res = get_min(res, seg_query(Rs, mid + 1, r, pos));
    return res;
}
#undef mid
#undef V
#undef Ls
#undef Rs
 
inline ll sqr(ll x) {
    return x * x;
}
 
int main() {

    int X, Y, P, x, y, r, i, tmp, pos;
    null = cnt_seg, null -&gt; son[0] = null -&gt; son[1] = null, null -&gt; v = 0;
    X = read(), Y = read(), P = read(), R2 = sqr(read()), n = read();
    for (i = 1; i &lt;= n; ++i) {
        x = read(), y = read(), a[i].w = read(), a[i].p = read(), r = read();
        a[i].d2 = sqr(X - x) + sqr(Y - y), a[i].r2 = sqr(r);
    }
    sort(a + 1, a + n + 1);
    seg_build(seg_root, 1, n);
    while ((pos = lower()) != 0) {
        tmp = seg_query(seg_root, 1, n, pos);
        if (!tmp || a[tmp].w &gt; P) break;
        seg_modify(seg_root, 1, n, tmp);
        q[++T] = tmp;
    }
    while (H &lt;= T) {
        P = a[q[H]].p, R2 = a[q[H]].r2, ++H;
        while ((pos = lower()) != 0) {
            tmp = seg_query(seg_root, 1, n, pos);
            if (!tmp || a[tmp].w &gt; P) break;
            seg_modify(seg_root, 1, n, tmp);
            q[++T] = tmp;
        }
    }
    printf("%d\n", T);
    return 0;
}
</pre><pre></pre><h2>Problem3277</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=2e5+5;
int son[maxn][26],len[maxn],fa[maxn];
int root=1,last=1,tot=1;
int newnode(int x){
	len[++tot]=x;
	return tot;
}
void add(int w){
	if(son[last][w]){
		int p=last;
		int q=son[last][w];
		if(len[p]+1==len[q])last=q;
		else{
			int nq=newnode(len[p]+1);
			memcpy(son[nq],son[q],sizeof son[nq]);
			fa[nq]=fa[q];fa[q]=nq;
			while(p&amp;&amp;son[p][w]==q)son[p][w]=nq,p=fa[p];	
			last=nq;		
		}
	}else{
		int p=last;
		int np=newnode(len[p]+1);
		while(p&amp;&amp;!son[p][w])son[p][w]=np,p=fa[p];
		if(!p)fa[np]=root;
		else{
			int q=son[p][w];
			if(len[p]+1==len[q])fa[np]=q;
			else{
				int nq=newnode(len[p]+1);
				memcpy(son[nq],son[q],sizeof son[nq]);
				fa[nq]=fa[q];
				fa[q]=fa[np]=nq;
				while(p&amp;&amp;son[p][w]==q)son[p][w]=nq,p=fa[p];
			}
		}last=np;
	}
}
void deb(){
	for(int i=1;i&lt;=tot;i++){
		fprintf(stderr,"id:%d fa:%d\n",i,fa[i]);
		for(int j=0;j&lt;26;j++)if(son[i][j])
			fprintf(stderr,"%d--%c--%d\n",i,j+'a',son[i][j]);
	}fprintf(stderr,"\n");
}
int n,K,now,vis[maxn],cnt[maxn],f[maxn];
string s[int(1e5+1)];
char str[maxn];
void make(int u){
	while(u&amp;&amp;vis[u]!=now){
		vis[u]=now;
		cnt[u]++;
		u=fa[u];
	}
}
void up(int u){
	if(u==1||vis[u])return;
	vis[u]=1;
	up(fa[u]);
	f[u]+=f[fa[u]];
}
int main(){
	scanf("%d%d",&amp;n,&amp;K);
	for(int i=1;i&lt;=n;i++){
		scanf("%s",str);s[i]=string(str);
		for(int j=0;j&lt;s[i].length();j++)
			add(s[i][j]-'a');
		last=root;
//		deb();
	}
//	deb();
	for(int i=1;i&lt;=n;i++){
		int u=root;now=i;
		for(int j=0;j&lt;s[i].length();j++){
			u=son[u][s[i][j]-'a'];
			make(u);
		}
	}
	memset(vis,0,sizeof vis);
	for(int i=1;i&lt;=tot;i++)f[i]=(cnt[i]&gt;=K)*(len[i]-len[fa[i]]);
	
	for(int i=1;i&lt;=tot;i++)up(i);
	
	for(int i=1;i&lt;=n;i++){
		int u=root;now=i;
		long long ans=0;
		for(int j=0;j&lt;s[i].length();j++){
			u=son[u][s[i][j]-'a'];
			ans+=f[u];
		}
		printf("%lld ",ans);
	}	
	
	return 0;
}</pre><pre></pre><h2>Problem3282</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=3e5+4;
int n,m;
struct node{
	int val,sum;
	bool rev;
	node *c[2],*f;
	void mkrev(){rev^=1;swap(c[0],c[1]);}
	void sets(node *x,int d){pd();if(x)x-&gt;f=this;c[d]=x;rz();}
	void rz(){sum=(c[0]?c[0]-&gt;sum:0)^val^(c[1]?c[1]-&gt;sum:0);}
	void pd(){if(rev){if(c[0])c[0]-&gt;mkrev();if(c[1])c[1]-&gt;mkrev();rev=0;}}
	int d(){return f-&gt;c[1]==this;}
	bool rt(){return !f||(f-&gt;c[0]!=this&amp;&amp;f-&gt;c[1]!=this);}
	node *C(int d){pd();return c[d];}
}nd[maxn],pool[maxn],*cur=pool;
void rot(node *x){
	node *y=x-&gt;f;if(!y-&gt;rt())y-&gt;f-&gt;pd();
	y-&gt;pd();x-&gt;pd();int d=x-&gt;d();y-&gt;sets(x-&gt;c[!d],d);
	if(y-&gt;rt())x-&gt;f=y-&gt;f;
	else y-&gt;f-&gt;sets(x,y-&gt;d());
	x-&gt;sets(y,!d);
}
void splay(node *x){
	while(!x-&gt;rt()){
		if(x-&gt;f-&gt;rt())rot(x);
		else if(x-&gt;f-&gt;d()==x-&gt;d())rot(x-&gt;f),rot(x);
		else rot(x),rot(x);
	}
}
node* access(node *x){
	static node* sta[maxn];
	static int top=0;
	node *y=x;
	while(y)sta[top++]=y,y=y-&gt;f;
	while(top)sta[--top]-&gt;pd();
	y=0;
	for(;x;x=x-&gt;f){
		splay(x);
		x-&gt;sets(y,1);
		y=x;
	}return y;
}
void mkrt(node *x){
	access(x)-&gt;mkrev();
}
node *findrt(node *u){
	access(u);
	splay(u);
	while(u-&gt;C(0))
	u=u-&gt;C(0);
	return u;
}
void link(node *u,node *v){
	if(findrt(u)!=findrt(v)){
		mkrt(u);
		u-&gt;f=v;
		access(u);
	}
}
node *findp(node *u){
	access(u);splay(u);
	u=u-&gt;C(0);while(u&amp;&amp;u-&gt;C(1))u=u-&gt;C(1);
	return u;
}
void cut(node *u,node *v){
	mkrt(u);
	if(findp(v)!=u)return;
	access(v);splay(v);
	v-&gt;c[0]=u-&gt;f=0;v-&gt;rz();
}
int main(){
	scanf("%d%d",&amp;n,&amp;m);
	for(int i=1;i&lt;=n;i++)scanf("%d",&amp;nd[i].val),nd[i].rz();
	while(m--){                    
		int op;scanf("%d",&amp;op);
		int x,y;scanf("%d%d",&amp;x,&amp;y);
		if(op==0){
			node *u=nd+x,*v=nd+y;
			mkrt(u);
			access(v);
			splay(v);
			printf("%d\n",v-&gt;sum);
		}else
		if(op==1){
			node *u=nd+x,*v=nd+y;
			link(u,v);
		}else
		if(op==2){
			node *u=nd+x,*v=nd+y;
			cut(u,v);
		}else
		if(op==3){
			node *u=nd+x;
			mkrt(u);access(u);splay(u);
			u-&gt;val=y;u-&gt;rz();		
		}
	}
	return 0;
}</pre><pre></pre><h2>Problem3282</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cstdlib&gt;
#define  l(x) (l+x)
using namespace std;
const int maxn=300001;
int n,m; 
struct node
{
	node *son[2],*p;
	int num,sum,rev;
	node (){num=sum=rev=0;}
	void pushdown();
	void pushup()
	{
		sum=num^son[0]-&gt;sum^son[1]-&gt;sum;
	}
	void setson(node*x,int r);
	int judge()
	{
		return p-&gt;son[1]==this;
	}
	bool isroot();
} l[maxn];
bool node::isroot()
{
	if(this-&gt;p==l) return true;
	return !(p-&gt;son[0]==this||p-&gt;son[1]==this); 
}
void node::pushdown()
	{	if (this==l) return;
		if (rev)
		{
			swap(son[0],son[1]);
			if (son[0]!=l)son[0]-&gt;rev^=1;
			if (son[1]!=l)son[1]-&gt;rev^=1;
		}
		rev=0; 
	}
void node::setson(node *x,int r)
	{	pushdown();
		son[r]=x;
		if (x!=l)x-&gt;p=this;
		pushup();
	}
void rot(node *now)
{
	if (!now-&gt;p-&gt;isroot()) now-&gt;p-&gt;p-&gt;pushdown();
	now-&gt;p-&gt;pushdown();now-&gt;pushdown();
	node *fa=now-&gt;p;int r=now-&gt;judge();
	fa-&gt;setson(now-&gt;son[r^1],r);
	if (fa-&gt;isroot()) now-&gt;p=fa-&gt;p;
		else fa-&gt;p-&gt;setson(now,fa-&gt;judge());
	now-&gt;setson(fa,r^1);
	//now fa?
	//if (!now-&gt;isroot()) now-&gt;p-&gt;pushup();
}
void splay(node *now)
{
	for (;!now-&gt;isroot();rot(now))
		if (now-&gt;p-&gt;isroot());
		else if (now-&gt;judge()==now-&gt;p-&gt;judge()) rot(now-&gt;p);
			else rot(now);
}
node *access(node *now)
{
	node *y=l;
	for (;now!=l;y=now,now=now-&gt;p)
	{
		splay(now);now-&gt;setson(y,1);
	}
	return y;
}
void changeroot(node *now)
{
	access(now)-&gt;rev^=1;
	splay(now);
}
void link(node *x,node *y)
{
//	changeroot(x);
//	node *now=access(y);
//	while (now-&gt;son[0]!=l) now=now-&gt;son[0];
//	if (now==x) return;
//	access(x);
changeroot(x);
//	splay(x);
	x-&gt;p=y;
	access(x);
}
void cut(node *x,node *y)
{
	changeroot(x);
	access(y);
//	splay(y);
//	if (y-&gt;son[0]==x) 
//	{
//		x-&gt;p=y-&gt;son[0]=l;
//	}
	splay(y);
	y-&gt;son[0]=x-&gt;p=l;y-&gt;pushup();
	/*if (y-&gt;son[0] == x)
	{
		y-&gt;setson(l, 0);
		x-&gt;p = l;
	}
	else
	{
		y-&gt;setson(l,1);
		x-&gt;p=l; 
	}*/
/*

	splay(x);
	if (x-&gt;son[1]==y) x-&gt;son[1]=y-&gt;p=l;
	splay(x);*/
}
node *findroot(node *x)
{
	node *now=access(x);
	while (now-&gt;son[0]!=l) now=now-&gt;son[0];
	return now;
}
int query(node *x,node *y)
{
	changeroot(x);
	access(y);
	splay(y);
	return y-&gt;sum;
}
int read()
{
	char c=getchar();int bj=1,result=0;
	while (c!='-'&amp;&amp;!(c&lt;='9'&amp;&amp;c&gt;='0')) c=getchar();
	if (c=='-') bj=-1,c=getchar();
	while (c&lt;='9'&amp;&amp;c&gt;='0') result=result*10+c-'0',c=getchar();
	return result*bj;
}
inline bool isLink(node *x,node *y) {
       return findroot(x)==findroot(y);
    }
int main()
{
//	freopen("3282.in","r",stdin);
//	freopen("3282.out","w",stdout);
	int i,j,k,opt,x,y;
	n=read();m=read();
	l(0)-&gt;p=l(0)-&gt;son[0]=l(0)-&gt;son[1]=l;
	for (i=1;i&lt;=n;i++)
	{
		l(i)-&gt;num=l(i)-&gt;sum=read();
		l(i)-&gt;p=l(i)-&gt;son[0]=l(i)-&gt;son[1]=l;
	}
	while (m--)
	{
		opt=read();
		if (opt==0) 
		{
			x=read();y=read();
			printf("%d\n",query(l(x),l(y)));
		}
		if (opt==1)
		{
			x=read();y=read();
			if (isLink(l(x),l(y))==false)
		//	if (findroot(l(x))!=findroot(l(y)))
			link(l(x),l(y));
		}
		if (opt==2)
		{
			x=read();y=read();
			if (isLink(l(x),l(y)))
		//	if (findroot(l(x))==findroot(l(y)))
			cut(l(x),l(y));
		}
		if (opt==3)
		{
			x=read();y=read();
			changeroot(l(x));
			node *now=access(l(x));
			now-&gt;num=now-&gt;sum=y;
		}
	/*	for (i=1;i&lt;=n;i++)
		{
			printf("%d %d %d %d\n",i,l(i)-&gt;p-l,l(i)-&gt;son[0]-l,l(i)-&gt;son[1]-l);
		}*/
	}
}</pre><pre></pre><h2>Problem3283</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
LL pow(LL x,LL k,LL p){
	LL ans=1;
	for(;k;k&gt;&gt;=1){
		if(k&amp;1)ans=ans*x%p;
		x=x*x%p;
	}return ans;
}
LL exgcd(LL a,LL b,LL &amp;x,LL &amp;y){
	if(!b){
		x=1;y=0;
		return a;
	}else{
		LL g=exgcd(b,a%b,x,y);
		LL t=x;x=y;y=t-a/b*y;
		return g;
	}
}
LL gcd(LL a,LL b){
	while(b){
		LL t=a%b;
		a=b;b=t;
	}return a;
}
LL lcm(LL a,LL b){return a*b/gcd(a,b);}
LL inv(LL a,LL p){
	LL x,y;
	LL d=exgcd(a,p,x,y);
	return d==1?(x+p)%p:-1;
}
void solve1(){
	int y,z,p;
	scanf("%d%d%d",&amp;y,&amp;z,&amp;p);
	printf("%lld\n",pow(y,z,p));
}
LL BSGS(LL a,LL b,LL p){
	LL m=0;for(;m*m&lt;=p;m++);
	map&lt;LL,int&gt;hash;hash[1]=0;
	LL e=1,amv=inv(pow(a,m,p),p);
	for(int i=1;i&lt;m;i++){
		e=e*a%p;
		if(!hash.count(e))
			hash[e]=i;	
		else break;
	}
	for(int i=0;i&lt;m;i++){
		if(hash.count(b))
			return hash[b]+i*m;
		b=b*amv%p;	
	}
	return -1;
}
void solve2(){
	LL a,b,p;
	scanf("%lld%lld%lld",&amp;a,&amp;b,&amp;p);
	b%=p;
	//if(b&gt;=p)return (void)puts("Math Error");
	//a^x=b (mod p)
	LL e=1%p;
	for(int i=0;i&lt;100;i++){
		if(e==b)return (void)printf("%d\n",i);
		e=e*a%p;
	}
	int r=0;
	while(gcd(a,p)!=1){
		LL d=gcd(a,p);
		if(b%d)return (void)puts("Math Error");
		p/=d;b/=d;b=b*inv(a/d,p);
		r++;
	}LL res=BSGS(a,b,p);
	if(res==-1)return (void)puts("Math Error");
	printf("%lld\n",res+r);
}
void sol(LL a,LL b,LL c,LL &amp;x,LL &amp;y){
	LL d=exgcd(a,b,x,y);
	x=x*c/d;y=y*c/d;
}
void merge(LL &amp;A,LL &amp;B,LL a,LL b){
	LL x,y;
	sol(A,-a,b-B,x,y);
	A=lcm(A,a);	
	B=(a*y+b)%A;
	B=(B+A)%A;
}
LL prod=1,P;
pair&lt;LL,LL&gt; comput(LL n,LL p,LL k){
	if(n&lt;=1)return make_pair(0,1);
	LL ans=1,cnt=0;
	ans=pow(prod,n/P,P);
	cnt=n/p;
	pair&lt;LL,LL&gt;res=comput(n/p,p,k);
	cnt+=res.first;
	ans=ans*res.second%P;
	for(int i=n-n%P+1;i&lt;=n;i++)if(i%p){
	
		ans=ans*i%P;
	}
	return make_pair(cnt,ans);
}
pair&lt;LL,LL&gt; calc(LL n,LL p,LL k){
	prod=1;P=pow(p,k,1e18);
	for(int i=1;i&lt;P;i++)if(i%p)prod=prod*i%P;
	pair&lt;LL,LL&gt; res=comput(n,p,k);
//	res.second=res.second*pow(p,res.first%k,P)%P;
//	res.first-=res.first%k;	
	return res;
}
LL calc(LL n,LL m,LL p,LL k){
	pair&lt;LL,LL&gt;A,B,C;
	LL P=pow(p,k,1e18);
	A=calc(n,p,k);
	B=calc(m,p,k);
	C=calc(n-m,p,k);
	LL ans=1;
	ans=pow(p,A.first-B.first-C.first,P);
	ans=ans*A.second%P*inv(B.second,P)%P*inv(C.second,P)%P;
	return ans;
}
void solve3(){
	LL n,m,P;scanf("%lld%lld%lld",&amp;m,&amp;n,&amp;P);
	if(n&lt;m)return (void)puts("0");
	//C(n,m) mod P
	//P=\prod p_i^{a_i} 
	//n! = p^x \times s
	//CRT ?
	vector&lt;pair&lt;int,int&gt; &gt;vec;
	for(int i=2;i&lt;=P;i++){
		if(P%i==0){
			vec.push_back(make_pair(i,1));
			P/=i;
			while(P%i==0){
				vec.back().second++;
				P/=i;
			}
		}
	}
	LL A=1,B=0;
	for(int i=0;i&lt;vec.size();i++)
		merge(A,B,pow(vec[i].first,vec[i].second),calc(n,m,vec[i].first,vec[i].second));	
	printf("%lld\n",B);
}
int main(){
	int T;scanf("%d",&amp;T);	
	while(T--){
		int ty;scanf("%d",&amp;ty);
		if(ty==1)solve1();
		else if(ty==2)solve2();
		else solve3();
	}
	return 0;
}</pre><pre></pre><h2>Problem3288</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1000010;
int n,mod=1000000007;
int p[maxn],minp[maxn],phi[maxn];
int main(){
	cin&gt;&gt;n;phi[1]=1;
	for(int i=2;i&lt;=n;i++){
		if(!minp[i]){p[++p[0]]=i;minp[i]=i;phi[i]=i-1;}
		for(int j=1;j&lt;=p[0]&amp;&amp;i*p[j]&lt;=n;j++){
			minp[i*p[j]]=p[j];
			if(i%p[j]==0){phi[i*p[j]]=phi[i]*p[j];break;}
			phi[i*p[j]]=phi[i]*(p[j]-1);
		}
	}long long ans=1;
	for(int i=1;i&lt;=n;i++){
		ans*=phi[i];
		if(ans&gt;=mod)ans%=mod;
	}cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}
</pre><pre></pre><h2>Problem3289</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;map&gt;
#include&lt;cctype&gt;
using namespace std;
const int maxn=50005;
int getint(){
	int res=0;char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))res=res*10+c-'0',c=getchar();
	return res;
}
int n,m,sqrtn,bel[maxn],a[maxn];
struct BIT{
	int d[maxn];
	inline int lowbit(int x){return x&amp;-x;}
	int get(int x){
		int ans=0;
		while(x)ans+=d[x],x-=lowbit(x);
		return ans;
	}
	void updata(int x,int f){
		while(x&lt;=n)d[x]+=f,x+=lowbit(x);
	}
}T;
struct qes{
	int l,r,id;
	bool operator&lt;(const qes oth)const{
		return bel[l]&lt;bel[oth.l]||(bel[l]==bel[oth.l]&amp;&amp;r&lt;oth.r);
	}
}q[maxn];
int anss[maxn],ans;
map&lt;int,int&gt;M;
int main(){
	n=getint();sqrtn=sqrt(n);
	for(int i=1;i&lt;=n;i++)a[i]=getint(),bel[i]=i/sqrtn,M[a[i]]=1;int tot=0;
	for(map&lt;int,int&gt;::iterator it=M.begin();it!=M.end();it++)it-&gt;second=++tot;
	for(int i=1;i&lt;=n;i++)a[i]=M[a[i]];
	m=getint();
	for(int i=1;i&lt;=m;i++)q[i].l=getint(),q[i].r=getint(),q[i].id=i;
	sort(q+1,q+1+m);
	int L=1,R=0;
	for(int i=1;i&lt;=m;i++){
		while(q[i].l&lt;L){
			L--;
			ans+=T.get(a[L]-1);
			T.updata(a[L],1);
		}
		while(q[i].l&gt;L){
			ans-=T.get(a[L]-1);
			T.updata(a[L],-1);
			L++;
		}
		while(q[i].r&gt;R){
			R++;
			ans+=(R-L)-T.get(a[R]);
			T.updata(a[R],1);
		}
		while(q[i].r&lt;R){
			ans-=(R-L+1)-T.get(a[R]);
			T.updata(a[R],-1);
			R--;
		}anss[q[i].id]=ans;
	}for(int i=1;i&lt;=m;i++)printf("%d\n",anss[i]);
	return 0;
}</pre><pre></pre><h2>Problem3290</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1e5+5;
int in(){
	int r=0;char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))r=r*10+c-'0',c=getchar();
	return r;
}
int n,m;
struct P{
	int x[3];
	int&amp; operator[](const int &amp;a){return a[x];}
	int operator[](const int &amp;a)const{return a[x];}
	bool operator==(const P &amp;p)const{
		return x[0]==p[0]&amp;&amp;x[1]==p[1]&amp;&amp;x[2]==p[2];
	}
	bool operator&lt;(const P &amp;p)const{
		return x[0]!=p[0]?x[0]&lt;p[0]:(x[1]!=p[1]?x[1]&lt;p[1]:x[2]&lt;p[2]);
	}
	P(){}
}p[maxn*2],_p[maxn];
struct R{
	int mn[3],mx[3];
	R(P p=P()){for(int i=0;i&lt;3;i++)mx[i]=mn[i]=p[i];}
};
R operator+(const R &amp;ls,const R &amp;rs){
	R r=ls;
	for(int i=0;i&lt;3;i++){
		r.mn[i]=min(r.mn[i],rs.mn[i]);
		r.mx[i]=max(r.mx[i],rs.mx[i]);
	}return r;
}
inline bool In(const P &amp;A,const R &amp;B){
	for(register int i=0;i&lt;3;i++){
		if(A[i]&gt;B.mx[i]||A[i]&lt;B.mn[i])
			return false;
	}return true;
}
inline bool In(const R &amp;A,const R &amp;B){
	for(register int i=0;i&lt;3;i++){
		if(!(B.mn[i]&lt;=A.mn[i]&amp;&amp;A.mx[i]&lt;=B.mx[i]))
			return false;
	}return true;	
}
inline bool Out(const R &amp;A,const R &amp;B){
	for(register int i=0;i&lt;3;i++){
		if(A.mx[i]&lt;B.mn[i]||A.mn[i]&gt;B.mx[i])
			return true;
	}return false;		
}
int z=0;
struct node{
	R rc;P p;
	int sum,val;
	int l,r,f;
	void rz();
}t[maxn*2];
void node::rz(){
	sum=val;
	if(l)sum+=t[l].sum;
	if(r)sum+=t[r].sum;
}
int D;
bool cmp(P A,P B){
	return A[D]!=B[D]?A[D]&lt;B[D]:A&lt;B;
}
map&lt;P,int&gt;M;
int ss=0;
int build(int l,int r,int d){
	int x=++z;D=d;
	int mid=(l+r)&gt;&gt;1;
	nth_element(p+l,p+mid,p+r+1,cmp);
	t[x].p=p[mid];t[x].rc=R(t[x].p);M[t[x].p]=++ss;
	if(l&lt;mid)t[x].l=build(l,mid-1,(d==2)?0:d+1),t[x].rc=t[x].rc+t[t[x].l].rc,t[t[x].l].f=x;
	if(r&gt;mid)t[x].r=build(mid+1,r,(d==2)?0:d+1),t[x].rc=t[x].rc+t[t[x].r].rc,t[t[x].r].f=x;
	return x;
}
void Add(int x,P p,int d){
	x=M[p];
	t[x].val+=d;
	while(x){
		t[x].sum+=d;
		x=t[x].f;
	}	
}
int Q(int x,R rc){
	if(In(t[x].rc,rc))return t[x].sum;
	if(Out(t[x].rc,rc))return 0;
	if(!t[x].sum)return 0;
	int ans=0;
	if(In(t[x].p,rc))ans+=t[x].val;
	if(t[x].l)ans+=Q(t[x].l,rc);
	if(t[x].r)ans+=Q(t[x].r,rc);
	return ans;
}
stack&lt;P&gt;ad;
struct qes{	
	int ty;P p;R rc;
}qe[maxn*2];
int psz;
int main(){
	n=in();
	for(int i=1;i&lt;=n;i++)p[i][0]=in(),p[i][1]=in(),p[i][2]=in(),_p[i]=p[i];
	psz=n;
	m=in();
	for(int i=1;i&lt;=m;i++){
		char op[5];scanf("%s",op);
		P p;R rc;
		if(op[0]=='A'){
			p[0]=in();p[1]=in();p[2]=in();
			qe[i].ty=1;qe[i].p=p;
			ad.push(p);
			::p[++psz]=p;
		}else if(op[0]=='Q'){
			rc.mn[0]=in();
			rc.mn[1]=in();
			rc.mn[2]=in();
			int r=in();
			rc.mx[0]=rc.mn[0]+r;
			rc.mx[1]=rc.mn[1]+r;
			rc.mx[2]=rc.mn[2]+r;
			qe[i].ty=0;
			qe[i].rc=rc;
		}else{
			qe[i].ty=-1;
			qe[i].p=ad.top();
			ad.pop();
		}
	}
	build(1,psz,0);
	for(int i=1;i&lt;=n;i++){
		D=2;
		Add(1,_p[i],1);	
	}
	for(int i=1;i&lt;=m;i++){
		int ty=qe[i].ty;
		if(ty==1){
			D=2;
			Add(1,qe[i].p,1);
		}else if(ty==0){
			printf("%d\n",Q(1,qe[i].rc));
		}else{
			D=2;
			Add(1,qe[i].p,-1);			
		}
	}
	return 0;
}</pre><pre></pre><h2>Problem3293</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#define read(x) scanf("%lld",&amp;x)
using namespace std;
typedef long long lld;
lld sum[1000001];
lld n;
lld av=0;
lld ans=0;
int main(){
	read(n);
	for(int i=1;i&lt;=n;i++){
		read(sum[i]);
		av+=sum[i];
	}
	av/=n;
	for(int i=1;i&lt;=n;i++){
		sum[i]-=av;
		sum[i]+=sum[i-1];
	}
	sort(sum+1,sum+1+n);
	lld mid=sum[(n+1)/2];
	for(int i=1;i&lt;=n;i++)
	ans+=abs(sum[i]-mid);
	cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem3295</h2><pre>#include&lt;cstdio&gt;
#include&lt;climits&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#define lson i&lt;&lt;1,l,mid
#define rson i&lt;&lt;1|1,mid+1,r
#define L i&lt;&lt;1
#define R i&lt;&lt;1|1
using namespace std;
const int maxn=1e5+10;
const int maxm=50010;
int n,m;
int a[maxn],b[maxm];
bool hash[maxn];
int rnd(){
	static int KEY=12345678;
	return KEY+=KEY&lt;&lt;2|1;
}
int getint(){
	int res=0,ok=0;char ch;
	while(1){
		ch=getchar();
		if(ch&lt;='9'&amp;&amp;ch&gt;='0'){
			res*=10;res+=ch-'0';ok=1;
		}else if(ok)break;
	}return res;
}
struct Treap{
	struct node{
		int val,key;
		int size;
		node *c[2];
		node(int _val,node *C){
			val=_val;key=rnd();
			c[0]=c[1]=C;size=1;
		}
		void rz(){
			size=c[0]-&gt;size+c[1]-&gt;size+1;
		}
	};
	node *root,*Null;
	Treap(){
		Null=new node(0,0);
		Null-&gt;size=0;Null-&gt;c[0]=Null-&gt;c[1]=Null;
		Null-&gt;key=INT_MAX;root=Null;
	}
	void rot(node *&amp;t,bool d){
		node *p=t-&gt;c[d];
		t-&gt;c[d]=p-&gt;c[!d];
		p-&gt;c[!d]=t;
		t-&gt;rz();p-&gt;rz();
		t=p;
	}
	void _insert(node *&amp;t,int x){
		if(t==Null){
			t=new node(x,Null);
			return ;
		}
		bool d=x&gt;t-&gt;val;
		_insert(t-&gt;c[d],x);
		if(t-&gt;c[d]-&gt;key&lt;t-&gt;key)
			rot(t,d);
		else 
			t-&gt;rz();
	}
	void _del(node *&amp;t,int x){
		if(t-&gt;val==x){
			bool d=t-&gt;c[0]-&gt;key&lt;t-&gt;c[1]-&gt;key;
			if(t-&gt;c[d]==Null){
				delete t;
				t=Null;
				return;
			}
			rot(t,d);
			_del(t-&gt;c[!d],x);
		}else{
			bool d=x&gt;t-&gt;val;
			_del(t-&gt;c[d],x);
		}
		t-&gt;rz();
	}
	int _rank(node *&amp;t,int x){
			if(t==Null)return 0;
		int r=t-&gt;c[0]-&gt;size;
		if(x==t-&gt;val)return r;
		if(x&lt;t-&gt;val)return _rank(t-&gt;c[0],x);
		else return r+1+_rank(t-&gt;c[1],x);
	}
	void _deb(node *&amp;t){
		printf("val:%d  size:%d\n",t-&gt;val,t-&gt;size);
		if(t-&gt;c[0]!=Null){
			printf("L: ");_deb(t-&gt;c[0]);
		}
		if(t-&gt;c[1]!=Null){
			printf("R: ");_deb(t-&gt;c[1]);
		}
	}
	void deb(){_deb(root);}
	void insert(int x){_insert(root,x);}
	void del(int x){_del(root,x);}
	int rank(int x){return _rank(root,x);}
	int size(){return root-&gt;size;}
};
Treap d[maxn];
int lowbit(int x){
	return x&amp;(-x);
}
void updata(int x,int val){
	while(x&lt;=n){
		d[x].insert(val);
		x+=lowbit(x);
	}
}
int get(int x,int val){
	if(x==0)return 0;
	int ans=0;
	while(x){
		ans+=d[x].rank(val);
		x-=lowbit(x);
	}
	return ans;
}
int size(int x){
	if(x==0)return 0;
	int ans=0;
	while(x){
		ans+=d[x].size();
		x-=lowbit(x);
	}
	return ans;
}
long long anss[maxm];
int p[maxn];
long long ans=0;
int main(){
//	freopen("1.txt","r",stdin);
//	freopen("3.txt","w",stdout);
	n=getint();m=getint();
	for(int i=1;i&lt;=n;i++)a[i]=getint(),p[a[i]]=i;
	for(int i=1;i&lt;=m;i++)b[i]=getint(),hash[b[i]]=1;
	
	for(int i=1;i&lt;=n;i++){
		if(!hash[a[i]]){
			updata(i,a[i]);
			ans+=get(n,a[i])-get(i,a[i]);
			ans+=size(i-1)-get(i-1,a[i]);
			//T.Change(1,1,n,i,a[i]);	
			//ans+=T.Rank(1,1,n,i+1,n,a[i]);
			//ans+=T.size(1,1,n,1,i-1)-T.Rank(1,1,n,1,i-1,a[i]);
			//T.deb();
		}	
	}
	
	for(int i=m;i&gt;=1;i--){
		
		
		updata(p[b[i]],b[i]);
		ans+=get(n,b[i])-get(p[b[i]],b[i]);
		ans+=size(p[b[i]]-1)-get(p[b[i]]-1,b[i]);
		//ans+=T.Rank(1,1,n,p[b[i]]+1,n,b[i]);
		//ans+=T.size(1,1,n,1,p[b[i]]-1)-T.Rank(1,1,n,1,p[b[i]]-1,b[i]);
		//T.deb();cout&lt;&lt;endl;
		anss[i]=ans;
	}
	for(int i=1;i&lt;=m;i++)
		printf("%lld\n",anss[i]);
	
	return 0;
}</pre><pre></pre><h2>Problem3295</h2><pre>#include&lt;cstdio&gt;
#include&lt;climits&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#define lson i&lt;&lt;1,l,mid
#define rson i&lt;&lt;1|1,mid+1,r
#define L i&lt;&lt;1
#define R i&lt;&lt;1|1
using namespace std;
const int maxn=1e5+10;
const int maxm=50010;
int n,m;
int a[maxn],b[maxm];
bool hash[maxn];
int rnd(){
	static int KEY=12345678;
	return KEY+=KEY&lt;&lt;2|1;
}
int getint(){
	int res=0,ok=0;char ch;
	while(1){
		ch=getchar();
		if(ch&lt;='9'&amp;&amp;ch&gt;='0'){
			res*=10;res+=ch-'0';ok=1;
		}else if(ok)break;
	}return res;
}
	struct node{
		int val,key;
		int size;
		node *c[2];
		node(int _val=0,node *C=0){
			val=_val;key=rnd();
			c[0]=c[1]=C;size=1;
		}
		void rz(){
			size=c[0]-&gt;size+c[1]-&gt;size+1;
		}
	};
node poor[maxn&lt;&lt;3];
int tot;
struct Treap{

	node *root,*Null;
	Treap(){
		Null=new node(0,0);
		Null-&gt;size=0;Null-&gt;c[0]=Null-&gt;c[1]=Null;
		Null-&gt;key=INT_MAX;root=Null;
	}
	void rot(node *&amp;t,bool d){
		node *p=t-&gt;c[d];
		t-&gt;c[d]=p-&gt;c[!d];
		p-&gt;c[!d]=t;
		t-&gt;rz();p-&gt;rz();
		t=p;
	}
	void _insert(node *&amp;t,int x){
		if(t==Null){
			if(tot&lt;(maxn&lt;&lt;3)){
				t=&amp;poor[tot++];
				t-&gt;val=x;t-&gt;key=rnd();
				t-&gt;c[0]=t-&gt;c[1]=Null;t-&gt;size=1;				
			}else
			t=new node(x,Null);
			return ;
		}
		bool d=x&gt;t-&gt;val;
		_insert(t-&gt;c[d],x);
		if(t-&gt;c[d]-&gt;key&lt;t-&gt;key)
			rot(t,d);
		else 
			t-&gt;rz();
	}
	void _del(node *&amp;t,int x){
		if(t-&gt;val==x){
			bool d=t-&gt;c[0]-&gt;key&lt;t-&gt;c[1]-&gt;key;
			if(t-&gt;c[d]==Null){
				delete t;
				t=Null;
				return;
			}
			rot(t,d);
			_del(t-&gt;c[!d],x);
		}else{
			bool d=x&gt;t-&gt;val;
			_del(t-&gt;c[d],x);
		}
		t-&gt;rz();
	}
	int _rank(node *&amp;t,int x){
			if(t==Null)return 0;
		int r=t-&gt;c[0]-&gt;size;
		if(x==t-&gt;val)return r;
		if(x&lt;t-&gt;val)return _rank(t-&gt;c[0],x);
		else return r+1+_rank(t-&gt;c[1],x);
	}
	void _deb(node *&amp;t){
		printf("val:%d  size:%d\n",t-&gt;val,t-&gt;size);
		if(t-&gt;c[0]!=Null){
			printf("L: ");_deb(t-&gt;c[0]);
		}
		if(t-&gt;c[1]!=Null){
			printf("R: ");_deb(t-&gt;c[1]);
		}
	}
	void deb(){_deb(root);}
	void insert(int x){_insert(root,x);}
	void del(int x){_del(root,x);}
	int rank(int x){return _rank(root,x);}
	int size(){return root-&gt;size;}
};
Treap d[maxn];
int lowbit(int x){
	return x&amp;(-x);
}
void updata(int x,int val){
	while(x&lt;=n){
		d[x].insert(val);
		x+=lowbit(x);
	}
}
int get(int x,int val){
	if(x==0)return 0;
	int ans=0;
	while(x){
		ans+=d[x].rank(val);
		x-=lowbit(x);
	}
	return ans;
}
int size(int x){
	if(x==0)return 0;
	int ans=0;
	while(x){
		ans+=d[x].size();
		x-=lowbit(x);
	}
	return ans;
}
long long anss[maxm];
int p[maxn];
long long ans=0;
int main(){
//	freopen("1.txt","r",stdin);
//	freopen("3.txt","w",stdout);
	n=getint();m=getint();
	for(int i=1;i&lt;=n;i++)a[i]=getint(),p[a[i]]=i;
	for(int i=1;i&lt;=m;i++)b[i]=getint(),hash[b[i]]=1;
	
	for(int i=1;i&lt;=n;i++){
		if(!hash[a[i]]){
			updata(i,a[i]);
			ans+=get(n,a[i])-get(i,a[i]);
			ans+=size(i-1)-get(i-1,a[i]);
			//T.Change(1,1,n,i,a[i]);	
			//ans+=T.Rank(1,1,n,i+1,n,a[i]);
			//ans+=T.size(1,1,n,1,i-1)-T.Rank(1,1,n,1,i-1,a[i]);
			//T.deb();
		}	
	}
	
	for(int i=m;i&gt;=1;i--){
		
		
		updata(p[b[i]],b[i]);
		ans+=get(n,b[i])-get(p[b[i]],b[i]);
		ans+=size(p[b[i]]-1)-get(p[b[i]]-1,b[i]);
		//ans+=T.Rank(1,1,n,p[b[i]]+1,n,b[i]);
		//ans+=T.size(1,1,n,1,p[b[i]]-1)-T.Rank(1,1,n,1,p[b[i]]-1,b[i]);
		//T.deb();cout&lt;&lt;endl;
		anss[i]=ans;
	}
	for(int i=1;i&lt;=m;i++)
		printf("%lld\n",anss[i]);
	
	return 0;
}</pre><pre></pre><h2>Problem3295</h2><pre>#include&lt;cstdio&gt;
#include&lt;climits&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#define lson i&lt;&lt;1,l,mid
#define rson i&lt;&lt;1|1,mid+1,r
#define L i&lt;&lt;1
#define R i&lt;&lt;1|1
using namespace std;
const int maxn=1e5+10;
const int maxm=50010;
int n,m;
int a[maxn],b[maxm];
bool hash[maxn];
int rnd(){
	static int KEY=12345678;
	return KEY+=KEY&lt;&lt;2|1;
}
int getint(){
	int res=0,ok=0;char ch;
	while(1){
		ch=getchar();
		if(ch&lt;='9'&amp;&amp;ch&gt;='0'){
			res*=10;res+=ch-'0';ok=1;
		}else if(ok)break;
	}return res;
}
	struct node{
		int val,key;
		int size;
		node *c[2];
		node(int _val=0,node *C=0){
			val=_val;key=rnd();
			c[0]=c[1]=C;size=1;
		}
		void rz(){
			size=c[0]-&gt;size+c[1]-&gt;size+1;
		}
	};
node poor[maxn&lt;&lt;4];
int tot;
struct Treap{

	node *root,*Null;
	Treap(){
			if(tot&lt;(maxn&lt;&lt;4)){
				Null=&amp;poor[tot++];			
			}else
			Null=new node(0,0);
		Null-&gt;size=0;Null-&gt;c[0]=Null-&gt;c[1]=Null;
		Null-&gt;key=INT_MAX;root=Null;
	}
	void rot(node *&amp;t,bool d){
		node *p=t-&gt;c[d];
		t-&gt;c[d]=p-&gt;c[!d];
		p-&gt;c[!d]=t;
		t-&gt;rz();p-&gt;rz();
		t=p;
	}
	void _insert(node *&amp;t,int x){
		if(t==Null){
			if(tot&lt;(maxn&lt;&lt;4)){
				t=&amp;poor[tot++];
				t-&gt;val=x;t-&gt;key=rnd();
				t-&gt;c[0]=t-&gt;c[1]=Null;t-&gt;size=1;				
			}else
			t=new node(x,Null);
			return ;
		}
		bool d=x&gt;t-&gt;val;
		_insert(t-&gt;c[d],x);
		if(t-&gt;c[d]-&gt;key&lt;t-&gt;key)
			rot(t,d);
		else 
			t-&gt;rz();
	}
	void _del(node *&amp;t,int x){
		if(t-&gt;val==x){
			bool d=t-&gt;c[0]-&gt;key&lt;t-&gt;c[1]-&gt;key;
			if(t-&gt;c[d]==Null){
				delete t;
				t=Null;
				return;
			}
			rot(t,d);
			_del(t-&gt;c[!d],x);
		}else{
			bool d=x&gt;t-&gt;val;
			_del(t-&gt;c[d],x);
		}
		t-&gt;rz();
	}
	int _rank(node *&amp;t,int x){
			if(t==Null)return 0;
		int r=t-&gt;c[0]-&gt;size;
		if(x==t-&gt;val)return r;
		if(x&lt;t-&gt;val)return _rank(t-&gt;c[0],x);
		else return r+1+_rank(t-&gt;c[1],x);
	}
	void _deb(node *&amp;t){
		printf("val:%d  size:%d\n",t-&gt;val,t-&gt;size);
		if(t-&gt;c[0]!=Null){
			printf("L: ");_deb(t-&gt;c[0]);
		}
		if(t-&gt;c[1]!=Null){
			printf("R: ");_deb(t-&gt;c[1]);
		}
	}
	void deb(){_deb(root);}
	void insert(int x){_insert(root,x);}
	void del(int x){_del(root,x);}
	int rank(int x){return _rank(root,x);}
	int size(){return root-&gt;size;}
};
Treap d[maxn];
int lowbit(int x){
	return x&amp;(-x);
}
void updata(int x,int val){
	while(x&lt;=n){
		d[x].insert(val);
		x+=lowbit(x);
	}
}
int get(int x,int val){
	if(x==0)return 0;
	int ans=0;
	while(x){
		ans+=d[x].rank(val);
		x-=lowbit(x);
	}
	return ans;
}
int size(int x){
	if(x==0)return 0;
	int ans=0;
	while(x){
		ans+=d[x].size();
		x-=lowbit(x);
	}
	return ans;
}
long long anss[maxm];
int p[maxn];
long long ans=0;
int main(){
//	freopen("1.txt","r",stdin);
//	freopen("3.txt","w",stdout);
	n=getint();m=getint();
	for(int i=1;i&lt;=n;i++)a[i]=getint(),p[a[i]]=i;
	for(int i=1;i&lt;=m;i++)b[i]=getint(),hash[b[i]]=1;
	
	for(int i=1;i&lt;=n;i++){
		if(!hash[a[i]]){
			updata(i,a[i]);
			ans+=get(n,a[i])-get(i,a[i]);
			ans+=size(i-1)-get(i-1,a[i]);
			//T.Change(1,1,n,i,a[i]);	
			//ans+=T.Rank(1,1,n,i+1,n,a[i]);
			//ans+=T.size(1,1,n,1,i-1)-T.Rank(1,1,n,1,i-1,a[i]);
			//T.deb();
		}	
	}
	
	for(int i=m;i&gt;=1;i--){
		
		
		updata(p[b[i]],b[i]);
		ans+=get(n,b[i])-get(p[b[i]],b[i]);
		ans+=size(p[b[i]]-1)-get(p[b[i]]-1,b[i]);
		//ans+=T.Rank(1,1,n,p[b[i]]+1,n,b[i]);
		//ans+=T.size(1,1,n,1,p[b[i]]-1)-T.Rank(1,1,n,1,p[b[i]]-1,b[i]);
		//T.deb();cout&lt;&lt;endl;
		anss[i]=ans;
	}
	for(int i=1;i&lt;=m;i++)
		printf("%lld\n",anss[i]);
	
	return 0;
}</pre><pre></pre><h2>Problem3295</h2><pre>#include&lt;cstdio&gt;
#include&lt;climits&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#define lson i&lt;&lt;1,l,mid
#define rson i&lt;&lt;1|1,mid+1,r
#define L i&lt;&lt;1
#define R i&lt;&lt;1|1
using namespace std;
const int maxn=1e5+10;
const int maxm=50010;
int n,m;
int a[maxn],b[maxm];
bool hash[maxn];
int rnd(){
	static int KEY=12345678;
	return KEY+=KEY&lt;&lt;2|1;
}
int getint(){
	int res=0,ok=0;char ch;
	while(1){
		ch=getchar();
		if(ch&lt;='9'&amp;&amp;ch&gt;='0'){
			res*=10;res+=ch-'0';ok=1;
		}else if(ok)break;
	}return res;
}
	struct node{
		int val,key;
		int size;
		node *c[2];
		node(int _val=0,node *C=0){
			val=_val;key=rnd();
			c[0]=c[1]=C;size=1;
		}
		void rz(){
			size=c[0]-&gt;size+c[1]-&gt;size+1;
		}
	};
node poor[maxn&lt;&lt;5];
int tot;
struct Treap{

	node *root,*Null;
	Treap(){
			if(tot&lt;(maxn&lt;&lt;5)){
				Null=&amp;poor[tot++];			
			}else
			Null=new node(0,0);
		Null-&gt;size=0;Null-&gt;c[0]=Null-&gt;c[1]=Null;
		Null-&gt;key=INT_MAX;root=Null;
	}
	void rot(node *&amp;t,bool d){
		node *p=t-&gt;c[d];
		t-&gt;c[d]=p-&gt;c[!d];
		p-&gt;c[!d]=t;
		t-&gt;rz();p-&gt;rz();
		t=p;
	}
	void _insert(node *&amp;t,int x){
		if(t==Null){
			if(tot&lt;(maxn&lt;&lt;5)){
				t=&amp;poor[tot++];
				t-&gt;val=x;t-&gt;key=rnd();
				t-&gt;c[0]=t-&gt;c[1]=Null;t-&gt;size=1;				
			}else
			t=new node(x,Null);
			return ;
		}
		bool d=x&gt;t-&gt;val;
		_insert(t-&gt;c[d],x);
		if(t-&gt;c[d]-&gt;key&lt;t-&gt;key)
			rot(t,d);
		else 
			t-&gt;rz();
	}
	void _del(node *&amp;t,int x){
		if(t-&gt;val==x){
			bool d=t-&gt;c[0]-&gt;key&lt;t-&gt;c[1]-&gt;key;
			if(t-&gt;c[d]==Null){
				delete t;
				t=Null;
				return;
			}
			rot(t,d);
			_del(t-&gt;c[!d],x);
		}else{
			bool d=x&gt;t-&gt;val;
			_del(t-&gt;c[d],x);
		}
		t-&gt;rz();
	}
	int _rank(node *&amp;t,int x){
			if(t==Null)return 0;
		int r=t-&gt;c[0]-&gt;size;
		if(x==t-&gt;val)return r;
		if(x&lt;t-&gt;val)return _rank(t-&gt;c[0],x);
		else return r+1+_rank(t-&gt;c[1],x);
	}
	void _deb(node *&amp;t){
		printf("val:%d  size:%d\n",t-&gt;val,t-&gt;size);
		if(t-&gt;c[0]!=Null){
			printf("L: ");_deb(t-&gt;c[0]);
		}
		if(t-&gt;c[1]!=Null){
			printf("R: ");_deb(t-&gt;c[1]);
		}
	}
	void deb(){_deb(root);}
	void insert(int x){_insert(root,x);}
	void del(int x){_del(root,x);}
	int rank(int x){return _rank(root,x);}
	int size(){return root-&gt;size;}
};
Treap d[maxn];
int lowbit(int x){
	return x&amp;(-x);
}
void updata(int x,int val){
	while(x&lt;=n){
		d[x].insert(val);
		x+=lowbit(x);
	}
}
int get(int x,int val){
	if(x==0)return 0;
	int ans=0;
	while(x){
		ans+=d[x].rank(val);
		x-=lowbit(x);
	}
	return ans;
}
int size(int x){
	if(x==0)return 0;
	int ans=0;
	while(x){
		ans+=d[x].size();
		x-=lowbit(x);
	}
	return ans;
}
long long anss[maxm];
int p[maxn];
long long ans=0;
int main(){
//	freopen("1.txt","r",stdin);
//	freopen("3.txt","w",stdout);
	n=getint();m=getint();
	for(int i=1;i&lt;=n;i++)a[i]=getint(),p[a[i]]=i;
	for(int i=1;i&lt;=m;i++)b[i]=getint(),hash[b[i]]=1;
	
	for(int i=1;i&lt;=n;i++){
		if(!hash[a[i]]){
			updata(i,a[i]);
			ans+=get(n,a[i])-get(i,a[i]);
			ans+=size(i-1)-get(i-1,a[i]);
			//T.Change(1,1,n,i,a[i]);	
			//ans+=T.Rank(1,1,n,i+1,n,a[i]);
			//ans+=T.size(1,1,n,1,i-1)-T.Rank(1,1,n,1,i-1,a[i]);
			//T.deb();
		}	
	}
	
	for(int i=m;i&gt;=1;i--){
		
		
		updata(p[b[i]],b[i]);
		ans+=get(n,b[i])-get(p[b[i]],b[i]);
		ans+=size(p[b[i]]-1)-get(p[b[i]]-1,b[i]);
		//ans+=T.Rank(1,1,n,p[b[i]]+1,n,b[i]);
		//ans+=T.size(1,1,n,1,p[b[i]]-1)-T.Rank(1,1,n,1,p[b[i]]-1,b[i]);
		//T.deb();cout&lt;&lt;endl;
		anss[i]=ans;
	}
	for(int i=1;i&lt;=m;i++)
		printf("%lld\n",anss[i]);
	
	return 0;
}</pre><pre></pre><h2>Problem3306</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1e5+5;
int siz[maxn],son[maxn],top[maxn],fa[maxn],dep[maxn],mp[maxn],rmp[maxn],z;
int lef[maxn],rig[maxn],tot;
int rt,n,m,a[maxn];
vector&lt;int&gt;G[maxn];
struct sgt{
	struct node{
		int mn,lz;
		node(){mn=lz=0;}
		node(int mn,int lz):mn(mn),lz(lz){}
		node operator+(const node &amp;rs){return node(min(mn,rs.mn),0);}	
	}t[maxn&lt;&lt;2];
	#define lson i&lt;&lt;1,l,(l+r)/2
	#define rson i&lt;&lt;1|1,(l+r)/2+1,r
	#define ls i&lt;&lt;1
	#define rs i&lt;&lt;1|1
	void build(int i,int l,int r){
		if(l==r){t[i]=node(a[rmp[l]],0);return;}
		build(lson);build(rson);t[i]=t[ls]+t[rs];
	}
	void pd(int i){
		if(t[i].lz){
			t[ls].mn=t[ls].lz=t[rs].mn=t[rs].lz=t[i].lz;
			t[i].lz=0;
		}
	}
	void Cov(int i,int l,int r,int l0,int r0,int d){
		if(l0&gt;r0)swap(l0,r0);
		if(l0&lt;=l&amp;&amp;r0&gt;=r){
			t[i].mn=t[i].lz=d;
			return ;
		}pd(i);
		if(l0&lt;=(l+r)/2)Cov(lson,l0,r0,d);
		if(r0&gt;(l+r)/2)Cov(rson,l0,r0,d);
		t[i]=t[ls]+t[rs];
	}
	int Qmin(int i,int l,int r,int l0,int r0){
		if(l0&gt;r0)swap(l0,r0);
		if(l0&lt;=l&amp;&amp;r0&gt;=r)return t[i].mn;pd(i);
		int ans=INT_MAX;
		if(l0&lt;=(l+r)/2)ans=min(ans,Qmin(lson,l0,r0));
		if(r0&gt;(l+r)/2)ans=min(ans,Qmin(rson,l0,r0));
		return ans;
	}
}T;
void dfs(int u){
	siz[u]=1;
	for(int v,i=0;i&lt;G[u].size();i++){
		if((v=G[u][i])==fa[u])continue;
		fa[v]=u;dep[v]=dep[u]+1;
		dfs(v);	
		siz[u]+=siz[v];
		if(siz[son[u]]&lt;siz[v])son[u]=v;
	}
}
void build(int u,int tp){
	top[u]=tp;mp[u]=++z;lef[u]=++tot;rmp[z]=u;
	if(son[u])build(son[u],tp);
	for(int v,i=0;i&lt;G[u].size();i++)if((v=G[u][i])!=son[u]&amp;&amp;v!=fa[u])
	build(v,v);rig[u]=tot;
}
int lca(int u,int v){
	while(top[u]!=top[v]){
		if(dep[top[u]]&lt;dep[top[v]])swap(u,v);
		u=fa[top[u]];
	}return dep[u]&lt;dep[v]?u:v;
}
int dis(int u,int v){
	int ans=0;
	while(top[u]!=top[v]){
		if(dep[top[u]]&lt;dep[top[v]])swap(u,v);
		ans+=dep[u]-dep[top[u]]+1;
		u=fa[top[u]];
	}if(dep[u]&gt;dep[v])swap(u,v);
	return ans+dep[v]-dep[u];
}
void Cov(int u,int v,int d){
	while(top[u]!=top[v]){
		if(dep[top[u]]&lt;dep[top[v]])swap(u,v);
		T.Cov(1,1,n,mp[u],mp[top[u]],d);
		u=fa[top[u]];
	}if(mp[u]&gt;mp[v])swap(u,v);
	T.Cov(1,1,n,mp[u],mp[v],d);
}
int Qmin(int x){
	if(x==rt)return T.Qmin(1,1,n,1,n);
	int LCA=lca(x,rt);
	if(LCA!=x){
		return T.Qmin(1,1,n,lef[x],rig[x]);
	}else{
		int d=dis(x,rt);
		for(int v,i=0;i&lt;G[x].size();i++){
			if(dis(rt,v=G[x][i])==d-1){
				int l=lef[v]-1,r=rig[v]+1;
				int ans=INT_MAX;
				if(1&lt;=l)ans=min(ans,T.Qmin(1,1,n,1,l));
				if(r&lt;=n)ans=min(ans,T.Qmin(1,1,n,r,n));
				return ans;
//				return min(T.Qmin(1,1,n,1,lef[v]-1),T.Qmin(1,1,n,rig[v]+1,n));
			}
		}
	}
}
int main(){
	scanf("%d%d",&amp;n,&amp;m);
	for(int i=1;i&lt;=n;i++){
		int u,v;scanf("%d%d",&amp;u,&amp;a[i]);
		if(!u){rt=i;continue;}
		G[u].push_back(i);
		G[i].push_back(u);
	}//for(int i=1;i&lt;=n;i++)scanf("%d",&amp;a[i]);
	dfs(1);build(1,1);
	T.build(1,1,n);
	//scanf("%d",&amp;rt);
	while(m--){
		char op=getchar();while(!isalpha(op))op=getchar();
		if(op=='E')scanf("%d",&amp;rt);else
		if(op=='V'){
			int u,v,d;scanf("%d%d",&amp;u,&amp;d);
			Cov(u,u,d);
		}else
		if(op=='Q'){
			int x;scanf("%d",&amp;x);
			printf("%d\n",Qmin(x));
		}
	}
	return 0;
}</pre><pre></pre><h2>Problem3307</h2><pre>#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
 
using namespace std;
 
#define MAXN 100010
#define AddEdge(s,t) Add(s,t),Add(t,s)
#define MAXE 2000010
 
struct edge {
    edge *next;
    int t;
    edge () {
        next=NULL;
    }
} *head[MAXN];
 
void Add(int s,int t) {
    edge *p=new(edge);
    p-&gt;t=t,p-&gt;next=head[s];
    head[s]=p;
}
 
int n,m,size[MAXN],child[MAXN],parent[MAXN],h[MAXN];
int step[MAXN][3],lca[MAXN];
int ans[MAXN];
bool f[MAXN];
 
struct Node {
    Node *next;
    bool flag;
    int z;
} *pre[MAXN];
 
void Maketree(int v) {
    f[v]=false;
    size[v]=1;
    int S=0;
    for (edge *p=head[v];p;p=p-&gt;next) if (f[p-&gt;t]) {
        parent[p-&gt;t]=v;
        h[p-&gt;t]=h[v]+1;
        Maketree(p-&gt;t);
        size[v]+=size[p-&gt;t];
        if (size[p-&gt;t]&gt;S) {
            S=size[p-&gt;t],child[v]=p-&gt;t;
        }
    }
}
 
int first[MAXN],arr[MAXN],Index=0,Rank[MAXN];
 
void Makepath(int v,bool flag,int fir) {
    f[v]=false;
    arr[Rank[v]=++Index]=v;
    if (flag) first[v]=v; else first[v]=fir;
    if (child[v]) {
        Makepath(child[v],false,first[v]);
        for (edge *p=head[v];p;p=p-&gt;next) if (f[p-&gt;t]) {
            Makepath(p-&gt;t,true,0);
        }
    }
}
 
struct node {
    node *next;
    int t,r;
    node () {
        next=NULL;
    }
} *fro[MAXN];
int father[MAXN];
 
void Insert(int s,int t,int r) {
    node *p=new(node);
    p-&gt;t=t,p-&gt;next=fro[s],p-&gt;r=r;
    fro[s]=p;
}
 
int Find(int v) {
    int i,j=v;
    for (i=v;father[i];i=father[i]) ;
    while (father[j]) {
        int k=father[j];
        father[j]=i;
        j=k;
    }
    return i;
}
 
void Tarjan(int v) {
    f[v]=false;
    for (node *p=fro[v];p;p=p-&gt;next) if (!f[p-&gt;t]) {
        lca[p-&gt;r]=Find(p-&gt;t);
    }
    for (edge *p=head[v];p;p=p-&gt;next) if (f[p-&gt;t]) {
        Tarjan(p-&gt;t);
        father[Find(p-&gt;t)]=v;
    }
}
 
void Insert_q(int s,int z,bool flag) {
    Node *p=new(Node);
    p-&gt;next=pre[s],p-&gt;z=z,p-&gt;flag=flag;
    pre[s]=p;
}
 
int b[MAXN],c[MAXN],N=0;
 
bool Cmp(int x,int y) {
    return x&lt;y;
}
 
int Search(int k) {
    int l=1,r=N;
    if (c[l]==k) return l;
    if (c[r]==k) return r;
    while (l&lt;=r) {
        int mid=(l+r)&gt;&gt;1;
        if (c[mid]==k) return mid;
        if (c[mid]&lt;k) l=mid; else r=mid;
    }
}
 
struct Sgt {
    int L[MAXN*4],R[MAXN*4],Max[MAXN*4],Size[MAXN*4];
    Sgt () {
        memset(L,0,sizeof(L));
        memset(R,0,sizeof(R));
        memset(Max,0,sizeof(Max));
        memset(Size,0,sizeof(Size));
    }
    void Build(int l,int r,int t) {
        L[t]=l,R[t]=r;
        if (l==r) {
            Max[t]=l;
            return ;
        }
        Build(l,(l+r)&gt;&gt;1,t&lt;&lt;1),Build(((l+r)&gt;&gt;1)+1,r,(t&lt;&lt;1)^1);
    }
    void update(int t) {
        if (L[t]&lt;R[t]) {
            if (Size[t&lt;&lt;1]&gt;=Size[(t&lt;&lt;1)^1]) {
                Size[t]=Size[t&lt;&lt;1],Max[t]=Max[t&lt;&lt;1];
            } else Size[t]=Size[(t&lt;&lt;1)^1],Max[t]=Max[(t&lt;&lt;1)^1];
        }
    }
    void Insert(int x,int y,int t) {
        if (L[t]==R[t]) {
            Size[t]+=y;
            return ;
        }
        int mid=(L[t]+R[t])&gt;&gt;1;
        if (x&lt;=mid) Insert(x,y,t&lt;&lt;1); else Insert(x,y,(t&lt;&lt;1)^1);
        update(t);
    }
    int Getmax() {
        return Size[1]?Max[1]:0;
    }
};
 
void getint(int &amp;t) {
    scanf("%d",&amp;t);
}
 
void putint(int t) {
    printf("%d\n",t);
}
 
int main() {
	int t=1;
	while(t--){
	    getint(n),getint(m);
	    if(!n&amp;&amp;!m)break;
	    memset(head,0,sizeof(head));
	    memset(fro,0,sizeof(fro));
	    for (int i=0;i++&lt;n-1;) {
	        int s,t;
	        getint(s),getint(t);
	        AddEdge(s,t);
	    }
	    for (int i=0;i++&lt;m;) {
	        getint(step[i][0]),getint(step[i][1]),getint(step[i][2]);
	        Insert(step[i][0],step[i][1],i),Insert(step[i][1],step[i][0],i);
	    }
	    memset(f,true,sizeof(f));
	    memset(child,0,sizeof(child));
	    parent[1]=h[1]=0;
	    h[0]=-1;
	    Maketree(1);
	    memset(f,true,sizeof(f));
	    Makepath(1,true,0);
	    memset(f,true,sizeof(f));
	    memset(father,0,sizeof(father));
	    Tarjan(1);
	    memset(pre,0,sizeof(pre));
	    for (int i=0;i++&lt;m;) {
	        int l=step[i][0],he=h[lca[i]];
	        while (h[l]&gt;=he) {
	            if (h[first[l]]&gt;=he) {
	                Insert_q(Rank[first[l]],step[i][2],true);
	                Insert_q(Rank[l]+1,step[i][2],false);
	                l=parent[first[l]];
	            } else {
	                int r=Rank[l]-(h[l]-he);
	                Insert_q(r,step[i][2],true);
	                Insert_q(Rank[l]+1,step[i][2],false);
	                break;
	            }
	        }
	        l=step[i][1],he=h[lca[i]]+1;
	        while (h[l]&gt;=he) {
	            if (h[first[l]]&gt;=he) {
	                Insert_q(Rank[first[l]],step[i][2],true);
	                Insert_q(Rank[l]+1,step[i][2],false);
	                l=parent[first[l]];
	            } else {
	                int r=Rank[l]-(h[l]-he);
	                Insert_q(r,step[i][2],true);
	                Insert_q(Rank[l]+1,step[i][2],false);
	                break;
	            }
	        }
	    }
	    for (int i=0;i++&lt;m;) b[i]=step[i][2];
	    sort(b+1,b+m+1,Cmp);
	    b[0]=0;
	    for (int i=0;i++&lt;m;) if (b[i]!=b[i-1]) {
	        c[++N]=b[i];
	    }
	    Sgt T;
	    T.Build(1,N,1);
	    c[0]=0;
	    for (int i=0;i++&lt;n;) {
	        for (Node *p=pre[i];p;p=p-&gt;next) if (p-&gt;flag) {
	            T.Insert(Search(p-&gt;z),1,1);
	        } else {
	            T.Insert(Search(p-&gt;z),-1,1);
	        }
	        ans[arr[i]]=T.Getmax();
	    }
	    for (int i=0;i++&lt;n;) putint(c[ans[i]]);		
	} 

    return 0;
}</pre><pre></pre><h2>Problem3307</h2><pre>#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
 
using namespace std;
 
#define MAXN 100010
#define AddEdge(s,t) Add(s,t),Add(t,s)
#define MAXE 2000010
 
struct edge {
    edge *next;
    int t;
    edge () {
        next=NULL;
    }
} *head[MAXN];
 
void Add(int s,int t) {
    edge *p=new(edge);
    p-&gt;t=t,p-&gt;next=head[s];
    head[s]=p;
}
 
int n,m,size[MAXN],child[MAXN],parent[MAXN],h[MAXN];
int step[MAXN][3],lca[MAXN];
int ans[MAXN];
bool f[MAXN];
 
struct Node {
    Node *next;
    bool flag;
    int z;
} *pre[MAXN];
 
void Maketree(int v) {
    f[v]=false;
    size[v]=1;
    int S=0;
    for (edge *p=head[v];p;p=p-&gt;next) if (f[p-&gt;t]) {
        parent[p-&gt;t]=v;
        h[p-&gt;t]=h[v]+1;
        Maketree(p-&gt;t);
        size[v]+=size[p-&gt;t];
        if (size[p-&gt;t]&gt;S) {
            S=size[p-&gt;t],child[v]=p-&gt;t;
        }
    }
}
 
int first[MAXN],arr[MAXN],Index=0,Rank[MAXN];
 
void Makepath(int v,bool flag,int fir) {
    f[v]=false;
    arr[Rank[v]=++Index]=v;
    if (flag) first[v]=v; else first[v]=fir;
    if (child[v]) {
        Makepath(child[v],false,first[v]);
        for (edge *p=head[v];p;p=p-&gt;next) if (f[p-&gt;t]) {
            Makepath(p-&gt;t,true,0);
        }
    }
}
 
struct node {
    node *next;
    int t,r;
    node () {
        next=NULL;
    }
} *fro[MAXN];
int father[MAXN];
 
void Insert(int s,int t,int r) {
    node *p=new(node);
    p-&gt;t=t,p-&gt;next=fro[s],p-&gt;r=r;
    fro[s]=p;
}
 
int Find(int v) {
    int i,j=v;
    for (i=v;father[i];i=father[i]) ;
    while (father[j]) {
        int k=father[j];
        father[j]=i;
        j=k;
    }
    return i;
}
 
void Tarjan(int v) {
    f[v]=false;
    for (node *p=fro[v];p;p=p-&gt;next) if (!f[p-&gt;t]) {
        lca[p-&gt;r]=Find(p-&gt;t);
    }
    for (edge *p=head[v];p;p=p-&gt;next) if (f[p-&gt;t]) {
        Tarjan(p-&gt;t);
        father[Find(p-&gt;t)]=v;
    }
}
 
void Insert_q(int s,int z,bool flag) {
    Node *p=new(Node);
    p-&gt;next=pre[s],p-&gt;z=z,p-&gt;flag=flag;
    pre[s]=p;
}
 
int b[MAXN],c[MAXN],N=0;
 
bool Cmp(int x,int y) {
    return x&lt;y;
}
 
int Search(int k) {
    int l=1,r=N;
    if (c[l]==k) return l;
    if (c[r]==k) return r;
    while (l&lt;=r) {
        int mid=(l+r)&gt;&gt;1;
        if (c[mid]==k) return mid;
        if (c[mid]&lt;k) l=mid; else r=mid;
    }
}
 
struct Sgt {
    int L[MAXN*4],R[MAXN*4],Max[MAXN*4],Size[MAXN*4];
    Sgt () {

    }
    void init(){
        memset(L,0,sizeof(L));
        memset(R,0,sizeof(R));
        memset(Max,0,sizeof(Max));
        memset(Size,0,sizeof(Size));  	
    }
    void Build(int l,int r,int t) {
        L[t]=l,R[t]=r;
        if (l==r) {
            Max[t]=l;
            return ;
        }
        Build(l,(l+r)&gt;&gt;1,t&lt;&lt;1),Build(((l+r)&gt;&gt;1)+1,r,(t&lt;&lt;1)^1);
    }
    void update(int t) {
        if (L[t]&lt;R[t]) {
            if (Size[t&lt;&lt;1]&gt;=Size[(t&lt;&lt;1)^1]) {
                Size[t]=Size[t&lt;&lt;1],Max[t]=Max[t&lt;&lt;1];
            } else Size[t]=Size[(t&lt;&lt;1)^1],Max[t]=Max[(t&lt;&lt;1)^1];
        }
    }
    void Insert(int x,int y,int t) {
        if (L[t]==R[t]) {
            Size[t]+=y;
            return ;
        }
        int mid=(L[t]+R[t])&gt;&gt;1;
        if (x&lt;=mid) Insert(x,y,t&lt;&lt;1); else Insert(x,y,(t&lt;&lt;1)^1);
        update(t);
    }
    int Getmax() {
        return Size[1]?Max[1]:0;
    }
};
 
void getint(int &amp;t) {
    scanf("%d",&amp;t);
}
 
void putint(int t) {
    printf("%d\n",t);
}
 
int main() {
	int t=1;
	while(t--){
		memset(size,0,sizeof size);
		memset(parent,0,sizeof parent);
		memset(h,0,sizeof h);
		memset(lca,0,sizeof lca);
		memset(ans,0,sizeof ans);
		memset(first,0,sizeof first);
		memset(arr,0,sizeof arr);
		memset(Rank,0,sizeof Rank);
		memset(c,0,sizeof c);
		memset(b,0,sizeof b);
	    getint(n),getint(m);
	    if(!n&amp;&amp;!m)break;
	    memset(head,0,sizeof(head));
	    memset(fro,0,sizeof(fro));
	    for (int i=0;i++&lt;n-1;) {
	        int s,t;
	        getint(s),getint(t);
	        AddEdge(s,t);
	    }
	    for (int i=0;i++&lt;m;) {
	        getint(step[i][0]),getint(step[i][1]),getint(step[i][2]);
	        Insert(step[i][0],step[i][1],i),Insert(step[i][1],step[i][0],i);
	    }
	    memset(f,true,sizeof(f));
	    memset(child,0,sizeof(child));
	    parent[1]=h[1]=0;
	    h[0]=-1;
	    Maketree(1);
	    memset(f,true,sizeof(f));
	    Makepath(1,true,0);
	    memset(f,true,sizeof(f));
	    memset(father,0,sizeof(father));
	    Tarjan(1);
	    memset(pre,0,sizeof(pre));
	    for (int i=0;i++&lt;m;) {
	        int l=step[i][0],he=h[lca[i]];
	        while (h[l]&gt;=he) {
	            if (h[first[l]]&gt;=he) {
	                Insert_q(Rank[first[l]],step[i][2],true);
	                Insert_q(Rank[l]+1,step[i][2],false);
	                l=parent[first[l]];
	            } else {
	                int r=Rank[l]-(h[l]-he);
	                Insert_q(r,step[i][2],true);
	                Insert_q(Rank[l]+1,step[i][2],false);
	                break;
	            }
	        }
	        l=step[i][1],he=h[lca[i]]+1;
	        while (h[l]&gt;=he) {
	            if (h[first[l]]&gt;=he) {
	                Insert_q(Rank[first[l]],step[i][2],true);
	                Insert_q(Rank[l]+1,step[i][2],false);
	                l=parent[first[l]];
	            } else {
	                int r=Rank[l]-(h[l]-he);
	                Insert_q(r,step[i][2],true);
	                Insert_q(Rank[l]+1,step[i][2],false);
	                break;
	            }
	        }
	    }
	    for (int i=0;i++&lt;m;) b[i]=step[i][2];
	    sort(b+1,b+m+1,Cmp);
	    b[0]=0;
	    for (int i=0;i++&lt;m;) if (b[i]!=b[i-1]) {
	        c[++N]=b[i];
	    }
	    Sgt T;T.init();
	    T.Build(1,N,1);
	    c[0]=0;
	    for (int i=0;i++&lt;n;) {
	        for (Node *p=pre[i];p;p=p-&gt;next) if (p-&gt;flag) {
	            T.Insert(Search(p-&gt;z),1,1);
	        } else {
	            T.Insert(Search(p-&gt;z),-1,1);
	        }
	        ans[arr[i]]=T.Getmax();
	    }
	    for (int i=0;i++&lt;n;) putint(c[ans[i]]);		
	} 

    return 0;
}</pre><pre></pre><h2>Problem3307</h2><pre>#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
 
using namespace std;
 
#define MAXN 100010
#define AddEdge(s,t) Add(s,t),Add(t,s)
#define MAXE 2000010
 
struct edge {
    edge *next;
    int t;
    edge () {
        next=NULL;
    }
} *head[MAXN];
 
void Add(int s,int t) {
    edge *p=new(edge);
    p-&gt;t=t,p-&gt;next=head[s];
    head[s]=p;
}
 
int n,m,size[MAXN],child[MAXN],parent[MAXN],h[MAXN];
int step[MAXN][3],lca[MAXN];
int ans[MAXN];
bool f[MAXN];
 
struct Node {
    Node *next;
    bool flag;
    int z;
} *pre[MAXN];
 
void Maketree(int v) {
    f[v]=false;
    size[v]=1;
    int S=0;
    for (edge *p=head[v];p;p=p-&gt;next) if (f[p-&gt;t]) {
        parent[p-&gt;t]=v;
        h[p-&gt;t]=h[v]+1;
        Maketree(p-&gt;t);
        size[v]+=size[p-&gt;t];
        if (size[p-&gt;t]&gt;S) {
            S=size[p-&gt;t],child[v]=p-&gt;t;
        }
    }
}
 
int first[MAXN],arr[MAXN],Index,Rank[MAXN];
 
void Makepath(int v,bool flag,int fir) {
    f[v]=false;
    arr[Rank[v]=++Index]=v;
    if (flag) first[v]=v; else first[v]=fir;
    if (child[v]) {
        Makepath(child[v],false,first[v]);
        for (edge *p=head[v];p;p=p-&gt;next) if (f[p-&gt;t]) {
            Makepath(p-&gt;t,true,0);
        }
    }
}
 
struct node {
    node *next;
    int t,r;
    node () {
        next=NULL;
    }
} *fro[MAXN];
int father[MAXN];
 
void Insert(int s,int t,int r) {
    node *p=new(node);
    p-&gt;t=t,p-&gt;next=fro[s],p-&gt;r=r;
    fro[s]=p;
}
 
int Find(int v) {
    int i,j=v;
    for (i=v;father[i];i=father[i]) ;
    while (father[j]) {
        int k=father[j];
        father[j]=i;
        j=k;
    }
    return i;
}
 
void Tarjan(int v) {
    f[v]=false;
    for (node *p=fro[v];p;p=p-&gt;next) if (!f[p-&gt;t]) {
        lca[p-&gt;r]=Find(p-&gt;t);
    }
    for (edge *p=head[v];p;p=p-&gt;next) if (f[p-&gt;t]) {
        Tarjan(p-&gt;t);
        father[Find(p-&gt;t)]=v;
    }
}
 
void Insert_q(int s,int z,bool flag) {
    Node *p=new(Node);
    p-&gt;next=pre[s],p-&gt;z=z,p-&gt;flag=flag;
    pre[s]=p;
}
 
int b[MAXN],c[MAXN],N;
 
bool Cmp(int x,int y) {
    return x&lt;y;
}
 
int Search(int k) {
    int l=1,r=N;
    if (c[l]==k) return l;
    if (c[r]==k) return r;
    while (l&lt;=r) {
        int mid=(l+r)&gt;&gt;1;
        if (c[mid]==k) return mid;
        if (c[mid]&lt;k) l=mid; else r=mid;
    }
}
 
struct Sgt {
    int L[MAXN*4],R[MAXN*4],Max[MAXN*4],Size[MAXN*4];
    Sgt () {

    }
    void init(){
        memset(L,0,sizeof(L));
        memset(R,0,sizeof(R));
        memset(Max,0,sizeof(Max));
        memset(Size,0,sizeof(Size));  	
    }
    void Build(int l,int r,int t) {
        L[t]=l,R[t]=r;
        if (l==r) {
            Max[t]=l;
            return ;
        }
        Build(l,(l+r)&gt;&gt;1,t&lt;&lt;1),Build(((l+r)&gt;&gt;1)+1,r,(t&lt;&lt;1)^1);
    }
    void update(int t) {
        if (L[t]&lt;R[t]) {
            if (Size[t&lt;&lt;1]&gt;=Size[(t&lt;&lt;1)^1]) {
                Size[t]=Size[t&lt;&lt;1],Max[t]=Max[t&lt;&lt;1];
            } else Size[t]=Size[(t&lt;&lt;1)^1],Max[t]=Max[(t&lt;&lt;1)^1];
        }
    }
    void Insert(int x,int y,int t) {
        if (L[t]==R[t]) {
            Size[t]+=y;
            return ;
        }
        int mid=(L[t]+R[t])&gt;&gt;1;
        if (x&lt;=mid) Insert(x,y,t&lt;&lt;1); else Insert(x,y,(t&lt;&lt;1)^1);
        update(t);
    }
    int Getmax() {
        return Size[1]?Max[1]:0;
    }
};
 
void getint(int &amp;t) {
    scanf("%d",&amp;t);
}
 
void putint(int t) {
    printf("%d\n",t);
}
 
int main() {
	int t=1;
	while(t--){
		memset(size,0,sizeof size);
		memset(parent,0,sizeof parent);
		memset(h,0,sizeof h);
		memset(lca,0,sizeof lca);
		memset(ans,0,sizeof ans);
		memset(first,0,sizeof first);
		memset(arr,0,sizeof arr);
		memset(Rank,0,sizeof Rank);
		memset(c,0,sizeof c);
		memset(b,0,sizeof b);
	    getint(n),getint(m);
        Index=0;
        N=0;
	    if(!n&amp;&amp;!m)break;
	    memset(head,0,sizeof(head));
	    memset(fro,0,sizeof(fro));
	    for (int i=0;i++&lt;n-1;) {
	        int s,t;
	        getint(s),getint(t);
	        AddEdge(s,t);
	    }
	    for (int i=0;i++&lt;m;) {
	        getint(step[i][0]),getint(step[i][1]),getint(step[i][2]);
	        Insert(step[i][0],step[i][1],i),Insert(step[i][1],step[i][0],i);
	    }
	    memset(f,true,sizeof(f));
	    memset(child,0,sizeof(child));
	    parent[1]=h[1]=0;
	    h[0]=-1;
	    Maketree(1);
	    memset(f,true,sizeof(f));
	    Makepath(1,true,0);
	    memset(f,true,sizeof(f));
	    memset(father,0,sizeof(father));
	    Tarjan(1);
	    memset(pre,0,sizeof(pre));
	    for (int i=0;i++&lt;m;) {
	        int l=step[i][0],he=h[lca[i]];
	        while (h[l]&gt;=he) {
	            if (h[first[l]]&gt;=he) {
	                Insert_q(Rank[first[l]],step[i][2],true);
	                Insert_q(Rank[l]+1,step[i][2],false);
	                l=parent[first[l]];
	            } else {
	                int r=Rank[l]-(h[l]-he);
	                Insert_q(r,step[i][2],true);
	                Insert_q(Rank[l]+1,step[i][2],false);
	                break;
	            }
	        }
	        l=step[i][1],he=h[lca[i]]+1;
	        while (h[l]&gt;=he) {
	            if (h[first[l]]&gt;=he) {
	                Insert_q(Rank[first[l]],step[i][2],true);
	                Insert_q(Rank[l]+1,step[i][2],false);
	                l=parent[first[l]];
	            } else {
	                int r=Rank[l]-(h[l]-he);
	                Insert_q(r,step[i][2],true);
	                Insert_q(Rank[l]+1,step[i][2],false);
	                break;
	            }
	        }
	    }
	    for (int i=0;i++&lt;m;) b[i]=step[i][2];
	    sort(b+1,b+m+1,Cmp);
	    b[0]=0;
	    for (int i=0;i++&lt;m;) if (b[i]!=b[i-1]) {
	        c[++N]=b[i];
	    }
	    Sgt T;T.init();
	    T.Build(1,N,1);
	    c[0]=0;
	    for (int i=0;i++&lt;n;) {
	        for (Node *p=pre[i];p;p=p-&gt;next) if (p-&gt;flag) {
	            T.Insert(Search(p-&gt;z),1,1);
	        } else {
	            T.Insert(Search(p-&gt;z),-1,1);
	        }
	        ans[arr[i]]=T.Getmax();
	    }
	    for (int i=0;i++&lt;n;) putint(c[ans[i]]);		
	} 

    return 0;
}</pre><pre></pre><h2>Problem3309</h2><pre>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
#include&lt;cstdlib&gt;
using namespace std;
#define MAXN 10000010
int num[MAXN];
bool not_prime[MAXN];
int prime[MAXN],top;
int mu[MAXN],Last[MAXN];
long long sum[MAXN];
long long ans;
int T;
int a,b;
void in(int &amp;x)
{
    char ch=' ';x=0;
    while (!(ch&gt;='0'&amp;&amp;ch&lt;='9')) ch=getchar();
    while (ch&gt;='0'&amp;&amp;ch&lt;='9') x=x*10+ch-'0',ch=getchar();
}
void check_prime()
{
    for (int i=2;i&lt;=MAXN-10;i++)
    {
        if (!not_prime[i])
            prime[++top]=i,mu[i]=-1,num[i]=1,sum[i]=1,Last[i]=i;
        for (int j=1;j&lt;=top&amp;&amp;i*prime[j]&lt;=MAXN-10;j++)
        {
            not_prime[i*prime[j]]=1;
            if (i%prime[j]==0)
            {
                mu[i*prime[j]]=0;
                num[i*prime[j]]=num[i]+1;
                Last[i*prime[j]]=Last[i]*prime[j];
                if (i/Last[i]==1) sum[i*prime[j]]=1;
                else
                if (num[i/Last[i]]==num[i*prime[j]]) sum[i*prime[j]]=-sum[i/Last[i]];
                else sum[i*prime[j]]=0;
                break;
            }
            mu[i*prime[j]]=-mu[i];
            num[i*prime[j]]=1;
            Last[i*prime[j]]=prime[j];
            if (num[i]==1) sum[i*prime[j]]=-sum[i];
            else sum[i*prime[j]]=0;
        }
    }
}
long long get_num(int a,int b)
{
    long long last=0;
    long long ret=0;
    for (long long i=1;i&lt;=min(a,b);i=last+1)
    {
        last=min(a/(a/i),b/(b/i));
        ret+=(long long)(a/i)*(b/i)*(sum[last]-sum[i-1]);
    }
    return ret;
}
int main()
{
    check_prime();
    num[0]=0;num[1]=0;num[2]=1;mu[0]=0;mu[1]=1;
    for (int i=1;i&lt;=MAXN-10;i++) sum[i]+=sum[i-1];
    in(T);
    while (T--)
    {
        in(a);in(b);
        printf("%lld\n",get_num(a,b));
    }
}</pre><pre></pre><h2>Problem3323</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1e5+50;
const int mo=20130426;
typedef long long LL;
struct flag{
	int mul,add;
	flag(){mul=1;add=0;}
	flag(int mul,int add):mul(mul),add(add){}
	void cl(){mul=1;add=0;}
	bool em(){return mul==1&amp;&amp;add==0;}
};
flag operator+(flag A,flag B){return flag((LL)A.mul*B.mul%mo,((LL)A.mul*B.add+A.add)%mo);}
int operator+(flag A,int B){return ((LL)A.mul*B+A.add)%mo;}
struct node{
	int key;
	int val,siz;flag fl;
	node(){}
	node *c[2],*f;
	node *rz(){siz=1;if(c[0])siz+=c[0]-&gt;siz;if(c[1])siz+=c[1]-&gt;siz;return this;}
	void pd(){
		if(fl.em())return;
		if(c[0])c[0]-&gt;val=fl+c[0]-&gt;val,c[0]-&gt;fl=fl+c[0]-&gt;fl;
		if(c[1])c[1]-&gt;val=fl+c[1]-&gt;val,c[1]-&gt;fl=fl+c[1]-&gt;fl;
		fl.cl();
	}
	void split(int ned,node *&amp;p,node *&amp;q);
}nd[maxn],*root;
node *merge(node *p,node *q){
	if(!p||!q)return p?p-&gt;rz():(q?q-&gt;rz():0);
	p-&gt;pd();q-&gt;pd();
	if(p-&gt;key&lt;q-&gt;key){
		p-&gt;c[1]=merge(p-&gt;c[1],q);
		return p-&gt;rz();
	}else{
		q-&gt;c[0]=merge(p,q-&gt;c[0]);
		return q-&gt;rz();
	}
}
#define sz(x) (x?x-&gt;siz:0)
void node::split(int ned,node *&amp;p,node *&amp;q){
	if(!ned){p=0;q=this;return;}
	if(ned==siz){p=this;q=0;return;}
	pd();
	if(sz(c[0])&gt;=ned){
		c[0]-&gt;split(ned,p,q);c[0]=0;rz();
		q=merge(q,this);
	}else{
		c[1]-&gt;split(ned-sz(c[0])-1,p,q);c[1]=0;rz();
		p=merge(this,p);
	}
}
int in(){
	int r=0,f=1;char c=getchar();
	while(!isdigit(c))f=c=='-'?-1:f,c=getchar();
	while(isdigit(c))r=r*10+c-'0',c=getchar();
	return r*f;
}
int n,m;
vector&lt;int&gt;vec;
void dfs(node *t){
	t-&gt;pd();
	if(t-&gt;c[0])dfs(t-&gt;c[0]);
	vec.push_back(t-&gt;val);
	if(t-&gt;c[1])dfs(t-&gt;c[1]);
}
void deb(node *t){
	if(t-&gt;c[0])deb(t-&gt;c[0]);
	printf("%d ",t-&gt;val);
	if(t-&gt;c[1])deb(t-&gt;c[1]);
}
int Q(int v){
	vec.clear();
	int ans=0;dfs(root);
	for(int i=vec.size()-1;i&gt;=0;i--)
		ans=((LL)ans*v+vec[i])%mo;
	return ans;
}
void Mulx(int l,int r){
	l++;r++;
	node *p,*q,*x,*y,*z,*w,*a,*b;
	root-&gt;split(l-1,p,q);
	q-&gt;split(r-l,x,y);
	y-&gt;split(1,z,w);
	w-&gt;split(1,a,b);	
	z-&gt;val=(z-&gt;val+a-&gt;val)%mo;
	a-&gt;val=0;
	//root=merge(p,a,x,z,b);
	root=merge(merge(p,a),merge(x,merge(z,b)));
}
void C(int l,int r,flag f){
	l++;r++;
	node *p,*q,*x,*y;
//	deb(root);puts("");
	root-&gt;split(l-1,p,q);
//	deb(p);puts("");
	q-&gt;split(r-l+1,x,y);
//	deb(x);puts("");
	x-&gt;val=(f+x-&gt;val)%mo;
	x-&gt;fl=f+x-&gt;fl;
	x-&gt;pd();
	root=merge(p,merge(x,y));
}
int main(){
	//freopen("bzoj3323.in","r",stdin);
	m=in();
	//for(int i=1;i&lt;=2e5;i++)root=merge(root,nd+i);
	for(int i=1;i&lt;=1e5+5;i++){
		nd[i].key=rand();
		root=merge(root,nd+i);
	}
	while(m--){
		char op[5];scanf("%s",op);
		int l,r,v;
		if(strlen(op)==4){
			l=in();r=in();
			Mulx(l,r);
		}else if(op[0]=='q'){
			printf("%d\n",Q(in()%mo));
		}else{
			l=in(),r=in();
			flag f;
			if(op[0]=='a')f=flag(1,in()%mo);
			else f=flag(in()%mo,0);
			C(l,r,f);
		}
	}
	return 0;
}</pre><pre></pre><h2>Problem3339</h2><pre>#include&lt;map&gt;
#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=200010;
int mex[maxn],a[maxn],next[maxn];
map&lt;int,int&gt;mp;
int n,m;
void pre(){
	for(int i=1;i&lt;=n;i++){
		if(mp.count(a[i]))
			next[mp[a[i]]]=i-1;
		else
			next[mp[a[i]]]=n;
		mp[a[i]]=i;
	}mp.clear();
	int minn=0;
	if(a[1]==0)minn++;
	mex[1]=minn;mp[a[1]]=1;
	for(int i=2;i&lt;=n;i++){
		mp[a[i]]=1;
		while(mp[minn])minn++;
		mex[i]=minn;
	}
}
int getint(){
	int res=0,ok=0;char ch;
	while(1){
		ch=getchar();
		if(isdigit(ch)){
			res*=10;res+=ch-'0';ok=1;
		}else if(ok)break;
	}return res;
}
void change(int x){
	int val=a[x];
	mex[x]=0;
	int end=next[x];
	if(end==0)end=n;
	for(int i=end;i&gt;x;i--)
		if(mex[i]&gt;val)
			mex[i]=val;
		else
			break;
}
struct qes{
	int ind,l,r;
	bool operator &lt; (const qes &amp;a)const{
		return l&lt;a.l||a.l==l&amp;&amp;r&lt;a.r;
	}	
};
qes q[maxn];
int anss[maxn];
int main(){
	n=getint();m=getint();
	for(int i=1;i&lt;=n;i++)a[i]=getint();
	pre();
	for(int i=1;i&lt;=m;i++){
		q[i].ind=i;q[i].l=getint();q[i].r=getint();
	}sort(q+1,q+1+m);
	int last=1;
	for(int i=1;i&lt;=m;i++){
		if(q[i].l==last){
			anss[q[i].ind]=mex[q[i].r];
		}else{
			for(int j=last;j&lt;q[i].l;j++)
				change(j);
			anss[q[i].ind]=mex[q[i].r];
		}
		last=q[i].l;
	}	
	for(int i=1;i&lt;=m;i++)
		printf("%d\n",anss[i]);
	return 0;
}</pre><pre></pre><h2>Problem3343</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1e6+10;
int a[maxn],s[maxn],L[maxn],R[maxn],delta[maxn],bel[maxn];
int n,m,sqrtn,cnt;
int getint(){
	int res=0;char ch=getchar();
	while(!isdigit(ch))ch=getchar();
	while(isdigit(ch))res=(res&lt;&lt;3)+(res&lt;&lt;1)+ch-'0',ch=getchar();
	return res;
}
int main(){
	n=getint(),m=getint();sqrtn=sqrt(n);
	for(int i=1;i&lt;=n;i++)a[i]=getint(),s[i]=a[i];
	int siz=0;
	int l=1,r=1;
	cnt=1;
	for(int i=1;i&lt;=n;i++){
		if(siz&lt;sqrtn){
			siz++;r=i;bel[i]=cnt;
		}else{			
			L[cnt]=l;R[cnt]=r;cnt++;
			l=r+1;siz=0;bel[i]=cnt;
		}
	}
	if(l&lt;r)L[cnt]=l,R[cnt]=r;
	for(int i=1;i&lt;=cnt;i++)
	sort(s+L[i],s+R[i]+1);
	while(m--){
		char op=getchar();while(!isalpha(op))op=getchar();
		int w;l=getint(),r=getint(),w=getint();
		int lx=l,rx=r;
		if(op=='M'){
			int ans=0;
			if(bel[l]!=bel[r]){
				while(l!=L[bel[l]])
				a[l]+=w,l++;
				while(r!=R[bel[r]])
				a[r]+=w,r--;
				if(l!=lx){
					for(int i=L[bel[lx]];i&lt;=R[bel[lx]];i++)s[i]=a[i];
					sort(s+L[bel[lx]],s+R[bel[lx]]+1);					
				}
				if(r!=rx){
					for(int i=L[bel[rx]];i&lt;=R[bel[rx]];i++)s[i]=a[i];
					sort(s+L[bel[rx]],s+R[bel[rx]]+1);					
				}

				while(bel[l]&lt;=bel[r]&amp;&amp;l&lt;=n)
				delta[bel[l]]+=w,l=R[bel[l]]+1;
			}else{
				while(l&lt;=r)a[l++]+=w;
				for(int i=L[bel[lx]];i&lt;=R[bel[lx]];i++)
				s[i]=a[i];
				sort(s+L[bel[lx]],s+R[bel[lx]]+1);				
			}			
		}else{
			int ans=0;
			if(bel[l]!=bel[r]){
				while(l!=L[bel[l]])
				ans+=a[l]&gt;=(w-delta[bel[l]]),l++;
				while(r!=R[bel[r]])
				ans+=a[r]&gt;=(w-delta[bel[r]]),r--;
				while(bel[l]&lt;=bel[r]&amp;&amp;l&lt;=n)
				ans+=R[bel[l]]-(lower_bound(s+L[bel[l]],s+R[bel[l]]+1,w-delta[bel[l]])-s)+1,l=R[bel[l]]+1;		
			}else
				while(l&lt;=r)
				ans+=a[l]&gt;=(w-delta[bel[l]]),l++;
			printf("%d\n",ans);
		}
	}
	return 0;
}</pre><pre></pre><h2>Problem3390</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
int n,m,tot,ans,fa[1001];
struct edge{int x,y,v;}a[20001];
bool cmp(edge a,edge b)
{return a.v&gt;b.v;}
int find(int x){return fa[x]==x?x:fa[x]=find(fa[x]);}
int main()
{
	scanf("%d%d",&amp;n,&amp;m);
	for(int i=1;i&lt;=n;i++)fa[i]=i;
	for(int i=1;i&lt;=m;i++)
	   scanf("%d%d%d",&amp;a[i].x,&amp;a[i].y,&amp;a[i].v);
	sort(a+1,a+m+1,cmp);
	for(int i=1;i&lt;=m;i++)
	{
		int p=find(a[i].x),q=find(a[i].y);
		if(p!=q)
		{
		    fa[p]=q;tot++;ans+=a[i].v;
		    if(tot==n-1){printf("%d",ans);return 0;}
		}
	}
	printf("-1");
	return 0;
}</pre><pre></pre><h2>Problem3436</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=10010;
int n,m;
struct edge{int u,v,w;};
vector&lt;edge&gt;G[maxn];
void add(int u,int v,int w){
//	cerr&lt;&lt;u&lt;&lt;" "&lt;&lt;v&lt;&lt;" "&lt;&lt;w&lt;&lt;endl;
	G[u].push_back((edge){u,v,w});
}
void spfa(){
	static int vis[maxn],d[maxn],in[maxn];
	for(int i=1;i&lt;=n;i++)d[i]=INT_MIN;
	d[0]=0;
	queue&lt;int&gt;q;q.push(0);
	while(!q.empty()){
		int u=q.front();q.pop();vis[u]=0;
		if(in[u]&gt;5)break;
		for(int i=0;i&lt;G[u].size();i++){
			edge e=G[u][i];
			if(d[e.v]&lt;d[u]+e.w){
				d[e.v]=d[u]+e.w;
				if(!vis[e.v])vis[e.v]=1,q.push(e.v),in[e.v]++;
			}
		}
	}if(*max_element(in+1,in+1+n)&lt;5)
		puts("Yes");
	else puts("No");
}
int main(){
	scanf("%d%d",&amp;n,&amp;m);
	for(int i=1;i&lt;=n;i++)add(0,i,0);
	while(m--){
		int ty,u,v,w;scanf("%d",&amp;ty);
		scanf("%d%d",&amp;u,&amp;v);
		if(ty==1){
			scanf("%d",&amp;w);
			add(v,u,w);
		}else if(ty==2){
			scanf("%d",&amp;w);
			add(u,v,-w);
		}else{
			add(u,v,0);
			add(v,u,0);
		}
	}spfa();
	return 0;
}</pre><pre></pre><h2>Problem3436</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=10010;
int n,m;
struct edge{int u,v,w;};
vector&lt;edge&gt;G[maxn];
void add(int u,int v,int w){
//	cerr&lt;&lt;u&lt;&lt;" "&lt;&lt;v&lt;&lt;" "&lt;&lt;w&lt;&lt;endl;
	G[u].push_back((edge){u,v,w});
}
void spfa(){
	static int vis[maxn],d[maxn],in[maxn];
	for(int i=1;i&lt;=n;i++)d[i]=INT_MAX;
	d[0]=0;
	queue&lt;int&gt;q;q.push(0);
	while(!q.empty()){
		int u=q.front();q.pop();vis[u]=0;
		if(in[u]&gt;5)break;
		for(int i=0;i&lt;G[u].size();i++){
			edge e=G[u][i];
			if(d[e.v]&gt;d[u]+e.w){
				d[e.v]=d[u]+e.w;
				if(!vis[e.v])vis[e.v]=1,q.push(e.v),in[e.v]++;
			}
		}
	}if(*max_element(in+1,in+1+n)&lt;5)
		puts("Yes");
	else puts("No");
}
int main(){
	scanf("%d%d",&amp;n,&amp;m);
	for(int i=1;i&lt;=n;i++)add(0,i,0);
	while(m--){
		int ty,u,v,w;scanf("%d",&amp;ty);
		scanf("%d%d",&amp;u,&amp;v);
		if(ty==1){
			scanf("%d",&amp;w);
			add(u,v,-w);
		}else if(ty==2){
			scanf("%d",&amp;w);
			add(v,u,w);
		}else{
			add(u,v,0);
			add(v,u,0);
		}
	}spfa();
	return 0;
}</pre><pre></pre><h2>Problem3437</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1e6+5;
typedef long long LL;
struct point{
	LL x,y;
	point(LL _x=0,LL _y=0){x=_x;y=_y;}
	LL operator*(point oth){return x*oth.y-y*oth.x;}
	LL operator^(point oth){return x*oth.x+y*oth.y;}
	point operator-(point oth){return point(x-oth.x,y-oth.y);}
};
LL f[maxn],bksum[maxn],sum[maxn];
int a[maxn],b[maxn],n;
struct CH{
	vector&lt;point&gt;ch;
	void push_back(point p){
		while(ch.size()&gt;1&amp;&amp;(p-ch.back())*(ch.back()-ch[ch.size()-2])&gt;=0)ch.pop_back();
		ch.push_back(p);
	}
	LL Qmin(point p){
		int l=0,r=ch.size()-1;
		LL ans=(1LL&lt;&lt;61);
		while(r-l&gt;2){
			int mid1=l+(r-l)/3;
			int mid2=r-(r-l)/3;
			if((p^ch[mid1])&lt;(p^ch[mid2]))
				r=mid2;
			else l=mid1;
		}for(int i=l;i&lt;=r;i++)ans=min(ans,p^ch[i]);
		return ans;
	}
}C;
int getint(){
	int res=0;char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))res=res*10+c-'0',c=getchar();
	return res;
}
int main(){
	n=getint();
	for(int i=1;i&lt;=n;++i)a[i]=getint();
	for(int i=1;i&lt;=n;++i)b[i]=getint();
	for(int i=1;i&lt;=n;i++)sum[i]=sum[i-1]+b[i];
	for(int i=1;i&lt;=n;i++)bksum[i]=bksum[i-1]+(LL)i*b[i];
	C.push_back(point(0,0));
	for(int i=1;i&lt;=n;i++){
		f[i]=C.Qmin(point(-i,1))+a[i]+(LL)i*sum[i]-bksum[i];		
		C.push_back(point(sum[i],f[i]+bksum[i]));
	}cout&lt;&lt;f[n]&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem3438</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=3050;
typedef long long LL;
struct edge{int u,v;LL cap,flow;};
vector&lt;edge&gt;edges;
vector&lt;int&gt;G[maxn];
int s,t;
int cur[maxn],d[maxn];
void add(int u,int v,LL cap){
//	cerr&lt;&lt;u&lt;&lt;" "&lt;&lt;v&lt;&lt;" "&lt;&lt;cap&lt;&lt;endl;
	edges.push_back((edge){u,v,cap,0});
	G[u].push_back(edges.size()-1);
	edges.push_back((edge){v,u,0,0});
	G[v].push_back(edges.size()-1);
}
bool bfs(){
	static int vis[maxn];
	memset(vis,0,sizeof vis);vis[s]=1;
	queue&lt;int&gt;q;q.push(s);d[s]=0;
	while(!q.empty()){
		int u=q.front();q.pop();
		for(int i=0;i&lt;G[u].size();i++){
			edge e=edges[G[u][i]];if(vis[e.v]||e.cap==e.flow)continue;
			d[e.v]=d[u]+1;vis[e.v]=1;q.push(e.v);
		}
	}return vis[t];
}
LL dfs(int u,LL a){
	if(u==t||!a)return a;
	LL flow=0,f;
	for(int &amp;i=cur[u];i&lt;G[u].size();i++){
		edge e=edges[G[u][i]];
		if(d[e.v]==d[u]+1&amp;&amp;(f=dfs(e.v,min(a,e.cap-e.flow)))&gt;0){
			edges[G[u][i]].flow+=f;
			edges[G[u][i]^1].flow-=f;
			flow+=f;a-=f;if(!a)break;
		}
	}return flow;
}
LL dinic(){
	LL flow=0,x;
	while(bfs()){
		memset(cur,0,sizeof cur);
		while(x=dfs(s,1e16)){
			flow+=x;
			memset(cur,0,sizeof cur);
		}
	}return flow;
}
int a[maxn],b[maxn],n,m,z;
int main(){
	scanf("%d",&amp;n);LL sum=0;
	for(int i=1;i&lt;=n;i++)scanf("%d",&amp;a[i]),sum+=a[i];
	for(int i=1;i&lt;=n;i++)scanf("%d",&amp;b[i]),sum+=b[i];
	scanf("%d",&amp;m);
	s=0;t=m*2+n+1;
	for(int i=1;i&lt;=n;i++)
		add(s,i,a[i]),add(i,t,b[i]);
	z=n;
	while(m--){
		int k;scanf("%d",&amp;k);
		int c1,c2;scanf("%d%d",&amp;c1,&amp;c2);
		sum+=c1;sum+=c2;
		add(s,z+1,c1);
		add(z+2,t,c2);
		for(int i=1;i&lt;=k;i++){
			int x;scanf("%d",&amp;x);
			add(z+1,x,1e14);
			add(x,z+2,1e14);
		}z+=2;
	}
	
	cout&lt;&lt;sum-dinic()&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem3450</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=3e5+5;
double l[maxn],f[maxn];
char s[maxn];
int main(){
	int n;scanf("%d",&amp;n);
	scanf("%s",s+1);
	for(int i=1;i&lt;=n;i++){
		if(s[i]=='o'){
			l[i]=l[i-1]+1;
			f[i]=f[i-1]+2*l[i-1]+1;
		}else
		if(s[i]=='x'){
			l[i]=0;
			f[i]=f[i-1];
		}else{
			l[i]=(l[i-1]+1)/2;
			f[i]=f[i-1]+(2*l[i-1]+1)/2;
		}
	}printf("%.4lf\n",f[n]);
	return 0;
}</pre><pre></pre><h2>Problem3473</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=2e5+5;
int son[maxn][26],len[maxn],fa[maxn];
int root=1,last=1,tot=1;
int newnode(int x){
	len[++tot]=x;
	return tot;
}
void add(int w){
	if(son[last][w]){
		int p=last;
		int q=son[last][w];
		if(len[p]+1==len[q])last=q;
		else{
			int nq=newnode(len[p]+1);
			memcpy(son[nq],son[q],sizeof son[nq]);
			fa[nq]=fa[q];fa[q]=nq;
			while(p&amp;&amp;son[p][w]==q)son[p][w]=nq,p=fa[p];	
			last=nq;		
		}
	}else{
		int p=last;
		int np=newnode(len[p]+1);
		while(p&amp;&amp;!son[p][w])son[p][w]=np,p=fa[p];
		if(!p)fa[np]=root;
		else{
			int q=son[p][w];
			if(len[p]+1==len[q])fa[np]=q;
			else{
				int nq=newnode(len[p]+1);
				memcpy(son[nq],son[q],sizeof son[nq]);
				fa[nq]=fa[q];
				fa[q]=fa[np]=nq;
				while(p&amp;&amp;son[p][w]==q)son[p][w]=nq,p=fa[p];
			}
		}last=np;
	}
}
void deb(){
	for(int i=1;i&lt;=tot;i++){
		fprintf(stderr,"id:%d fa:%d\n",i,fa[i]);
		for(int j=0;j&lt;26;j++)if(son[i][j])
			fprintf(stderr,"%d--%c--%d\n",i,j+'a',son[i][j]);
	}fprintf(stderr,"\n");
}
int n,K,now,vis[maxn],cnt[maxn],f[maxn];
string s[int(1e5+1)];
char str[maxn];
void make(int u){
	while(u&amp;&amp;vis[u]!=now){
		vis[u]=now;
		cnt[u]++;
		u=fa[u];
	}
}
void up(int u){
	if(u==1||vis[u])return;
	vis[u]=1;
	up(fa[u]);
	f[u]+=f[fa[u]];
}
int main(){
	scanf("%d%d",&amp;n,&amp;K);
	for(int i=1;i&lt;=n;i++){
		scanf("%s",str);s[i]=string(str);
		for(int j=0;j&lt;s[i].length();j++)
			add(s[i][j]-'a');
		last=root;
//		deb();
	}
//	deb();
	for(int i=1;i&lt;=n;i++){
		int u=root;now=i;
		for(int j=0;j&lt;s[i].length();j++){
			u=son[u][s[i][j]-'a'];
			make(u);
		}
	}
	memset(vis,0,sizeof vis);
	for(int i=1;i&lt;=tot;i++)f[i]=(cnt[i]&gt;=K)*(len[i]-len[fa[i]]);
	
	for(int i=1;i&lt;=tot;i++)up(i);
	
	for(int i=1;i&lt;=n;i++){
		int u=root;now=i;
		long long ans=0;
		for(int j=0;j&lt;s[i].length();j++){
			u=son[u][s[i][j]-'a'];
			ans+=f[u];
		}
		printf("%lld ",ans);
	}	
	
	return 0;
}</pre><pre></pre><h2>Problem3489</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1e5+5;
int n,m;
int in(){
    int r=0;char c=getchar();
    while(!isdigit(c))c=getchar();
    while(isdigit(c))r=r*10+c-'0',c=getchar();
    return r;
}
int lans=0;
int a[maxn],pre[maxn],nxt[maxn],tmp[maxn];
struct point{
    int x[3],v;
    inline int&amp; operator[](const int &amp;s){return x[s];}
    inline int operator[](const int &amp;s)const{return x[s];}
    point(){}
    point(int a,int b,int c){x[0]=a;x[1]=b;x[2]=c;}
}p[maxn];
struct rec{
    int mn[3],mx[3];
    rec(){}
    rec(point p){for(int i=0;i&lt;3;i++)mn[i]=mx[i]=p[i];}
};
rec operator+(rec A,rec B){
    for(int i=0;i&lt;3;i++){
        A.mn[i]=min(A.mn[i],B.mn[i]);
        A.mx[i]=max(A.mx[i],B.mx[i]);
    }return A;
}
struct node{
    rec R;point p;
    int mx;
    int l,r;
    void rz();
}t[maxn];
void node::rz(){
    mx=p.v;R=rec(p);
    if(l)mx=max(mx,t[l].mx),R=R+t[l].R;
    if(r)mx=max(mx,t[r].mx),R=R+t[r].R;
}
int D,z;
bool cmp(point A,point B){
    return A[D]&lt;B[D];
}
int build(int l,int r,int d){
    D=d;int mid=(l+r)&gt;&gt;1;int x=++z;
    nth_element(p+l,p+mid,p+r+1,cmp);
    t[x].p=p[mid];
    if(l&lt;=mid-1)t[x].l=build(l,mid-1,d+1==3?0:d+1);
    if(mid+1&lt;=r)t[x].r=build(mid+1,r,d+1==3?0:d+1);
    t[x].rz();return x;
}
#define IIn(l0,r0,l1,r1) l1&lt;=l0&amp;&amp;r0&lt;=r1
#define OOut(l0,r0,l1,r1) (r0&lt;l1||l0&gt;r1)
#define In(A) \
    (IIn(A.mn[0],A.mx[0],mn[0],mx[0])\
    &amp;&amp;IIn(A.mn[1],A.mx[1],mn[1],mx[1])\
    &amp;&amp;IIn(A.mn[2],A.mx[2],mn[2],mx[2]))
     
#define Out(A) \
    OOut(A.mn[0],A.mx[0],mn[0],mx[0])\
    ||OOut(A.mn[1],A.mx[1],mn[1],mx[1])\
    ||OOut(A.mn[2],A.mx[2],mn[2],mx[2])
#define Inn(p) \
    p[0]&gt;=mn[0]&amp;&amp;p[0]&lt;=mx[0]\
    &amp;&amp;p[1]&gt;=mn[1]&amp;&amp;p[1]&lt;=mx[1]\
    &amp;&amp;p[2]&gt;=mn[2]&amp;&amp;p[2]&lt;=mx[2]
     
#define upd(a,b) (a=a&lt;b?b:a)
//rec R;
int mx[3],mn[3];
#define check(i) (t[i].mx&lt;=lans||(Out(t[i].R)))
 
void Q(const int &amp;i){
    if(In(t[i].R)){upd(lans,t[i].mx);return;}
    if(Inn(t[i].p))upd(lans,t[i].p.v);
    if(t[i].l&amp;&amp;!check(t[i].l))Q(t[i].l);
    if(t[i].r&amp;&amp;!check(t[i].r))Q(t[i].r);
}
int main(){
    n=in();m=in();
    for(int i=1;i&lt;=n;i++)a[i]=in();
    for(int i=1;i&lt;=n;i++)
        pre[i]=tmp[a[i]],tmp[a[i]]=i;
    for(int i=1;i&lt;=n;i++)
        tmp[i]=n+1;
    for(int i=n;i&gt;=1;i--)
        nxt[i]=tmp[a[i]],tmp[a[i]]=i;
    for(int i=1;i&lt;=n;i++){
        p[i]=point(i,pre[i],nxt[i]);
        p[i].v=a[i];
    }
    build(1,n,0);
    while(m--){
        int x=in(),y=in();
        int l=min((x+lans)%n+1,(y+lans)%n+1);
        int r=max((x+lans)%n+1,(y+lans)%n+1);
         
        mn[0]=l;mx[0]=r;
        mn[1]=0;mx[1]=l-1;
        mn[2]=r+1;mx[2]=n+1;
        lans=0;Q(1);
        printf("%d\n",lans);
    }
    return 0;
}</pre><pre></pre><h2>Problem3505</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
LL n,m;
LL C(LL n,LL m){
	LL ans=1;
	for(int i=n;i&gt;n-m;i--)
	ans*=i;
	for(int i=2;i&lt;=m;i++)
	ans/=i;
	return ans;
}
LL ans=0;
int main(){
	cin&gt;&gt;n&gt;&gt;m;
	n++;m++;
	ans=C(n*m,3);
	ans-=C(n,3)*m;
	ans-=C(m,3)*n;
	for(int i=1;i&lt;=n;i++)
	for(int j=1;j&lt;=m;j++){
		ans-=(__gcd(i,j)-1)*(n-i)*(m-j)*2;
	}cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem3506</h2><pre>#include&lt;cstdio&gt;
#include&lt;climits&gt;
#include&lt;cstdlib&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
struct node{
	int val,key,rev,size,id;
	node *c[2],*mn;
	void split(int ned,node *&amp;p,node *&amp;q);
	node(int _val=0,int _id=0,node *C=0){
		key=rand();val=_val;rev=0;size=1;
		c[0]=c[1]=C;mn=this;id=_id;
	}
	void makerev(){
		rev^=1;
		swap(c[0],c[1]);
		if(mn!=this&amp;&amp;c[0]-&gt;mn-&gt;val&lt;=c[1]-&gt;mn-&gt;val){
			if(c[0]-&gt;mn-&gt;id&lt;c[1]-&gt;mn-&gt;id)mn=c[0]-&gt;mn;
		}
	}
	void pushdown(){
		if(rev){
			c[0]-&gt;makerev();
			c[1]-&gt;makerev();
			rev^=1;
		}
	}
	node* rz(){
		size=c[0]-&gt;size+1+c[1]-&gt;size;
		if(c[0]-&gt;mn-&gt;val&lt;c[1]-&gt;mn-&gt;val
		||(c[0]-&gt;mn-&gt;val==c[1]-&gt;mn-&gt;val&amp;&amp;c[0]-&gt;mn-&gt;id&lt;c[1]-&gt;mn-&gt;id))
		mn=c[0]-&gt;mn;else mn=c[1]-&gt;mn;
		if(val&lt;mn-&gt;val||(val==mn-&gt;val&amp;&amp;id&lt;mn-&gt;id))
		mn=this;
		return this;
	}
}*root,*Null;
node *merge(node *p,node *q){
	if(p==Null)return q-&gt;rz();
	if(q==Null)return p-&gt;rz();
	p-&gt;pushdown();q-&gt;pushdown();
	if(p-&gt;key&lt;q-&gt;key){
		p-&gt;c[1]=merge(p-&gt;c[1],q);
		return p-&gt;rz();
	}else{
		q-&gt;c[0]=merge(p,q-&gt;c[0]);
		return q-&gt;rz();
	}
}
void node::split(int ned,node *&amp;p,node *&amp;q){
	if(this==Null){p=q=Null;return;}
	pushdown();
	if(c[0]-&gt;size&gt;=ned){
		c[0]-&gt;split(ned,p,q);
		c[0]=Null;rz();
		q=merge(q,this);
	}else{
		c[1]-&gt;split(ned-c[0]-&gt;size-1,p,q);
		c[1]=Null;rz();
		p=merge(this,p);
	}
}
node *p,*q,*r,*s;
int n;
int getint(){
	int res=0;char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))res=res*10+c-'0',c=getchar();
	return res;
}
int main(){
	Null=new node(INT_MAX,0);
	Null-&gt;key=INT_MAX;Null-&gt;size=0;
	Null-&gt;c[0]=Null-&gt;c[1]=Null;
	root=Null;
	scanf("%d",&amp;n);
	for(int i=1;i&lt;=n;i++){
		int x;scanf("%d",&amp;x);
		root=merge(root,new node(x,i,Null));
	}
	for(int i=1;i&lt;=n;i++){
		root-&gt;split(i-1,p,q);
		int ps=i;r=q;
		while(r-&gt;mn!=r){
			r-&gt;pushdown();
			if(r-&gt;c[0]-&gt;mn-&gt;id==r-&gt;mn-&gt;id)r=r-&gt;c[0];
			else ps+=r-&gt;c[0]-&gt;size+1,r=r-&gt;c[1];
		}ps+=r-&gt;c[0]-&gt;size;
		printf("%d%c",ps," \n"[i==n]);
		q-&gt;split(ps-i+1,r,s);
		r-&gt;makerev();
		root=merge(p,merge(r,s));
	}
	return 0;
}</pre><pre></pre><h2>Problem3522</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=5005;
typedef long long LL;
int n;
vector&lt;int&gt;G[maxn];
LL C(LL n,LL m){
	if(n&lt;m)return 0;
	return n*(n-1)*(n-2)/6;
}
LL dep[maxn];
LL one[maxn];
LL two[maxn];
void dfs(int u,int fa,int d){
	dep[d]++;
	for(int v,i=0;i&lt;G[u].size();i++)if((v=G[u][i])!=fa)dfs(v,u,d+1);
}
LL calc(int s){
	LL ans=0;
	memset(one,0,sizeof one);
	memset(two,0,sizeof two);
	for(int i=0;i&lt;G[s].size();i++){
		int v=G[s][i];
		memset(dep,0,sizeof dep);
		dfs(v,s,1);
		for(int i=1;i&lt;=n;i++){
			ans+=dep[i]*two[i];
			two[i]+=one[i]*dep[i];
			one[i]+=dep[i];
		}
	}return ans;
}
int main(){
	scanf("%d",&amp;n);
	for(int i=1;i&lt;n;i++){
		int u,v;scanf("%d%d",&amp;u,&amp;v);
		G[u].push_back(v);
		G[v].push_back(u);
	}long long ans=0;
	for(int i=1;i&lt;=n;i++)
	ans+=calc(i);
	cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem3523</h2><pre>#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;queue&gt;
#define mp make_pair
#define X first
#define Y second
using namespace std;
const int N=1000100;
priority_queue&lt;pair&lt;int,int&gt; &gt; q;
int n,k,st,ed,p[N],b[N];
bool ok;
void print(int n) {
    for (int i=0;i&lt;n;i++) printf("%d ",p[i]);
    printf("%d\n",p[n]);
}
int main() {
    int i,x,x1,x2,y1,y2;
    scanf("%d%d%d",&amp;k,&amp;st,&amp;ed);
    for (i=1;i&lt;=k;i++) {
        scanf("%d",&amp;b[i]);
        n+=b[i];
    } b[st]--; b[ed]--;
    n--; p[0]=st; p[n]=ed;
    if (!n) {
        if (st!=ed) return puts("0"),0;
        else return printf("%d\n",st),0;
    }
    for (i=1;i&lt;=k;i++) if (b[i]&gt;0) q.push(mp(b[i],i));
    for (i=1;i&lt;n;i++) {
        x1=q.top().X;
        y1=q.top().Y;
        q.pop();
        if (y1!=p[i-1]) {
            p[i]=y1;
            if (x1&gt;1) q.push(mp(x1-1,y1));
        } else {
            if (q.empty()) return puts("0"),0;
            x2=q.top().X;
            y2=q.top().Y;
            q.pop();
            p[i]=y2;
            q.push(mp(x1,y1));
            if (x2&gt;1) q.push(mp(x2-1,y2));
        }
    }
    if (!q.empty()) return puts("0"),0;
    if (p[n-1]!=p[n]) print(n);
    else {
        if (p[n-3]!=p[n-1]) {
            swap(p[n-2],p[n-1]);
            print(n);
        } else return puts("0"),0;
    }
    return 0;
}</pre><pre></pre><h2>Problem3524</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cctype&gt;
#include&lt;map&gt;
#include&lt;vector&gt;
using namespace std;
const int maxn=500005;
int n,m;
map&lt;int,vector&lt;int&gt; &gt;M;
struct qes{
	int x,y,z,ty,ind,cur,delta;
	qes(int _x=0,int _y=0,int _z=0,int _ty=0,int _ind=0,int _cur=0,int _delta=0):
		x(_x),y(_y),z(_z),ty(_ty),cur(_cur),delta(_delta),ind(_ind){}
}q[maxn*2];
int anss[maxn],cnt,mx,md,d[maxn];
int lowbit(int x){return x&amp;-x;}  
int get(int x){int ans=0;while(x)ans+=d[x],x-=lowbit(x);return ans;}  
void updata(int x,int y){while(x&lt;=n)d[x]+=y,x+=lowbit(x);}  
bool part(qes &amp;Q){  
    if(Q.ty==2){  
        if(Q.cur+Q.delta&gt;Q.z-1)return true;  
        Q.cur+=Q.delta;Q.delta=0;return false;  
    }return Q.y&lt;=md;  
}  
void solve(int lef,int rig,int l,int r){  
    if(lef&gt;rig)return;  
    if(l==r){  
        for(int i=lef;i&lt;=rig;i++)if(q[i].ty==2){
        	int L=lower_bound(M[l].begin(),M[l].end(),q[i].x)-M[l].begin();
        	int R=upper_bound(M[l].begin(),M[l].end(),q[i].y)-M[l].begin();
        	if(R-L&gt;(q[i].y-q[i].x+1)/2)
			anss[q[i].ind]=l;
        }return;  
    }int mid=(l+r)&gt;&gt;1;md=mid;  
    for(int i=lef;i&lt;=rig;i++){  
        if(q[i].ty==1&amp;&amp;q[i].y&lt;=mid)updata(q[i].x,1);   
        if(q[i].ty==2)q[i].delta=get(q[i].y)-get(q[i].x-1);  
    }for(int i=lef;i&lt;=rig;i++)
        if(q[i].ty==1&amp;&amp;q[i].y&lt;=mid)updata(q[i].x,-1);   
    int dv=stable_partition(q+lef,q+rig+1,part)-q-1;  
    solve(lef,dv,l,mid);  
    solve(dv+1,rig,mid+1,r);  
}  
int getint(){
	int res=0;char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))res=res*10+c-'0',c=getchar();
	return res;
}
int main(){
	scanf("%d%d",&amp;n,&amp;m);
	for(int i=1;i&lt;=n;i++){
		int x=getint();mx=max(mx,x);
		q[++cnt]=qes(i,x,0,1);M[x].push_back(i);
	}for(int i=1;i&lt;=m;i++){
		int l=getint(),r=getint();
		q[++cnt]=qes(l,r,(r-l+2)/2,2,++anss[0]);
	}solve(1,cnt,0,mx);
	for(int i=1;i&lt;=anss[0];i++)printf("%d\n",anss[i]);	
	return 0;
}</pre><pre></pre><h2>Problem3527</h2><pre>#include&lt;cmath&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=1000010;
int n,N,L;
int rev[maxn];
int dig[maxn];
double p[maxn];
struct cp{
	double r,i;
	cp(double _r=0,double _i=0):
		r(_r),i(_i){}
	cp operator+(cp x){return cp(r+x.r,i+x.i);}
	cp operator-(cp x){return cp(r-x.r,i-x.i);}
	cp operator*(cp x){return cp(r*x.r-i*x.i,r*x.i+i*x.r);}
};
cp a[maxn],b[maxn],c[maxn],A[maxn],x,y;
void FFT(cp a[],int flag){
	for(int i=0;i&lt;N;i++)A[i]=a[rev[i]];
	for(int i=0;i&lt;N;i++)a[i]=A[i];
	for(int i=2;i&lt;=N;i&lt;&lt;=1){
		cp wn(cos(2*M_PI/i),flag*sin(2*M_PI/i));
		for(int k=0;k&lt;N;k+=i){
			cp w(1,0);
			for(int j=0;j&lt;i/2;j++){
				x=a[k+j];
				y=w*a[k+j+i/2];
				a[k+j]=x+y;
				a[k+j+i/2]=x-y;
				w=w*wn;  
			}
		}
	}
	if(flag==-1)for(int i=0;i&lt;N;i++)a[i].r/=N;
}
double anss[maxn];
int main(){
	scanf("%d",&amp;n);
	for(int i=0;i&lt;n;i++)scanf("%lf",&amp;p[i]);
	for(L=0,N=1;N&lt;n;N&lt;&lt;=1,L++);L++;N&lt;&lt;=1;
	for(int i=0;i&lt;N;i++){
		int len=0;
		for(int t=i;t;t&gt;&gt;=1)dig[len++]=t&amp;1;
		for(int j=0;j&lt;L;j++)rev[i]=rev[i]*2+dig[j];
	}
	for(int i=0;i&lt;n;i++)a[i]=cp(p[i],0);
	for(int i=1;i&lt;n;i++)b[i]=cp(1.0/i/i,0);
	FFT(a,1);FFT(b,1);
	for(int i=0;i&lt;N;i++)c[i]=a[i]*b[i];
	FFT(c,-1);
	for(int i=0;i&lt;n;i++)anss[i]=c[i].r;
	memset(a,0,sizeof(a));
	memset(b,0,sizeof(b));
	for(int i=0;i&lt;n;i++)a[i]=cp(p[n-i-1],0);
	for(int i=1;i&lt;n;i++)b[i]=cp(1.0/i/i,0);
	FFT(a,1);FFT(b,1);
	for(int i=0;i&lt;N;i++)c[i]=a[i]*b[i];
	FFT(c,-1);
	for(int i=0;i&lt;n;i++)anss[i]-=c[n-i-1].r;
	for(int i=0;i&lt;n;i++)
		printf("%.9f\n",anss[i]);
	return 0;
}</pre><pre></pre><h2>Problem3529</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cctype&gt;
using namespace std;
const int maxn=1e5+5;
int mx;
int d[maxn];
inline int lowbit(int x){return x&amp;-x;}
int get(int x){
	int ans=0;
	while(x)ans+=d[x],x-=lowbit(x);
	return ans;
}
void updata(int x,int f){
	while(x&lt;=mx)d[x]+=f,x+=lowbit(x);
}
struct qes{int n,m,a,id;bool operator&lt;(const qes oth)const{return a&lt;oth.a;}}Q[maxn];
int anss[maxn];
int getint(){
	int res=0;char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))res=res*10+c-'0',c=getchar();
	return res;
}
bool notp[maxn];
int p[maxn],u[maxn];
pair&lt;int,int&gt; sig[maxn];
void init(int maxn){
	u[1]=1;
	for(int i=2;i&lt;maxn;i++){
		if(!notp[i]){
			p[++p[0]]=i;u[i]=-1;
		}for(int j=1;i*p[j]&lt;maxn&amp;&amp;j&lt;=p[0];j++){
			notp[i*p[j]]=1;
			if(i%p[j]==0){
				u[i*p[j]]=0;break;
			}else u[i*p[j]]=-u[i];
		}
	}for(int i=1;i&lt;maxn;i++)
	for(int j=i;j&lt;maxn;j+=i)sig[j].first+=i;
	for(int i=1;i&lt;maxn;i++)sig[i].second=i;
	sort(sig+1,sig+maxn);
}
int main(){
	int T=getint();
	for(int i=1;i&lt;=T;i++){
		Q[i].n=getint();Q[i].m=getint();
		if(Q[i].n&gt;Q[i].m)swap(Q[i].n,Q[i].m);
		Q[i].a=getint();Q[i].id=i;
		mx=max(mx,Q[i].n);
	}init(mx+1);
	sort(Q+1,Q+1+T);
	int lasta=1;
	for(int i=1;i&lt;=T;i++){
		int newa=upper_bound(sig+1,sig+mx,make_pair(Q[i].a+1,-1))-sig-1;
		for(int j=lasta;j&lt;=newa;j++)
		for(int k=sig[j].second;k&lt;=mx;k+=sig[j].second)
			updata(k,sig[j].first*u[k/sig[j].second]);	
		for(int j=1,k;j&lt;=Q[i].n;j=k+1){
			k=min(Q[i].n/(Q[i].n/j),Q[i].m/(Q[i].m/j));
			anss[Q[i].id]+=(get(k)-get(j-1))*(Q[i].n/j)*(Q[i].m/j);
		}lasta=newa+1;
	}for(int i=1;i&lt;=T;i++)printf("%d\n",anss[i]&amp;0x7fffffff);
	return 0;
} </pre><pre></pre><h2>Problem3531</h2><pre>#include&lt;cstdio&gt;
#include&lt;stack&gt;
#include&lt;deque&gt;
#include&lt;vector&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#define X first
#define Y second
using namespace std;
const int maxn=100100;
vector&lt;int&gt;G[maxn];
typedef pair&lt;int,int&gt; pii;
void add(int u,int v){
	G[u].push_back(v);
	G[v].push_back(u);
}
int top[maxn],w[maxn],fa[maxn],son[maxn],siz[maxn],dep[maxn],z=0;
int n,q;
int W[maxn],C[maxn];
/*
void dfs(const int &amp;u){
	son[u]=0;siz[u]=1;
	for(int i=0;i&lt;G[u].size();i++){
		const int &amp;v=G[u][i];
		if(v!=fa[u]){
			fa[v]=u;
			dep[v]=dep[u]+1;
			dfs(v);
			if(siz[son[u]]&lt;siz[v])son[u]=v;
			siz[u]+=siz[v];
		}
	}
}*//*
inline void dfs(int root,int BigBoss)
{
    memset(cur,-1,sizeof(cur));
    int now=root;
    while (now!=f[root])
    {
        if (cur[now]==-1) 
        {
            cur[now]=point[now];
            boss[now]=BigBoss;
            bossson[BigBoss]++;
            NewSon(now);
        }
        else cur[now]=next[cur[now]];
        if (cur[now]&amp;&amp;v[cur[now]]==f[now]) cur[now]=next[cur[now]];
        if (!cur[now])
        {
            now=f[now];
            continue;
        }
        f[v[cur[now]]]=now;
        now=v[cur[now]];
    }
}*/
int order[maxn];
stack&lt;int&gt;S;
void dfs(int u){
	S.push(u);
	order[0]=0;
	while(!S.empty()){
		int u=S.top();S.pop();
		son[u]=0;siz[u]=1;
		for(int i=0;i&lt;G[u].size();i++){
			int v=G[u][i];
			if(v!=fa[u]){
				dep[v]=dep[u]+1;
				fa[v]=u;
				S.push(v);
				order[++order[0]]=v;			
			}
		}
	}
	for(int i=order[0];i&gt;=1;i--){
		int u=order[i];
		if(siz[son[fa[u]]]&lt;siz[u])son[fa[u]]=u;
		siz[fa[u]]+=siz[u];
	}
}/*
void build(int u,int tp){
	w[u]=++z;top[u]=tp;
	if(son[u])build(son[u],tp);
	for(int i=0;i&lt;G[u].size();i++){
		int v=G[u][i];
		if(v!=fa[u]&amp;&amp;v!=son[u])build(v,v);
	}
}*/
deque&lt;pii&gt;Q;
void build(int u,int tp){
	Q.push_front(pii(u,tp));
	while(!Q.empty()){
		pii t=Q.front();Q.pop_front();
		int u=t.X,tp=t.Y;
		w[u]=++z;top[u]=tp;
		if(son[u])Q.push_front(pii(son[u],tp));
		for(int i=0;i&lt;G[u].size();i++){
			int v=G[u][i];
			if(v!=fa[u]&amp;&amp;v!=son[u])
			Q.push_back(pii(v,v));
		}
	}
}
int V=0;
struct seg_tree{
	struct node{
		int l,r,sum,m;
		node(){l=0;r=0;sum=0;m=0;}
	};
	node t[3010000];
	void rz(int x){
		t[x].sum=t[t[x].l].sum+t[t[x].r].sum;
		t[x].m=max(t[t[x].l].m,t[t[x].r].m);
	}
	void change(int l,int r,int pos,int val,int &amp;c){
		if(l&gt;r)return;
		if(!c)c=++V;
		if(l==r){
			t[c].sum=t[c].m=val;
			return;
		}int mid=l+r&gt;&gt;1;
		if(pos&lt;=mid)change(l,mid,pos,val,t[c].l);
		else change(mid+1,r,pos,val,t[c].r);
		rz(c);
	}
	int qsum(int l,int r,int l0,int r0,int &amp;c){
		if(c==0)return 0;
		if(l&gt;r)return 0;
		if(l0&lt;=l&amp;&amp;r0&gt;=r)
			return t[c].sum;
		int mid=l+r&gt;&gt;1;
		int ans=0;
		if(l0&lt;=mid)ans+=qsum(l,mid,l0,r0,t[c].l);
		if(r0&gt;mid) ans+=qsum(mid+1,r,l0,r0,t[c].r);
		return ans;
	}
	int qmax(int l,int r,int l0,int r0,int &amp;c){
		if(c==0)return 0;
		if(l&gt;r)return 0;
		if(l0&lt;=l&amp;&amp;r0&gt;=r)
			return t[c].m;
		int mid=l+r&gt;&gt;1;
		int ans=0;
		if(l0&lt;=mid)ans=max(ans,qmax(l,mid,l0,r0,t[c].l));
		if(r0&gt;mid) ans=max(ans,qmax(mid+1,r,l0,r0,t[c].r));
		return ans;		
	}
}T;
int Tr[maxn];
void CC(int x,int c){
	T.change(1,n,w[x],0,Tr[C[x]]);
	C[x]=c;
	T.change(1,n,w[x],W[x],Tr[C[x]]);
}
void CW(int x,int ww){
	W[x]=ww;
	T.change(1,n,w[x],ww,Tr[C[x]]);
}
int QS(int u,int v){
	int ans=0;int c=C[u];
	while(top[u]!=top[v]){
		if(dep[top[u]]&gt;dep[top[v]]){
			int a=w[u],b=w[top[u]];
			if(a&gt;b)swap(a,b);
			ans+=T.qsum(1,n,a,b,Tr[c]);
			u=fa[top[u]];
		}else{
			int a=w[v],b=w[top[v]];
			if(a&gt;b)swap(a,b);
			ans+=T.qsum(1,n,a,b,Tr[c]);			
			v=fa[top[v]];
		}
	}
	int a=w[u],b=w[v];
	if(a&gt;b)swap(a,b);
	ans+=T.qsum(1,n,a,b,Tr[c]);
	return ans;
}
int QM(int u,int v){
	int ans=0;int c=C[u];
	while(top[u]!=top[v]){
		if(dep[top[u]]&gt;dep[top[v]]){
			int a=w[u],b=w[top[u]];
			if(a&gt;b)swap(a,b);
			ans=max(ans,T.qmax(1,n,a,b,Tr[c]));
			u=fa[top[u]];
		}else{
			int a=w[v],b=w[top[v]];
			if(a&gt;b)swap(a,b);
			ans=max(ans,T.qmax(1,n,a,b,Tr[c]));		
			v=fa[top[v]];
		}
	}
	int a=w[u],b=w[v];
	if(a&gt;b)swap(a,b);
	ans=max(ans,T.qmax(1,n,a,b,Tr[c]));
	return ans;	
}
int main(){
//	freopen("Q3.in","r",stdin);
	scanf("%d%d",&amp;n,&amp;q);
	for(int i=1;i&lt;=n;i++)
		scanf("%d%d",&amp;W[i],&amp;C[i]);
	for(int i=1;i&lt;n;i++){
		int u,v;
		scanf("%d%d",&amp;u,&amp;v);
		add(u,v);
	}dfs(1);build(1,1);
	for(int i=1;i&lt;=n;i++){
		CC(i,C[i]);
		CW(i,W[i]);
	}
	while(q--){
		int x,y,c,w;
		char opt[2];
		scanf("%s",opt);
		if(opt[0]=='C'&amp;&amp;opt[1]=='C'){
			scanf("%d%d",&amp;x,&amp;c);
			CC(x,c);
		}else
		if(opt[0]=='C'&amp;&amp;opt[1]=='W'){
			scanf("%d%d",&amp;x,&amp;w);
			CW(x,w);
		}else
		if(opt[0]=='Q'&amp;&amp;opt[1]=='S'){
			scanf("%d%d",&amp;x,&amp;y);
			printf("%d\n",QS(x,y));
		}else
		if(opt[0]=='Q'&amp;&amp;opt[1]=='M'){
			scanf("%d%d",&amp;x,&amp;y);
			printf("%d\n",QM(x,y));
		}
	}
	return 0;
}</pre><pre></pre><h2>Problem3531</h2><pre>#include&lt;cstdio&gt;
#include&lt;stack&gt;
#include&lt;deque&gt;
#include&lt;vector&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#define X first
#define Y second
using namespace std;
const int maxn=100100;
vector&lt;int&gt;G[maxn];
typedef pair&lt;int,int&gt; pii;
void add(int u,int v){
	G[u].push_back(v);
	G[v].push_back(u);
}
int top[maxn],w[maxn],fa[maxn],son[maxn],siz[maxn],dep[maxn],z=0;
int n,q;
int W[maxn],C[maxn];

//递归版 
/*
void dfs(const int &amp;u){
	son[u]=0;siz[u]=1;
	for(int i=0;i&lt;G[u].size();i++){
		const int &amp;v=G[u][i];
		if(v!=fa[u]){
			fa[v]=u;
			dep[v]=dep[u]+1;
			dfs(v);
			if(siz[son[u]]&lt;siz[v])son[u]=v;
			siz[u]+=siz[v];
		}
	}
}*/

//GTY神犇版 
/*
inline void dfs(int root,int BigBoss)
{
    memset(cur,-1,sizeof(cur));
    int now=root;
    while (now!=f[root])
    {
        if (cur[now]==-1) 
        {
            cur[now]=point[now];
            boss[now]=BigBoss;
            bossson[BigBoss]++;
            NewSon(now);
        }
        else cur[now]=next[cur[now]];
        if (cur[now]&amp;&amp;v[cur[now]]==f[now]) cur[now]=next[cur[now]];
        if (!cur[now])
        {
            now=f[now];
            continue;
        }
        f[v[cur[now]]]=now;
        now=v[cur[now]];
    }
}*/
//YY的非递归#1 
int order[maxn];
stack&lt;int&gt;S;
void dfs(int u){
	S.push(u);
	order[0]=0;
	while(!S.empty()){
		int u=S.top();S.pop();
		son[u]=0;siz[u]=1;
		for(int i=0;i&lt;G[u].size();i++){
			int v=G[u][i];
			if(v!=fa[u]){
				dep[v]=dep[u]+1;
				fa[v]=u;
				S.push(v);
				order[++order[0]]=v;			
			}
		}
	}
	for(int i=order[0];i&gt;=1;i--){
		int u=order[i];
		if(siz[son[fa[u]]]&lt;siz[u])son[fa[u]]=u;
		siz[fa[u]]+=siz[u];
	}
}
//递归版 
/*
void build(int u,int tp){
	w[u]=++z;top[u]=tp;
	if(son[u])build(son[u],tp);
	for(int i=0;i&lt;G[u].size();i++){
		int v=G[u][i];
		if(v!=fa[u]&amp;&amp;v!=son[u])build(v,v);
	}
}*/
//YY的非递归#2 
deque&lt;pii&gt;Q;
void build(int u,int tp){
	Q.push_front(pii(u,tp));
	while(!Q.empty()){
		pii t=Q.front();Q.pop_front();
		int u=t.X,tp=t.Y;
		w[u]=++z;top[u]=tp;
		if(son[u])Q.push_front(pii(son[u],tp));
		for(int i=0;i&lt;G[u].size();i++){
			int v=G[u][i];
			if(v!=fa[u]&amp;&amp;v!=son[u])
			Q.push_back(pii(v,v));
		}
	}
}

int V=0;
struct seg_tree{
	struct node{
		int l,r,sum,m;
		node(){l=0;r=0;sum=0;m=0;}
	};
	node t[3010000];
	void rz(int x){
		t[x].sum=t[t[x].l].sum+t[t[x].r].sum;
		t[x].m=max(t[t[x].l].m,t[t[x].r].m);
	}
	void change(int l,int r,int pos,int val,int &amp;c){
		if(l&gt;r)return;
		if(!c)c=++V;
		if(l==r){
			t[c].sum=t[c].m=val;
			return;
		}int mid=l+r&gt;&gt;1;
		if(pos&lt;=mid)change(l,mid,pos,val,t[c].l);
		else change(mid+1,r,pos,val,t[c].r);
		rz(c);
	}
	int qsum(int l,int r,int l0,int r0,int &amp;c){
		if(c==0)return 0;
		if(l&gt;r)return 0;
		if(l0&lt;=l&amp;&amp;r0&gt;=r)
			return t[c].sum;
		int mid=l+r&gt;&gt;1;
		int ans=0;
		if(l0&lt;=mid)ans+=qsum(l,mid,l0,r0,t[c].l);
		if(r0&gt;mid) ans+=qsum(mid+1,r,l0,r0,t[c].r);
		return ans;
	}
	int qmax(int l,int r,int l0,int r0,int &amp;c){
		if(c==0)return 0;
		if(l&gt;r)return 0;
		if(l0&lt;=l&amp;&amp;r0&gt;=r)
			return t[c].m;
		int mid=l+r&gt;&gt;1;
		int ans=0;
		if(l0&lt;=mid)ans=max(ans,qmax(l,mid,l0,r0,t[c].l));
		if(r0&gt;mid) ans=max(ans,qmax(mid+1,r,l0,r0,t[c].r));
		return ans;		
	}
}T;
int Tr[maxn];
void CC(int x,int c){
	T.change(1,n,w[x],0,Tr[C[x]]);
	C[x]=c;
	T.change(1,n,w[x],W[x],Tr[C[x]]);
}
void CW(int x,int ww){
	W[x]=ww;
	T.change(1,n,w[x],ww,Tr[C[x]]);
}
int QS(int u,int v){
	int ans=0;int c=C[u];
	while(top[u]!=top[v]){
		if(dep[top[u]]&gt;dep[top[v]]){
			int a=w[u],b=w[top[u]];
			if(a&gt;b)swap(a,b);
			ans+=T.qsum(1,n,a,b,Tr[c]);
			u=fa[top[u]];
		}else{
			int a=w[v],b=w[top[v]];
			if(a&gt;b)swap(a,b);
			ans+=T.qsum(1,n,a,b,Tr[c]);			
			v=fa[top[v]];
		}
	}
	int a=w[u],b=w[v];
	if(a&gt;b)swap(a,b);
	ans+=T.qsum(1,n,a,b,Tr[c]);
	return ans;
}
int QM(int u,int v){
	int ans=0;int c=C[u];
	while(top[u]!=top[v]){
		if(dep[top[u]]&gt;dep[top[v]]){
			int a=w[u],b=w[top[u]];
			if(a&gt;b)swap(a,b);
			ans=max(ans,T.qmax(1,n,a,b,Tr[c]));
			u=fa[top[u]];
		}else{
			int a=w[v],b=w[top[v]];
			if(a&gt;b)swap(a,b);
			ans=max(ans,T.qmax(1,n,a,b,Tr[c]));		
			v=fa[top[v]];
		}
	}
	int a=w[u],b=w[v];
	if(a&gt;b)swap(a,b);
	ans=max(ans,T.qmax(1,n,a,b,Tr[c]));
	return ans;	
}
int main(){
//	freopen("Q3.in","r",stdin);
	scanf("%d%d",&amp;n,&amp;q);
	for(int i=1;i&lt;=n;i++)
		scanf("%d%d",&amp;W[i],&amp;C[i]);
	for(int i=1;i&lt;n;i++){
		int u,v;
		scanf("%d%d",&amp;u,&amp;v);
		add(u,v);
	}dfs((n+1)&gt;&gt;1);build((n+1)&gt;&gt;1,(n+1)&gt;&gt;1);
	for(int i=1;i&lt;=n;i++){
		CC(i,C[i]);
		CW(i,W[i]);
	}
	while(q--){
		int x,y,c,w;
		char opt[2];
		scanf("%s",opt);
		if(opt[0]=='C'&amp;&amp;opt[1]=='C'){
			scanf("%d%d",&amp;x,&amp;c);
			CC(x,c);
		}else
		if(opt[0]=='C'&amp;&amp;opt[1]=='W'){
			scanf("%d%d",&amp;x,&amp;w);
			CW(x,w);
		}else
		if(opt[0]=='Q'&amp;&amp;opt[1]=='S'){
			scanf("%d%d",&amp;x,&amp;y);
			printf("%d\n",QS(x,y));
		}else
		if(opt[0]=='Q'&amp;&amp;opt[1]=='M'){
			scanf("%d%d",&amp;x,&amp;y);
			printf("%d\n",QM(x,y));
		}
	}
	return 0;
}</pre><pre></pre><h2>Problem3533</h2><pre>#include&lt;cstdio&gt;
#include&lt;cctype&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=4e5+5;
typedef long long LL;
int n,m,tmpsize;
LL lastans=0;
int getint(){
	int res=0,f=1;char c=getchar();
	while(!isdigit(c))f=f==-1||c=='-'?-1:1,c=getchar();
	while(isdigit(c))res=res*10+c-'0',c=getchar();
	return (res*f);
}
int decode(LL x){return x^(lastans&amp;0x7fffffff);}
struct point{
	int x,y;
	point(int _x=0,int _y=0):
		x(_x),y(_y){}
}p[maxn],tmp[maxn];
point operator+(const point &amp;a,const point &amp;b){return point(a.x+b.x,a.y+b.y);}
point operator-(const point &amp;a,const point &amp;b){return point(a.x-b.x,a.y-b.y);}
LL operator*(const point &amp;a,const point &amp;b){return (LL)a.x*b.y-(LL)a.y*b.x;}
LL operator^(const point &amp;a,const point &amp;b){return (LL)a.x*b.x+(LL)a.y*b.y;}	
bool operator&lt;(const point &amp;a,const point &amp;b){return a.x&lt;b.x||(a.x==b.x&amp;&amp;a.y&lt;b.y);}
struct CH{
	point *up,*dw;
	int upsize,dwsize;
	void init(int l,int r){
		up=new point[r-l+2];
		dw=new point[r-l+2];
		tmpsize=dwsize=upsize=0;
		for(int i=l;i&lt;=r;i++)tmp[++tmpsize]=p[i];
		sort(tmp+1,tmp+1+tmpsize);
		for(int i=1;i&lt;=tmpsize;i++){
			while(upsize&gt;1&amp;&amp;(tmp[i]-up[upsize])*(up[upsize]-up[upsize-1])&lt;=0)upsize--;
			up[++upsize]=tmp[i];
			while(dwsize&gt;1&amp;&amp;(dw[dwsize]-dw[dwsize-1])*(tmp[i]-dw[dwsize])&lt;=0)dwsize--;
			dw[++dwsize]=tmp[i];
		}
	}	
	LL Qmax(point p){
		int l,r,mid1,mid2;
		LL res=-(1LL&lt;&lt;61);
		if(p.y&gt;=0){
			l=1;r=upsize;
			while(r-l&gt;2){
				mid1=l+(r-l)/3;
				mid2=r-(r-l)/3;
				if((up[mid1]^p)&lt;(up[mid2]^p))
					l=mid1;
				else r=mid2;
			}for(int i=l;i&lt;=r;i++)res=max(res,up[i]^p);
		}else{
			l=1;r=dwsize;
			while(r-l&gt;2){
				mid1=l+(r-l)/3;
				mid2=r-(r-l)/3;
				if(dw[mid1]^p&lt;dw[mid2]^p)
					l=mid1;
				else r=mid2;
			}for(int i=l;i&lt;=r;i++)res=max(res,dw[i]^p);			
		}return res;
	}
};
struct seg{
	#define lson i&lt;&lt;1,l,mid
	#define rson i&lt;&lt;1|1,mid+1,r
	#define L i&lt;&lt;1
	#define R i&lt;&lt;1|1
	bool bud[maxn&lt;&lt;2];
	CH C[maxn&lt;&lt;2];	
	LL Qmax(int i,int l,int r,int l0,int r0,point p){
		if(l0&lt;=l&amp;&amp;r0&gt;=r){
			if(bud[i])return C[i].Qmax(p);
			bud[i]=1;C[i].init(l,r);
			return C[i].Qmax(p);
		}int mid=(l+r)&gt;&gt;1;LL ans=-(1LL&lt;&lt;61);
		if(l0&lt;=mid)ans=max(ans,Qmax(lson,l0,r0,p));
		if(r0&gt;mid)ans=max(ans,Qmax(rson,l0,r0,p));
		return ans;
	}
	#undef lson
	#undef rson
	#undef L
	#undef R
}T;
struct qes{int l,r,x,y,ty;}Q[maxn];
int main(){
	m=getint();char type=getchar();
	while(!isalpha(type))type=getchar();
	for(int i=1;i&lt;=m;i++){
		char op=getchar();while(op!='A'&amp;&amp;op!='Q')op=getchar();
		int l=0,r=0,x=0,y=0,ty=0;LL ans=0;
		if(op=='Q'){
			x=getint();y=getint();
			l=getint();r=getint();
			ty=1;
		}else{
			x=getint();y=getint();
			n++;ty=2;
		}Q[i]=(qes){l,r,x,y,ty};		
	}int size=0;
	for(int i=1;i&lt;=m;i++){
		int l=0,r=0,x=0,y=0;LL ans=0;
		if(Q[i].ty==1){
			x=decode(Q[i].x);y=decode(Q[i].y);
			l=decode(Q[i].l);r=decode(Q[i].r);
			printf("%lld\n",(ans=T.Qmax(1,1,n,l,r,point(x,y))));
			if(type!='E')lastans=ans;
		}else{
			x=decode(Q[i].x);y=decode(Q[i].y);
			p[++size]=point(x,y);
		}
	}	
	return 0;
}</pre><pre></pre><h2>Problem3534</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
int n;
const double eps=1e-8;
double A[55][55];
int dcmp(double x){return x&lt;-eps?-1:x&gt;eps;}
double Gauss(){
	double ans=1;
	for(int i=1;i&lt;n;i++){
		int r=i;
		for(int j=i+1;j&lt;n;j++)if(fabs(A[r][i])&lt;fabs(A[j][i]))r=j;
		if(r!=i)for(int j=1;j&lt;n;j++)swap(A[r][j],A[i][j]);
		for(int j=i+1;j&lt;n;j++){
			double t=A[j][i]/A[i][i];
			for(int k=i;k&lt;n;k++)A[j][k]-=A[i][k]*t;
		}
		if(!dcmp(A[i][i]))return 0;
	}for(int i=1;i&lt;n;i++)ans*=A[i][i];
	return fabs(ans);
}
int main(){
	cin&gt;&gt;n;
	double tmp=1;
	for(int i=1;i&lt;=n;i++)
	for(int j=1;j&lt;=n;j++){
		cin&gt;&gt;A[i][j];
		if(i==j)continue;
		if(A[i][j]&gt;1-eps)A[i][j]-=eps;
		if(i&lt;j)tmp*=1-A[i][j];
		A[i][j]=A[i][j]/(1-A[i][j]);
	}for(int i=1;i&lt;=n;i++)for(int j=1;j&lt;=n;j++)if(i!=j)A[i][i]-=A[i][j];
	cout&lt;&lt;Gauss()*tmp&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem3534</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
int n;
const double eps=1e-8;
double A[55][55];
int dcmp(double x){return x&lt;-eps?-1:x&gt;eps;}
double Gauss(){
	double ans=1;
	for(int i=1;i&lt;n;i++){
		int r=i;
		for(int j=i+1;j&lt;n;j++)if(fabs(A[r][i])&lt;fabs(A[j][i]))r=j;
		if(r!=i)for(int j=1;j&lt;n;j++)swap(A[r][j],A[i][j]);
		for(int j=i+1;j&lt;n;j++){
			double t=A[j][i]/A[i][i];
			for(int k=i;k&lt;n;k++)A[j][k]-=A[i][k]*t;
		}
		if(!dcmp(A[i][i]))return 0;
	}for(int i=1;i&lt;n;i++)ans*=A[i][i];
	return fabs(ans);
}
int main(){
	cin&gt;&gt;n;
	double tmp=1;
	for(int i=1;i&lt;=n;i++)
	for(int j=1;j&lt;=n;j++){
		cin&gt;&gt;A[i][j];
		if(i==j)continue;
		if(A[i][j]&gt;1-eps)A[i][j]-=eps;
		if(i&lt;j)tmp*=1-A[i][j];
		A[i][j]=A[i][j]/(1-A[i][j]);
	}for(int i=1;i&lt;=n;i++)for(int j=1;j&lt;=n;j++)if(i!=j)A[i][i]-=A[i][j];
	//cout&lt;&lt;Gauss()*tmp&lt;&lt;endl;
	printf("%g\n",Gauss()*tmp);
	return 0;
}</pre><pre></pre><h2>Problem3534</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
int n;
const double eps=1e-8;
double A[55][55];
int dcmp(double x){return x&lt;-eps?-1:x&gt;eps;}
double Gauss(){
	double ans=1;
	for(int i=1;i&lt;n;i++){
		int r=i;
		for(int j=i+1;j&lt;n;j++)if(fabs(A[r][i])&lt;fabs(A[j][i]))r=j;
		if(r!=i)for(int j=1;j&lt;n;j++)swap(A[r][j],A[i][j]);
		for(int j=i+1;j&lt;n;j++){
			double t=A[j][i]/A[i][i];
			for(int k=i;k&lt;n;k++)A[j][k]-=A[i][k]*t;
		}
		if(!dcmp(A[i][i]))return 0;
	}for(int i=1;i&lt;n;i++)ans*=A[i][i];
	return fabs(ans);
}
int main(){
	cin&gt;&gt;n;
	double tmp=1;
	for(int i=1;i&lt;=n;i++)
	for(int j=1;j&lt;=n;j++){
		cin&gt;&gt;A[i][j];
		if(i==j)continue;
		if(A[i][j]&gt;1-eps)A[i][j]-=eps;
		if(i&lt;j)tmp*=1-A[i][j];
		A[i][j]=A[i][j]/(1-A[i][j]);
	}for(int i=1;i&lt;=n;i++)for(int j=1;j&lt;=n;j++)if(i!=j)A[i][i]-=A[i][j];
	//cout&lt;&lt;Gauss()*tmp&lt;&lt;endl;
	printf("%.10lf\n",Gauss()*tmp);
	return 0;
}</pre><pre></pre><h2>Problem3534</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
int n;
const double eps=1e-10;
double A[55][55];
int dcmp(double x){return x&lt;-eps?-1:x&gt;eps;}
double Gauss(){
	double ans=1;
	for(int i=1;i&lt;n;i++){
		int r=i;
		for(int j=i+1;j&lt;n;j++)if(fabs(A[r][i])&lt;fabs(A[j][i]))r=j;
		if(r!=i)for(int j=1;j&lt;n;j++)swap(A[r][j],A[i][j]);
		for(int j=i+1;j&lt;n;j++){
			double t=A[j][i]/A[i][i];
			for(int k=i;k&lt;n;k++)A[j][k]-=A[i][k]*t;
		}
		if(!dcmp(A[i][i]))return 0;
	}for(int i=1;i&lt;n;i++)ans*=A[i][i];
	return fabs(ans);
}
int main(){
	cin&gt;&gt;n;
	double tmp=1;
	for(int i=1;i&lt;=n;i++)
	for(int j=1;j&lt;=n;j++){
		cin&gt;&gt;A[i][j];
		if(i==j)continue;
		if(A[i][j]&gt;1-eps)A[i][j]-=eps;
		if(i&lt;j)tmp*=1-A[i][j];
		A[i][j]=A[i][j]/(1-A[i][j]);
	}for(int i=1;i&lt;=n;i++)for(int j=1;j&lt;=n;j++)if(i!=j)A[i][i]-=A[i][j];
	printf("%.10lf\n",Gauss()*tmp);
	return 0;
}</pre><pre></pre><h2>Problem3543</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1e5+10;
const int maxA=maxn*10;
int x[maxn],y[maxn],X[maxn],Y[maxn];
map&lt;int,int&gt; reX,reY;
vector&lt;int&gt; b[maxn],a[maxn];
set&lt;int&gt;Sx[maxn],Sy[maxn];
int n,sqrtn;
int hash[maxn];
int A[maxn],B[maxn];
int getint(){
    int res=0,f=1;char c=getchar();
    while(!isdigit(c))f=f==-1||c=='-'?-1:1,c=getchar();
    while(isdigit(c))res=(res&lt;&lt;3)+(res&lt;&lt;1)+c-'0',c=getchar();
    return res*f;
}
void deb(vector&lt;int&gt; v){
	for(int i=0;i&lt;v.size()-1;i++)
	cout&lt;&lt;v[i]&lt;&lt;" ";cout&lt;&lt;v.back()&lt;&lt;endl;
}
int main(){
    n=getint();sqrtn=sqrt(n);
    for(int i=1;i&lt;=n;i++){
        y[i]=getint();x[i]=getint();
        X[++X[0]]=x[i];Y[++Y[0]]=y[i];
    }sort(X+1,X+1+X[0]);X[0]=unique(X+1,X+1+X[0])-X-1;
    sort(Y+1,Y+1+Y[0]);Y[0]=unique(Y+1,Y+1+Y[0])-Y-1;
    for(int i=1;i&lt;=n;i++)x[i]=lower_bound(X+1,X+1+X[0],x[i])-X,y[i]=lower_bound(Y+1,Y+1+Y[0],y[i])-Y;
    //cerr&lt;&lt;((double)clock()/CLOCKS_PER_SEC)&lt;&lt;endl;
    for(int i=1;i&lt;=X[0];i++)reX[X[i]+maxA]=i;
    for(int i=1;i&lt;=Y[0];i++)reY[Y[i]+maxA]=i;
	for(int i=1;i&lt;=n;i++)b[x[i]].push_back(y[i]);
	for(int i=1;i&lt;=n;i++)a[y[i]].push_back(x[i]);
    long long ans=0;
    //cerr&lt;&lt;((double)clock()/CLOCKS_PER_SEC)&lt;&lt;endl;
    for(int i=1;i&lt;=X[0];i++)sort(b[i].begin(),b[i].end());//,deb(b[i]);
    for(int i=1;i&lt;=Y[0];i++)sort(a[i].begin(),a[i].end());//,deb(a[i]); 
    //cerr&lt;&lt;((double)clock()/CLOCKS_PER_SEC)&lt;&lt;endl;
    for(int i=1;i&lt;=n;i++){
    	int j=upper_bound(b[x[i]].begin(),b[x[i]].end(),y[i])-b[x[i]].begin();
		int k=upper_bound(a[y[i]].begin(),a[y[i]].end(),x[i])-a[y[i]].begin();
		if(b[x[i]].size()-j&lt;a[y[i]].size()-k){
	        for(;j&lt;b[x[i]].size();j++){
	            int len=abs(Y[y[i]]-Y[b[x[i]][j]]);
	            int xx=reX[X[x[i]]+len+maxA];
	            if(xx&amp;&amp;binary_search(b[xx].begin(),b[xx].end(),y[i])
					&amp;&amp;binary_search(b[xx].begin(),b[xx].end(),b[x[i]][j]))
	            ans++;
	        }
		}else{
	        for(;k&lt;a[y[i]].size();k++){
	        	int len=abs(X[x[i]]-X[a[y[i]][k]]);
	        	int yy=reY[Y[y[i]]+len+maxA];
	        	if(yy&amp;&amp;binary_search(a[yy].begin(),a[yy].end(),x[i])
					&amp;&amp;binary_search(a[yy].begin(),a[yy].end(),a[y[i]][k]))
				ans++;
	        }			
		}
    }cout&lt;&lt;ans&lt;&lt;endl;
    //cerr&lt;&lt;((double)clock()/CLOCKS_PER_SEC)&lt;&lt;endl;
    return 0;
} </pre><pre></pre><h2>Problem3544</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
const int maxn=2e5+5;
int n;
LL a[maxn],m;
set&lt;LL&gt;S;
int main(){
	scanf("%d%lld",&amp;n,&amp;m);
	for(int i=1;i&lt;=n;i++){
		LL x;scanf("%lld",&amp;x);
		a[i]=(a[i-1]%m+x%m+m)%m;
	}LL ans=0;
	for(int i=1;i&lt;=n;i++){
		set&lt;LL&gt;::iterator it;
		ans=max(ans,a[i]);
		if((it=S.upper_bound(a[i]))!=S.end())
			ans=max(ans,(a[i]-*it+m)%m);
		S.insert(a[i]);
	}cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}
</pre><pre></pre><h2>Problem3545</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1e5+10;
const int maxm=5e5+10;
int n,m,q;
int getint(){
	int res=0;char ch=getchar();
	while(!isdigit(ch))ch=getchar();
	while(isdigit(ch))res=(res&lt;&lt;3)+(res&lt;&lt;1)+ch-'0',ch=getchar();
	return res;
}
int rnd(){
	static int KEY=12345678;
	return KEY+=KEY&lt;&lt;2|1;
}
struct node{
	int val,key,size,s;
	node *c[2];
    void rz(){  
        size=c[0]-&gt;size+s+c[1]-&gt;size;  
    }  
    void set(int _val=0,int _key=rnd(),int _size=1,int _s=1,node *C=NULL){  
        val=_val;key=_key;size=_size;s=_s;c[0]=c[1]=C;  
    }  
};
node pool[maxn];
node* newnode(){
	static int tot=0;
	if(tot&lt;maxn)return &amp;pool[tot++];
	return new node();
}
struct Treap{
	node *root,*Null;
	Treap(){
		Null=newnode();
		Null-&gt;set(0,INT_MAX,0,0,Null);
		root=Null;
	}	
   void rot(node *&amp;t,bool d){  
        node *p=t-&gt;c[d];t-&gt;c[d]=p-&gt;c[!d];  
        p-&gt;c[!d]=t;t-&gt;rz();p-&gt;rz();t=p;  
    }  
    void _insert(node *&amp;t,int x){  
        if(t==Null){t=newnode();t-&gt;set(x,rnd(),1,1,Null);return;}  
        if(t-&gt;val==x){t-&gt;size+=1;t-&gt;s+=1;return;}  
        _insert(t-&gt;c[x&gt;t-&gt;val],x);  
        if(t-&gt;c[x&gt;t-&gt;val]-&gt;key&lt;t-&gt;key)rot(t,x&gt;t-&gt;val);  
        else t-&gt;rz();  
    }  
	int _kth(node *t,int x){
        int r=t-&gt;c[0]-&gt;size;  
        if(t==Null)return 0;  
        else if(x&lt;=r)return _kth(t-&gt;c[0],x);  
        else if(x&gt;r+t-&gt;s)return _kth(t-&gt;c[1],x-r-t-&gt;s);  
        else return t-&gt;val;  
	}
	void insert(int x){_insert(root,x);}
	int kth(int x){return _kth(root,x);}
	int size(){return root-&gt;size;}
}T[maxn];
int fa[maxn];
int find(int x){
	if(fa[x]!=x)return fa[x]=find(fa[x]);return x;
}
void Union(int x,int y){
	int fax=find(x),fay=find(y);
	if(fax==fay)return;
	if(T[fax].size()&lt;T[fay].size())swap(x,y),swap(fax,fay);
	fa[fay]=fax;
	for(int i=0;i&lt;T[fay].size();i++){
		int val=T[fay].kth(i+1);
//		cout&lt;&lt;T[fax].size()&lt;&lt;endl;
		T[fax].insert(val);
//		cout&lt;&lt;T[fax].size()&lt;&lt;endl;
	}
}
struct edge{
	int u,v,w;
	bool operator&lt;(const edge &amp;E)const{return w&lt;E.w;}
};
edge edges[maxm];
struct qes{
	int u,x,k,ind;
	bool operator&lt;(const qes &amp;q)const{return x&lt;q.x;}
};
qes Q[maxm];
int anss[maxm];
int main(){
	n=getint();m=getint();q=getint();
	for(int i=1;i&lt;=n;i++){
		int x=getint();
		T[i].insert(x);fa[i]=i;
	}for(int i=1;i&lt;=m;i++){
		edges[i].u=getint();
		edges[i].v=getint();
		edges[i].w=getint();
	}sort(edges+1,edges+1+m);
	for(int i=1;i&lt;=q;i++){
		Q[i].u=getint();Q[i].x=getint();
		Q[i].k=getint();Q[i].ind=i;
	}sort(Q+1,Q+1+q);
	int now=1;
	for(int i=1;i&lt;=q;i++){	
		for(;now&lt;=m&amp;&amp;edges[now].w&lt;=Q[i].x;now++)
		Union(edges[now].u,edges[now].v);
		int f=find(Q[i].u);
		Q[i].k=T[f].size()-Q[i].k;
		if(Q[i].k&lt;0)anss[Q[i].ind]=-1;
		else anss[Q[i].ind]=T[f].kth(Q[i].k+1);
	}
	for(int i=1;i&lt;=q;i++)
	printf("%d\n",anss[i]);
	return 0;
}</pre><pre></pre><h2>Problem3550</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1005;
const int maxm=605;
const double eps=1e-8;
double a[maxn][maxm];
int n,m;
int dcmp(double x){
	if(fabs(x)&lt;eps)return 0;
	return x&gt;0?1:-1;
}
double simplex(bool f);
void pivot(int l,int e,bool f){
	for(int i=0;i&lt;=m+f;i++){
		if(i==e)continue;
		a[l][i]/=a[l][e];
	}a[l][e]=1/a[l][e];
	for(int i=0;i&lt;=n+f;i++){
		if(i==l)continue;
		for(int j=0;j&lt;=m+f;j++){
			if(j==e)continue;
			a[i][j]-=a[i][e]*a[l][j];
		}a[i][e]*=-a[l][e];
	}
}
void init(){
	int pos=-1;
	double minn=1e10;
	for(int i=1;i&lt;=n;i++)
	if(dcmp(minn-a[i][0])==1)minn=a[i][0],pos=i;
	if(dcmp(minn)&gt;=0)return;
	for(int i=0;i&lt;=m;i++)swap(a[0][i],a[n+1][i]);
	for(int i=0;i&lt;=n;i++)a[i][m+1]=-1;
	pivot(pos,m+1,1);
	if(!dcmp(simplex(1))){
		for(int i=1;i&lt;=m+1;i++)if(!dcmp(a[0][i]+1)){pos=i;break;}
		for(int i=0;i&lt;=m+1;i++)swap(a[0][i],a[n+1][i]);
		for(int i=0;i&lt;=n+1;i++)swap(a[i][pos],a[i][m+1]);
	}else puts("Can't solve!!");
}
double simplex(bool f){
	for(;;){
		int pos=-1,l,e;
		double minn=0;
		for(int i=1;i&lt;=m+f;i++)
		if(dcmp(a[0][i]-minn)==1)minn=a[0][i],pos=i;
		if(!~pos)return -a[0][0];
		e=pos;pos=-1;minn=1e10;
		for(int i=1;i&lt;=n;i++)
		if(dcmp(a[i][e])==1&amp;&amp;dcmp(a[i][0]/a[i][e]-minn)==-1)
		minn=a[i][0]/a[i][e],pos=i;
		if(!~pos){
			printf("INF!!\n");
			return 1e10;
		}l=pos;
		pivot(l,e,f);
	}
}
int main(){
	int k=0;
	scanf("%d%d",&amp;m,&amp;k);m*=3;
	for(int i=1;i&lt;=m;i++)scanf("%lf",&amp;a[0][i]);
	for(int i=1;i+m/3&lt;=m+1;i++){
		n++;
		for(int j=i;j&lt;i+m/3;j++)
			a[n][j]=1;
		a[n][0]=k;
	}
	for(int i=1;i&lt;=m;i++){
		n++;
		a[n][0]=1;
		a[n][i]=1;
	}
//	init();
	int ans=simplex(0)+.5;
	printf("%d\n",ans);
	return 0;
}
</pre><pre></pre><h2>Problem3550</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=610;
struct edge{
	int u,v,cap,flow,cost;
};
vector&lt;edge&gt;edges;
vector&lt;int&gt;G[maxn];
void add(int u,int v,int cap,int cost){
	edges.push_back((edge){u,v,cap,0,cost});
	G[u].push_back(edges.size()-1);
	edges.push_back((edge){v,u,0,0,-cost});
	G[v].push_back(edges.size()-1);
}
int d[maxn],vis[maxn],pre[maxn],a[maxn];
int s,t,flow,cost,n,k;
bool spfa(){
	memset(d,0xaf,sizeof d);int duang=d[0];
	queue&lt;int&gt;q;q.push(s);d[s]=0;a[s]=1e9;
	while(!q.empty()){
		int u=q.front();q.pop();vis[u]=0;
		for(int i=0;i&lt;G[u].size();i++){
			edge e=edges[G[u][i]];
			if(e.cap==e.flow)continue;
			if(d[e.v]&lt;d[u]+e.cost){
				d[e.v]=d[u]+e.cost;
				a[e.v]=min(e.cap-e.flow,a[u]);
				pre[e.v]=G[u][i];
				if(!vis[e.v])q.push(e.v),vis[e.v]=1;
			}
		}
	}
	if(d[t]==duang)return false;
	flow+=a[t];
	cost+=a[t]*d[t];
	int u=t;
	while(u!=s){
		edges[pre[u]].flow+=a[t];
		edges[pre[u]^1].flow-=a[t];
		u=edges[pre[u]].u;
	}return true;
}
int main(){
	scanf("%d%d",&amp;n,&amp;k);
	for(int i=1;i&lt;=3*n;i++)scanf("%d",&amp;a[i]);
	s=0;t=maxn-1;int ss=t-1;int tt=ss-1;
	add(s,ss,k,0);add(tt,t,k,0);
	for(int i=1;i&lt;3*n;i++)add(i,i+1,1e9,0);
	for(int i=1;i&lt;=n;i++)add(ss,i,1,a[i]);
	for(int i=n+1;i&lt;=2*n;i++)add(i-n,i,1,a[i]);
	for(int i=2*n+1;i&lt;=3*n;i++)add(i-n,i,1,a[i]);
	for(int i=2*n+1;i&lt;=3*n;i++)add(i,tt,1e9,0);
//	for(int i=0;i&lt;edges.size();i++)if(i%2==0)
//	printf("%d -&gt; %d cap;%d cost:%d\n",edges[i].u,edges[i].v,edges[i].cap,edges[i].cost);
	while(spfa());
	cout&lt;&lt;cost&lt;&lt;endl;
	return 0;
} </pre><pre></pre><h2>Problem3550</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=610;
struct edge{
	int u,v,cap,flow,cost;
};
vector&lt;edge&gt;edges;
vector&lt;int&gt;G[maxn];
void add(int u,int v,int cap,int cost){
	edges.push_back((edge){u,v,cap,0,cost});
	G[u].push_back(edges.size()-1);
	edges.push_back((edge){v,u,0,0,-cost});
	G[v].push_back(edges.size()-1);
}
int d[maxn],vis[maxn],pre[maxn],a[maxn];
int s,t,flow,cost,n,k;
bool spfa(){
	memset(d,0xaf,sizeof d);int duang=d[0];
	queue&lt;int&gt;q;q.push(s);d[s]=0;a[s]=1e9;
	while(!q.empty()){
		int u=q.front();q.pop();vis[u]=0;
		for(int i=0;i&lt;G[u].size();i++){
			edge e=edges[G[u][i]];
			if(e.cap==e.flow)continue;
			if(d[e.v]&lt;d[u]+e.cost){
				d[e.v]=d[u]+e.cost;
				a[e.v]=min(e.cap-e.flow,a[u]);
				pre[e.v]=G[u][i];
				if(!vis[e.v])q.push(e.v),vis[e.v]=1;
			}
		}
	}
	if(d[t]==duang)return false;
	flow+=a[t];
	cost+=a[t]*d[t];
	int u=t;
	while(u!=s){
		edges[pre[u]].flow+=a[t];
		edges[pre[u]^1].flow-=a[t];
		u=edges[pre[u]].u;
	}return true;
}
int main(){
	scanf("%d%d",&amp;n,&amp;k);
	for(int i=1;i&lt;=3*n;i++)scanf("%d",&amp;a[i]);
	s=0;t=maxn-1;int ss=t-1;int tt=ss-1;
	add(s,ss,k,0);add(tt,t,k,0);
	for(int i=1;i&lt;2*n;i++)add(i,i+1,1e9,0);
	for(int i=1;i&lt;=n;i++)add(ss,i,1,a[i]);
	for(int i=n+1;i&lt;=2*n;i++)add(i-n,i,1,a[i]);
	for(int i=2*n+1;i&lt;=3*n;i++)add(i-n,i,1,a[i]);
	for(int i=2*n+1;i&lt;=3*n;i++)add(i,tt,1,0);
	while(spfa());
	cout&lt;&lt;cost&lt;&lt;endl;
	return 0;
} </pre><pre></pre><h2>Problem3555</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;map&gt;
#include&lt;cctype&gt;
using namespace std;
typedef unsigned long long UL;
const int maxn=30010;
UL hash[maxn][202];
UL base=233;
UL hash_l[202];
int n,len;
char s[202];
UL ans=0;
void hash_init(int x){
	UL val=0;
	for(int i=0;i&lt;len;i++)
	val=val*base+s[i],
	hash[x][i]=val;
}
 UL GetHash(int x,int l,int r){
	if(l&gt;r)return 0;
	return hash[x][r]-(l?hash[x][l-1]:0)*hash_l[r-l+1];	
}
pair&lt;UL,UL&gt; H[maxn];
int Hsize;
int main(){
	scanf("%d%d%*d",&amp;n,&amp;len);
	hash_l[0]=1;
	for(int i=1;i&lt;=len;i++)hash_l[i]=hash_l[i-1]*base;
	for(int i=1;i&lt;=n;i++){
		scanf("%s",s);
		hash_init(i);
	}
	for(int i=0;i&lt;len;i++){
		Hsize=0;
		for(int j=1;j&lt;=n;j++)
		H[++Hsize]=make_pair(GetHash(j,0,i-1),GetHash(j,i+1,len-1));
		sort(H+1,H+1+Hsize);
		for(int i=1;i&lt;n;i++){
			int cnt=1;
			while(i!=n&amp;&amp;H[i]==H[i+1])cnt++,i++;
			ans+=(UL)(cnt-1)*cnt/2;
		}
	}cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem3563</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=100010; 
typedef unsigned long long UL;
struct edge{int u,v;};
int n,m,dep[maxn];
vector&lt;edge&gt;E;
vector&lt;int&gt;G[maxn];
int in(){
	int r=0;char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))r=r*10+c-'0',c=getchar();
	return r;
}
void add(int u,int v){
	E.push_back((edge){u,v});
	G[u].push_back(E.size()-1);
	E.push_back((edge){v,u});
	G[v].push_back(E.size()-1);
}
int fa[maxn],vis[maxn];
UL ran(){
	return ((UL)rand()&lt;&lt;32)|(rand());
}
UL Ran[1000001],f[maxn];
void dfs(int u){
	vis[u]=1;
	for(int i=0;i&lt;G[u].size();i++){
		edge e=E[G[u][i]];
		if(e.v==fa[u])continue;
		if(!vis[e.v]){
			fa[e.v]=u;
			dep[e.v]=dep[u]+1;
			dfs(e.v);
		}else if(dep[e.v]&lt;dep[u]){
			Ran[G[u][i]]=Ran[G[u][i]^1]=ran();
			f[e.v]^=Ran[G[u][i]];
			f[u]^=Ran[G[u][i]];
		}
	}
}
void dfs2(int u){
	for(int i=0;i&lt;G[u].size();i++){
		edge e=E[G[u][i]];
		if(fa[e.v]==u){
			dfs2(e.v);
			f[u]^=f[e.v];
			Ran[G[u][i]]=Ran[G[u][i]^1]^=f[e.v];
		}
	}
}
UL base[64];
int main(){
//	freopen("bzoj3563.in","r",stdin);
	n=in();m=in();
	for(int i=1;i&lt;=m;i++){
		int u=in(),v=in();
		add(u,v);
	}dfs(1);
	dfs2(1);
	int q=in();
	int lans=0;
	while(q--){
		int k=in()^lans;
		int flag=1;
		memset(base,0,sizeof base);
		while(k--){
			UL x=Ran[((in()^lans)-1)&lt;&lt;1];
			for(int i=63;i&gt;=0;i--){
				if(x&gt;&gt;i&amp;1){
					if(base[i])x^=base[i];
					else {base[i]=x;break;}
				}
				if(!x)flag=0;
			}
		}lans+=flag;
		puts(flag?"Connected":"Disconnected");
	}
	return 0;
}</pre><pre></pre><h2>Problem3564</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const double eps=1e-6;
const double pi=acos(-1);
int dcmp(double x){return (x&gt;eps)-(x&lt;-eps);}
struct point{
	double x,y;
	point(double _x=0,double _y=0):x(_x),y(_y){}
	point operator-(point o){return point(x-o.x,y-o.y);}
	point operator+(point o){return point(x+o.x,y+o.y);}
	double operator*(point o){return x*o.y-y*o.x;}
	double operator^(point o){return x*o.x+y*o.y;}
	point operator*(double p){return point(x*p,y*p);}
	point operator/(double p){return point(x/p,y/p);}
	bool operator==(point o){return !dcmp(x-o.x)&amp;&amp;!dcmp(y-o.y);}
}O,p[int(1000001)];
double sqr(double x){return x*x;}
double dis(point a,point b){return sqrt(sqr(a.x-b.x)+sqr(a.y-b.y));}
int n;
double r;
struct line{
	point p,v;
};
point Rev(point v){return point(-v.y,v.x);}
point operator*(line A,line B){
	point u=B.p-A.p;
	double t=(B.v*u)/(B.v*A.v);
	return A.p+A.v*t;
}
point get(point a,point b){
	return (a+b)/2;
}
point get(point a,point b,point c){
	if(a==b)return get(a,c);
	if(a==c)return get(a,b);
	if(b==c)return get(a,b);	
	line ABO=(line){(a+b)/2,Rev(a-b)};
	line BCO=(line){(c+b)/2,Rev(b-c)};
	return ABO*BCO;
}
double a,P;
point rot(point p,double rad){return point(p.x*cos(rad)-p.y*sin(rad),p.x*sin(rad)+p.y*cos(rad));}
int main(){
	scanf("%d",&amp;n);
	for(int i=1;i&lt;=n;i++)scanf("%lf%lf",&amp;p[i].x,&amp;p[i].y);
	scanf("%lf%lf",&amp;a,&amp;P);
	a=a*pi/180;
	for(int i=1;i&lt;=n;i++)p[i]=rot(p[i],2*pi-a);
	for(int i=1;i&lt;=n;i++)p[i].x=p[i].x/=P;
	random_shuffle(p+1,p+1+n);
	O=p[1];r=0;
	for(int i=2;i&lt;=n;i++){
		if(dis(p[i],O)&lt;r+1e-6)continue;
		O=get(p[1],p[i]);r=dis(O,p[i]);
		for(int j=1;j&lt;i;j++){
			if(dis(p[j],O)&lt;r+1e-6)continue;
			O=get(p[i],p[j]);r=dis(O,p[i]);
			for(int k=1;k&lt;j;k++){
				if(dis(p[k],O)&lt;r+1e-6)continue;
				O=get(p[i],p[j],p[k]);r=dis(O,p[i]);
			}
		}
	}printf("%.3lf\n",r);
	return 0;
}</pre><pre></pre><h2>Problem3566</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=500010;
int n;
double f[maxn][2],p[maxn];
struct edge{int u,v;double w;};
vector&lt;edge&gt;G[maxn];
void dp0(int u,int fa){
	for(int i=0;i&lt;G[u].size();i++){
		int v=G[u][i].v;
		if(v!=fa)dp0(v,u);
	}f[u][0]=1-p[u];
	for(int i=0;i&lt;G[u].size();i++){
		edge e=G[u][i];
		if(e.v==fa)continue;
		f[u][0]*=f[e.v][0]+(1-f[e.v][0])*(1-e.w);
	}
}
int dcmp(double x){return (x&gt;1e-8)-(x&lt;-1e8);}
void dp1(int u,int fa){
	for(int i=0;i&lt;G[u].size();i++){
		edge e=G[u][i];
		if(e.v==fa)continue;
		if(dcmp((f[e.v][0]+(1-f[e.v][0])*(1-e.w)))){
			double t=f[u][0]*f[u][1]/(f[e.v][0]+(1-f[e.v][0])*(1-e.w));
			f[e.v][1]=t+(1-t)*(1-e.w);
		}
		dp1(e.v,u);
	}
}
int main(){
	scanf("%d",&amp;n);	
	for(int i=1;i&lt;n;i++){
		int u,v;double w;
		scanf("%d%d%lf",&amp;u,&amp;v,&amp;w);w/=100;
		G[u].push_back((edge){u,v,w});
		G[v].push_back((edge){v,u,w});
	}for(int i=1;i&lt;=n;i++)scanf("%lf",&amp;p[i]),p[i]/=100;
	dp0(1,0);
	f[1][1]=1;
	dp1(1,0);
	double ans=0;
	for(int i=1;i&lt;=n;i++)ans+=1-f[i][0]*f[i][1];
	printf("%.6f\n",ans);
	return 0;
}</pre><pre></pre><h2>Problem3569</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=100010; 
typedef unsigned long long UL;
struct edge{int u,v;};
int n,m,dep[maxn];
vector&lt;edge&gt;E;
vector&lt;int&gt;G[maxn];
int in(){
	int r=0;char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))r=r*10+c-'0',c=getchar();
	return r;
}
void add(int u,int v){
	E.push_back((edge){u,v});
	G[u].push_back(E.size()-1);
	E.push_back((edge){v,u});
	G[v].push_back(E.size()-1);
}
int fa[maxn],vis[maxn];
UL ran(){
	return ((UL)rand()&lt;&lt;32)|(rand());
}
UL Ran[1000001],f[maxn];
void dfs(int u){
	vis[u]=1;
	for(int i=0;i&lt;G[u].size();i++){
		edge e=E[G[u][i]];
		if(e.v==fa[u])continue;
		if(!vis[e.v]){
			fa[e.v]=u;
			dep[e.v]=dep[u]+1;
			dfs(e.v);
		}else if(dep[e.v]&lt;dep[u]){
			Ran[G[u][i]]=Ran[G[u][i]^1]=ran();
			f[e.v]^=Ran[G[u][i]];
			f[u]^=Ran[G[u][i]];
		}
	}
}
void dfs2(int u){
	for(int i=0;i&lt;G[u].size();i++){
		edge e=E[G[u][i]];
		if(fa[e.v]==u){
			dfs2(e.v);
			f[u]^=f[e.v];
			Ran[G[u][i]]=Ran[G[u][i]^1]^=f[e.v];
		}
	}
}
UL base[64];
int main(){
//	freopen("bzoj3563.in","r",stdin);
	n=in();m=in();
	for(int i=1;i&lt;=m;i++){
		int u=in(),v=in();
		add(u,v);
	}dfs(1);
	dfs2(1);
	int q=in();
	int lans=0;
	while(q--){
		int k=in();
		int flag=1;
		memset(base,0,sizeof base);
		while(k--){
			UL x=Ran[((in()^lans)-1)&lt;&lt;1];
			for(int i=63;i&gt;=0;i--){
				if(x&gt;&gt;i&amp;1){
					if(base[i])x^=base[i];
					else {base[i]=x;break;}
				}
				if(!x)flag=0;
			}
		}lans+=flag;
		puts(flag?"Connected":"Disconnected");
	}
	return 0;
}</pre><pre></pre><h2>Problem3570</h2><pre>#include&lt;bits/stdc++.h&gt;
#define lowbit(x) (x&amp;-x)
using namespace std;
const int maxn=1&lt;&lt;17;
int n,m,C;
int getint(){
	int res=0;char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))res=res*10+c-'0',c=getchar();
	return res;
}
int d[maxn];
void updata(int x,int f){while(x&lt;maxn)d[x]+=f,x+=lowbit(x);}
int kth(int k){
    int l=0,r=maxn,cur=0;
    while(l&lt;r){
    	int mid=(l+r)/2;cur+=d[mid];
       	if(cur&gt;=k)r=mid,cur-=d[mid];
    	else l=mid+1;
    }return l;
}
int main(){
	n=getint();C=getint();
	for(int i=1;i&lt;=n;i++){
		int x=getint();
		updata(x,1);getint();getint();
	}m=getint();
	while(m--){
		int op=getint(),x=getint();
		if(op==0){
			getint();getint();
			updata(x,1);	
		}else{
			int y=getint();
			int z=kth(y);
			printf("%.3lf\n",sqrt((double)2*C*x+(double)z*z));
		}
	}
	return 0;
}</pre><pre></pre><h2>Problem3573</h2><pre>#include&lt;map&gt;
#include&lt;cmath&gt;
#include&lt;vector&gt;
#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=5e5+5;
const double eps=1e-6;
typedef long long LL;
vector&lt;int&gt;G[maxn];
int fa[maxn],n;
double c[maxn],a[maxn],t[maxn];
int getint(){
	int res=0;char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))res=res*10+c-'0',c=getchar();
	return res;
}
void dfs(int u){
	for(int i=0;i&lt;G[u].size();i++){
		int v=G[u][i];
		if(v!=fa[u]){
			fa[v]=u;
			c[v]=c[u]+log(G[u].size()-(u!=1));
			dfs(v);		
		}
	}
}
map&lt;double,int&gt;M;
int dcmp(double x){return x&lt;-eps?-1:x&gt;eps;}
bool equal(double a,double b){return !dcmp(a-b);}
int main(){
	n=getint();
	for(int i=1;i&lt;=n;++i)a[i]=log(getint());
	for(int i=1;i&lt;n;i++){
		int u=getint(),v=getint();
		G[u].push_back(v);
		G[v].push_back(u);
	}dfs(1);
	map&lt;double,int&gt;::iterator it;
	for(int i=2;i&lt;=n;i++){
		t[i]=a[i]+c[i];
		it=M.lower_bound(a[i]+c[i]-1e-7);
		if(it==M.end()||!equal(it-&gt;first,a[i]+c[i]))M[a[i]+c[i]]++;
		else it-&gt;second++;
	}int ans=n;
	it=M.lower_bound(a[1]-1e-7);
	if(it!=M.end()&amp;&amp;equal(it-&gt;first,a[1]))ans=min(ans,n-it-&gt;second-1);
	for(it=M.begin();it!=M.end();it++)ans=min(ans,n-it-&gt;second);
	cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem3576</h2><pre>#include&lt;cmath&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
#define N 100000 + 5
int T, F, id, mex[N], sg[N];
bool done[N];

int Get_sg(int n)
{
    if (n &lt; F)
        return 0;
    if (done[n])
        return sg[n];
    done[n] = 1;
    for (int i = 2; i &lt;= n; i = n / (n / i) + 1)
        for (int j = i; j &lt;= i + 1 &amp;&amp; j &lt;= n; j ++)
            Get_sg(n / j), Get_sg(n / j + 1);
    id ++;
    for (int i = 2; i &lt;= n; i = n / (n / i) + 1)
        for (int j = i; j &lt;= i + 1 &amp;&amp; j &lt;= n; j ++)
        {
            int tmp = 0;
            if ((n % j) % 2 == 1) tmp ^= sg[n / j + 1];
            if ((j - n % j) % 2 == 1) tmp ^= sg[n / j];
            mex[tmp] = id;
        }
    for (sg[n] = 0; mex[sg[n]] == id; sg[n] ++) ;
    return sg[n];
}

void begin()
{
    scanf("%d%d", &amp;T, &amp;F);
}

void work()
{
    int t, xsum = 0;
    scanf("%d", &amp;t);
    while (t --)
    {
        int x;
        scanf("%d", &amp;x);
        xsum ^= Get_sg(x);
    }
    printf("%d%c", xsum == 0 ? 0 : 1," \n"[T==0]);
}

void end()
{
}

int main()
{
    begin();
    while (T --)
        work();
    end();
    return 0;
}
</pre><pre></pre><h2>Problem3578</h2><pre>/*
	ID:zky
*/
#include&lt;map&gt;
#include&lt;set&gt;
#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#define lson i&lt;&lt;1,l,mid
#define rson i&lt;&lt;1|1,mid+1,r
#define L i&lt;&lt;1
#define R i&lt;&lt;1|1
using namespace std;
const int maxn=1e5+10;
const int maxm=1e5+10;
const int maxq=1e5+10;
int n,m,q;
map&lt;set&lt;int&gt;,int&gt;M;
int home[maxn];
struct seg_tree{
	struct node{
		set&lt;int&gt;s;
		int size,lazy;
		node(){
			size=lazy=0;
		}
	};
	node t[maxn&lt;&lt;2];
	void deb(int i){
//		printf("#%d size:%d lazy:%d\n",i,t[i].size,t[i].lazy);
//		for(set&lt;int&gt;::iterator it=t[i].s.begin();it!=t[i].s.end();it++)
//			cout&lt;&lt;*it&lt;&lt;" ";
//		cout&lt;&lt;endl;
	}
	void pushdown(int i,int l,int r){
		if(t[i].lazy==0)return;
		int mid=l+r&gt;&gt;1;
		if(l==mid)
			M[t[L].s]=1;
		if(r==mid+1)
			M[t[R].s]=1;
		t[L].lazy=1;
		t[L].size=0;
		t[R].lazy=1;
		t[R].size=0;
		t[i].lazy=0;
	}
	void rz(int i){
		t[i].size=0;
//		if(!M.count(t[L].s))
		t[i].size+=t[L].size;
//		1if(!M.count(t[R].s))		
		t[i].size+=t[R].size;
	}
	void Change(int i,int l,int r,int pos,int val){
		deb(i);
		if(l==r){
			deb(i);
			t[i].s.insert(val);
			if(!M.count(t[i].s))
				t[i].size=t[i].s.size();
			else
				t[i].size=0;
			deb(i);
			return ;
		}
		int mid=l+r&gt;&gt;1;
		pushdown(i,l,r);
		if(pos&lt;=mid)Change(lson,pos,val);
		else Change(rson,pos,val);
		rz(i);
		deb(i);
	}
	void Erase(int i,int l,int r,int pos,int val){
		deb(i);
		if(l==r){
			deb(i);
			t[i].s.erase(val);
			if(!M.count(t[i].s))
				t[i].size=t[i].s.size();
			else
				t[i].size=0;
			deb(i);
			return ;
		}
		int mid=l+r&gt;&gt;1;
		pushdown(i,l,r);
		if(pos&lt;=mid)Erase(lson,pos,val);
		else Erase(rson,pos,val);
		rz(i);
		deb(i);
	}
	int qsum(int i,int l,int r,int l0,int r0){
		deb(i);
		if(l0&lt;=l&amp;&amp;r0&gt;=r){
			deb(i);
			M[t[i].s]=1;
			int s=t[i].size;
			t[i].size=0;
			t[i].lazy=1;
			deb(i);
			return s;
		}
		pushdown(i,l,r);
		int mid=l+r&gt;&gt;1;

		int ans=0;
		if(l0&lt;=mid)ans+=qsum(lson,l0,r0);
		if(r0&gt;mid) ans+=qsum(rson,l0,r0);
		rz(i);
		deb(i);
		return ans;
	}
}T;
void Change(int i,int j){
	if(home[i])
	T.Erase(1,1,n,home[i],i);
	T.Change(1,1,n,(home[i]=j),i);
}
int Qsum(int l,int r){
	return T.qsum(1,1,n,l,r);
}
int getint(){
	int res=0,ok=0;char ch;
	while(1){
		ch=getchar();
		if(ch&lt;='9'&amp;&amp;ch&gt;='0'){
			res*=10;res+=ch-'0';ok=1;
		}else if(ok)break;
	}return res;
}
int main(){
	n=getint();m=getint();q=getint();
	for(int i=1;i&lt;=n;i++)Change(i,1);
	while(q--){
		char opt[3];scanf("%s",opt);
		if(opt[0]=='C'){
			int i=getint(),j=getint();
			Change(i,j);
		}else{
			int l=getint(),r=getint();
			printf("%d\n",Qsum(l,r));
		}
//		for(map&lt;set&lt;int&gt;,int&gt;::iterator it=M.begin();it!=M.end();it++)
//			for(set&lt;int&gt;::iterator i=it-&gt;first.begin();i!=it-&gt;first.end();i++)
//				cout&lt;&lt;*i&lt;&lt;" ";
//		cout&lt;&lt;endl;
	}
	return 0;
}</pre><pre></pre><h2>Problem3578</h2><pre>/*
	ID:zky
*/
#include&lt;set&gt;
#include&lt;cctype&gt;
#include&lt;cstdlib&gt;
#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#define lson i&lt;&lt;1,l,mid
#define rson i&lt;&lt;1|1,mid+1,r
#define L i&lt;&lt;1
#define R i&lt;&lt;1|1
using namespace std;
const int maxn=1e5+10;
typedef unsigned long long lld;
lld MOD=100000000000007LL;
set&lt;lld&gt;hash;
lld mp[maxn];
int room[maxn];
int n,m,q;
lld t[maxn&lt;&lt;2];
int size[maxn&lt;&lt;2];
int rsize[maxn&lt;&lt;2];
int lazy[maxn&lt;&lt;2];
struct seg_tree{

	seg_tree(){
		memset(t,0,sizeof(t));
		memset(size,0,sizeof(size));
		memset(lazy,0,sizeof(lazy));
		memset(rsize,0,sizeof(rsize));
	}
	void pushdown(int i,int l,int r){
		if(!lazy[i])return;
		int mid=l+r&gt;&gt;1;
		if(l==mid)
			hash.insert(t[L]);
		if(r==mid+1)
			hash.insert(t[R]);
		size[L]=0;
		size[R]=0;
		lazy[L]=1;
		lazy[R]=1;		
		lazy[i]=0;
	}
	void rz(int i){
		size[i]=size[L]+size[R];
	}
	void Erase(int i,int l,int r,int pos,int val){
		if(l==r){
			t[i]-=mp[val];
			t[i]=(t[i]+MOD)%MOD;
			rsize[i]--;
			if(!hash.count(t[i]))
				size[i]=rsize[i];
			else
				size[i]=0;
			return;
		}
		pushdown(i,l,r);
		int mid=l+r&gt;&gt;1;
		if(pos&lt;=mid)Erase(lson,pos,val);
		else Erase(rson,pos,val);
		rz(i);
	}
	void Change(int i,int l,int r,int pos,int val){
		if(l==r){
			t[i]+=mp[val];
			t[i]%=MOD;
			rsize[i]++;
			if(!hash.count(t[i]))
				size[i]=rsize[i];
			else
				size[i]=0;
			return;
		}
		pushdown(i,l,r);
		int mid=l+r&gt;&gt;1;
		if(pos&lt;=mid)Change(lson,pos,val);
		else Change(rson,pos,val);
		rz(i);
	}
	int qsum(int i,int l,int r,int l0,int r0){
		if(l0&lt;=l&amp;&amp;r0&gt;=r){
			hash.insert(t[i]);
			int s=size[i];
			size[i]=0;
			lazy[i]=1;
			return s;			
		}
		pushdown(i,l,r);
		int mid=l+r&gt;&gt;1;
		int ans=0;
		if(l0&lt;=mid)ans+=qsum(lson,l0,r0);
		if(r0&gt;mid) ans+=qsum(rson,l0,r0);
		rz(i);
		return ans;		
	}
}T;
void Change(int i,int j){
	if(room[i])
	T.Erase(1,1,n,room[i],i);
	T.Change(1,1,n,(room[i]=j),i);
}
int Qsum(int l,int r){
	return T.qsum(1,1,n,l,r);
}
int getint(){
	int res=0,ok=0;char ch;
	while(1){
		ch=getchar();
		if(ch&lt;='9'&amp;&amp;ch&gt;='0'){
			res*=10;res+=ch-'0';ok=1;
		}else if(ok)break;
	}return res;
}
int main(){
	srand(112);
//	freopen("input10.txt","r",stdin);
	n=getint();m=getint();q=getint();
	for(int i=1;i&lt;=n;i++)mp[i]=(rand()*13131+21313*(rand()+756753))*10007%MOD;
	for(int i=1;i&lt;=n;i++)Change(i,1);
	while(q--){
		char opt[3];scanf("%s",opt);
		if(opt[0]=='C'){
			int i=getint(),j=getint();
			Change(i,j);
		}else{
			int l=getint(),r=getint();
			printf("%d\n",Qsum(l,r));
		}
	}
	return 0;
}</pre><pre></pre><h2>Problem3578</h2><pre>/*
	ID:zky
*/
#include&lt;set&gt;
#include&lt;cctype&gt;
#include&lt;cstdlib&gt;
#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#define lson i&lt;&lt;1,l,mid
#define rson i&lt;&lt;1|1,mid+1,r
#define L i&lt;&lt;1
#define R i&lt;&lt;1|1
using namespace std;
const int maxn=1e5+10;
typedef unsigned long long lld;
lld MOD=100000000000007LL;
set&lt;lld&gt;hash;
lld mp[maxn];
int room[maxn];
int n,m,q;
lld t[maxn&lt;&lt;2];
int size[maxn&lt;&lt;2];
int rsize[maxn&lt;&lt;2];
int lazy[maxn&lt;&lt;2];
struct seg_tree{

	seg_tree(){
		memset(t,0,sizeof(t));
		memset(size,0,sizeof(size));
		memset(lazy,0,sizeof(lazy));
		memset(rsize,0,sizeof(rsize));
	}
	void pushdown(int i,int l,int r){
		if(!lazy[i])return;
		int mid=l+r&gt;&gt;1;
		if(l==mid)
			hash.insert(t[L]);
		if(r==mid+1)
			hash.insert(t[R]);
		size[L]=0;
		size[R]=0;
		lazy[L]=1;
		lazy[R]=1;		
		lazy[i]=0;
	}
	void rz(int i){
		size[i]=size[L]+size[R];
	}
	void Erase(int i,int l,int r,int pos,int val){
		if(l==r){
			t[i]^=mp[val];
			rsize[i]--;
			if(!hash.count(t[i]))
				size[i]=rsize[i];
			else
				size[i]=0;
			return;
		}
		pushdown(i,l,r);
		int mid=l+r&gt;&gt;1;
		if(pos&lt;=mid)Erase(lson,pos,val);
		else Erase(rson,pos,val);
		rz(i);
	}
	void Change(int i,int l,int r,int pos,int val){
		if(l==r){
			t[i]^=mp[val];
			rsize[i]++;
			if(!hash.count(t[i]))
				size[i]=rsize[i];
			else
				size[i]=0;
			return;
		}
		pushdown(i,l,r);
		int mid=l+r&gt;&gt;1;
		if(pos&lt;=mid)Change(lson,pos,val);
		else Change(rson,pos,val);
		rz(i);
	}
	int qsum(int i,int l,int r,int l0,int r0){
		if(l0&lt;=l&amp;&amp;r0&gt;=r){
			hash.insert(t[i]);
			int s=size[i];
			size[i]=0;
			lazy[i]=1;
			return s;			
		}
		pushdown(i,l,r);
		int mid=l+r&gt;&gt;1;
		int ans=0;
		if(l0&lt;=mid)ans+=qsum(lson,l0,r0);
		if(r0&gt;mid) ans+=qsum(rson,l0,r0);
		rz(i);
		return ans;		
	}
}T;
void Change(int i,int j){
	if(room[i])
	T.Erase(1,1,n,room[i],i);
	T.Change(1,1,n,(room[i]=j),i);
}
int Qsum(int l,int r){
	return T.qsum(1,1,n,l,r);
}
int getint(){
	int res=0,ok=0;char ch;
	while(1){
		ch=getchar();
		if(ch&lt;='9'&amp;&amp;ch&gt;='0'){
			res*=10;res+=ch-'0';ok=1;
		}else if(ok)break;
	}return res;
}
int main(){
	srand(112);
//	freopen("input10.txt","r",stdin);
	n=getint();m=getint();q=getint();
	for(int i=1;i&lt;=n;i++)mp[i]=(rand()*13131+21313*(rand()+756753))*10007;
	for(int i=1;i&lt;=n;i++)Change(i,1);
	while(q--){
		char opt[3];scanf("%s",opt);
		if(opt[0]=='C'){
			int i=getint(),j=getint();
			Change(i,j);
		}else{
			int l=getint(),r=getint();
			printf("%d\n",Qsum(l,r));
		}
	}
	return 0;
}</pre><pre></pre><h2>Problem3578</h2><pre>/*
	ID:zky
*/
#include&lt;set&gt;
#include&lt;cctype&gt;
#include&lt;cstdlib&gt;
#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#define lson i&lt;&lt;1,l,mid
#define rson i&lt;&lt;1|1,mid+1,r
#define L i&lt;&lt;1
#define R i&lt;&lt;1|1
using namespace std;
const int maxn=1e5+10;
typedef unsigned long long lld;
lld MOD=100000000000007LL;
set&lt;lld&gt;hash;
lld mp[maxn];
int room[maxn];
int n,m,q;
lld t[maxn&lt;&lt;2];
int size[maxn&lt;&lt;2];
int rsize[maxn&lt;&lt;2];
int lazy[maxn&lt;&lt;2];
struct seg_tree{

	void pushdown(int i,int l,int r){
		if(!lazy[i])return;
		int mid=l+r&gt;&gt;1;
		if(l==mid)
			hash.insert(t[L]);
		if(r==mid+1)
			hash.insert(t[R]);
		size[L]=0;
		size[R]=0;
		lazy[L]=1;
		lazy[R]=1;		
		lazy[i]=0;
	}
	void rz(int i){
		size[i]=size[L]+size[R];
	}
	void Erase(int i,int l,int r,int pos,int val){
		if(l==r){
			t[i]^=mp[val];
			rsize[i]--;
			if(!hash.count(t[i]))
				size[i]=rsize[i];
			else
				size[i]=0;
			return;
		}
		pushdown(i,l,r);
		int mid=l+r&gt;&gt;1;
		if(pos&lt;=mid)Erase(lson,pos,val);
		else Erase(rson,pos,val);
		rz(i);
	}
	void Change(int i,int l,int r,int pos,int val){
		if(l==r){
			t[i]^=mp[val];
			rsize[i]++;
			if(!hash.count(t[i]))
				size[i]=rsize[i];
			else
				size[i]=0;
			return;
		}
		pushdown(i,l,r);
		int mid=l+r&gt;&gt;1;
		if(pos&lt;=mid)Change(lson,pos,val);
		else Change(rson,pos,val);
		rz(i);
	}
	int qsum(int i,int l,int r,int l0,int r0){
		if(l0&lt;=l&amp;&amp;r0&gt;=r){
			hash.insert(t[i]);
			int s=size[i];
			size[i]=0;
			lazy[i]=1;
			return s;			
		}
		pushdown(i,l,r);
		int mid=l+r&gt;&gt;1;
		int ans=0;
		if(l0&lt;=mid)ans+=qsum(lson,l0,r0);
		if(r0&gt;mid) ans+=qsum(rson,l0,r0);
		rz(i);
		return ans;		
	}
}T;
void Change(int i,int j){
	if(room[i])
	T.Erase(1,1,n,room[i],i);
	T.Change(1,1,n,(room[i]=j),i);
}
int Qsum(int l,int r){
	return T.qsum(1,1,n,l,r);
}
int getint(){
	int res=0,ok=0;char ch;
	while(1){
		ch=getchar();
		if(ch&lt;='9'&amp;&amp;ch&gt;='0'){
			res*=10;res+=ch-'0';ok=1;
		}else if(ok)break;
	}return res;
}
int main(){
	srand(112);
//	freopen("input10.txt","r",stdin);
	n=getint();m=getint();q=getint();
	for(int i=1;i&lt;=n;i++)mp[i]=(rand()*13131+21313*(rand()+756753))*10007;
	for(int i=1;i&lt;=n;i++)Change(i,1);
	while(q--){
		char opt[3];scanf("%s",opt);
		if(opt[0]=='C'){
			int i=getint(),j=getint();
			Change(i,j);
		}else{
			int l=getint(),r=getint();
			printf("%d\n",Qsum(l,r));
		}
	}
	return 0;
}</pre><pre></pre><h2>Problem3578</h2><pre>/*
	ID:zky
*/
#include&lt;set&gt;
#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=1e5+10;
typedef unsigned long long lld;
set&lt;lld&gt;hash;
set&lt;int&gt;s;
lld mp[maxn];
lld room[maxn];
int size[maxn];
int bel[maxn];
int n,m,q;
int getint(){
	int res=0,ok=0;char ch;
	while(1){
		ch=getchar();
		if(ch&lt;='9'&amp;&amp;ch&gt;='0'){
			res*=10;res+=ch-'0';ok=1;
		}else if(ok)break;
	}return res;
}
void Change(int i,int j){
	room[bel[i]]^=mp[i];
	size[bel[i]]--;
	if(!hash.count(room[bel[i]]))
		s.insert(bel[i]);
	else
		s.erase(bel[i]);
	room[(bel[i]=j)]^=mp[i];
	size[bel[i]]++;
	if(!hash.count(room[bel[i]]))
		s.insert(bel[i]);
	else
		s.erase(bel[i]);	
}
int Qsum(int l,int r){
	int ans=0;
	
	for(;;){
		set&lt;int&gt;::iterator it=s.lower_bound(l);
		if(it==s.end()||*it&gt;r)break;
		int deb=*it;
		ans+=size[*it];
		hash.insert(room[*it]);
		s.erase(it);
	}
	
	return ans;
}
int main(){
	srand(112);
	n=getint();m=getint();q=getint();
	for(int i=1;i&lt;=n;i++)mp[i]=(rand()*13131+21313*(rand()+756753))*10007;
	size[1]=n;
	for(int i=1;i&lt;=n;i++){
		room[1]^=mp[i];
		bel[i]=1;
	}
	s.insert(1);
	while(q--){
		char opt[3];scanf("%s",opt);
		if(opt[0]=='C'){
			int i=getint(),j=getint();
			Change(i,j);
		}else{
			int l=getint(),r=getint();
			printf("%d\n",Qsum(l,r));
		}
	}		
	return 0;
}
</pre><pre></pre><h2>Problem3585</h2><pre>#include&lt;map&gt;
#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=200010;
int mex[maxn],a[maxn],next[maxn];
map&lt;int,int&gt;mp;
int n,m;
void pre(){
	for(int i=1;i&lt;=n;i++){
		if(mp.count(a[i]))
			next[mp[a[i]]]=i-1;
		else
			next[mp[a[i]]]=n;
		mp[a[i]]=i;
	}mp.clear();
	int minn=0;
	if(a[1]==0)minn++;
	mex[1]=minn;mp[a[1]]=1;
	for(int i=2;i&lt;=n;i++){
		mp[a[i]]=1;
		while(mp[minn])minn++;
		mex[i]=minn;
	}
}
int getint(){
	int res=0,ok=0;char ch;
	while(1){
		ch=getchar();
		if(isdigit(ch)){
			res*=10;res+=ch-'0';ok=1;
		}else if(ok)break;
	}return res;
}
void change(int x){
	int val=a[x];
	mex[x]=0;
	int end=next[x];
	if(end==0)end=n;
	for(int i=end;i&gt;x;i--)
		if(mex[i]&gt;val)
			mex[i]=val;
		else
			break;
}
struct qes{
	int ind,l,r;
	bool operator &lt; (const qes &amp;a)const{
		return l&lt;a.l||a.l==l&amp;&amp;r&lt;a.r;
	}	
};
qes q[maxn];
int anss[maxn];
int main(){
	n=getint();m=getint();
	for(int i=1;i&lt;=n;i++)a[i]=getint();
	pre();
	for(int i=1;i&lt;=m;i++){
		q[i].ind=i;q[i].l=getint();q[i].r=getint();
	}sort(q+1,q+1+m);
	int last=1;
	for(int i=1;i&lt;=m;i++){
		if(q[i].l==last){
			anss[q[i].ind]=mex[q[i].r];
		}else{
			for(int j=last;j&lt;q[i].l;j++)
				change(j);
			anss[q[i].ind]=mex[q[i].r];
		}
		last=q[i].l;
	}	
	for(int i=1;i&lt;=m;i++)
		printf("%d\n",anss[i]);
	return 0;
}</pre><pre></pre><h2>Problem3611</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1e6+5;
const int BIT=21;
int dfn[maxn],n,fa[maxn][BIT],dep[maxn],z;
vector&lt;int&gt;G[maxn];
vector&lt;pair&lt;int,int&gt; &gt;Ge[maxn];
void dfs(int u){
	dfn[u]=++z;
	for(int i=1;i&lt;BIT;i++)if(fa[u][i-1])
		fa[u][i]=fa[fa[u][i-1]][i-1];
	for(int i=0;i&lt;G[u].size();i++){
		int v=G[u][i];
		if(v==fa[u][0])continue;
		dep[v]=dep[u]+1;fa[v][0]=u;
		dfs(v);
	}
}
int lca(int u,int v){
	if(dep[u]&lt;dep[v])swap(u,v);
	int d=dep[u]-dep[v];
	for(int i=BIT-1;i&gt;=0;i--)if(d&gt;&gt;i&amp;1)u=fa[u][i];
	if(u==v)return u;
	for(int i=BIT-1;i&gt;=0;i--)if(fa[u][i]!=fa[v][i])
		u=fa[u][i],v=fa[v][i];
	return fa[u][0];
}
int dis(int u,int v){
	int ans=0;
	if(dep[u]&lt;dep[v])swap(u,v);
	int d=dep[u]-dep[v];ans=d;
	for(int i=BIT-1;i&gt;=0;i--)if(d&gt;&gt;i&amp;1)u=fa[u][i];
	if(u==v)return ans;
	for(int i=BIT-1;i&gt;=0;i--)if(fa[u][i]==fa[v][i])
		u=fa[u][i],v=fa[v][i],ans+=1&lt;&lt;i&lt;&lt;1;
	return ans;
}
int getn(){
	int res=0;char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))res=res*10+c-'0',c=getchar();
	return res;
}
bool bydfn(int x,int y){return dfn[x]&lt;dfn[y];}
int inr[maxn];
void add(int u,int v){
	//Erase[e++]=v;
	int w=dis(u,v);
//	cerr&lt;&lt;u&lt;&lt;" "&lt;&lt;v&lt;&lt;" "&lt;&lt;w&lt;&lt;endl;
	Ge[u].push_back(make_pair(v,w));
	//Ge[v].push_back(make_pair(u,w));
}
int rt;
int _n;
long long s=0,up[maxn],dw[maxn];
int mxx,mnn;
int siz[maxn],d[maxn];
int mx[maxn],mn[maxn];
void dp(int u){
	siz[u]=inr[u];
	mx[u]=inr[u]?0:-1e9;
	mn[u]=inr[u]?0:1e9;
	dw[u]=0;
	for(int i=0;i&lt;Ge[u].size();i++){
		int v=Ge[u][i].first,w=Ge[u][i].second;
		dp(v);
		dw[u]+=(long long)siz[v]*w+dw[v];
   		mxx=max(mxx,mx[u]+mx[v]+w);
		mnn=min(mnn,mn[u]+mn[v]+w);
		mx[u]=max(mx[u],mx[v]+w);
		mn[u]=min(mn[u],mn[v]+w);
		siz[u]+=siz[v];
	}	
}
void dp2(int u){
	for(int i=0;i&lt;Ge[u].size();i++){
		int v=Ge[u][i].first,w=Ge[u][i].second;
		up[v]=(up[u]+dw[u]-dw[v]-(long long)w*siz[v])+(long long)w*(_n-siz[v]);
		dp2(v);
	}Ge[u].clear();
}
void Q(){
	static int a[maxn*2],sta[maxn*2];
	int top=0;
	int k=getn();
	for(int i=0;i&lt;k;i++)a[i]=getn();
	sort(a,a+k,bydfn);
	k=unique(a,a+k)-a;
	sta[top++]=1;_n=k;
	for(int i=0;i&lt;k;i++){
		int LCA=lca(a[i],sta[top-1]);
		while(dep[LCA]&lt;dep[sta[top-1]]){
			if(dep[LCA]&gt;=dep[sta[top-2]]){
				add(LCA,sta[--top]);
				if(sta[top-1]!=LCA)sta[top++]=LCA;
				break;
			}add(sta[top-2],sta[top-1]);top--;
		}if(sta[top-1]!=a[i])sta[top++]=a[i];
	}
	while(top&gt;1)
		add(sta[top-2],sta[top-1]),top--;
	s=0;mxx=INT_MIN;mnn=INT_MAX;
	for(int i=0;i&lt;k;i++)inr[a[i]]=1;
	dp(1);
	dp2(1);
	for(int i=0;i&lt;k;i++)s+=up[a[i]]+dw[a[i]];
	printf("%lld %d %d\n",s/2,mnn,mxx);
	for(int i=0;i&lt;k;i++)inr[a[i]]=0;
}
int main(){
	n=getn();
	for(int i=1;i&lt;n;i++){
		int u=getn(),v=getn();
		G[u].push_back(v);
		G[v].push_back(u);
	}dfs(1);
	int m=getn();
	while(m--)
		Q();
	return 0;
}</pre><pre></pre><h2>Problem3624</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1e5+10;
struct edge{
	int u,v;
}edges[maxn];
int fa[maxn];
int n,m,k,cnt;
int front,back;
bool vis[maxn];
int find(int x){
	if(fa[x]!=x)return fa[x]=find(fa[x]);return x;
}
int main(){
	scanf("%d%d%d",&amp;n,&amp;m,&amp;k);back=m;
	for(int i=1;i&lt;=m;i++){
		int u,v,c;scanf("%d%d%d",&amp;u,&amp;v,&amp;c);
		if(!c)edges[back--]=(edge){u,v};
		else edges[++front]=(edge){u,v};
	}for(int i=1;i&lt;=n;i++)fa[i]=i;
	for(int i=1;i&lt;=m;i++){
		if(find(edges[i].u)!=find(edges[i].v)){
			fa[find(edges[i].u)]=find(edges[i].v);
			vis[i]=i&gt;front;	cnt+=i&gt;front;
		}
	}if(cnt&gt;k){
		puts("no solution");
		return 0;
	}for(int i=1;i&lt;=n;i++)fa[i]=i;
	for(int i=back+1;i&lt;=m;i++)
		if(vis[i])fa[find(edges[i].u)]=find(edges[i].v);	
	for(int i=back+1;i&lt;=m;i++)
		if(!vis[i]&amp;&amp;cnt&lt;k&amp;&amp;find(edges[i].u)!=find(edges[i].v))
		fa[find(edges[i].u)]=find(edges[i].v),cnt++,vis[i]=1;
	for(int i=1;i&lt;=front;i++)
		if(find(edges[i].u)!=find(edges[i].v))
		fa[find(edges[i].u)]=find(edges[i].v),vis[i]=1;
	for(int i=1;i&lt;=m;i++)if(vis[i])
	printf("%d %d %d\n",edges[i].u,edges[i].v,i&lt;=front);		
	return 0;
}</pre><pre></pre><h2>Problem3624</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1e5+10;
struct edge{
	int u,v;
}edges[maxn];
int fa[maxn];
int n,m,k,cnt;
int front,back;
bool vis[maxn];
int find(int x){
	if(fa[x]!=x)return fa[x]=find(fa[x]);return x;
}
int main(){
	scanf("%d%d%d",&amp;n,&amp;m,&amp;k);back=m;
	for(int i=1;i&lt;=m;i++){
		int u,v,c;scanf("%d%d%d",&amp;u,&amp;v,&amp;c);
		if(!c)edges[back--]=(edge){u,v};
		else edges[++front]=(edge){u,v};
	}for(int i=1;i&lt;=n;i++)fa[i]=i;
	for(int i=1;i&lt;=m;i++){
		if(find(edges[i].u)!=find(edges[i].v)){
			fa[find(edges[i].u)]=find(edges[i].v);
			vis[i]=i&gt;front;	cnt+=i&gt;front;
		}
	}if(cnt&gt;k){
		puts("no solution");
		return 0;
	}for(int i=1;i&lt;=n;i++)fa[i]=i;
	for(int i=back+1;i&lt;=m;i++)
		if(vis[i])fa[find(edges[i].u)]=find(edges[i].v);	
	for(int i=back+1;i&lt;=m;i++)
		if(!vis[i]&amp;&amp;cnt&lt;k&amp;&amp;find(edges[i].u)!=find(edges[i].v))
		fa[find(edges[i].u)]=find(edges[i].v),cnt++,vis[i]=1;
	if(cnt!=k){
		puts("no solution");
		return 0;		
	}
	for(int i=1;i&lt;=front;i++)
		if(find(edges[i].u)!=find(edges[i].v))
		fa[find(edges[i].u)]=find(edges[i].v),vis[i]=1;
	for(int i=1;i&lt;=m;i++)if(vis[i])
	printf("%d %d %d\n",edges[i].u,edges[i].v,i&lt;=front);		
	return 0;
}</pre><pre></pre><h2>Problem3626</h2><pre>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
#define MAXN 50005
#define mod 201314
using namespace std;
int aa[MAXN], cnt, n, q, ee, head[MAXN], dep[MAXN], sz[MAXN], son[MAXN], top[MAXN], ti[MAXN], fat[MAXN], ans[MAXN], lala;
struct Tree{int l, r, tag, sum;}tree[MAXN * 4];
struct Edge{int to, next;}edge[MAXN * 2];
struct La{int wei, id, flag, z;}la[MAXN * 2];
bool operator &lt; (La a, La b){return a.wei &lt; b.wei;}
inline void addedge(int x, int y){edge[++ ee].to = y; edge[ee].next = head[x]; head[x] = ee;}
void dfs1(int x, int fatt){
    dep[x] = dep[fatt] + 1; sz[x] = 1; fat[x] = fatt; son[x] = 0;
    for(int i = head[x]; i != -1; i = edge[i].next)if(edge[i].to != fatt){
        dfs1(edge[i].to, x), sz[x] += sz[edge[i].to];
        if(sz[edge[i].to] &gt; sz[son[x]]) son[x] = edge[i].to;
    }
}
void dfs2(int x, int fatt){
    top[x] = fatt; ti[x] = ++ cnt; 
    if(son[x])dfs2(son[x], top[x]);
    for(int i = head[x]; i != -1; i = edge[i].next)
        if(edge[i].to != fat[x] &amp;&amp; edge[i].to != son[x])dfs2(edge[i].to, edge[i].to);
}
void build(int t, int l, int r){
    tree[t].l = l; tree[t].r = r; tree[t].sum = tree[t].tag = 0;
    if(l == r)return; int mid = l + r &gt;&gt; 1;
    build(t + t, l, mid); build(t + t + 1, mid + 1, r);
}
inline void pushdown(int t){if(!tree[t].tag)return;
    (tree[t + t].tag += tree[t].tag) %= mod; (tree[t + t].sum += (tree[t].tag * (long long)(tree[t + t].r - tree[t + t].l + 1)) % mod) %= mod;
    (tree[t + t + 1].tag += tree[t].tag) %= mod; (tree[t + t + 1].sum += (tree[t].tag * (long long)(tree[t + t + 1].r - tree[t + t + 1].l + 1)) % mod) %= mod;
    tree[t].tag = 0;
}
inline void pushup(int t){tree[t].sum = (tree[t + t].sum + tree[t + t + 1].sum) % mod;}
void update(int t, int l, int r){
    if(tree[t].l &gt;= l &amp;&amp; r &gt;= tree[t].r){
    (tree[t].sum += tree[t].r - tree[t].l + 1) %= mod; tree[t].tag ++; return;}
    int mid = tree[t].l + tree[t].r &gt;&gt; 1;
    pushdown(t);
    if(l &lt;= mid)update(t + t, l, r); 
    if(r &gt;= mid + 1)update(t + t + 1, l, r);
    pushup(t);
}
void add(int x){
    int l = ti[top[x]], r = ti[x];
    update(1, l, r);    
    if(top[x] != 1)add(fat[top[x]]);
}
int askk(int t, int l, int r){
    if(tree[t].l &gt;= l &amp;&amp; r &gt;= tree[t].r){return tree[t].sum;}
    int mid = tree[t].l + tree[t].r &gt;&gt; 1, ret = 0;
    pushdown(t);
    if(l &lt;= mid) ret += askk(t + t, l, r);
    if(r &gt;= mid + 1) ret += askk(t + t + 1, l, r);
    return ret% mod;
}
int ask(int x){
    int l = ti[top[x]], r = ti[x];if(l == 0 || r == 0)return 0;
   int ret = askk(1, l, r); 
    return (ret + (top[x] == 1 ? 0 : ask(fat[top[x]]))) % mod;
}
int main()
{
    scanf("%d%d", &amp;n, &amp;q);
    memset(head, -1, sizeof(head));
    for(int i = 2; i &lt;= n; i ++){int x; scanf("%d", &amp;x); addedge(x + 1, i);}
    dfs1(1, 1); dfs2(1, 1); 
    build(1, 1, n);
    for(int i = 1; i &lt;= q; i ++){
        int l, r, z; scanf("%d%d%d", &amp;l, &amp;r, &amp;z);l ++; r ++; z ++;
        la[++ lala].wei = l - 1; la[lala].id = i; la[lala].flag = 0; la[lala].z = z;
        la[++ lala].wei = r; la[lala].id = i; la[lala].flag = 1;    la[lala].z = z;
    }
    sort(la + 1, la + lala + 1);int ll = 1;
    for(int i = 1; i &lt;= lala; i ++){
        while(ll &lt;= n &amp;&amp; ll &lt;= la[i].wei){add(ll); ll ++;    }  
        int ha = ask(la[i].z);
        if(la[i].flag)ans[la[i].id] += ha;
        else ans[la[i].id] -= ha;
    }
    for(int i = 1; i &lt;= q; i ++)printf("%d\n", (ans[i] + mod) % mod);
    return 0;
}</pre><pre></pre><h2>Problem3631</h2><pre>#include&lt;cstdio&gt;
#include&lt;climits&gt;
#include&lt;cstring&gt;
#include&lt;vector&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=3*1e5+10;
vector&lt;int&gt;G[maxn];
void add(int u,int v){
	G[u].push_back(v);
	G[v].push_back(u);
}int w[maxn],dep[maxn],siz[maxn],fa[maxn],son[maxn],top[maxn],z,n;
void dfs(int u){
	siz[u]=1;son[u]=0;
	for(int i=0;i&lt;G[u].size();i++){
		int v=G[u][i];
		if(v!=fa[u]){
			dep[v]=dep[u]+1;
			fa[v]=u;
			dfs(v);
			siz[u]+=siz[v];
			if(siz[son[u]]&lt;siz[v])son[u]=v;
		}
	}
}
void build(int u,int tp){
	top[u]=tp;w[u]=++z;
	if(son[u])build(son[u],tp);
	for(int i=0;i&lt;G[u].size();i++){
		int v=G[u][i];
		if(v!=fa[u]&amp;&amp;v!=son[u])build(v,v);
	}
}int q[maxn];
struct node{
	int sum,lazy;
	node():
		sum(0),lazy(0){}
};node t[maxn&lt;&lt;2];
struct seg_tree{
	#define lson i&lt;&lt;1,l,mid
	#define rson i&lt;&lt;1|1,mid+1,r
	#define L i&lt;&lt;1
	#define R i&lt;&lt;1|1	
	
	void pushdown(int i,int l,int r){
		if(t[i].lazy){
			int mid=(l+r)&gt;&gt;1;
			t[L].sum+=(mid-l+1)*t[i].lazy;
			t[L].lazy+=t[i].lazy;
			t[R].sum+=(r-mid)*t[i].lazy;
			t[R].lazy+=t[i].lazy;			
			t[i].lazy=0;
		}
	}
	void Change(int i,int l,int r,int l0,int r0,int d){
		if(l0&lt;=l&amp;&amp;r0&gt;=r){
			t[i].sum+=(r-l+1)*d;
			t[i].lazy+=d;return;
		}int mid=(l+r)&gt;&gt;1;
		pushdown(i,l,r);
		if(l0&lt;=mid)Change(lson,l0,r0,d);
		if(r0&gt;mid) Change(rson,l0,r0,d);
		t[i].sum=t[L].sum+t[R].sum;
	}
	int qsum(int i,int l,int r,int pos){
		if(l==r)return t[i].sum;
		int mid=(l+r)&gt;&gt;1;
		pushdown(i,l,r);
		if(pos&lt;=mid)return qsum(lson,pos);
		return qsum(rson,pos);
	}
	#undef lson
	#undef rson
	#undef L
	#undef R	
}T;
void Change(int u,int v,int d){
	while(top[u]!=top[v]){
		if(dep[top[u]]&gt;dep[top[v]]){
			int a=w[u],b=w[top[u]];
			if(a&gt;b)swap(a,b);
			T.Change(1,1,n,a,b,d);
			u=fa[top[u]];
		}else{
			int a=w[v],b=w[top[v]];
			if(a&gt;b)swap(a,b);
			T.Change(1,1,n,a,b,d);
			v=fa[top[v]];
		}
	}
	int a=w[u],b=w[v];
	if(a&gt;b)swap(a,b);
	T.Change(1,1,n,a,b,d);
	return ;
}
int main(){	
	scanf("%d",&amp;n);
	for(int i=1;i&lt;=n;i++)scanf("%d",&amp;q[i]);
	for(int i=1;i&lt;n;i++){
		int u,v;scanf("%d%d",&amp;u,&amp;v);
		add(u,v);
	}dfs(1);build(1,1);
	Change(q[1],q[1],1);
	for(int i=1;i&lt;n;i++){
		Change(q[i],q[i+1],1);
		Change(q[i],q[i],-1);
	}
	Change(q[n],q[n],-1);
	for(int i=1;i&lt;=n;i++)
		printf("%d\n",T.qsum(1,1,n,w[i]));
	return 0;
}
</pre><pre></pre><h2>Problem3632</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=55;
int w[maxn][maxn];
int n,ans;
int can[maxn][maxn];
int f[maxn];
bool dfs(int num,int res){
	if(!num){
		if(res&gt;ans){
			ans=res;return 1;
		}return 0;
	}
	for(int i=0;i&lt;num;i++){
		if(res+num-i&lt;=ans)return 0;
		int u=can[res][i];
		if(res+f[u]&lt;=ans)return 0;
		int suf=0;
		for(int j=i+1;j&lt;num;j++)
		if(w[u][can[res][j]])
		can[res+1][suf++]=can[res][j];
		if(dfs(suf,res+1))return 1;
	}return 0;
}
int main(){
	scanf("%d",&amp;n);
	int u,v;
	while(scanf("%d%d",&amp;u,&amp;v)==2)
	w[u-1][v-1]=w[v-1][u-1]=1;
	for(int i=n-1;i&gt;=0;i--){
		int num=0;
		for(int j=i+1;j&lt;n;j++)
			if(w[i][j])
				can[1][num++]=j;
		dfs(num,1);
		f[i]=ans;
	}cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem3643</h2><pre>#include&lt;map&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;climits&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef unsigned int LL;
LL modular_multi(LL x,LL y,LL mo){
	LL t;
	x%=mo;
	for(t=0;y;x=(x&lt;&lt;1)%mo,y&gt;&gt;=1)
		if (y&amp;1)
			t=(t+x)%mo;
	return t;
}
LL modular_exp(LL num,LL t,LL mo){
	LL ret=1,temp=num%mo;
	for(;t;t&gt;&gt;=1,temp=modular_multi(temp,temp,mo))
		if (t&amp;1)
			ret=modular_multi(ret,temp,mo);
	return ret;
}
bool isprime(LL n){
	if (n==2)return true;
	if (n&lt;2||!(n&amp;1))return false;
	int t=0;
	LL a,x,y,u=n-1;
	while((u&amp;1)==0) t++,u&gt;&gt;=1;
	for(int i=0;i&lt;5;i++){
		a=rand()%(n-1)+1;
		x=modular_exp(a,u,n);
		for(int j=0;j&lt;t;j++){
			y=modular_multi(x,x,n);
			if (y==1&amp;&amp;x!=1&amp;&amp;x!=n-1)
				return false;
    			x=y;
		}if (x!=1)return false;
	}return true;
}
LL ans=(1LL&lt;&lt;31)+1,res=1;
LL n,nn;
map&lt;LL,int&gt;M;double st;
int T=0;
void dfs(LL n){
	T++;
	if(n==1){
		if(ans&gt;res){
			ans=min(ans,res);
			
		}
		return;
	}
	for(LL i=n;i&gt;=1;i--){
		if(n%i==0){
			if(isprime(i+1)&amp;&amp;!M[i+1]){
				int cnt=0;
				M[i+1]++;
				res*=i+1;
				n/=i;
				while(n%(i+1)==0){
					n/=i+1;cnt++;
					res*=i+1;M[i+1]++;
				}
				dfs(n);
				n*=i;
				while(cnt--)n*=(i+1),res/=i+1,M[i+1]--;
				res/=i+1;
				M[i+1]--;
			}
			if(isprime(i)&amp;&amp;M[i]){
				M[i]++;
				res*=i;
				dfs(n/i);
				res/=i;
				M[i]--;
			}
		}
	}
	
}
int main(){
	srand(10086);
	cin&gt;&gt;n;nn=n;
	dfs(n);
	if(ans!=(1LL&lt;&lt;31)+1)
	cout&lt;&lt;ans&lt;&lt;endl;
	else puts("-1");
	return 0;
}</pre><pre></pre><h2>Problem3647</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
const int maxn=501000;
const int mo=1000173169;
int n,m;
int notp[maxn],p[maxn],minp[maxn];
int h[maxn],h_l[maxn];
int get(int l,int r){
    if(l&gt;r)return 0;
    return ((LL)h[r]-(LL)h[l-1]*h_l[r-l+1]%mo+mo)%mo;  
}
char s[maxn];
int getint(){
    int res=0;char c=getchar();
    while(!isdigit(c))c=getchar();
    while(isdigit(c))res=res*10+c-'0',c=getchar();
    return res;
}
int main(){
    for(int i=2;i&lt;maxn;i++){
        if(!notp[i])minp[i]=i,p[++p[0]]=i;
        for(int j=1;j&lt;=p[0]&amp;&amp;i*p[j]&lt;maxn;j++){
            notp[i*p[j]]=1;minp[i*p[j]]=p[j];
            if(i%p[j]==0)break;
        }
    }
    scanf("%d",&amp;n);
    scanf("%s",s+1);
    h_l[0]=1;
    for(int i=1;i&lt;=n;i++)h_l[i]=(LL)h_l[i-1]*31%mo;
    for(int i=1;i&lt;=n;i++)h[i]=((LL)h[i-1]*31%mo+s[i]-'a')%mo;
    for(scanf("%d",&amp;m);m--;){
        int l=getint(),r=getint();
        int len=r-l+1;
        for(int i=len;i&gt;1;){
            int j=minp[i];
            while(len%j==0&amp;&amp;get(l,r-len/j)==get(l+len/j,r))len/=j;
            while(i%j==0)i/=j;
        }printf("%d\n",len);
    }
    return 0;
}</pre><pre></pre><h2>Problem3668</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
using namespace std;
const int maxn=1e5+10;
int n,m;
unsigned int ans=0;
int op[maxn],t[maxn],Bit;
int bans[32],rbans[32],zeroto[32],oneto[32];
unsigned int inm=0;
//1 AND 2 OR 3 XOR
int main(){
	scanf("%d%d",&amp;n,&amp;m);
	for(int i=1;i&lt;=n;i++){
		char opt[4];scanf("%s%d",opt,&amp;t[i]);
		if(opt[0]=='A')op[i]=1;
		if(opt[0]=='O')op[i]=2;
		if(opt[0]=='X')op[i]=3;
	}
	Bit=31;
	long long test=0;
	for(int j=1;j&lt;=n;j++){
		if(op[j]==1)test&amp;=t[j];
		if(op[j]==2)test|=t[j];
		if(op[j]==3)test^=t[j];		
	}
	for(int i=0;i&lt;=Bit;i++)
		zeroto[i]=test&gt;&gt;i&amp;1;
	test=4294967295LL;
	for(int j=1;j&lt;=n;j++){
		if(op[j]==1)test&amp;=t[j];
		if(op[j]==2)test|=t[j];
		if(op[j]==3)test^=t[j];		
	}
	for(int i=0;i&lt;=Bit;i++)
		oneto[i]=test&gt;&gt;i&amp;1;

	for(int i=Bit;i&gt;=0;i--){
		if(oneto[i]&amp;&amp;zeroto[i]){
			ans|=1&lt;&lt;i;
		}else
		if(!oneto[i]&amp;&amp;zeroto[i]){
			ans|=1&lt;&lt;i;
		}else
		if(oneto[i]&amp;&amp;!zeroto[i]){
			if((inm|(1&lt;&lt;i))&lt;=m){
				inm|=(1&lt;&lt;i);
				ans|=1&lt;&lt;i;
			}
		}
	}		
	cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem3669</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;cctype&gt;
#include&lt;climits&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=50010;
const int maxm=1e5+10;
int n,m,mid,ans=INT_MAX;
int getint(){
	char ch=0;int res=0;
	while(!isdigit(ch))ch=getchar();
	while(isdigit(ch))(res*=10)+=ch-'0',ch=getchar();
	return res;
}
void putint(int x){
	printf("%d\n",x);
}
struct edge{
	int u,v,a,b;
	edge(int _u=0,int _v=0,int _a=0,int _b=0):
		u(_u),v(_v),a(_a),b(_b){}
	bool operator&lt;(const edge &amp;x)const{
		return a&lt;x.a;
	}
};
int fa[maxn];
int find(int x){if(fa[x]!=x)return fa[x]=find(fa[x]);return x;}
void Union(int a,int b){fa[find(a)]=find(b);}
edge edges[maxm];
struct node{
	int rev,val;
	node *c[2],*p,*maxx;
	node(){
		rev=val=0;
		maxx=this;
	}
	void pushdown(){
		if(rev){
			c[0]-&gt;rev^=1;
			c[1]-&gt;rev^=1;
			swap(c[0],c[1]);
			rev^=1;
		}
	}
	node* rz(){
		maxx=this;
		if(c[0]-&gt;maxx-&gt;val&gt;maxx-&gt;val)maxx=c[0]-&gt;maxx;
		if(c[1]-&gt;maxx-&gt;val&gt;maxx-&gt;val)maxx=c[1]-&gt;maxx;
		return this;
	}
	void sets(node *x,int d){
		pushdown();
		(c[d]=x)-&gt;p=this;
		rz();
	}
	bool d(){
		return p-&gt;c[1]==this;
	}
	bool root(){
		return p-&gt;c[0]!=this&amp;&amp;p-&gt;c[1]!=this;
	}
}pool[maxn+maxm];
void newnode(node *x,int i){
	static int tot=0;
	x=pool+(++tot);
	x-&gt;rev=0;x-&gt;val=edges[i].b;x-&gt;maxx=x;
	x-&gt;c[0]=x-&gt;c[1]=x-&gt;p=pool;
}
void rot(node *x){
    node *y=x-&gt;p;
    if(!y-&gt;root())y-&gt;p-&gt;pushdown();
    y-&gt;pushdown();
    x-&gt;pushdown();
    int d=x-&gt;d();
    y-&gt;sets(x-&gt;c[!d],d);
    if(y-&gt;root())x-&gt;p=y-&gt;p;
    else y-&gt;p-&gt;sets(x,y-&gt;d());
    x-&gt;sets(y,!d);
}
void splay(node *x){
    for(;!x-&gt;root();rot(x))
    if(x-&gt;p-&gt;root());
    else if(x-&gt;d()==x-&gt;p-&gt;d())rot(x-&gt;p);
    else rot(x);
}
node *access(node *x){
	node *y=pool;
	for(;x!=pool;x=x-&gt;p){
		splay(x);
		x-&gt;sets(y,1);
		y=x;
	}return y;
}
void makert(node *x){
	access(x)-&gt;rev^=1;
	splay(x);
}
node *qmax(node *u,node *v){
	makert(u);
	access(v);
	splay(v);
	return v-&gt;maxx;
}
node *findrt(node *x){
	for(x=access(x);x-&gt;pushdown(),x-&gt;c[0]!=pool;x=x-&gt;c[0]);
	return x;
}
void link(node *x,node *y){
    makert(x);
    x-&gt;p=y;
    access(x);
}
void cut(node *y){
	splay(y);
	y-&gt;c[0]-&gt;p=y-&gt;p;
	y-&gt;c[1]-&gt;p=pool;
	y-&gt;c[0]=y-&gt;c[1]=y-&gt;p=pool;
	y-&gt;maxx=y;
	y-&gt;val=0;
}
void add(node *u,node *v,node *w){
	if(findrt(u)==findrt(v)){
		node *x=qmax(u,v);
		if(x-&gt;val&lt;w-&gt;val)return;
		cut(x);
		v-&gt;rz();
		link(v,w);
		link(w,u);
	}else{
		link(v,w);
		link(w,u);
	}
}
#define id(i) (pool+i)
int main(){
	n=getint();m=getint();
	for(int i=1;i&lt;=n;i++)fa[i]=i;
	for(int i=1;i&lt;=m;i++){
		edges[i].u=getint();
		edges[i].v=getint();
		edges[i].a=getint();
		edges[i].b=getint();
		Union(edges[i].u,edges[i].v);
	}if(find(1)!=find(n)){
		puts("-1");return 0;
	}sort(edges+1,edges+1+m);
	for(int i=0;i&lt;=n+m;i++)
		id(i)-&gt;p=id(i)-&gt;c[0]=id(i)-&gt;c[1]=pool,id(i)-&gt;maxx=id(i);
	int ans=INT_MAX;
	for(int i=1;i&lt;=m;i++){
		id(i+n)-&gt;val=edges[i].b;
		node *u=edges[i].u+pool,*v=edges[i].v+pool,*w=i+n+pool;
		add(u,v,w);
		if(findrt(id(1))==findrt(id(n)))
		ans=min(ans,edges[i].a+qmax(id(1),id(n))-&gt;val);
	}cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem3670</h2><pre>#define PROC "zoo"
#include &lt;cstdio&gt;
#include &lt;cctype&gt;
#include &lt;cstring&gt;
#include &lt;memory.h&gt;
#include &lt;algorithm&gt;
 
using namespace std;
 
#define _l (long long int)
 
struct edge {
    int t;
    edge *next;
};
 
const int maxl = 1000009;
const int mod = 1000000007;
 
char a[maxl];
int next[maxl], num[maxl], l, rp[maxl], d;
edge *head[maxl], *ep, elst[maxl];
 
void dfs() {
    static int p[maxl], q[maxl], ste[maxl];
    static edge* e[maxl];
    int t = 0;
    p[0] = 0;
    q[0] = 0;
    ste[0] = 0;
    do {
        if (ste[t] == 0) {
            while (q[t] + 1 &lt; t &amp;&amp; (p[q[t] + 1] &lt;&lt; 1) &lt;= p[t])
                q[t] ++;
            num[p[t]] = q[t];
            ste[t] = 1;
            e[t] = head[p[t]];
        }
        else if (ste[t] == 1) {
            if (!e[t]) {
                ste[t] = 3;
                continue;
            }
            p[t + 1] = e[t]-&gt; t;
            q[t + 1] = q[t];
            ste[t + 1] = 0;
            t ++;
        }
        else if (ste[t] == 2) {
            e[t] = e[t]-&gt; next;
            if (e[t])
                ste[t] = 1;
            else
                ste[t] = 3;
        }
        else if (ste[t] == 3) {
            if (t)
                ste[t - 1] = 2;
            t --;
        }
    } while (t &gt; -1);
}   
 
int sov() {
    int s = 1;
    memset(next, 0, sizeof(next));
    memset(num, 0, sizeof(num));
    memset(head, 0, sizeof(head));
    ep = elst;
    l = strlen(a + 1);
    for (int i = 1; i &lt; l; i ++) {
        int p = i;
        while (p) {
            p = next[p];
            if (a[p + 1] == a[i + 1]) {
                next[i + 1] = p + 1;
                break;
            }
        }
    }
    for (int i = 1; i &lt;= l; i ++) {
        ep-&gt; t = i;
        ep-&gt; next = head[next[i]];
        head[next[i]] = ep ++;
    }
    dfs();
    for (int i = 1; i &lt;= l; i ++)
        s = _l s * (num[i] + 1) % mod;
    return s;
}
 
int main() {
    int t;
    scanf("%d", &amp;t);
    while (t --) {
        scanf("\n%s", a + 1);
        printf("%d\n", sov());
    }
    return 0;
}</pre><pre></pre><h2>Problem3670</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1e6+5;
int T,n;
int next[maxn],num[maxn];
char s[maxn];
typedef long long LL;
LL p=1000000007;
vector&lt;int&gt;G[maxn];
#define lowbit(x) (x&amp;-x)
int d[maxn];
int get(int x){
	int ans=0;while(x)ans+=d[x],x-=lowbit(x);
	return ans;
}
void updata(int x,int f){
	if(x)
	while(x&lt;=n)d[x]+=f,x+=lowbit(x);
}
void dfs(int u){
	num[u]=get(u/2);
	updata(u,1);
	for(int i=0;i&lt;G[u].size();i++)
		dfs(G[u][i]);
	updata(u,-1);
}
int main(){
	scanf("%d",&amp;T);
	while(T--){
		scanf("%s",s+1);n=strlen(s+1);
		for(int i=0;i&lt;=n;++i)G[i].clear();
		memset(num,0,sizeof num);
		G[0].push_back(1);
		for(int i=2,j=0;i&lt;=n;i++){
			while(j&amp;&amp;s[i]!=s[j+1])j=next[j];
			next[i]=j+=s[i]==s[j+1];
			G[next[i]].push_back(i);
		}dfs(0);
		LL ans=1;
		for(int i=1;i&lt;=n;i++)
			ans=(LL)ans*(num[i]+1)%p;
		cout&lt;&lt;ans&lt;&lt;endl;
	}
	return 0;
}</pre><pre></pre><h2>Problem3670</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1e6+5;
int T,n;
int next[maxn],num[maxn];
char s[maxn];
typedef long long LL;
LL p=1000000007;
vector&lt;int&gt;G[maxn];
#define lowbit(x) (x&amp;-x)
int d[maxn];
int get(int x){
	int ans=0;while(x)ans+=d[x],x-=lowbit(x);
	return ans;
}
void updata(int x,int f){
	if(x)
	while(x&lt;=n)d[x]+=f,x+=lowbit(x);
}
void dfs(int u){
	num[u]=get(u/2);
	updata(u,1);
	for(int i=0;i&lt;G[u].size();i++)
		dfs(G[u][i]);
	updata(u,-1);
}
int main(){
	scanf("%d",&amp;T);
	while(T--){
		scanf("%s",s+1);n=strlen(s+1);
		for(int i=0;i&lt;=n;++i)G[i].clear();
		G[0].push_back(1);
		for(int i=2,j=0;i&lt;=n;i++){
			while(j&amp;&amp;s[i]!=s[j+1])j=next[j];
			next[i]=j+=s[i]==s[j+1];
			G[next[i]].push_back(i);
		}dfs(0);
		LL ans=1;
		for(int i=1;i&lt;=n;i++)
			ans=(LL)ans*(num[i]+1)%p;
		cout&lt;&lt;ans&lt;&lt;endl;
	}
	return 0;
}</pre><pre></pre><h2>Problem3671</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=5001;
int n,m,q;
long long x,a,b,c,d;
int getint(){
	int res=0;
	char ch=getchar();
	while(!isdigit(ch))ch=getchar();
	while(isdigit(ch))(res*=10)+=ch-'0',ch=getchar();
	return res;
}
int rnd(){
	return x=(x*(a*x+b)+c)%d;
}
int t[maxn*maxn];
int pos[maxn*maxn];
int up[maxn],down[maxn];
int main(){
	x=getint();a=getint();
	b=getint();c=getint();
	d=getint();n=getint();
	m=getint();q=getint();
	for(int i=1;i&lt;=n*m;i++)t[i]=i;
	for(int i=1;i&lt;=n;i++)up[i]=m,down[i]=1;
	for(int i=1;i&lt;=n*m;i++)swap(t[i],t[(rnd()%i)+1]);
	for(int i=1;i&lt;=q;i++){
		int u=getint(),v=getint();
		swap(t[u],t[v]);
	}
	for(int i=1;i&lt;=n*m;i++)pos[t[i]]=i;
	int x,y,tot=0;
	for(int i=1;i&lt;=n*m;i++){
		if(pos[i]%m)x=pos[i]/m+1;else x=pos[i]/m;
		y=pos[i]%m?pos[i]%m:m;
		if(y&lt;=up[x]&amp;&amp;y&gt;=down[x]){
        	for(int j=1;j&lt;=n;j++)
        	if(j&lt;x)up[j]=min(y,up[j]);
        	else if(j&gt;x)down[j]=max(y,down[j]);
        	tot++;
        	printf("%d%c",i," \n"[tot==n+m-1]);
			if(tot==n+m-1)break;
		}
	}
	
	return 0;
}</pre><pre></pre><h2>Problem3672</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
#include&lt;cctype&gt;
typedef long long LL;
const int maxn=2e5+5;
using namespace std;
int DEB;
LL getint(){
	LL res=0;char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))res=res*10+c-'0',c=getchar();
	return res;
}
struct point{
	LL x,y;
	point(LL _x=0,LL _y=0):x(_x),y(_y){}
	double operator*(point oth)const{return (double)x*oth.y-(double)y*oth.x;}
	LL operator^(point oth)const{return (LL)x*oth.x+(LL)y*oth.y;}
	point operator-(point oth)const{return point(x-oth.x,y-oth.y);}
	point operator+(point oth)const{return point(x+oth.x,y+oth.y);}
	bool operator&lt;(point oth)const{return x&lt;oth.x||(x==oth.x&amp;&amp;y&lt;oth.y);}
	void print(){printf("%d %d\n",int(x),int(y));}
}tmp[maxn];
int tmpsize,n,T,siz[maxn],son[maxn],dep[maxn],top[maxn],w[maxn],rw[maxn],fa[maxn],z,dfn[maxn];
LL d[maxn],p[maxn],q[maxn],l[maxn],dp[maxn];
vector&lt;int&gt;G[maxn];
void dfs(int u){
	siz[u]=1;dfn[++dfn[0]]=u;
	for(int i=0;i&lt;G[u].size();i++){
		int v=G[u][i];
		if(v!=fa[u]){
			fa[v]=u;dep[v]=dep[u]+1;d[v]+=d[u];
			dfs(v);
			siz[u]+=siz[v];
			if(siz[son[u]]&lt;siz[v])son[u]=v;
		}
	}
}
void buiLL(int u,int tp){
	w[u]=++z;rw[z]=u;top[u]=tp;
	if(son[u])buiLL(son[u],tp);
	for(int i=0;i&lt;G[u].size();i++){
		int v=G[u][i];
		if(v!=fa[u]&amp;&amp;v!=son[u])buiLL(v,v);
	}
}
struct CH{
	point *ch;
	int size;
	void init(int l,int r){
		tmpsize=size=0;
		for(int i=l;i&lt;=r;i++)tmp[++tmpsize]=point(d[rw[i]],dp[rw[i]]);
		sort(tmp+1,tmp+1+tmpsize);
		ch=new point[tmpsize+5];
		for(int i=1;i&lt;=tmpsize;i++){
			while(size&gt;1&amp;&amp;(tmp[i]-ch[size])*(ch[size]-ch[size-1])&gt;=-1e-20)size--;
			ch[++size]=tmp[i];			
		}
	}
	LL qmin(point p){
		int l=1,r=size;
		LL ans=min((ch[l]^p),(ch[r]^p));
		while(r-l&gt;2){
			int mid1=l+(r-l)/3;
			int mid2=r-(r-l)/3;
			if((ch[mid1]^p)&lt;=(ch[mid2]^p))
				r=mid2;
			else l=mid1;
		}		
		for(int i=l;i&lt;=r;i++)ans=min(ans,(LL)(ch[i]^p));
		return ans;
	}
};
int findrt(int u){
	LL lim=d[u]-l[u];
	for(;u&amp;&amp;d[top[u]]&gt;=lim;){
		u=top[u];
		if(d[fa[u]]&gt;=lim)u=fa[u];else break;
	}
	if(!u)return 1;
	int l=w[u],r=w[top[u]];
	if(l&gt;r)swap(l,r);
	while(l&lt;r){
		int mid=(l+r)&gt;&gt;1;
		if(d[rw[mid]]&lt;lim)
			l=mid+1;
		else r=mid;
	}return rw[l];
}
bool bud[maxn&lt;&lt;2];
CH t[maxn&lt;&lt;2];
LL Qmin(int i,int l,int r,int l0,int r0,point p){
	if(l0&gt;r0)swap(l0,r0);
	if(l0&lt;=l&amp;&amp;r0&gt;=r){
		if(bud[i])return t[i].qmin(p);
		bud[i]=1;t[i].init(l,r);
		return t[i].qmin(p);
	}int mid=(l+r)&gt;&gt;1;LL ans=1LL&lt;&lt;61;
	if(l0&lt;=mid)ans=min(ans,Qmin(i&lt;&lt;1,l,mid,l0,r0,p));
	if(r0&gt;mid)ans=min(ans,Qmin(i&lt;&lt;1|1,mid+1,r,l0,r0,p));
	return ans;
}
int main(){
	n=getint();T=getint();
	for(int i=2;i&lt;=n;i++){
		fa[i]=getint(),d[i]=getint(),p[i]=getint(),q[i]=getint(),l[i]=getint();
		G[i].push_back(fa[i]);G[fa[i]].push_back(i);
	}if(T==0||T==2){
		queue&lt;int&gt;q;
		q.push(1);
		while(!q.empty()){
			int u=q.front();q.pop();
			dfn[++dfn[0]]=u;w[u]=++z;rw[z]=u;top[u]=1;
			for(int i=0;i&lt;G[u].size();i++){
				int v=G[u][i];
				if(v!=fa[u]){
					q.push(v);
					d[v]+=d[u];fa[v]=u;
					dep[v]=dep[u]+1;
					son[u]=v;					
				}			
			}
		}
	}else dfs(1),buiLL(1,1);	
	for(int i=2;i&lt;=dfn[0];i++){
		DEB=dfn[i];
		dp[dfn[i]]=1LL&lt;&lt;61;int u=fa[dfn[i]],v=findrt(dfn[i]);
		for(;top[u]!=top[v];u=fa[top[u]])
			dp[dfn[i]]=min(dp[dfn[i]],Qmin(1,1,n,w[u],w[top[u]],point(-p[dfn[i]],1)));
		dp[dfn[i]]=min(dp[dfn[i]],Qmin(1,1,n,w[u],w[v],point(-p[dfn[i]],1)));
		dp[dfn[i]]+=p[dfn[i]]*d[dfn[i]]+q[dfn[i]];
	}
	for(int i=2;i&lt;=n;i++)printf("%lld\n",dp[i]);
	return 0;
}</pre><pre></pre><h2>Problem3673</h2><pre>#include&lt;bits/stdc++.h&gt;
#include&lt;ext/rope&gt;
using namespace std;
using namespace __gnu_cxx;
const int maxn=1e5+10;
rope&lt;int&gt; *fa[maxn];
rope&lt;int&gt;::iterator it;
int n,m;
int find(int i,int x){
	if(fa[i]-&gt;at(x)!=x){
		int f=find(i,fa[i]-&gt;at(x));
		fa[i]-&gt;replace(x,f);
		return fa[i]-&gt;at(x);
	}
	return x;
}
void Union(int i,int x,int y){
	int fx=find(i,x),fy=find(i,y);
	fa[i]-&gt;replace(fx,fy);
}
int a[maxn];
int main(){
	scanf("%d%d",&amp;n,&amp;m);
	for(int i=0;i&lt;=n;i++)a[i]=i;
	fa[0]=new rope&lt;int&gt;(a,a+n+1);
	for(int i=1;i&lt;=m;i++){
		fa[i]=new rope&lt;int&gt;(*fa[i-1]);
		int op;scanf("%d",&amp;op);
		if(op==1){
			int a,b;scanf("%d%d",&amp;a,&amp;b);
			Union(i,a,b);
		}else
		if(op==2){
			int k;scanf("%d",&amp;k);
			fa[i]=fa[k];
		}else
		if(op==3){
			int a,b;scanf("%d%d",&amp;a,&amp;b);
			printf("%d\n",find(i,a)==find(i,b));
		}
	}
	return 0;
}</pre><pre></pre><h2>Problem3674</h2><pre>#include&lt;bits/stdc++.h&gt;
#include&lt;ext/rope&gt;
using namespace std;
using namespace __gnu_cxx;
const int maxn=2e5+10;
rope&lt;int&gt; *fa[maxn];
rope&lt;int&gt;::iterator it;
int n,m;
int find(int i,int x){
	if(fa[i]-&gt;at(x)!=x){
		int f=find(i,fa[i]-&gt;at(x));
		if(f==fa[i]-&gt;at(x))return f;
		fa[i]-&gt;replace(x,f);
		return fa[i]-&gt;at(x);
	}
	return x;
}
void Union(int i,int x,int y){
	int fx=find(i,x),fy=find(i,y);
	fa[i]-&gt;replace(fy,fx);
}
int a[maxn];
int lastans=0;
int main(){
	scanf("%d%d",&amp;n,&amp;m);
	for(int i=0;i&lt;=n;i++)a[i]=i;
	fa[0]=new rope&lt;int&gt;(a,a+n+1);
	for(int i=1;i&lt;=m;i++){
		fa[i]=new rope&lt;int&gt;(*fa[i-1]);
		int op;scanf("%d",&amp;op);
		if(op==1){
			int a,b;scanf("%d%d",&amp;a,&amp;b);
			Union(i,a^lastans,b^lastans);
		}else
		if(op==2){
			int k;scanf("%d",&amp;k);
			fa[i]=fa[k^lastans];
		}else
		if(op==3){
			int a,b;scanf("%d%d",&amp;a,&amp;b);
			printf("%d\n",(lastans=find(i,a^lastans)==find(i,b^lastans)));
		}
	}
	return 0;
}</pre><pre></pre><h2>Problem3674</h2><pre>#include&lt;bits/stdc++.h&gt;
#include&lt;ext/rope&gt;
using namespace std;
using namespace __gnu_cxx;
const int maxn=2e5+10;
rope&lt;int&gt; *fa[maxn];
int n,m;
int find(int i,int x){
	if(fa[i]-&gt;at(x)!=x){
		int f=find(i,fa[i]-&gt;at(x));
		if(f==fa[i]-&gt;at(x))return f;
		fa[i]-&gt;replace(x,f);
		fa[i]-&gt;erase(x,1);
		fa[i]-&gt;insert(x,f);
		return fa[i]-&gt;at(x);
	}
	return x;
}
void Union(int i,int x,int y){
	int fx=find(i,x),fy=find(i,y);
	fa[i]-&gt;erase(fy,1);
	fa[i]-&gt;insert(fy,fx);
}
int a[maxn];
int lastans=0;
int main(){
	scanf("%d%d",&amp;n,&amp;m);
	for(int i=0;i&lt;=n;i++)a[i]=i;
	fa[0]=new rope&lt;int&gt;(a,a+n+1);
	for(int i=1;i&lt;=m;i++){
		fa[i]=new rope&lt;int&gt;(*fa[i-1]);
		int op;scanf("%d",&amp;op);
		if(op==1){
			int a,b;scanf("%d%d",&amp;a,&amp;b);
			a^=lastans;b^=lastans;
			Union(i,a,b);
		}else
		if(op==2){
			int k;scanf("%d",&amp;k);
			k^=lastans;
			fa[i]=fa[k];
		}else
		if(op==3){
			int a,b;scanf("%d%d",&amp;a,&amp;b);
			a^=lastans;b^=lastans;
			lastans=bool(find(i,a)==find(i,b));
			printf("%d\n",lastans);
		}
	}
	return 0;
}</pre><pre></pre><h2>Problem3674</h2><pre>#include&lt;bits/stdc++.h&gt;  
#include&lt;ext/rope&gt;  
using namespace std;  
using namespace __gnu_cxx;  
const int maxn=2e5+10;  
rope&lt;int&gt; *fa[maxn];  
rope&lt;int&gt;::iterator it;  
int n,m;  
inline int read()  
{  
    int x=0;char ch=getchar();  
    while(ch&gt;'9'||ch&lt;'0')ch=getchar();  
    while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=x*10+ch-'0';ch=getchar();}  
    return x;  
} 
int find(int i,int x){  
    if(fa[i]-&gt;at(x)!=x){  
        int f=find(i,fa[i]-&gt;at(x));  
        if(f==fa[i]-&gt;at(x))return f;  
        fa[i]-&gt;replace(x,f);  
        return fa[i]-&gt;at(x);  
    }  
    return x;  
}  
void Union(int i,int x,int y){  
    int fx=find(i,x),fy=find(i,y);  
    fa[i]-&gt;replace(fy,fx);  
}  
int a[maxn];  
int lastans=0;  
int main(){  
    scanf("%d%d",&amp;n,&amp;m);  
    for(int i=0;i&lt;=n;i++)a[i]=i;  
    fa[0]=new rope&lt;int&gt;(a,a+n+1);  
    for(int i=1;i&lt;=m;i++){  
        fa[i]=new rope&lt;int&gt;(*fa[i-1]);  
        int op;scanf("%d",&amp;op);  
        if(op==1){  
            int a=read(),b=read();
            Union(i,a^lastans,b^lastans);  
        }else  
        if(op==2){  
            int k=read(); 
            fa[i]=fa[k^lastans];  
        }else  
        if(op==3){  
            int a=read(),b=read(); 
            lastans=find(i,a^lastans)==find(i,b^lastans);
			if(lastans)puts("1");else puts("0");  
        }  
    }  
    return 0;  
}  </pre><pre></pre><h2>Problem3674</h2><pre>#include&lt;bits/stdc++.h&gt;  
#include&lt;ext/rope&gt;  
using namespace std;  
using namespace __gnu_cxx;  
const int maxn=2e5+10;  
rope&lt;int&gt; *fa[maxn];  
rope&lt;int&gt;::iterator it;  
int n,m;  
inline int read()  
{  
    int x=0;char ch=getchar();  
    while(ch&gt;'9'||ch&lt;'0')ch=getchar();  
    while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=x*10+ch-'0';ch=getchar();}  
    return x;  
} 
int find(int i,int x){  
    if(fa[i]-&gt;at(x)!=x){  
        int f=find(i,fa[i]-&gt;at(x));  
        if(f==fa[i]-&gt;at(x))return f;  
        fa[i]-&gt;replace(x,f);  
        return fa[i]-&gt;at(x);  
    }  
    return x;  
}  
void Union(int i,int x,int y){  
    int fx=find(i,x),fy=find(i,y);  
    fa[i]-&gt;replace(fy,fx);  
}  
int a[maxn];  
int lastans=0;  
int main(){  
    scanf("%d%d",&amp;n,&amp;m);  
    for(int i=0;i&lt;=n;i++)a[i]=i;  
    fa[0]=new rope&lt;int&gt;(a,a+n+1);  
    for(int i=1;i&lt;=m;i++){  
        fa[i]=new rope&lt;int&gt;(*fa[i-1]);  
        int op=read();
        if(op==1){  
            int a=read(),b=read();
            Union(i,a^lastans,b^lastans);  
        }else  
        if(op==2){  
            int k=read(); 
            fa[i]=fa[k^lastans];  
        }else  
        if(op==3){  
            int a=read(),b=read(); 
            lastans=find(i,a^lastans)==find(i,b^lastans);
			if(lastans)puts("1");else puts("0");  
        }  
    }  
    return 0;  
}  </pre><pre></pre><h2>Problem3674</h2><pre>#include&lt;bits/stdc++.h&gt;  
#include&lt;ext/rope&gt;  
using namespace std;  
using namespace __gnu_cxx;  
const int maxn=2e5+10;  
rope&lt;int&gt; *fa[maxn];  
rope&lt;int&gt;::iterator it;  
int n,m;  
int find(int i,int x){  
    if(fa[i]-&gt;at(x)!=x){  
        int f=find(i,fa[i]-&gt;at(x));   
        return f;  
    }  
    return x;  
}  
void Union(int i,int x,int y){  
    int fx=find(i,x),fy=find(i,y);  
    fa[i]-&gt;replace(fy,fx);  
}  
int a[maxn];  
int lastans=0;  
int main(){  
    scanf("%d%d",&amp;n,&amp;m);  
    for(int i=0;i&lt;=n;i++)a[i]=i;  
    fa[0]=new rope&lt;int&gt;(a,a+n+1);  
    for(int i=1;i&lt;=m;i++){  
        fa[i]=new rope&lt;int&gt;(*fa[i-1]);  
        int op;scanf("%d",&amp;op);  
        if(op==1){  
            int a,b;scanf("%d%d",&amp;a,&amp;b);  
            Union(i,a^lastans,b^lastans);  
        }else  
        if(op==2){  
            int k;scanf("%d",&amp;k);  
            fa[i]=fa[k^lastans];  
        }else  
        if(op==3){  
            int a,b;scanf("%d%d",&amp;a,&amp;b);  
            printf("%d\n",(lastans=find(i,a^lastans)==find(i,b^lastans)));  
        }  
    }  
    return 0;  
}  </pre><pre></pre><h2>Problem3676</h2><pre>#include&lt;bits/stdc++.h&gt;
#define fst first
#define sec second
using namespace std;
const int maxn=1e6+5;
typedef pair&lt;int,int&gt; pi;
typedef long long LL;
typedef unsigned int UL;
int n,m,fa[maxn],sum[maxn],f[maxn];
char s[maxn],str[maxn];
UL hash[maxn],hash_l[maxn],base=233;
int hash2[maxn],hash_l2[maxn],base2=97,p=10007;
vector&lt;int&gt;G[maxn];
LL ans=0;int len[maxn];
void hash_init(){
	hash_l[0]=1;for(int i=1;i&lt;=m;i++)hash_l[i]=hash_l[i-1]*base;
	hash_l2[0]=1;for(int i=1;i&lt;=m;i++)hash_l2[i]=hash_l2[i-1]*base2%p;
	UL val=0;int val2=0;
	for(int i=1;i&lt;=m;i++){
		val=val*base+str[i]-'a'+1;
		val2=val2*base2+str[i]-'a'+1;
		val2%=p;
		hash[i]=val;
		hash2[i]=val2;
	}
}	
int cnt=0;
map&lt;pair&lt;UL,int&gt;,int&gt; M;
inline int GetHashCode(int l,int r){
	UL key1=l&lt;=r?hash[r]-hash[l-1]*hash_l[r-l+1]:0;
	int key2=(l&lt;=r?hash2[r]-hash2[l-1]*hash_l2[r-l+1]%p+p:0)%p;
	if(M.count(make_pair(key1,key2)))return M[make_pair(key1,key2)];
	len[++cnt]=r-l+1;
	return M[make_pair(key1,key2)]=cnt;
}
void dfs(int u){
	for(int i=0;i&lt;G[u].size();i++){
		dfs(G[u][i]);
		sum[u]+=sum[G[u][i]];
	}ans=max(ans,(LL)sum[u]*len[u]);
}
int main(){
	char c=getchar();s[0]='+';s[++n]='#';
	while(isalpha(c))str[++m]=c,s[++n]=c,s[++n]='#',c=getchar();s[++n]='-';
	hash_init();
	f[1]=1;
	for(int i=2,k=1;i&lt;=n;i++){
		if(f[k]+k&gt;i)f[i]=min(f[k+k-i],f[k]+k-i);else f[i]=1;
		while(s[i+f[i]]==s[i-f[i]]){
			int l=0,r=0,u=0,v=0;
			f[i]++;
			l=(i-f[i]+2)/2;
			r=(i+f[i]-2)/2;
			u=GetHashCode(l+1,r-1);
			v=GetHashCode(l,r);			
			if(v==1||fa[v]==u)continue;
			fa[v]=u;
			G[u].push_back(v);			
		}
		int l=0,r=0,u=0,v=0;
		l=(i-f[i]+2)/2;
		r=(i+f[i]-2)/2;
		v=GetHashCode(l,r);
		if(v==1)continue;
		sum[v]++;
		if(f[k]+k&lt;f[i]+i)k=i;		
	}
	dfs(1);
	cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem3676</h2><pre>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
const int M = 700050;
const int MAXM = 3000010;
const int inf = 987654321;
char data[M];
int sa[M],rank[MAXM],sab[M];
int val[M],valb[M];
int cc[M];
int height[MAXM],h[M],MT;
int n,m;
int tree[M];
struct XuA
{
    int l,r;
}xua[M],ja[M];
int ca;
struct XuB
{
    int l,r;
    int xi;
}xub[M],jb[M];
int cb=0;
int duix[M],duiy[M],top,tail;
void GetData()
{
    int i;
    scanf("%s",data+1);
    n=m=strlen(data+1);
    data[++n]='@';
    for(i=m;i&gt;0;i--)
        data[++n]=data[i];
    data[n+1]=0;
}
void Suffix()
{
    int i,j,p;
    for(i=1;i&lt;=n;i++)
        cc[data[i]]++;
    for(i=1;i&lt;='z';i++)
        cc[i]+=cc[i-1];
    for(i=1;i&lt;=n;i++)
    {
        rank[i]=cc[data[i]]--;
        sa[rank[i]]=i;
        val[i]=data[i];
    }
    p=1;
    for(i=1;i&lt;n;i++)
    {
        if(val[sa[i]]==val[sa[i+1]])
            val[sa[i]]=p;
        else
        {
            val[sa[i]]=p;
            p++;
        }
    }
    val[sa[n]]=p;
    for(i=0;i&lt;='z';i++)
        cc[i]=0;
    for(i=1;p&lt;n;i&lt;&lt;=1)
    {
        for(j=1;j+i&lt;=n;j++)
            valb[j]=val[j+i];
        memset(valb+j,0,(n&lt;&lt;2)-(j&lt;&lt;2)+4);
        for(j=1;j&lt;=n;j++)
            cc[valb[j]]++;
        for(j=1;j&lt;=p;j++)
            cc[j]+=cc[j-1];
        for(j=1;j&lt;=n;j++)
            sab[cc[valb[j]]--]=j;
        memset(cc,0,(p&lt;&lt;2)+4);
        for(j=1;j&lt;=n;j++)
            cc[val[j]]++;
        for(j=1;j&lt;=p;j++)
            cc[j]+=cc[j-1];
        for(j=n;j&gt;=1;j--)
            sa[cc[val[sab[j]]]--]=sab[j];
        memset(cc,0,(p&lt;&lt;2)+4);
        for(j=1;j&lt;=n;j++)
            rank[sa[j]]=j;
        p=1;
        for(j=1;j&lt;n;j++)
        {
            if(val[sa[j]]==val[sa[j+1]] &amp;&amp; valb[sa[j]]==valb[sa[j+1]])
                val[sa[j]]=p;
            else
            {
                val[sa[j]]=p;
                p++;
            }
        }
        val[sa[n]]=p;
    }
    MT=1;
    while(MT&lt;n+5)
        MT&lt;&lt;=1;
    for(i=1;i&lt;=n;i++)
    {
        if(rank[i]==1)
            continue;
        h[i]=h[i-1]&gt;0?h[i-1]-1:0;
        while(data[i+h[i]]==data[sa[rank[i]-1]+h[i]])
            h[i]++;
        height[rank[i]+MT]=h[i];
    }
    for(i=MT-1;i&gt;0;i--)
        height[i]=height[i&lt;&lt;1]&lt;height[(i&lt;&lt;1)|1]?height[i&lt;&lt;1]:height[(i&lt;&lt;1)|1];
}
int findmin(int l,int r)
{
    l+=MT-1;
    r+=MT+1;
    int minz=inf;
    int ll=l;
    int rr=r;
    while(ll^rr^1)
    {
        if(ll%2==0 &amp;&amp; minz&gt;height[ll^1])
            minz=height[ll^1];
        if(rr%2==1 &amp;&amp; minz&gt;height[rr^1])
            minz=height[rr^1];
        ll&gt;&gt;=1;
        rr&gt;&gt;=1;
    }
    while(l^r^1)
    {
        if(l%2==0 &amp;&amp; height[l^1]==minz)
        {
            l^=1;
            break;
        }
        if(r%2==1 &amp;&amp; height[r^1]==minz)
        {
            l=r^1;
            break;
        }
        l&gt;&gt;=1;
        r&gt;&gt;=1;
    }
    while(l&lt;MT)
    {
        l&lt;&lt;=1;
        if(height[l]&gt;height[l^1])
            l^=1;
    }
    l-=MT;
    return l;
}
void add(int x)
{
    while(x&lt;=n)
    {
        tree[x]++;
        x+=(x&amp;(-x));
    }
}
int find(int x)
{
    int res=0;
    while(x)
    {
        res+=tree[x];
        x-=(x&amp;(-x));
    }
    return res;
}
void GetAns()
{
    int i,point;
    top=0;tail=1;
    duix[1]=1;duiy[1]=n;
    while(top&lt;tail)
    {
        top++;
        int l=duix[top];
        int r=duiy[top];
        int now=findmin(l+1,r);
        cb++;
        jb[cb].l=l;
        jb[cb].r=r;
        jb[cb].xi=height[now+MT];
        if(l&lt;now-1)
        {
            tail++;
            duix[tail]=l;
            duiy[tail]=now-1;
        }
        if(now&lt;r)
        {
            tail++;
            duix[tail]=now;
            duiy[tail]=r;
        }
    }
    for(i=1;i&lt;=cb;i++)
        cc[jb[i].l]++;
    for(i=n;i&gt;=1;i--)
        cc[i]+=cc[i+1];
    for(i=1;i&lt;=cb;i++)
        xub[cc[jb[i].l]--]=jb[i];
    for(i=1;i&lt;=n;i++)
        cc[i]=0;
    long long ans=0,now;
    ca=0;
    for(i=1;i&lt;=m;i++)
    {
        ca++;
        ja[ca].l=rank[i];
        ja[ca].r=rank[n-i+1];
        if(ja[ca].l&gt;ja[ca].r)
        {
            ja[ca].l^=ja[ca].r;
            ja[ca].r^=ja[ca].l;
            ja[ca].l^=ja[ca].r;
        }
    }
    for(i=1;i&lt;=ca;i++)
        cc[ja[i].l]++;
    for(i=n;i&gt;=1;i--)
        cc[i]+=cc[i+1];
    for(i=1;i&lt;=ca;i++)
        xua[cc[ja[i].l]--]=ja[i];
    for(i=1;i&lt;=n;i++)
        cc[i]=0;
    point=1;
    for(i=1;i&lt;=cb;i++)
    {
        while(point&lt;=ca &amp;&amp; xua[point].l&gt;=xub[i].l)
        {
            add(xua[point].r);
            point++;
        }
        now=find(xub[i].r);
        now*=(xub[i].xi*2-1);
        if(ans&lt;now)
            ans=now;
    }
    ca=0;
    for(i=2;i&lt;=m;i++)
    {
        ca++;
        ja[ca].l=rank[i];
        ja[ca].r=rank[n-i+2];
        if(ja[ca].l&gt;ja[ca].r)
        {
            ja[ca].l^=ja[ca].r;
            ja[ca].r^=ja[ca].l;
            ja[ca].l^=ja[ca].r;
        }
    }
    for(i=1;i&lt;=ca;i++)
        cc[ja[i].l]++;
    for(i=n;i&gt;=1;i--)
        cc[i]+=cc[i+1];
    for(i=1;i&lt;=ca;i++)
        xua[cc[ja[i].l]--]=ja[i];
    for(i=1;i&lt;=n;i++)
        cc[i]=0;
    memset(tree,0,(n&lt;&lt;2)+4);
    point=1;
    for(i=1;i&lt;=cb;i++)
    {
        while(point&lt;=ca &amp;&amp; xua[point].l&gt;=xub[i].l)
        {
            add(xua[point].r);
            point++;
        }
        now=find(xub[i].r);
        now*=(xub[i].xi&lt;&lt;1);
        if(ans&lt;now)
            ans=now;
    }
    printf("%lld\n",ans);
}
int main()
{
    GetData();
    Suffix();
    GetAns();
    return 0;
}</pre><pre></pre><h2>Problem3680</h2><pre>#include&lt;cmath&gt;
#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
const double eps=1e-9;
const int maxn=1e4+10;
int n;
double a[maxn][2];
double w[maxn];
double dis(double x,double y,int i){
	return sqrt((x-a[i][0])*(x-a[i][0])+(y-a[i][1])*(y-a[i][1]));
}
double dist(double x,double y){
	double ans=0;
	for(int i=1;i&lt;=n;i++)
	ans+=dis(x,y,i)*w[i];
	return ans;
}
double rnd(){
	return (double)rand()/RAND_MAX;
}
int main(){
	srand(10086);
	while(scanf("%d",&amp;n)==1){
		double x=0,y=0;
		for(int i=1;i&lt;=n;i++)
		scanf("%lf%lf%lf",&amp;a[i][0],&amp;a[i][1],&amp;w[i]),
		x=max(x,a[i][0]),y=max(y,a[i][1]);
		x++;y++;
		double T=1e3,ans=dist(x,y);
		while(T&gt;eps){
			double dx=0,dy=0;
			for(int i=1;i&lt;=n;i++){
				dx+=(a[i][0]-x)/dis(x,y,i)*w[i];
				dy+=(a[i][1]-y)/dis(x,y,i)*w[i];
			}
			double res=dist(x+dx*T,y+dy*T);
			if(res&lt;ans){
				ans=res;x+=dx*T;y+=dy*T;
			}else{
				double test=pow(2.718281828,(ans-res)/T);
				if(rnd()&lt;test){
					ans=res;x+=dx*T;y+=dy*T;
				}
			}
			T*=0.98;
		}printf("%.3lf %.3lf\n",x,y);
	}
	return 0;
}</pre><pre></pre><h2>Problem3685</h2><pre>#include&lt;bits/stdc++.h&gt;
#define lowsqrt(u) (1&lt;&lt;(M[u]&gt;&gt;1))
#define low(u,x) (x%lowsqrt(u))
#define high(u,x) (x/lowsqrt(u))
#define indx(u,x,y) (x*lowsqrt(u)+y)
using namespace std;
map&lt;int,int&gt;M;
struct vEB{
	struct node{
		int Max,Min,u;
		node *Summ;
		vector&lt;node*&gt;clus;
		void build(int Bitsize){
			if(Bitsize&lt;=1){
				Max=Min=-1;u=2;
				Summ=NULL;return;
			}
			Max=Min=-1;u=1&lt;&lt;Bitsize;
			int Nsize=(Bitsize&gt;&gt;1)+(Bitsize&amp;1);
			Summ=new node();
			Summ-&gt;build(Nsize);
			clus.resize(1&lt;&lt;Nsize);
			for(int i=0;i&lt;(1&lt;&lt;Nsize);i++){
				clus[i]=new node();
				clus[i]-&gt;build(Bitsize&gt;&gt;1);
			}				
		}
	}*root;
	void build(int size){		
		int L=0;for(size--;size;size&gt;&gt;=1,L++);
		root=new node();
		root-&gt;build(L);
	}
	int _Min(node *t){
		return t-&gt;Min;
	}
	int _Max(node *t){
		return t-&gt;Max;
	}
	void _insert(node *t,int x){
		if(t-&gt;Min==-1){
			t-&gt;Min=t-&gt;Max=x;
			return;
		}		
		if(x&lt;t-&gt;Min)swap(x,t-&gt;Min);
		int H=high(t-&gt;u,x),L=low(t-&gt;u,x);
		if(t-&gt;u&gt;2){
			if(_Min(t-&gt;clus[H])==-1){
				_insert(t-&gt;Summ,H);
				t-&gt;clus[H]-&gt;Min=L;
				t-&gt;clus[H]-&gt;Max=L;
			}else _insert(t-&gt;clus[H],L);			
		}
		if(x&gt;t-&gt;Max)t-&gt;Max=x;
	}
	void _del(node *t,int x){
		if(t-&gt;Min==t-&gt;Max){
			t-&gt;Min=t-&gt;Max=-1;
		}else
		if(t-&gt;u==2)
			t-&gt;Max=t-&gt;Min=!x;			
		else{		
			if(x==t-&gt;Min){
				int fclus=_Min(t-&gt;Summ);
				x=indx(t-&gt;u,fclus,_Min(t-&gt;clus[fclus]));
				t-&gt;Min=x;				
			}int H=high(t-&gt;u,x),L=low(t-&gt;u,x);
			_del(t-&gt;clus[H],L);
			if(_Min(t-&gt;clus[H])==-1){
				_del(t-&gt;Summ,H);
				if(x==t-&gt;Max){
					int Smax=_Max(t-&gt;Summ);
					if(Smax==-1)
						t-&gt;Max=t-&gt;Min;
					else
						t-&gt;Max=indx(t-&gt;u,Smax,_Max(t-&gt;clus[Smax]));
				}				
			}else if(x==t-&gt;Max){
				t-&gt;Max=indx(t-&gt;u,H,_Max(t-&gt;clus[H]));
			}
		}
	}
	int _pred(node *t,int x){
		if(t-&gt;u==2){
			if(x==1&amp;&amp;t-&gt;Min==0)return 0;
			else return -1;
		}else if(t-&gt;Max!=-1&amp;&amp;x&gt;t-&gt;Max)return t-&gt;Max;
		else{
			int H=high(t-&gt;u,x),L=low(t-&gt;u,x);
			int minhigh=_Min(t-&gt;clus[H]);
			if(minhigh!=-1&amp;&amp;L&gt;minhigh){
				int offset=_pred(t-&gt;clus[H],L);
				return indx(t-&gt;u,H,offset);
			}else{
				int preclus=_pred(t-&gt;Summ,H);
				if(preclus==-1){
					if(t-&gt;Min!=-1&amp;&amp;x&gt;t-&gt;Min)return t-&gt;Min;
					else return -1;
				}
				else{
					int offset=_Max(t-&gt;clus[preclus]);
					return indx(t-&gt;u,preclus,offset);					
				}
			}
		}
	}
	int _succ(node *t,int x){
		if(t-&gt;u==2){
			if(x==0&amp;&amp;t-&gt;Max==1)return 1;
			else return -1;
		}else if(t-&gt;Min!=-1&amp;&amp;x&lt;t-&gt;Min)return t-&gt;Min;
		else{
			int H=high(t-&gt;u,x),L=low(t-&gt;u,x);
			int maxlow=_Max(t-&gt;clus[H]);
			if(maxlow!=-1&amp;&amp;L&lt;maxlow){
				int offset=_succ(t-&gt;clus[H],L);
				return indx(t-&gt;u,H,offset);
			}else{
				int suclus=_succ(t-&gt;Summ,H);
				if(suclus==-1)return -1;
				else{
					int offset=_Min(t-&gt;clus[suclus]);
					return indx(t-&gt;u,suclus,offset);
				}
			}
		}
	}
	bool _exist(node *t,int x){
		if(x==t-&gt;Min||x==t-&gt;Max)return 1;
		else if(t-&gt;u==2)return 0;
		else return _exist(t-&gt;clus[high(t-&gt;u,x)],low(t-&gt;u,x));
	}
	int Min(){return _Min(root);}
	int Max(){return _Max(root);}
	void insert(int x){_insert(root,x);}
	void del(int x){_del(root,x);}
	int pred(int x){return _pred(root,x);}
	int succ(int x){return _succ(root,x);}
	bool exist(int x){return _exist(root,x);}
}T;
int n,m;
int getint(){
	int res=0;char ch=getchar();
	while(!isdigit(ch))ch=getchar();
	while(isdigit(ch))res=(res&lt;&lt;3)+(res&lt;&lt;1)+ch-'0',ch=getchar();
	return res;
}
void putint(int x){
	if(x&lt;0)putchar('-'),x=-x;
	if(x&lt;10)
		putchar(x+'0');
	else{
		putint(x/10);
		putchar(x%10+'0');
	}
}
int main(){
	for(int i=0;i&lt;32;i++)M[1&lt;&lt;i]=i;
//	freopen("vEB.in","r",stdin);
//	freopen("vEB.out","w",stdout);
	 n=getint();m=getint();
	 T.build(n);int x;
//	 cerr&lt;&lt;(double)clock()/CLOCKS_PER_SEC&lt;&lt;endl;
	 while(m--){
	 	//if(m%1000==0)cerr&lt;&lt;m&lt;&lt;endl;
	 	int op=getint();
	 	switch(op){
			case 1:{
				x=getint();
				if(!T.exist(x))
				T.insert(x);
				break;
			}
			case 2:{
				x=getint();
				if(T.exist(x)) 
				T.del(x);
				break;
			}
			case 3:{
				putint(T.Min());puts("");
				break;
			}
			case 4:{
				putint(T.Max());puts("");
				break;
			}
			case 5:{
				x=getint();
				putint(T.pred(x));puts("");
				break;
			}
			case 6:{
				x=getint();
				putint(T.succ(x));puts("");
				break;
			}
			case 7:{
				x=getint();
				if(T.exist(x))puts("1");
				else puts("-1");
				break;
			}
		}
	 }	
//	 cerr&lt;&lt;(double)clock()/CLOCKS_PER_SEC&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem3687</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
bitset&lt;2000001&gt;bt;
int main(){
	int ans=0,n,x,sum=0;scanf("%d",&amp;n);
	bt[0]=1;
	for(int i=1;i&lt;=n;i++){
		scanf("%d",&amp;x);sum+=x;
		bt=bt^(bt&lt;&lt;x);
	}for(int i=1;i&lt;=sum;i++)ans^=bt[i]?i:0;
	cout&lt;&lt;ans&lt;&lt;endl;
}</pre><pre></pre><h2>Problem3689</h2><pre>#include&lt;bits/stdc++.h&gt;
#define fst first
#define sec second
using namespace std;
const int maxn=100010;
struct node{
	int size,val;
	node *c[2];
	node(node *C=0){size=val=0;c[0]=c[1]=C;}
}*root[maxn],*Null;
int n,m;
node *insert(node *x,int val,int d,int f){
	node *y=new node(Null);
	*y=*x;y-&gt;size++;
	if(d&lt;0) return y-&gt;val=f,y;
	int v=val&gt;&gt;d&amp;1;
	y-&gt;c[v]=insert(x-&gt;c[v],val,d-1,f);
	return y;
}
typedef pair&lt;int,int&gt; pi;
pi Qmin(node *x,node *y,int val,int d){
	if(d&lt;0) return pi(0,x-&gt;val);
	int v=(val&gt;&gt;d&amp;1);
	if(x-&gt;c[v]-&gt;size&gt;y-&gt;c[v]-&gt;size)
		return Qmin(x-&gt;c[v],y-&gt;c[v],val,d-1);
	else{
		pi res=Qmin(x-&gt;c[!v],y-&gt;c[!v],val,d-1);
		return pi(res.fst+(1&lt;&lt;d),res.sec);		
	}
}
int a[maxn];
struct sta{
	int x,l,r,ps,mn;
	bool operator&lt;(sta o)const{return mn&gt;o.mn;}
};
priority_queue&lt;sta&gt;q;
int main(){
	Null=new node();root[0]=Null;
	Null-&gt;c[0]=Null-&gt;c[1]=Null;
	scanf("%d%d",&amp;n,&amp;m);
	for(int i=1;i&lt;=n;i++){
		scanf("%d",&amp;a[i]);
		root[i]=insert(root[i-1],a[i],30,i);
	}pi x;
	for(int i=1;i&lt;n;i++){
		x=Qmin(root[n],root[i],a[i],30);
		q.push((sta){a[i],i+1,n,x.sec,x.fst});
	}
	while(m--){
		sta u=q.top();q.pop();
		printf("%d ",u.mn);
		if(u.l&lt;=u.ps-1){
			x=Qmin(root[u.ps-1],root[u.l-1],u.x,30);
			q.push((sta){u.x,u.l,u.ps-1,x.sec,x.fst});
		}
		if(u.ps+1&lt;=u.r){
			x=Qmin(root[u.r],root[u.ps],u.x,30);
			q.push((sta){u.x,u.ps+1,u.r,x.sec,x.fst});
		}
	}
	return 0;
}</pre><pre></pre><h2>Problem3697</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;cctype&gt;
#include&lt;map&gt;
#include&lt;set&gt;
using namespace std;
typedef long long LL;
const int maxn=1e5+5;
LL ans=0;
int n;
int getint(){
	int res=0;char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))res=res*10+c-'0',c=getchar();
	return res;
}
struct edge{int u,v,w;};
vector&lt;edge&gt;G[maxn];
int siz[maxn],f[maxn],dep[maxn],cant[maxn],root,All,d[maxn];
map&lt;int,int&gt;M,mp,MA,data,data2;
void makert(int u,int fa){
	siz[u]=1;f[u]=0;
	for(int i=0;i&lt;G[u].size();i++){
		edge e=G[u][i];
		if(e.v!=fa&amp;&amp;!cant[e.v]){
			dep[e.v]=dep[u]+1;
			makert(e.v,u);
			siz[u]+=siz[e.v];
			f[u]=max(f[u],siz[e.v]);
		}
	}f[u]=max(f[u],All-f[u]);
	if(f[root]&gt;f[u])root=u;
}
void dfs(int u,int fa){
	data[d[u]]++;
	for(int i=0;i&lt;G[u].size();i++){
		edge e=G[u][i];
		if(e.v==fa||cant[e.v])continue;
		d[e.v]=d[u]+e.w;
		if(M.count(d[e.v])){
			data2[d[e.v]]++;
//			cerr&lt;&lt;d[e.v]&lt;&lt;endl;
		}
		M[d[e.v]]++;
		dfs(e.v,u);
		if(!--M[d[e.v]])M.erase(d[e.v]);
	}
}
typedef map&lt;int,int&gt;::iterator iter;
void deb(map&lt;int,int&gt;M){
	puts("");
	for(iter it=M.begin();it!=M.end();it++)if(it-&gt;second)
	cout&lt;&lt;it-&gt;first&lt;&lt;" "&lt;&lt;it-&gt;second&lt;&lt;endl;
	
}
void calc(int u){
	LL res=0;MA.clear();mp.clear();d[u]=0;
	for(int i=0;i&lt;G[u].size();i++){
		edge e=G[u][i];
		if(cant[e.v])continue;
		d[e.v]=e.w;M[e.w]++;data.clear();data2.clear();
		dfs(e.v,u);M.erase(e.w);
//		deb(MA);
//		deb(mp);
//		deb(data);
//		deb(data2);
		for(iter it=data.begin();it!=data.end();it++){
			LL num=it-&gt;first,cant=it-&gt;second-data2[it-&gt;first],can=data2[it-&gt;first];
			if(!num){
				res+=it-&gt;second*MA[0];
			}else{
				res+=can*MA[-num];
				res+=cant*mp[-num];				
			}
		}
		for(iter it=data.begin();it!=data.end();it++)MA[it-&gt;first]+=it-&gt;second;
		for(iter it=data2.begin();it!=data2.end();it++)mp[it-&gt;first]+=it-&gt;second;
	}ans+=res;ans+=mp[0];
}
void solve(int u){
	calc(u);cant[u]=1;
	for(int i=0;i&lt;G[u].size();i++){
		edge e=G[u][i];
		if(cant[e.v])continue;
		All=siz[e.v];
		f[root=0]=n+1;
		makert(e.v,0);
		solve(root);
	}
}
int main(){
	n=getint();All=n;
	for(int i=1;i&lt;n;i++){
		int u=getint(),v=getint(),w=getint();
		G[u].push_back((edge){u,v,w?w:-1});
		G[v].push_back((edge){v,u,w?w:-1});
	}f[root=0]=n+1;
	makert(1,1);
	solve(root);
	cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem3698</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=233;
int s,t;
struct edge{int u,v,ca,fl,co;};
vector&lt;edge&gt;E;
vector&lt;int&gt;G[maxn];
void add(int u,int v,int ca,int co){
	E.push_back((edge){u,v,ca,0,co});
	G[u].push_back(E.size()-1);
	E.push_back((edge){v,u,0,0,-co});
	G[v].push_back(E.size()-1);
}
int cost,flow=0;
bool spfa(){
	static int vis[maxn],d[maxn],a[maxn],pre[maxn];
	memset(d,0x7f,sizeof d);int B=d[0];a[s]=INT_MAX;
	queue&lt;int&gt;q;q.push(s);vis[s]=1;d[s]=0;	
	while(!q.empty()){
		int u=q.front();q.pop();vis[u]=0;
		for(int i=0;i&lt;G[u].size();i++){
			edge e=E[G[u][i]];
			if(e.ca==e.fl||d[e.v]&lt;=d[u]+e.co)continue;
			a[e.v]=min(e.ca-e.fl,a[u]);pre[e.v]=G[u][i];
			d[e.v]=d[u]+e.co;if(!vis[e.v])q.push(e.v),vis[e.v]=1;
		}	
	}
	if(d[t]==B)return false;
	flow+=a[t];
	cost+=a[t]*d[t];
	int u=t;
	while(u!=s){
		E[pre[u]].fl+=a[t];
		E[pre[u]^1].fl-=a[t];
		u=E[pre[u]].u;
	}return true;
}
int n;
double a[101][101];
int main(){
	scanf("%d",&amp;n);
	for(int i=1;i&lt;=n;i++)
	for(int j=1;j&lt;=n;j++)scanf("%lf",&amp;a[i][j]);
	s=0;t=n*2+1;
	int sum=0,tmp;
	for(int i=1;i&lt;=n;i++)for(int j=1;j&lt;=n;j++)sum+=int(a[i][j]);
	for(int i=1;i&lt;n;i++)
	for(int j=1;j&lt;n;j++){
		tmp=(int)a[i][j];a[i][j]-=tmp;
		a[i][n]-=tmp;a[n][j]-=tmp;
		if(a[i][j]&gt;0)add(i,j+n,1,1);
	}
	for(int i=1;i&lt;n;i++){
		tmp=(int)a[i][n];add(s,i,tmp,0);
		if(tmp!=a[i][n])add(s,i,1,1);
		tmp=(int)a[n][i];add(i+n,t,tmp,0);
		if(tmp!=a[n][i])add(i+n,t,1,1);
	}
	while(spfa());
	cout&lt;&lt;cost+sum&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem3702</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=4e5+5;
struct node{  
    int val,key,size,s;  
    node *c[2];  
    node(int _val=0,node *C=0){  
        val=_val;key=rand();  
        size=s=1;c[0]=c[1]=C;  
    }void rz(){  
        size=c[0]-&gt;size+s+c[1]-&gt;size;  
    }  
};
struct Treap{  
    node *root,*Null;  
    Treap(){  
        Null=new node(0,0);  
        Null-&gt;size=Null-&gt;s=0;Null-&gt;key=INT_MAX;  
        Null-&gt;c[0]=Null-&gt;c[1]=Null;root=Null;  
    }  
    void rot(node *&amp;t,bool d){  
        node *p=t-&gt;c[d];t-&gt;c[d]=p-&gt;c[!d];  
        p-&gt;c[!d]=t;t-&gt;rz();p-&gt;rz();t=p;  
    }  
    void _insert(node *&amp;t,int x){  
        if(t==Null){t=new node(x,Null);return;}  
        if(t-&gt;val==x){t-&gt;s++;t-&gt;size++;return;}  
        _insert(t-&gt;c[x&gt;t-&gt;val],x);  
        if(t-&gt;c[x&gt;t-&gt;val]-&gt;key&lt;t-&gt;key)  
        rot(t,x&gt;t-&gt;val);else t-&gt;rz();  
    }  
    int _kth(node *t,int x){  
        int r=t-&gt;c[0]-&gt;size;  
        if(x&lt;=r)return _kth(t-&gt;c[0],x);  
        else if(x&gt;r+t-&gt;s) return _kth(t-&gt;c[1],x-r-t-&gt;s);  
        return t-&gt;val;  
    }  
    int _rank(node *t,int x){  
    	if(t==Null)return 0;
        int r=t-&gt;c[0]-&gt;size;  
        if(x&lt;t-&gt;val)return _rank(t-&gt;c[0],x);  
        else if(x&gt;t-&gt;val)return _rank(t-&gt;c[1],x)+r+t-&gt;s;  
        return r;  
    }  
    void erase(node *t){
    	if(t-&gt;c[0]!=Null)erase(t-&gt;c[0]);
    	if(t-&gt;c[1]!=Null)erase(t-&gt;c[1]);
    	delete t;
    }
    void clear(){erase(root);}
    void insert(int x){_insert(root,x);}  
    int kth(int x){return _kth(root,x);}  
    int rank(int x){return _rank(root,x);}    
    int size(){return root-&gt;size;}
}T[maxn];  
typedef long long LL;
int n;
LL cnt[maxn],ans;
int tot=1;
int getint(){
	int res=0;char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))res=res*10+c-'0',c=getchar();
	return res;
}
void dfs(int u){
	int x=getint();
	if(!x){
		int l=++tot,r=++tot;
		dfs(l);
		dfs(r);
		if(T[l].size()&lt;T[r].size())swap(l,r);
		LL res=0;
		for(int i=1;i&lt;=T[r].size();i++)
			res+=T[l].rank(T[r].kth(i));
		ans+=min(res,(LL)T[l].size()*T[r].size()-res);
		for(int i=1;i&lt;=T[r].size();i++){
			int k=T[r].kth(i);
			T[l].insert(k);
		}T[u]=T[l];
	}else T[u].insert(x);	
}
int main(){
	scanf("%d",&amp;n);
	dfs(1);
	cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem3707</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
int n,sqrtn,bel[1010],cnt,L[55],R[55];
struct point{
	double x,y;
	point(double _x=0,double _y=0):x(_x),y(_y){}
	double operator*(point o){return x*o.y-y*o.x;}
	bool operator&lt;(point o)const{return x&lt;o.x;}
	point operator-(point o){return point(x-o.x,y-o.y);}
}p[1010];
point rot(point p,double rad){return point(p.x*cos(rad)-p.y*sin(rad),p.x*sin(rad)+p.y*cos(rad));}
double ans=1e100;
void calc(int l,int r){
	for(int i=l;i&lt;=r;i++)
	for(int j=i+1;j&lt;=r;j++)
	for(int k=j+1;k&lt;=r;k++)
	ans=min(ans,fabs((p[j]-p[i])*(p[k]-p[i]))/2);
}
void solve(){
	double rad=rand();
	for(int i=1;i&lt;=n;i++)p[i]=rot(p[i],rad);
	sort(p+1,p+1+n);
	for(int i=0;i&lt;cnt;i++)
	calc(L[i],R[i]);
}
int main(){
	scanf("%d",&amp;n);sqrtn=50;cnt=n/sqrtn+(!!n%sqrtn);
	for(int i=1;i&lt;=n;i++){
		bel[i]=i/sqrtn;
		if(bel[i]!=bel[i-1])
		R[bel[i-1]]=i-1,L[bel[i]]=i;
	}L[0]=1;R[cnt-1]=n;
	for(int i=1;i&lt;=n;i++){
		scanf("%lf%lf",&amp;p[i].x,&amp;p[i].y);
	}for(int i=1;i&lt;=100;i++)solve();
	printf("%.2lf\n",ans);	
	return 0;
}</pre><pre></pre><h2>Problem3709</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1e5+10;
int n;
long long HP;
int a[maxn],d[maxn],anss[maxn];
bool cmp(int i,int j){
	return d[i]&lt;d[j];
}
bool grcmp(int i,int j){
	return a[i]&gt;a[j];
}
int main(){
	cin&gt;&gt;n&gt;&gt;HP;
	for(int i=1;i&lt;=n;i++){
		cin&gt;&gt;d[i]&gt;&gt;a[i];
		if(d[i]-a[i]&lt;=0)anss[++anss[0]]=i;
	}sort(anss+1,anss+1+anss[0],cmp);
	for(int i=1;i&lt;=anss[0];i++){
		HP-=d[anss[i]];d[anss[i]]=-1;
		if(HP&lt;=0){puts("NIE");return 0;}
		HP+=a[anss[i]];a[anss[i]]=-1;
	}int size=anss[0];
	for(int i=1;i&lt;=n;i++)if(~d[i])
	anss[++size]=i;
	sort(anss+anss[0]+1,anss+1+n,grcmp);
	for(int i=anss[0]+1;i&lt;=n;i++)HP-=d[anss[i]],HP+=a[anss[i]];
	if(HP&lt;=0){puts("NIE");return 0;}
	for(int i=n;i&gt;=anss[0]+1;i--){
		HP-=a[anss[i]];
		if(HP&lt;=0){puts("NIE");return 0;}		
		HP+=d[anss[i]];
	}puts("TAK");
	for(int i=1;i&lt;=n;i++)
	printf("%d ",anss[i]);
	return 0;
} </pre><pre></pre><h2>Problem3709</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1e5+10;
int n;
long long HP;
int a[maxn],d[maxn],anss[maxn];
bool cmp(int i,int j){
	return d[i]&lt;d[j];
}
bool grcmp(int i,int j){
	return a[i]&gt;a[j];
}
int getint(){
	int res=0;char ch=getchar();
	while(!isdigit(ch))ch=getchar();
	while(isdigit(ch))res=(res&lt;&lt;3)+(res&lt;&lt;1)+ch-'0',ch=getchar();
	return res;
}
int main(){
	n=getint();HP=getint();
	for(int i=1;i&lt;=n;i++){
		d[i]=getint();a[i]=getint();
		if(d[i]-a[i]&lt;=0)anss[++anss[0]]=i;
	}sort(anss+1,anss+1+anss[0],cmp);
	for(int i=1;i&lt;=anss[0];i++){
		HP-=d[anss[i]];d[anss[i]]=-1;
		if(HP&lt;=0){puts("NIE");return 0;}
		HP+=a[anss[i]];a[anss[i]]=-1;
	}int size=anss[0];
	for(int i=1;i&lt;=n;i++)if(~d[i])
	anss[++size]=i;
	sort(anss+anss[0]+1,anss+1+n,grcmp);
	for(int i=anss[0]+1;i&lt;=n;i++)HP-=d[anss[i]],HP+=a[anss[i]];
	if(HP&lt;=0){puts("NIE");return 0;}
	for(int i=n;i&gt;=anss[0]+1;i--){
		HP-=a[anss[i]];
		if(HP&lt;=0){puts("NIE");return 0;}		
		HP+=d[anss[i]];
	}puts("TAK");
	for(int i=1;i&lt;=n;i++)
	printf("%d ",anss[i]);
	return 0;
} </pre><pre></pre><h2>Problem3712</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
using namespace std;
inline void in(int &amp;x){
	char c=getchar();
	x=0;
	while(c&lt;'0'||c&gt;'9')c=getchar();
	for(;c&gt;='0'&amp;&amp;c&lt;='9';c=getchar())x=x*10+c-'0';
}
int g[200005];
#include&lt;vector&gt;
vector&lt;int&gt; son[200005];
bool p[200005];
struct NS{
	int ano,i;
};
vector&lt;NS&gt; nodeq[200005];
int lca[500005],bson[500005],fa[200005],wson[200005],wsn[200005];
int find(int x){
	if(fa[x]!=fa[fa[x]]){
		int ftr=fa[x];
		fa[x]=find(fa[x]);
		wson[x]=wson[ftr];
	}
	return fa[x];
}
void tarjan(int node,int ftr){
	fa[node]=node;
	for(int i=0,sz=son[node].size();i&lt;sz;++i){
		wsn[node]=i;
		tarjan(son[node][i],node);
		wson[son[node][i]]=i;
	}
	for(int i=0,sz=nodeq[node].size();i&lt;sz;++i)
		if(p[nodeq[node][i].ano]){
			lca[nodeq[node][i].i]=find(nodeq[node][i].ano);
			if(lca[nodeq[node][i].i]==node)bson[nodeq[node][i].i]=wson[nodeq[node][i].ano];
			else bson[nodeq[node][i].i]=wsn[lca[nodeq[node][i].i]];
		}
	p[node]=1;
	fa[node]=ftr;
}

int a[500005],b[500005];
vector&lt;int&gt; ptr[200005];
int next[500005],succ[500005];
long long ans;
void dfs(int node){
	int tmp;
	for(int i=0,sz=son[node].size(),j;i&lt;sz;++i){
		dfs(son[node][i]);
		for(j=ptr[node][i];j;j=next[j]){
			tmp=min(g[a[succ[j]]],g[b[succ[j]]]);
			g[a[succ[j]]]-=tmp,g[b[succ[j]]]-=tmp;
			ans+=tmp&lt;&lt;1;
			//if(tmp)cout&lt;&lt;"Get("&lt;&lt;a[succ[j]]&lt;&lt;","&lt;&lt;b[succ[j]]&lt;&lt;") at "&lt;&lt;node&lt;&lt;"="&lt;&lt;tmp&lt;&lt;endl;
		}
	}
}
int main(){
	int n,m,k;
	in(n),in(m),in(k);
	for(int i=1;i&lt;=n;++i)in(g[i]);
	while(m--){
		in(a[m]),in(b[m]);
		son[b[m]].push_back(a[m]);
		ptr[b[m]].push_back(0);
		p[a[m]]=1;
	}
	for(int i=n;i;--i)
		if(!p[i]){
			son[0].push_back(i);
			ptr[0].push_back(0);
		}
	for(int i=0;i&lt;k;++i){
		in(a[i]),in(b[i]);
		nodeq[a[i]].push_back((NS){b[i],i});
		nodeq[b[i]].push_back((NS){a[i],i});
	}
	memset(p,0,sizeof(p));
	for(int i=son[0].size();i--;)tarjan(son[0][i],0);
	int rtot=1;
	for(int i=k;i--;)
		if(lca[i]){
			next[rtot]=ptr[lca[i]][bson[i]];
			succ[rtot]=i;
			ptr[lca[i]][bson[i]]=rtot++;
		}
	for(int i=son[0].size();i--;)dfs(son[0][i]);
	cout&lt;&lt;ans&lt;&lt;endl;
}</pre><pre></pre><h2>Problem3712</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
using namespace std;
char * c=(char *)malloc(30000000);
inline void in(int &amp;x){
	x=0;
	while(*c&lt;'0'||*c&gt;'9')++c;
	while(*c&gt;='0'&amp;&amp;*c&lt;='9')x=x*10+(*c++^'0');
}
int g[200005];
#include&lt;vector&gt;
vector&lt;int&gt; son[200005];
bool p[200005];
struct NS{
	int ano,i;
};
vector&lt;NS&gt; nodeq[200005];
int lca[500005],bson[500005],fa[200005],wson[200005],wsn[200005];
int find(int x){
	if(fa[x]!=fa[fa[x]]){
		int ftr=fa[x];
		fa[x]=find(fa[x]);
		wson[x]=wson[ftr];
	}
	return fa[x];
}
void tarjan(int node,int ftr){
	fa[node]=node;
	for(int i=0,sz=son[node].size();i&lt;sz;++i){
		wsn[node]=i;
		tarjan(son[node][i],node);
		wson[son[node][i]]=i;
	}
	for(int i=0,sz=nodeq[node].size();i&lt;sz;++i)
		if(p[nodeq[node][i].ano]){
			lca[nodeq[node][i].i]=find(nodeq[node][i].ano);
			if(lca[nodeq[node][i].i]==node)bson[nodeq[node][i].i]=wson[nodeq[node][i].ano];
			else bson[nodeq[node][i].i]=wsn[lca[nodeq[node][i].i]];
		}
	p[node]=1;
	fa[node]=ftr;
}

int a[500005],b[500005];
vector&lt;int&gt; ptr[200005];
int next[500005],succ[500005];
long long ans;
void dfs(int node){
	int tmp;
	for(int i=0,sz=son[node].size(),j;i&lt;sz;++i){
		dfs(son[node][i]);
		for(j=ptr[node][i];j;j=next[j]){
			tmp=min(g[a[succ[j]]],g[b[succ[j]]]);
			g[a[succ[j]]]-=tmp,g[b[succ[j]]]-=tmp;
			ans+=tmp&lt;&lt;1;
			//if(tmp)cout&lt;&lt;"Get("&lt;&lt;a[succ[j]]&lt;&lt;","&lt;&lt;b[succ[j]]&lt;&lt;") at "&lt;&lt;node&lt;&lt;"="&lt;&lt;tmp&lt;&lt;endl;
		}
	}
}
int main(){
	int n,m,k;
	fread(c,1,30000000,stdin);
	in(n),in(m),in(k);
	for(int i=1;i&lt;=n;++i)in(g[i]);
	while(m--){
		in(a[m]),in(b[m]);
		son[b[m]].push_back(a[m]);
		ptr[b[m]].push_back(0);
		p[a[m]]=1;
	}
	for(int i=n;i;--i)
		if(!p[i]){
			son[0].push_back(i);
			ptr[0].push_back(0);
		}
	for(int i=0;i&lt;k;++i){
		in(a[i]),in(b[i]);
		nodeq[a[i]].push_back((NS){b[i],i});
		nodeq[b[i]].push_back((NS){a[i],i});
	}
	memset(p,0,sizeof(p));
	for(int i=son[0].size();i--;)tarjan(son[0][i],0);
	int rtot=1;
	for(int i=k;i--;)
		if(lca[i]){
			next[rtot]=ptr[lca[i]][bson[i]];
			succ[rtot]=i;
			ptr[lca[i]][bson[i]]=rtot++;
		}
	for(int i=son[0].size();i--;)dfs(son[0][i]);
	printf("%lld\n",ans);
}</pre><pre></pre><h2>Problem3712</h2><pre>#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
using namespace std;
char * c=(char *)malloc(30000000);
inline void in(int &amp;x){
    x=0;
    while(*c&lt;'0'||*c&gt;'9')++c;
    while(*c&gt;='0'&amp;&amp;*c&lt;='9')x=x*10+(*c++^'0');
}
int g[200005];
#include&lt;vector&gt;
int sonptr[200005],sonsize[200005],sonnext[200005],sonsucc[200005];
bool p[200005];
int qptr[200005],qnext[1000005],ab[1000005];
int lca[500005],bson[500005],fa[200005],wson[200005],wsn[200005];
int find(int x){
    if(fa[x]!=fa[fa[x]]){
        int ftr=fa[x];
        fa[x]=find(fa[x]);
        wson[x]=wson[ftr];
    }
    return fa[x];
}
void tarjan(int node,int ftr){
    fa[node]=node;
    for(int i=sonptr[node],j=0;i;i=sonnext[i],++j){
        wsn[node]=j;
        tarjan(sonsucc[i],node);
        wson[sonsucc[i]]=j;
    }
    for(int i=qptr[node];i;i=qnext[i])
        if(p[node^ab[i]]){
            lca[i-1&gt;&gt;1]=find(node^ab[i]);
            if(lca[i-1&gt;&gt;1]==node)bson[i-1&gt;&gt;1]=wson[node^ab[i]];
            else bson[i-1&gt;&gt;1]=wsn[lca[i-1&gt;&gt;1]];
        }
    p[node]=1;
    fa[node]=ftr;
}
 
int a[500005],b[500005];
int ptr[200005],sons[200005];
int next[500005],succ[500005];
long long ans;
void dfs(int node){
    int tmp;
    for(int i=sonptr[node],k=0,j;i;i=sonnext[i],++k){
        dfs(sonsucc[i]);
        for(j=ptr[sons[node]+k];j;j=next[j]){
            tmp=min(g[a[succ[j]]],g[b[succ[j]]]);
            g[a[succ[j]]]-=tmp,g[b[succ[j]]]-=tmp;
            ans+=tmp&lt;&lt;1;
            //if(tmp)cout&lt;&lt;"Get("&lt;&lt;a[succ[j]]&lt;&lt;","&lt;&lt;b[succ[j]]&lt;&lt;") at "&lt;&lt;node&lt;&lt;"="&lt;&lt;tmp&lt;&lt;endl;
        }
    }
}
int main(){
    int n,m,k;
    fread(c,1,30000000,stdin);
    in(n),in(m),in(k);
    for(int i=1;i&lt;=n;++i)in(g[i]);
    int stot=1,rtot=1,qtot=1;
    for(int i=0;i&lt;m;++i)in(a[i]),in(b[i]);
    for(int i=m;i--;){
        ++sonsize[b[i]];
        sonnext[stot]=sonptr[b[i]];
        sonptr[b[i]]=stot;
        sonsucc[stot++]=a[i];
        p[a[i]]=1;
    }
    for(int i=n;i;--i)
        if(!p[i]){
            ++sonsize[0];
            sonnext[stot]=sonptr[0];
            sonptr[0]=stot;
            sonsucc[stot++]=i;
        }
    for(int i=0;i&lt;k;++i){
        in(a[i]),in(b[i]);
        qnext[qtot]=qptr[a[i]];
        qptr[a[i]]=qtot;
        ab[qtot++]=a[i]^b[i];
        
        qnext[qtot]=qptr[b[i]];
        qptr[b[i]]=qtot;
        ab[qtot++]=a[i]^b[i];
    }
    memset(p,0,sizeof(p));
    for(int i=sonptr[0];i;i=sonnext[i])tarjan(sonsucc[i],0);
    sons[1]=1;
    for(int i=2;i&lt;=n;++i)sons[i]=sons[i-1]+sonsize[i-1];
    for(int i=k;i--;)
        if(lca[i]){
            next[rtot]=ptr[sons[lca[i]]+bson[i]];
            succ[rtot]=i;
            ptr[sons[lca[i]]+bson[i]]=rtot++;
            //cout&lt;&lt;a[i]&lt;&lt;","&lt;&lt;b[i]&lt;&lt;":"&lt;&lt;lca[i]&lt;&lt;" "&lt;&lt;bson[i]&lt;&lt;endl;
        }
    for(int i=sonptr[0];i;i=sonnext[i])dfs(sonsucc[i]);
    printf("%lld\n",ans);
}</pre><pre></pre><h2>Problem3713</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
int f[2333];
int T,n=2;
map&lt;int,int&gt;M;
int main(){
	f[1]=f[2]=1;M[1]=1;
	for(int i=3;;i++){
		f[i]=f[i-1]+f[i-2];
		if(f[i]&lt;=int(1e9))n++,M[f[i]]=1;
		else break;
	}cin&gt;&gt;T;
	while(T--){
		int x,ok=0;
		cin&gt;&gt;x;if(x==0){puts("TAK");continue;}
		for(int i=2;i&lt;=n;i++)
		if(x%f[i]==0&amp;&amp;M[x/f[i]]){
			puts("TAK");ok=1;break;
		}if(!ok)puts("NIE");		
	}
	return 0;
}</pre><pre></pre><h2>Problem3714</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=2e3+10;
struct edge{
	int u,v,w;
	bool operator&lt;(const edge &amp;E)const{
		return w&lt;E.w;
	}
}edges[maxn*maxn];
int fa[maxn];
int find(int x){
	if(fa[x]!=x)return fa[x]=find(fa[x]);
	return x;
}
int n,m;
int main(){
	scanf("%d",&amp;n);
	for(int i=1;i&lt;=n;i++)fa[i]=i;
	for(int i=1;i&lt;=n;i++){
		for(int j=i;j&lt;=n;j++){
			int x;
			scanf("%d",&amp;x);
			edges[++m]=(edge){i-1,j,x};
		}
	}sort(edges+1,edges+1+m);
	long long ans=0;
	for(int i=1;i&lt;=m;i++){
		int u=edges[i].u,v=edges[i].v;
		if(find(u)!=find(v)){
			fa[find(u)]=find(v);
			ans+=edges[i].w;
		} 
	}cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}
</pre><pre></pre><h2>Problem3715</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1e5+10;
int a[maxn],b[maxn],c[maxn],d[maxn];
int getint(){
	int res=0;char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))res=(res&lt;&lt;1)+(res&lt;&lt;3)+c-'0',c=getchar();
	return res;
}
int T,n;
int main(){
	T=getint();
	while(T--){
		n=getint();
		for(int i=1;i&lt;=n;i++)
		a[i]=getint(),b[i]=getint(),
		c[i]=getint(),d[i]=getint();
		int A=*min_element(a+1,a+1+n);
		int B=*max_element(b+1,b+1+n);
		int C=*min_element(c+1,c+1+n);
		int D=*max_element(d+1,d+1+n);
		int ok=0;
		for(int i=1;i&lt;=n;i++){
			if(a[i]==A&amp;&amp;b[i]==B&amp;&amp;c[i]==C&amp;&amp;d[i]==D){
				puts("TAK");ok=1;break;
			}
		}if(!ok)puts("NIE");
	} 
	return 0;
}</pre><pre></pre><h2>Problem3720</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=60010;
int sqrtn,siz[maxn],dep[maxn],bel[maxn],cnt,fa[maxn],n,lastans,w[maxn],mp[maxn],Bfa[maxn],m;
vector&lt;int&gt;G[maxn],Ge[maxn];
vector&lt;int&gt;block[maxn];
int ind[maxn],vis[maxn];
void dfs(int u){
	for(int i=0;i&lt;G[u].size();i++){
		int v=G[u][i];
		if(v==fa[u])continue;
		fa[v]=u;dep[v]=dep[u]+1;
		if(siz[bel[u]]&lt;sqrtn)
			siz[bel[v]=bel[u]]++;
		else
			Ge[bel[u]].push_back(bel[v]),
			Ge[bel[v]].push_back(bel[u]);
		dfs(v);
	}
}
int op0(int u,int x){
	int ans=0;
	if(bel[u]==u){
		ans+=block[u].end()-upper_bound(block[u].begin(),block[u].end(),x);
		for(int i=0;i&lt;Ge[u].size();i++){
			int v=Ge[u][i]; 
			if(dep[v]&gt;dep[u]){
				ans+=op0(Ge[u][i],x);
			}
		}return ans;
	}else{
		ans+=w[u]&gt;x;
		for(int i=0;i&lt;G[u].size();i++){
			int v=G[u][i];
			if(v==fa[u])continue;
			ans+=op0(v,x);
		}return ans;
	}
}
void op1(int u,int x){
	int pos=lower_bound(block[bel[u]].begin(),block[bel[u]].end(),w[u])-block[bel[u]].begin();
	block[bel[u]][pos]=x;
	w[u]=x;
	sort(block[bel[u]].begin(),block[bel[u]].end());
}
void op2(int u,int x){
	fa[++n]=u;
	w[n]=x;
	dep[n]=dep[u]+1;
	G[u].push_back(n);
	G[n].push_back(u);
	block[bel[n]=bel[u]].push_back(x);
	sort(block[bel[u]].begin(),block[bel[u]].end());
}
int main(){
	scanf("%d",&amp;n);sqrtn=sqrt(n);
	for(int i=1;i&lt;n;i++){
		int u,v;scanf("%d%d",&amp;u,&amp;v);
		G[u].push_back(v);G[v].push_back(u);
	}for(int i=1;i&lt;=n;i++)bel[i]=i,siz[i]=1,scanf("%d",&amp;w[i]);
	dfs(1);	
	for(int i=1;i&lt;=n;i++){
		block[bel[i]].push_back(w[i]);		
		if(!vis[bel[i]])vis[bel[i]]=1,ind[++ind[0]]=bel[i];
	}for(int i=1;i&lt;=ind[0];i++)sort(block[ind[i]].begin(),block[ind[i]].end());

	
//	for(int i=1;i&lt;=ind[0];i++)
//	for(int j=0;j&lt;block[ind[i]].size();j++)
//	printf("%d%c",block[ind[i]][j]," \n"[j==block[ind[i]].size()-1]);


	scanf("%d",&amp;m);
	while(m--){
		int op;scanf("%d",&amp;op);
		int u,x;scanf("%d%d",&amp;u,&amp;x);
//		!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		u^=lastans;x^=lastans;
//		!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		if(op==0){
			printf("%d\n",(lastans=op0(u,x)));	
		}else 
		if(op==1){
			op1(u,x);
		}else
		if(op==2){
			op2(u,x);
		}
	}
	return 0;
}</pre><pre></pre><h2>Problem3720</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=60010;
int sqrtn,siz[maxn],dep[maxn],bel[maxn],cnt,fa[maxn],n,lastans,w[maxn],mp[maxn],Bfa[maxn],m;
vector&lt;int&gt;G[maxn],Ge[maxn];
vector&lt;int&gt;block[maxn];
int ind[maxn],vis[maxn];
void dfs(int u){
    for(int i=0;i&lt;G[u].size();i++){
        int v=G[u][i];
        if(v==fa[u])continue;
        fa[v]=u;dep[v]=dep[u]+1;
        if(siz[bel[u]]&lt;sqrtn)
            siz[bel[v]=bel[u]]++;
        else
            Ge[bel[u]].push_back(bel[v]),
            Ge[bel[v]].push_back(bel[u]);
        dfs(v);
    }
}
int op0(int u,int x){
    int ans=0;
    if(bel[u]==u){
        ans+=block[u].end()-upper_bound(block[u].begin(),block[u].end(),x);
        for(int i=0;i&lt;Ge[u].size();i++){
            int v=Ge[u][i]; 
            if(dep[v]&gt;dep[u]){
                ans+=op0(Ge[u][i],x);
            }
        }return ans;
    }else{
        ans+=w[u]&gt;x;
        for(int i=0;i&lt;G[u].size();i++){
            int v=G[u][i];
            if(v==fa[u])continue;
            ans+=op0(v,x);
        }return ans;
    }
}
void op1(int u,int x){
    int pos=lower_bound(block[bel[u]].begin(),block[bel[u]].end(),w[u])-block[bel[u]].begin();
    block[bel[u]][pos]=x;
    w[u]=x;
    sort(block[bel[u]].begin(),block[bel[u]].end());
}
void op2(int u,int x){
    fa[++n]=u;
    w[n]=x;
    dep[n]=dep[u]+1;
    G[u].push_back(n);
    G[n].push_back(u);
    block[bel[n]=bel[u]].push_back(x);
    sort(block[bel[u]].begin(),block[bel[u]].end());
}
int main(){
    scanf("%d",&amp;n);sqrtn=233;
    for(int i=1;i&lt;n;i++){
        int u,v;scanf("%d%d",&amp;u,&amp;v);
        G[u].push_back(v);G[v].push_back(u);
    }for(int i=1;i&lt;=n;i++)bel[i]=i,siz[i]=1,scanf("%d",&amp;w[i]);
    dfs(1); 
    for(int i=1;i&lt;=n;i++){
        block[bel[i]].push_back(w[i]);      
        if(!vis[bel[i]])vis[bel[i]]=1,ind[++ind[0]]=bel[i];
    }for(int i=1;i&lt;=ind[0];i++)sort(block[ind[i]].begin(),block[ind[i]].end());
    scanf("%d",&amp;m);
    while(m--){
        int op;scanf("%d",&amp;op);
        int u,x;scanf("%d%d",&amp;u,&amp;x);
        u^=lastans;x^=lastans;
        if(op==0){
            printf("%d\n",(lastans=op0(u,x)));  
        }else
        if(op==1){
            op1(u,x);
        }else
        if(op==2){
            op2(u,x);
        }
    }
    return 0;
}</pre><pre></pre><h2>Problem3720</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=60010;
int sqrtn,siz[maxn],dep[maxn],bel[maxn],cnt,fa[maxn],n,lastans,w[maxn],mp[maxn],Bfa[maxn],m;
vector&lt;int&gt;G[maxn],Ge[maxn];
vector&lt;int&gt;block[maxn];
int ind[maxn],vis[maxn];
void dfs(int u){
    for(int i=0;i&lt;G[u].size();i++){
        int v=G[u][i];
        if(v==fa[u])continue;
        fa[v]=u;dep[v]=dep[u]+1;
        if(siz[bel[u]]&lt;sqrtn)
            siz[bel[v]=bel[u]]++;
        else
            Ge[bel[u]].push_back(bel[v]),
            Ge[bel[v]].push_back(bel[u]);
        dfs(v);
    }
}
int op0(int u,int x){
    int ans=0;
    if(bel[u]==u){
        ans+=block[u].end()-upper_bound(block[u].begin(),block[u].end(),x);
        for(int i=0;i&lt;Ge[u].size();i++){
            int v=Ge[u][i]; 
            if(dep[v]&gt;dep[u]){
                ans+=op0(Ge[u][i],x);
            }
        }return ans;
    }else{
        ans+=w[u]&gt;x;
        for(int i=0;i&lt;G[u].size();i++){
            int v=G[u][i];
            if(v==fa[u])continue;
            ans+=op0(v,x);
        }return ans;
    }
}
void op1(int u,int x){
    int pos=lower_bound(block[bel[u]].begin(),block[bel[u]].end(),w[u])-block[bel[u]].begin();
    block[bel[u]][pos]=x;
    w[u]=x;
    sort(block[bel[u]].begin(),block[bel[u]].end());
}
void op2(int u,int x){
    fa[++n]=u;
    w[n]=x;
    dep[n]=dep[u]+1;
    G[u].push_back(n);
    G[n].push_back(u);
	if(siz[bel[u]]&lt;sqrtn){
	    block[bel[n]=bel[u]].push_back(x);
	    sort(block[bel[u]].begin(),block[bel[u]].end());   	
    }else{
    	block[bel[n]=n].push_back(x);
    	siz[bel[n]]++;
        Ge[bel[u]].push_back(bel[n]),
        Ge[bel[n]].push_back(bel[u]);  	
    }
}
int main(){
    scanf("%d",&amp;n);sqrtn=233;
    for(int i=1;i&lt;n;i++){
        int u,v;scanf("%d%d",&amp;u,&amp;v);
        G[u].push_back(v);G[v].push_back(u);
    }for(int i=1;i&lt;=n;i++)bel[i]=i,siz[i]=1,scanf("%d",&amp;w[i]);
    dfs(1); 
    for(int i=1;i&lt;=n;i++){
        block[bel[i]].push_back(w[i]);      
        if(!vis[bel[i]])vis[bel[i]]=1,ind[++ind[0]]=bel[i];
    }for(int i=1;i&lt;=ind[0];i++)sort(block[ind[i]].begin(),block[ind[i]].end());
    scanf("%d",&amp;m);
    while(m--){
        int op;scanf("%d",&amp;op);
        int u,x;scanf("%d%d",&amp;u,&amp;x);
        u^=lastans;x^=lastans;
        if(op==0){
            printf("%d\n",(lastans=op0(u,x)));  
        }else
        if(op==1){
            op1(u,x);
        }else
        if(op==2){
            op2(u,x);
        }
    }
    return 0;
}</pre><pre></pre><h2>Problem3720</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=60010;
int sqrtn,siz[maxn],dep[maxn],bel[maxn],cnt,fa[maxn],n,lastans,w[maxn],mp[maxn],Bfa[maxn],m;
vector&lt;int&gt;G[maxn],Ge[maxn];
vector&lt;int&gt;block[maxn];
int ind[maxn],vis[maxn];
void dfs(int u){
    for(int i=0;i&lt;G[u].size();i++){
        int v=G[u][i];
        if(v==fa[u])continue;
        fa[v]=u;dep[v]=dep[u]+1;
        if(siz[bel[u]]&lt;sqrtn)
            siz[bel[v]=bel[u]]++;
        else
            Ge[bel[u]].push_back(bel[v]),
            Ge[bel[v]].push_back(bel[u]);
        dfs(v);
    }
}
int op0(int u,int x){
    int ans=0;
    if(bel[u]==u){
        ans+=block[u].end()-upper_bound(block[u].begin(),block[u].end(),x);
        for(int i=0;i&lt;Ge[u].size();i++){
            int v=Ge[u][i]; 
            if(dep[v]&gt;dep[u]){
                ans+=op0(Ge[u][i],x);
            }
        }return ans;
    }else{
        ans+=w[u]&gt;x;
        for(int i=0;i&lt;G[u].size();i++){
            int v=G[u][i];
            if(v==fa[u])continue;
            ans+=op0(v,x);
        }return ans;
    }
}
void op1(int u,int x){
    int pos=lower_bound(block[bel[u]].begin(),block[bel[u]].end(),w[u])-block[bel[u]].begin();
    block[bel[u]][pos]=x;
    w[u]=x;
    sort(block[bel[u]].begin(),block[bel[u]].end());
}
void op2(int u,int x){
    fa[++n]=u;
    w[n]=x;
    dep[n]=dep[u]+1;
    G[u].push_back(n);
    G[n].push_back(u);
	if(siz[bel[u]]&lt;sqrtn){
	    block[bel[n]=bel[u]].push_back(x);
	    sort(block[bel[u]].begin(),block[bel[u]].end());   	
    }else{
    	block[bel[n]=n].push_back(x);
    	siz[bel[n]]++;
        Ge[bel[u]].push_back(bel[n]),
        Ge[bel[n]].push_back(bel[u]);  	
    }
}
int main(){
    scanf("%d",&amp;n);sqrtn=512;
    for(int i=1;i&lt;n;i++){
        int u,v;scanf("%d%d",&amp;u,&amp;v);
        G[u].push_back(v);G[v].push_back(u);
    }for(int i=1;i&lt;=n;i++)bel[i]=i,siz[i]=1,scanf("%d",&amp;w[i]);
    dfs(1); 
    for(int i=1;i&lt;=n;i++){
        block[bel[i]].push_back(w[i]);      
        if(!vis[bel[i]])vis[bel[i]]=1,ind[++ind[0]]=bel[i];
    }for(int i=1;i&lt;=ind[0];i++)sort(block[ind[i]].begin(),block[ind[i]].end());
    scanf("%d",&amp;m);
    while(m--){
        int op;scanf("%d",&amp;op);
        int u,x;scanf("%d%d",&amp;u,&amp;x);
        u^=lastans;x^=lastans;
        if(op==0){
            printf("%d\n",(lastans=op0(u,x)));  
        }else
        if(op==1){
            op1(u,x);
        }else
        if(op==2){
            op2(u,x);
        }
    }
    return 0;
}</pre><pre></pre><h2>Problem3720</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=60010;
int sqrtn,siz[maxn],dep[maxn],bel[maxn],cnt,fa[maxn],n,lastans,w[maxn],mp[maxn],Bfa[maxn],m;
vector&lt;int&gt;G[maxn],Ge[maxn];
vector&lt;int&gt;block[maxn];
int ind[maxn],vis[maxn];
void dfs(int u){
    for(int i=0;i&lt;G[u].size();i++){
        int v=G[u][i];
        if(v==fa[u])continue;
        fa[v]=u;dep[v]=dep[u]+1;
        if(siz[bel[u]]&lt;sqrtn)
            siz[bel[v]=bel[u]]++;
        else
            Ge[bel[u]].push_back(bel[v]),
            Ge[bel[v]].push_back(bel[u]);
        dfs(v);
    }
}
int op0(int u,int x){
    int ans=0;
    if(bel[u]==u){
        ans+=block[u].end()-upper_bound(block[u].begin(),block[u].end(),x);
        for(int i=0;i&lt;Ge[u].size();i++){
            int v=Ge[u][i]; 
            if(dep[v]&gt;dep[u]){
                ans+=op0(Ge[u][i],x);
            }
        }return ans;
    }else{
        ans+=w[u]&gt;x;
        for(int i=0;i&lt;G[u].size();i++){
            int v=G[u][i];
            if(v==fa[u])continue;
            ans+=op0(v,x);
        }return ans;
    }
}
void op1(int u,int x){
    int pos=lower_bound(block[bel[u]].begin(),block[bel[u]].end(),w[u])-block[bel[u]].begin();
    block[bel[u]][pos]=x;
    w[u]=x;
    sort(block[bel[u]].begin(),block[bel[u]].end());
}
void op2(int u,int x){
    fa[++n]=u;
    w[n]=x;
    dep[n]=dep[u]+1;
    G[u].push_back(n);
    G[n].push_back(u);
	if(siz[bel[u]]&lt;sqrtn){
	    block[bel[n]=bel[u]].push_back(x);
	    sort(block[bel[u]].begin(),block[bel[u]].end());   	
    }else{
    	block[bel[n]=n].push_back(x);
    	siz[bel[n]]++;
        Ge[bel[u]].push_back(bel[n]),
        Ge[bel[n]].push_back(bel[u]);  	
    }
}
int main(){
    scanf("%d",&amp;n);sqrtn=1024;
    for(int i=1;i&lt;n;i++){
        int u,v;scanf("%d%d",&amp;u,&amp;v);
        G[u].push_back(v);G[v].push_back(u);
    }for(int i=1;i&lt;=n;i++)bel[i]=i,siz[i]=1,scanf("%d",&amp;w[i]);
    dfs(1); 
    for(int i=1;i&lt;=n;i++){
        block[bel[i]].push_back(w[i]);      
        if(!vis[bel[i]])vis[bel[i]]=1,ind[++ind[0]]=bel[i];
    }for(int i=1;i&lt;=ind[0];i++)sort(block[ind[i]].begin(),block[ind[i]].end());
    scanf("%d",&amp;m);
    while(m--){
        int op;scanf("%d",&amp;op);
        int u,x;scanf("%d%d",&amp;u,&amp;x);
        u^=lastans;x^=lastans;
        if(op==0){
            printf("%d\n",(lastans=op0(u,x)));  
        }else
        if(op==1){
            op1(u,x);
        }else
        if(op==2){
            op2(u,x);
        }
    }
    return 0;
}</pre><pre></pre><h2>Problem3720</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=60010;
int sqrtn,siz[maxn],dep[maxn],bel[maxn],cnt,fa[maxn],n,lastans,w[maxn],mp[maxn],Bfa[maxn],m;
vector&lt;int&gt;G[maxn],Ge[maxn];
vector&lt;int&gt;block[maxn];
int ind[maxn],vis[maxn];
void dfs(int u){
    for(int i=0;i&lt;G[u].size();i++){
        int v=G[u][i];
        if(v==fa[u])continue;
        fa[v]=u;dep[v]=dep[u]+1;
        if(siz[bel[u]]&lt;sqrtn)
            siz[bel[v]=bel[u]]++;
        else
            Ge[bel[u]].push_back(bel[v]),
            Ge[bel[v]].push_back(bel[u]);
        dfs(v);
    }
}
int op0(int u,int x){
    int ans=0;
    if(bel[u]==u){
        ans+=block[u].end()-upper_bound(block[u].begin(),block[u].end(),x);
        for(int i=0;i&lt;Ge[u].size();i++){
            int v=Ge[u][i]; 
            if(dep[v]&gt;dep[u]){
                ans+=op0(Ge[u][i],x);
            }
        }return ans;
    }else{
        ans+=w[u]&gt;x;
        for(int i=0;i&lt;G[u].size();i++){
            int v=G[u][i];
            if(v==fa[u])continue;
            ans+=op0(v,x);
        }return ans;
    }
}
void op1(int u,int x){
    int pos=lower_bound(block[bel[u]].begin(),block[bel[u]].end(),w[u])-block[bel[u]].begin();
    block[bel[u]][pos]=x;
    w[u]=x;
    sort(block[bel[u]].begin(),block[bel[u]].end());
}
void op2(int u,int x){
    fa[++n]=u;
    w[n]=x;
    dep[n]=dep[u]+1;
    G[u].push_back(n);
    G[n].push_back(u);
	if(siz[bel[u]]&lt;sqrtn){
	    block[bel[n]=bel[u]].push_back(x);
	    sort(block[bel[u]].begin(),block[bel[u]].end());   	
    }else{
    	block[bel[n]=n].push_back(x);
    	siz[bel[n]]++;
        Ge[bel[u]].push_back(bel[n]),
        Ge[bel[n]].push_back(bel[u]);  	
    }
}
int main(){
    scanf("%d",&amp;n);sqrtn=sqrt((double)n*log2(n));
    for(int i=1;i&lt;n;i++){
        int u,v;scanf("%d%d",&amp;u,&amp;v);
        G[u].push_back(v);G[v].push_back(u);
    }for(int i=1;i&lt;=n;i++)bel[i]=i,siz[i]=1,scanf("%d",&amp;w[i]);
    dfs(1); 
    for(int i=1;i&lt;=n;i++){
        block[bel[i]].push_back(w[i]);      
        if(!vis[bel[i]])vis[bel[i]]=1,ind[++ind[0]]=bel[i];
    }for(int i=1;i&lt;=ind[0];i++)sort(block[ind[i]].begin(),block[ind[i]].end());
    scanf("%d",&amp;m);
    while(m--){
        int op;scanf("%d",&amp;op);
        int u,x;scanf("%d%d",&amp;u,&amp;x);
        u^=lastans;x^=lastans;
        if(op==0){
            printf("%d\n",(lastans=op0(u,x)));  
        }else
        if(op==1){
            op1(u,x);
        }else
        if(op==2){
            op2(u,x);
        }
    }
    return 0;
}</pre><pre></pre><h2>Problem3720</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=60010;
int sqrtn,siz[maxn],dep[maxn],bel[maxn],cnt,fa[maxn],n,lastans,w[maxn],mp[maxn],Bfa[maxn],m;
vector&lt;int&gt;G[maxn],Ge[maxn];
vector&lt;int&gt;block[maxn];
int ind[maxn],vis[maxn];
void dfs(int u){
    for(int i=0;i&lt;G[u].size();i++){
        int v=G[u][i];
        if(v==fa[u])continue;
        fa[v]=u;dep[v]=dep[u]+1;
        if(siz[bel[u]]&lt;sqrtn)
            siz[bel[v]=bel[u]]++;
        else
            Ge[bel[u]].push_back(bel[v]),
            Ge[bel[v]].push_back(bel[u]);
        dfs(v);
    }
}
int op0(int u,int x){
    int ans=0;
    if(bel[u]==u){
        ans+=block[u].end()-upper_bound(block[u].begin(),block[u].end(),x);
        for(int i=0;i&lt;Ge[u].size();i++){
            int v=Ge[u][i]; 
            if(dep[v]&gt;dep[u]){
                ans+=op0(Ge[u][i],x);
            }
        }return ans;
    }else{
        ans+=w[u]&gt;x;
        for(int i=0;i&lt;G[u].size();i++){
            int v=G[u][i];
            if(v==fa[u])continue;
            ans+=op0(v,x);
        }return ans;
    }
}
void op1(int u,int x){
    int pos=lower_bound(block[bel[u]].begin(),block[bel[u]].end(),w[u])-block[bel[u]].begin();
    block[bel[u]][pos]=x;
    w[u]=x;
    sort(block[bel[u]].begin(),block[bel[u]].end());
}
void op2(int u,int x){
    fa[++n]=u;
    w[n]=x;
    dep[n]=dep[u]+1;
    G[u].push_back(n);
    G[n].push_back(u);
	if(siz[bel[u]]&lt;sqrtn){
	    block[bel[n]=bel[u]].push_back(x);
	    sort(block[bel[u]].begin(),block[bel[u]].end());   	
    }else{
    	block[bel[n]=n].push_back(x);
    	siz[bel[n]]++;
        Ge[bel[u]].push_back(bel[n]),
        Ge[bel[n]].push_back(bel[u]);  	
    }
}
int main(){
    scanf("%d",&amp;n);sqrtn=sqrt((double)n*log(n));
    for(int i=1;i&lt;n;i++){
        int u,v;scanf("%d%d",&amp;u,&amp;v);
        G[u].push_back(v);G[v].push_back(u);
    }for(int i=1;i&lt;=n;i++)bel[i]=i,siz[i]=1,scanf("%d",&amp;w[i]);
    dfs(1); 
    for(int i=1;i&lt;=n;i++){
        block[bel[i]].push_back(w[i]);      
        if(!vis[bel[i]])vis[bel[i]]=1,ind[++ind[0]]=bel[i];
    }for(int i=1;i&lt;=ind[0];i++)sort(block[ind[i]].begin(),block[ind[i]].end());
    scanf("%d",&amp;m);
    while(m--){
        int op;scanf("%d",&amp;op);
        int u,x;scanf("%d%d",&amp;u,&amp;x);
        u^=lastans;x^=lastans;
        if(op==0){
            printf("%d\n",(lastans=op0(u,x)));  
        }else
        if(op==1){
            op1(u,x);
        }else
        if(op==2){
            op2(u,x);
        }
    }
    return 0;
}</pre><pre></pre><h2>Problem3721</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
const int maxn=1e6+10;
LL A[maxn],B[maxn],f[maxn];
int cur=1;
int n,m;
//此题有单调性 
int main(){
	scanf("%d",&amp;n);
	for(int i=1;i&lt;=n;i++){
		int x;scanf("%d",&amp;x);
		if(x&amp;1)A[++A[0]]=x;
		else B[++B[0]]=x;
	}sort(A+1,A+1+A[0],greater&lt;LL&gt;());
	sort(B+1,B+1+B[0],greater&lt;LL&gt;());
	for(int i=2;i&lt;=A[0];i++)A[i]+=A[i-1];
	for(int i=2;i&lt;=B[0];i++)B[i]+=B[i-1];int Bz=B[0];B[0]=0;
	f[1]=A[0]?A[1]:-1;
	for(int i=2;i&lt;=n;i++){
		f[i]=-1;
		//f[i]=max(A[cur]+B[i-cur]*(i-cur&gt;0),A[cur+2]+B[i-cur-2]*(i-cur-2&gt;0));
		if(i-cur&gt;=0&amp;&amp;i-cur&lt;=Bz&amp;&amp;cur&lt;=A[0])
			f[i]=A[cur]+B[i-cur];
		if(i-cur-2&gt;=0&amp;&amp;i-cur-2&lt;=Bz&amp;&amp;cur+2&lt;=A[0]&amp;&amp;f[i]&lt;=A[cur+2]+B[i-cur-2]){
			f[i]=A[cur+2]+B[i-cur-2];
			cur+=2;
		}
	}scanf("%d",&amp;m);
	while(m--){
		int x;scanf("%d",&amp;x);
		printf("%lld\n",f[x]);
	}
	return 0;
} </pre><pre></pre><h2>Problem3721</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
const int maxn=1e6+10;
LL A[maxn],B[maxn],f[maxn];
int cur=1;
int n,m;
int getint(){
	int res=0,f=1;char c=getchar();
	while(!isdigit(c))f=f==-1||c=='-'?-1:1,c=getchar();
	while(isdigit(c))res=(res&lt;&lt;1)+(res&lt;&lt;3)+c-'0',c=getchar();
	return res*f;
}
void putint(LL x){
	if(x&lt;0)putchar('-'),x=-x;
	if(x&lt;10){
		putchar(x+'0');
	}else{
		putint(x/10);
		putchar(x%10+'0');
	}
} 
int main(){
	scanf("%d",&amp;n);
	for(int i=1;i&lt;=n;i++){
		int x=getint();
		if(x&amp;1)A[++A[0]]=x;
		else B[++B[0]]=x;
	}sort(A+1,A+1+A[0],greater&lt;LL&gt;());
	sort(B+1,B+1+B[0],greater&lt;LL&gt;());
	for(int i=2;i&lt;=A[0];i++)A[i]+=A[i-1];
	for(int i=2;i&lt;=B[0];i++)B[i]+=B[i-1];int Bz=B[0];B[0]=0;
	f[1]=A[0]?A[1]:-1;
	for(int i=2;i&lt;=n;i++){
		f[i]=-1;
		//f[i]=max(A[cur]+B[i-cur]*(i-cur&gt;0),A[cur+2]+B[i-cur-2]*(i-cur-2&gt;0));
		if(i-cur&gt;=0&amp;&amp;i-cur&lt;=Bz&amp;&amp;cur&lt;=A[0])
			f[i]=A[cur]+B[i-cur];
		if(i-cur-2&gt;=0&amp;&amp;i-cur-2&lt;=Bz&amp;&amp;cur+2&lt;=A[0]&amp;&amp;f[i]&lt;=A[cur+2]+B[i-cur-2]){
			f[i]=A[cur+2]+B[i-cur-2];
			cur+=2;
		}
	}scanf("%d",&amp;m);
	while(m--){
		int x=getint();
		putint(f[x]);puts("");
	}
	return 0;
} </pre><pre></pre><h2>Problem3721</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
const int maxn=1e6+10;
LL A[maxn],B[maxn],f[maxn];
int cur=1;
int n,m;
int getint(){
	int res=0;char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))res=(res&lt;&lt;1)+(res&lt;&lt;3)+c-'0',c=getchar();
	return res;
}
void putint(LL x){
	if(x&lt;0)putchar('-'),x=-x;
	if(x&lt;10){
		putchar(x+'0');
	}else{
		putint(x/10);
		putchar(x%10+'0');
	}
} 
int main(){
	scanf("%d",&amp;n);
	for(int i=1;i&lt;=n;i++){
		int x=getint();
		if(x&amp;1)A[++A[0]]=x;
		else B[++B[0]]=x;
	}sort(A+1,A+1+A[0],greater&lt;LL&gt;());
	sort(B+1,B+1+B[0],greater&lt;LL&gt;());
	for(int i=2;i&lt;=A[0];i++)A[i]+=A[i-1];
	for(int i=2;i&lt;=B[0];i++)B[i]+=B[i-1];int Bz=B[0];B[0]=0;
	f[1]=A[0]?A[1]:-1;
	for(int i=2;i&lt;=n;i++){
		f[i]=-1;
		//f[i]=max(A[cur]+B[i-cur]*(i-cur&gt;0),A[cur+2]+B[i-cur-2]*(i-cur-2&gt;0));
		if(i-cur&gt;=0&amp;&amp;i-cur&lt;=Bz&amp;&amp;cur&lt;=A[0])
			f[i]=A[cur]+B[i-cur];
		if(i-cur-2&gt;=0&amp;&amp;i-cur-2&lt;=Bz&amp;&amp;cur+2&lt;=A[0]&amp;&amp;f[i]&lt;=A[cur+2]+B[i-cur-2]){
			f[i]=A[cur+2]+B[i-cur-2];
			cur+=2;
		}
	}scanf("%d",&amp;m);
	while(m--){
		int x=getint();
		printf("%lld\n",f[x]);
	}
	return 0;
} </pre><pre></pre><h2>Problem3721</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
const int maxn=1e6+10;
LL A[maxn],B[maxn],f[maxn];
int cur=1;
int n,m;
int getint(){
	int res=0;char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))res=(res&lt;&lt;1)+(res&lt;&lt;3)+c-'0',c=getchar();
	return res;
}
void putint(LL x){
	if(x&lt;0)putchar('-'),x=-x;
	if(x&lt;10){
		putchar(x+'0');
	}else{
		putint(x/10);
		putchar(x%10+'0');
	}
} 
int main(){
	scanf("%d",&amp;n);
	for(int i=1;i&lt;=n;i++){
		int x=getint();
		if(x&amp;1)A[++A[0]]=x;
		else B[++B[0]]=x;
	}sort(A+1,A+1+A[0],greater&lt;LL&gt;());
	sort(B+1,B+1+B[0],greater&lt;LL&gt;());
	for(int i=2;i&lt;=A[0];i++)A[i]+=A[i-1];
	for(int i=2;i&lt;=B[0];i++)B[i]+=B[i-1];int Bz=B[0];B[0]=0;
	f[1]=A[0]?A[1]:-1;
	for(int i=2;i&lt;=n;i++){
		f[i]=-1;
		//f[i]=max(A[cur]+B[i-cur]*(i-cur&gt;0),A[cur+2]+B[i-cur-2]*(i-cur-2&gt;0));
		if(i-cur&gt;=0&amp;&amp;i-cur&lt;=Bz&amp;&amp;cur&lt;=A[0])
			f[i]=A[cur]+B[i-cur];
		if(i-cur-2&gt;=0&amp;&amp;i-cur-2&lt;=Bz&amp;&amp;cur+2&lt;=A[0]&amp;&amp;f[i]&lt;A[cur+2]+B[i-cur-2]){
			f[i]=A[cur+2]+B[i-cur-2];
			cur+=2;
		}
	}scanf("%d",&amp;m);
	while(m--){
		int x=getint();
		printf("%lld\n",f[x]);
	}
	return 0;
} </pre><pre></pre><h2>Problem3732</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1.5e4+10;
struct edge{
	int u,v,w;
	bool operator&lt;(const edge &amp;E)const{
		return w&lt;E.w;
	}
};
edge edges[50001];
vector&lt;edge&gt;G[maxn];
int n,m,q;
int fa[maxn],dep[maxn];
int p[maxn][17],vis[maxn];
int maxx[maxn][17];
int find(int x){
	if(fa[x]!=x)return fa[x]=find(fa[x]);return x;
}
void dfs(int u){
	vis[u]=1;
	for(int i=1;i&lt;=16;i++){
		if(dep[u]&lt;(1&lt;&lt;i))break;
		p[u][i]=p[p[u][i-1]][i-1];
		maxx[u][i]=max(maxx[u][i-1],maxx[p[u][i-1]][i-1]);
	}for(int i=0;i&lt;G[u].size();i++){
		edge e=G[u][i];
		if(!vis[e.v]){
			p[e.v][0]=u;
			maxx[e.v][0]=e.w;
			dep[e.v]=dep[u]+1;
			dfs(e.v);
		}
	}
}
int Qmax(int u,int v){
	if(find(u)!=find(v))return -1;
	if(dep[u]&lt;dep[v])swap(u,v);
	int d=dep[u]-dep[v];
	int ans=INT_MIN;
	for(int i=0;i&lt;=16;i++){
		if((1&lt;&lt;i)&amp;d){
			ans=max(ans,maxx[u][i]);
			u=p[u][i];
		}
	}if(u==v)return ans;
	for(int i=16;i&gt;=0;i--){
		if(p[u][i]!=p[v][i]){
			ans=max(ans,max(maxx[u][i],maxx[v][i]));
			u=p[u][i];v=p[v][i];
		}
	}ans=max(ans,max(maxx[u][0],maxx[v][0]));
	return ans;
}
int main(){
	scanf("%d%d",&amp;n,&amp;m);
	scanf("%d",&amp;q);
	for(int i=1;i&lt;=n;i++)fa[i]=i;
	for(int i=1;i&lt;=m;i++)
		scanf("%d%d%d",&amp;edges[i].u,&amp;edges[i].v,&amp;edges[i].w);
	sort(edges+1,edges+1+m);
	for(int i=1;i&lt;=m;i++){
		if(find(edges[i].u)!=find(edges[i].v)){
			fa[find(edges[i].u)]=find(edges[i].v);
			G[edges[i].u].push_back(edges[i]);
			G[edges[i].v].push_back((edge){edges[i].v,edges[i].u,edges[i].w});
		}
	}
	memset(maxx,0x7f,sizeof maxx);
	for(int i=1;i&lt;=n;i++)if(!vis[i])
	dfs(i);
	while(q--){
		int u,v;scanf("%d%d",&amp;u,&amp;v);
		printf("%d\n",Qmax(u,v));
	}	
	return 0;
} </pre><pre></pre><h2>Problem3732</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1.5e4+10;
struct edge{
	int u,v,w;
	bool operator&lt;(const edge &amp;E)const{
		return w&lt;E.w;
	}
};
edge edges[50001];
vector&lt;edge&gt;G[maxn];
int n,m,q;
int fa[maxn],dep[maxn];
int p[maxn][17],vis[maxn];
int maxx[maxn][17];
int find(int x){
	if(fa[x]!=x)return fa[x]=find(fa[x]);return x;
}
void dfs(int u){
	vis[u]=1;
	for(int i=1;i&lt;=16;i++){
		if(dep[u]&lt;(1&lt;&lt;i))break;
		p[u][i]=p[p[u][i-1]][i-1];
		maxx[u][i]=max(maxx[u][i-1],maxx[p[u][i-1]][i-1]);
	}for(int i=0;i&lt;G[u].size();i++){
		edge e=G[u][i];
		if(!vis[e.v]){
			p[e.v][0]=u;
			maxx[e.v][0]=e.w;
			dep[e.v]=dep[u]+1;
			dfs(e.v);
		}
	}
}
int Qmax(int u,int v){
	if(find(u)!=find(v))return -1;
	if(dep[u]&lt;dep[v])swap(u,v);
	int d=dep[u]-dep[v];
	int ans=INT_MIN;
	for(int i=0;i&lt;=16;i++){
		if((1&lt;&lt;i)&amp;d){
			ans=max(ans,maxx[u][i]);
			u=p[u][i];
		}
	}if(u==v)return ans;
	for(int i=16;i&gt;=0;i--){
		if(p[u][i]!=p[v][i]){
			ans=max(ans,max(maxx[u][i],maxx[v][i]));
			u=p[u][i];v=p[v][i];
		}
	}ans=max(ans,max(maxx[u][0],maxx[v][0]));
	return ans;
}
int getint(){
	int res=0;char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))res=res*10+c-'0',c=getchar();
	return res;
}
int main(){
	n=getint();m=getint();q=getint();
	for(int i=1;i&lt;=n;i++)fa[i]=i;
	for(int i=1;i&lt;=m;i++)
	edges[i].u=getint(),edges[i].v=getint(),edges[i].w=getint();
	sort(edges+1,edges+1+m);
	for(int i=1;i&lt;=m;i++){
		if(find(edges[i].u)!=find(edges[i].v)){
			fa[find(edges[i].u)]=find(edges[i].v);
			G[edges[i].u].push_back(edges[i]);
			G[edges[i].v].push_back((edge){edges[i].v,edges[i].u,edges[i].w});
		}
	}
	memset(maxx,0x7f,sizeof maxx);
	for(int i=1;i&lt;=n;i++)if(!vis[i])
	dfs(i);
	while(q--){
		int u,v;scanf("%d%d",&amp;u,&amp;v);
		printf("%d\n",Qmax(u,v));
	}	
	return 0;
} </pre><pre></pre><h2>Problem3754</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=101;
struct edge{
	int u,v,c;double w;
	bool operator&lt;(edge oth)const{return w&lt;oth.w;};
}edges[2001];
int fa[maxn];
int find(int x){if(fa[x]==x)return x;return fa[x]=find(fa[x]);}
int n,m;
double abar;
double Mst(){
	double ans=0;int cnt=0;
	for(int i=1;i&lt;=n;i++)fa[i]=i;
	sort(edges+1,edges+1+m);
	for(int i=1;i&lt;=m;i++){
		int u=edges[i].u,v=edges[i].v;
		if(find(u)!=find(v)){
			fa[find(u)]=find(v);
			ans+=edges[i].w;
			if(++cnt==n-1)break;
		}
	}
	return ans;
}
double ans=1e10;
int main(){
	scanf("%d%d",&amp;n,&amp;m);
	for(int i=1;i&lt;=m;i++)scanf("%d%d%d",&amp;edges[i].u,&amp;edges[i].v,&amp;edges[i].c);
	for(int i=0;i&lt;=10000;i++){
		abar=(double)i/100.0;
		for(int j=1;j&lt;=m;j++)edges[j].w=(double)(edges[j].c-abar)*(edges[j].c-abar);
		ans=min(ans,Mst());
	//	cerr&lt;&lt;ans&lt;&lt;endl;
	}printf("%.4lf\n",sqrt((double)ans/(n-1)));
	return 0;
}</pre><pre></pre><h2>Problem3754</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=101;
struct edge{
	int u,v,c;double w;
	bool operator&lt;(edge oth)const{return w&lt;oth.w;};
}edges[2001];
int fa[maxn];
int find(int x){if(fa[x]==x)return x;return fa[x]=find(fa[x]);}
int n,m;
double abar;
const double eps=1e-1;
int dcmp(double x){return x&lt;-eps?-1:x&gt;eps;}
double Mst(){
	double ans=0,res=0;int cnt=0;
	for(int i=1;i&lt;=n;i++)fa[i]=i;
	sort(edges+1,edges+1+m);
	for(int i=1;i&lt;=m;i++){
		int u=edges[i].u,v=edges[i].v;
		if(find(u)!=find(v)){
			fa[find(u)]=find(v);
			ans+=edges[i].w;
			res+=edges[i].c;
			if(++cnt==n-1)break;
		}
	}return !dcmp(res/(n-1)-abar)?ans:1e10;
}
double ans=1e10;
int mx=0;
int main(){
	scanf("%d%d",&amp;n,&amp;m);
	for(int i=1;i&lt;=m;i++)scanf("%d%d%d",&amp;edges[i].u,&amp;edges[i].v,&amp;edges[i].c),mx=max(mx,edges[i].c);
	for(int i=0;i&lt;=mx*100;i++){
		abar=(double)i/100.0;
		for(int j=1;j&lt;=m;j++)edges[j].w=(double)(edges[j].c-abar)*(edges[j].c-abar);
		ans=min(ans,Mst());
	}printf("%.4lf\n",sqrt((double)ans/(n-1)));
	return 0;
}</pre><pre></pre><h2>Problem3754</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=101;
struct edge{
	int u,v,c;double w;
	bool operator&lt;(edge oth)const{return w&lt;oth.w;};
}edges[2001];
int fa[maxn];
int find(int x){if(fa[x]==x)return x;return fa[x]=find(fa[x]);}
int n,m;
double abar;
double Mst(){
	double ans=0,res=0;int cnt=0;
	for(int i=1;i&lt;=n;i++)fa[i]=i;
	sort(edges+1,edges+1+m);
	for(int i=1;i&lt;=m;i++){
		int u=edges[i].u,v=edges[i].v;
		if(find(u)!=find(v)){
			fa[find(u)]=find(v);
			ans+=edges[i].w;
			res+=edges[i].c;
			if(++cnt==n-1)break;
		}
	}return fabs(res-abar*(n-1))&lt;1?ans:1e10;
}
double ans=1e10;
int mx=0;
int main(){
	scanf("%d%d",&amp;n,&amp;m);
	for(int i=1;i&lt;=m;i++)scanf("%d%d%d",&amp;edges[i].u,&amp;edges[i].v,&amp;edges[i].c),mx=max(mx,edges[i].c);
	for(int i=0;i&lt;=mx*100;i++){
		abar=(double)i/100.0;
		for(int j=1;j&lt;=m;j++)edges[j].w=(double)(edges[j].c-abar)*(edges[j].c-abar);
		ans=min(ans,Mst());
	}printf("%.4lf\n",sqrt((double)ans/(n-1)));
	return 0;
}</pre><pre></pre><h2>Problem3757</h2><pre>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;string&gt;
#include&lt;cstring&gt;
#include&lt;queue&gt;
#include&lt;vector&gt;
#include&lt;cmath&gt;
using namespace std;
inline int getint()
{
	char c=getchar();
	int con=0;
	while(c&lt;'0'||c&gt;'9') c=getchar();
	while(c&gt;='0'&amp;&amp;c&lt;='9') con=con*10+c-'0',c=getchar();
	return con;
}
const int MAXN=100010;
int n,m,K,lca,u,v,c[MAXN],dfn[MAXN],belongn[MAXN];
int tot,root,dfs_clock,remain;
int head[MAXN],to[MAXN],next[MAXN],cnt;
int anc[MAXN][21],dep[MAXN],Log[MAXN];
int Stack[MAXN],top;
int p[MAXN],ans,con[MAXN];
bool used[MAXN];
struct Query
{
	int u,v,a,b,sub;
	friend bool operator&lt;(const Query &amp;i,const Query &amp;j)
	{
		if(belongn[i.u]==belongn[j.u]) return dfn[i.v]&lt;dfn[j.v];
		else return belongn[i.u]&lt;belongn[j.u];
	}
}Q[MAXN];
inline void adde(int f,int t)
{
	cnt++,to[cnt]=t,next[cnt]=head[f],head[f]=cnt;
	cnt++,to[cnt]=f,next[cnt]=head[t],head[t]=cnt;
}
int DFS(int x)
{
	int size=0;
	dfn[x]=++dfs_clock;
	for(int i=head[x];i;i=next[i])
		if(to[i]!=anc[x][0])
		{
			dep[to[i]]=dep[x]+1,anc[to[i]][0]=x;
			size+=DFS(to[i]);
			if(size&gt;=K)
			{
				tot++;
				for(int i=1;i&lt;=size;i++)
					belongn[Stack[top--]]=tot;
				size=0;
			}
		}
	Stack[++top]=x;
	return size+1;
}
int LCA(int p,int q)
{
	if(dep[p]&lt;dep[q]) swap(p,q);
	int d=dep[p]-dep[q];
	for(int i=Log[d];i&gt;=0;i--)
		if(d&amp;(1&lt;&lt;i)) p=anc[p][i];
	for(int i=Log[n];i&gt;=0;i--)
		if(anc[p][i]!=anc[q][i]) p=anc[p][i],q=anc[q][i];
	if(p!=q) return anc[p][0];
	else return p;
}
void work(int u,int v,int lca)
{
	while(u!=lca)
	{
		if(!used[u]) {p[c[u]]++,used[u]=true;if(p[c[u]]==1) ans++;}
		else {p[c[u]]--,used[u]=false;if(p[c[u]]==0) ans--;}
		u=anc[u][0];
	}
	while(v!=lca)
	{
		if(!used[v]) {p[c[v]]++,used[v]=true;if(p[c[v]]==1) ans++;}
		else {p[c[v]]--,used[v]=false;if(p[c[v]]==0) ans--;}
		v=anc[v][0];
	}
}
int main()
{
	//freopen("apple.in","r",stdin);
	//freopen("apple.out","w",stdout);
	n=getint(),m=getint();
	K=(int)sqrt(2*n);
	for(int i=1;i&lt;=n;i++) c[i]=getint();
	for(int i=1;i&lt;=n;i++)
	{
		u=getint(),v=getint();
		if(u==0) root=v;
		else if(v==0) root=u;
		else adde(u,v);
	}
	for(int i=1;i&lt;=m;i++)
	{
		Q[i].u=getint(),Q[i].v=getint();
		Q[i].a=getint(),Q[i].b=getint();
		Q[i].sub=i;
	}
	remain=DFS(root);
	for(int i=1;i&lt;=remain;i++) belongn[Stack[top--]]=tot;
	sort(Q+1,Q+m+1);
	Log[0]=-1;
	for(int i=1;i&lt;=n;i++) Log[i]=Log[i&gt;&gt;1]+1;
	for(int i=1;i&lt;=Log[n];i++)
		for(int j=1;j&lt;=n;j++)
			anc[j][i]=anc[anc[j][i-1]][i-1];
	work(Q[1].u,Q[1].v,lca=LCA(Q[1].u,Q[1].v));
	if(!used[lca]) {p[c[lca]]++,used[lca]=true;if(p[c[lca]]==1) ans++;}
	else {p[c[lca]]--,used[lca]=false;if(p[c[lca]]==0) ans--;}
	con[Q[1].sub]=ans;
	if(p[Q[1].a]!=0&amp;&amp;p[Q[1].b]!=0) con[Q[1].sub]--;
	if(!used[lca]) {p[c[lca]]++,used[lca]=true;if(p[c[lca]]==1) ans++;}
	else {p[c[lca]]--,used[lca]=false;if(p[c[lca]]==0) ans--;}
	for(int i=2;i&lt;=m;i++)
	{
		work(Q[i-1].u,Q[i].u,LCA(Q[i-1].u,Q[i].u));
		work(Q[i-1].v,Q[i].v,LCA(Q[i-1].v,Q[i].v));
		lca=LCA(Q[i].u,Q[i].v);
		if(!used[lca]) {p[c[lca]]++,used[lca]=true;if(p[c[lca]]==1) ans++;}
		else {p[c[lca]]--,used[lca]=false;if(p[c[lca]]==0) ans--;}
		con[Q[i].sub]=ans;
		if(p[Q[i].a]!=0&amp;&amp;p[Q[i].b]!=0&amp;&amp;Q[i].a!=Q[i].b) con[Q[i].sub]--;
		if(!used[lca]) {p[c[lca]]++,used[lca]=true;if(p[c[lca]]==1) ans++;}
		else {p[c[lca]]--,used[lca]=false;if(p[c[lca]]==0) ans--;}
	}
	for(int i=1;i&lt;=m;i++) printf("%d\n",con[i]);
	return 0;
}</pre><pre></pre><h2>Problem3760</h2><pre>#include &lt;cstdio&gt;
#include &lt;climits&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#define X first
#define Y second
using namespace std;
typedef pair&lt;int,int&gt; pii;
pii point[20001];
int n;
int len;
int vis[20001];
int minx=INT_MAX,miny=INT_MAX;
int maxx=INT_MIN,maxy=INT_MIN;
bool yes;
void dfs(int deep,int left){
    if(deep&gt;4)return;
    if(left==0){
        yes=true;
        return;
    }
    int minx=INT_MAX,miny=INT_MAX;
    int maxx=INT_MIN,maxy=INT_MIN;
    for(int i=0;i&lt;n;i++){
        if(!vis[i]){
            minx=min(minx,point[i].X);
            miny=min(miny,point[i].Y);
            maxx=max(maxx,point[i].X);
            maxy=max(maxy,point[i].Y);
        }
    }
    if(deep==3){
        yes=((maxx-minx)&lt;=len)&amp;&amp;((maxy-miny)&lt;=len);
        return;
    }
    int pre=left,last[20001];
    memcpy(last,vis,sizeof(vis));
    for(int j=1;j&lt;=4;j++){
        int nowx,nowy;
        switch(j) {
            case 1:{nowx=minx;nowy=miny;break;} 
            case 2:{nowx=minx;nowy=maxy-len;break;}
            case 3:{nowx=maxx-len;nowy=miny;break;}
            case 4:{nowx=maxx-len;nowy=maxy-len;break;}
        }
        for(int i=0;i&lt;n;i++){
            if(!vis[i]){
                if(nowx&lt;=point[i].X&amp;&amp;point[i].X&lt;=nowx+len
                 &amp;&amp;nowy&lt;=point[i].Y&amp;&amp;point[i].Y&lt;=nowy+len)
                 vis[i]=1,left--;
            }
        }
        dfs(deep+1,left);
        if(yes)return;
        left=pre;
        memcpy(vis,last,sizeof(last));
    }
}
bool ok(){
    memset(vis,0,sizeof(vis));
    yes=false;
    dfs(1,n);
    return yes;
}
int main(){
//  freopen("cover.in","r",stdin);
//  freopen("cover.out","w",stdout);
    cin&gt;&gt;n;
    for(int i=0;i&lt;n;i++){
        cin&gt;&gt;point[i].X&gt;&gt;point[i].Y;
        minx=min(minx,point[i].X);
        miny=min(miny,point[i].Y);
        maxx=max(maxx,point[i].X);
        maxy=max(maxy,point[i].Y);
    }
    int l=0,r=max(maxx-minx,maxy-miny);
    while(l&lt;r){
        len=(l+r)&gt;&gt;1;
        if(ok())
            r=len;
        else
            l=len+1;
    }
    cout&lt;&lt;l&lt;&lt;endl;
    return 0;
}</pre><pre></pre><h2>Problem3767</h2><pre>a,b=[int(x) for x in raw_input().split()]
print a+b</pre><pre></pre><h2>Problem3774</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=5050;
struct edge{int u,v,cap,flow;};
vector&lt;edge&gt;edges;
vector&lt;int&gt;G[maxn];
int s,t;
int cur[maxn],d[maxn];
void add(int u,int v,int cap){
	edges.push_back((edge){u,v,cap,0});
	G[u].push_back(edges.size()-1);
	edges.push_back((edge){v,u,0,0});
	G[v].push_back(edges.size()-1);
}
bool bfs(){
	static int vis[maxn];
	memset(vis,0,sizeof vis);vis[s]=1;
	queue&lt;int&gt;q;q.push(s);d[s]=0;
	while(!q.empty()){
		int u=q.front();q.pop();
		for(int i=0;i&lt;G[u].size();i++){
			edge e=edges[G[u][i]];if(vis[e.v]||e.cap==e.flow)continue;
			d[e.v]=d[u]+1;vis[e.v]=1;q.push(e.v);
		}
	}return vis[t];
}
int dfs(int u,int a){
	if(u==t||!a)return a;
	int flow=0,f;
	for(int &amp;i=cur[u];i&lt;G[u].size();i++){
		edge e=edges[G[u][i]];
		if(d[e.v]==d[u]+1&amp;&amp;(f=dfs(e.v,min(a,e.cap-e.flow)))&gt;0){
			edges[G[u][i]].flow+=f;
			edges[G[u][i]^1].flow-=f;
			flow+=f;a-=f;if(!a)break;
		}
	}return flow;
}
int dinic(){
	int flow=0,x;
	while(bfs()){
		memset(cur,0,sizeof cur);
		while(x=dfs(s,INT_MAX)){
			flow+=x;
			memset(cur,0,sizeof cur);
		}
	}return flow;
}
int a[501][501],n,ans,tot,m;
int b[501][501]; 
int mp[501][501][2];
int main(){
	scanf("%d%d",&amp;n,&amp;m);
	for(int i=1;i&lt;=n;i++)for(int j=1;j&lt;=m;j++)scanf("%d",&amp;a[i][j]);
	for(int i=1;i&lt;=n;i++)for(int j=1;j&lt;=m;j++)scanf("%d",&amp;b[i][j]),ans+=b[i][j];
	for(int i=1;i&lt;=n;i++)for(int j=1;j&lt;=m;j++)mp[i][j][0]=++tot,mp[i][j][1]=++tot;
	s=0;t=tot+1;
	for(int i=1;i&lt;=n;i++)for(int j=1;j&lt;=m;j++){
		if((i+j)%2){
			add(s,mp[i][j][0],a[i][j]);
			add(mp[i][j][0],mp[i][j][1],b[i][j]);
		}else{
			add(mp[i][j][0],t,a[i][j]);
			add(mp[i][j][1],mp[i][j][0],b[i][j]);
		}
		const int dx[4]={0,0,1,-1};
		const int dy[4]={1,-1,0,0};
		for(int k=0;k&lt;4;k++){
			int x=i+dx[k],y=j+dy[k];
			if(x&lt;1||y&lt;1||x&gt;n||y&gt;m)continue;
			if((i+j)%2)add(mp[i][j][1],mp[x][y][0],1e9);
			else add(mp[x][y][0],mp[i][j][1],1e9);
		}
	}cout&lt;&lt;ans-dinic()&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem3781</h2><pre>#include&lt;bits/stdc++.h&gt;
#define sqr(x) ((x)*(x))
using namespace std;
const int maxn=50010;
int n,m,k,sqrtn;
int getint(){
	int res=0;char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))res=res*10+c-'0',c=getchar();
	return res;
}
int a[maxn],anss[maxn];
int c[maxn],L,R;
int ans=0;
struct qes{
	int l,r,id;
	bool operator&lt;(qes oth)const{
		return l/sqrtn&lt;oth.l/sqrtn||(l/sqrtn==oth.l/sqrtn&amp;&amp;r&lt;oth.r);
	}
}q[maxn];
int main(){
	n=getint();m=getint();k=getint();sqrtn=sqrt(n);
	for(int i=1;i&lt;=n;i++)a[i]=getint();
	for(int i=1;i&lt;=m;i++)
		q[i].l=getint(),q[i].r=getint(),q[i].id=i;
	sort(q+1,q+1+m);
	c[a[1]]++;L=R=1;ans=1;
	for(int i=1;i&lt;=n;i++){
		while(L&gt;q[i].l){
			L--;
			c[a[L]]++;
			ans=ans-sqr(c[a[L]]-1)+sqr(c[a[L]]);
		}
		while(R&lt;q[i].r){
			R++;
			c[a[R]]++;
			ans=ans-sqr(c[a[R]]-1)+sqr(c[a[R]]);			
		}
		while(L&lt;q[i].l){
			c[a[L]]--;
			ans=ans-sqr(c[a[L]]+1)+sqr(c[a[L]]);
			L++;
		}
		while(R&gt;q[i].r){
			c[a[R]]--;
			ans=ans-sqr(c[a[R]]+1)+sqr(c[a[R]]);	
			R--;		
		}anss[q[i].id]=ans;
	}
	for(int i=1;i&lt;=m;i++)printf("%d\n",anss[i]);
	return 0;	
}</pre><pre></pre><h2>Problem3786</h2><pre>#include&lt;bits/stdc++.h&gt;
#define rep(i,a,n) for(int i=a;i&lt;n;i++)
using namespace std;
typedef long long LL;
const int maxn=1e5+5;
int getint(){
	int res=0;char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))res=res*10+c-'0',c=getchar();
	return res;
}
int n;
struct info{
	LL sum;int size;
	info(LL _sum=0,int _size=1){sum=_sum;size=_size;}
	void clear(){sum=0;size=1;}
	void deb(){printf("sum:%d size:%d",(int)sum,size);}
};
struct flag{
	LL add;
	flag(LL _add=0){add=_add;}
	bool empty(){return !add;}
	void clear(){add=0;}
};
info operator+(const info &amp;ls,const info &amp;rs){
	return info(ls.sum+rs.sum,ls.size+rs.size);
}
info operator+(const info &amp;ls,const flag &amp;rs){
	return ls.size?info(ls.sum+(LL)rs.add*ls.size,ls.size):ls;
}
flag operator+(const flag &amp;ls,const flag &amp;rs){
	return flag(ls.add+rs.add);
}
struct node{
	node *c[4],*f;
	flag Cha,All;
	info cha,sub,all;
	bool rev,inr;
	LL val;
	node(){
		memset(c,0,sizeof c);f=0;
		Cha.clear();All.clear();cha.clear();sub.clear();all.clear();
		rev=inr=0;val=0;
	}
	void makerev(){rev^=1;swap(c[0],c[1]);}
	void makec(const flag &amp;a){
		Cha=Cha+a;cha=cha+a;val=val+a.add;
		all=cha+sub;
	}
	void makes(const flag &amp;a,bool _=1){
		All=All+a;all=all+a;sub=sub+a;
		if(_)makec(a);
	}
	void rz(){
		cha.clear();sub=info(0,0);all.clear();
		if(!inr)cha=all=info(val);
		rep(i,0,2)if(c[i])cha=cha+c[i]-&gt;cha,sub=sub+c[i]-&gt;sub;
		rep(i,0,4)if(c[i])all=all+c[i]-&gt;all;
		rep(i,2,4)if(c[i])sub=sub+c[i]-&gt;all;
	}
	void pd(){
		if(rev){
			if(c[0])c[0]-&gt;makerev();
			if(c[1])c[1]-&gt;makerev();
			rev=0;
		}
		if(!Cha.empty()){
			rep(i,0,2)if(c[i])c[i]-&gt;makec(Cha);
			Cha.clear();
		}
		if(!All.empty()){
			rep(i,0,4)if(c[i])c[i]-&gt;makes(All,i&gt;=2);
			All.clear();
		}
	}
	node *C(int i){if(c[i])c[i]-&gt;pd();return c[i];}
	bool d(int ty){return f-&gt;c[ty+1]==this;}
	int D(){rep(i,0,4)if(f-&gt;c[i]==this)return i;}
	void sets(node *x,int d){if(x)x-&gt;f=this;c[d]=x;}
	bool rt(int ty){
		if(ty==0)return !f||(f-&gt;c[0]!=this&amp;&amp;f-&gt;c[1]!=this);
		else return !f||!f-&gt;inr||!inr;
	}
}nd[maxn*2],*cur=nd+maxn,*pool[maxn],**Cur=pool;
int _cnt;
node *newnode(){
	_cnt++;
	node *x=(Cur==pool)?cur++:*(--Cur);
	rep(i,0,4)x-&gt;c[i]=0;x-&gt;f=0;
	x-&gt;all=info(0,0);
	x-&gt;cha=info(0,0);
	x-&gt;sub=info(0,0);
	x-&gt;inr=1;x-&gt;rev=0;x-&gt;val=0;
	return x;	
}
int max(long long x,int y){return max(int(x),y);}
void deb(node *x){
	if(!x)return;
	printf("id:%d f:%d c[0]:%d c[1]:%d c[2]:%d c[3]:%d inr:%d val:%d",
	max(x-nd,-1),max(x-&gt;f-nd,-1),max(x-&gt;c[0]-nd,-1),max(x-&gt;c[1]-nd,-1),max(x-&gt;c[2]-nd,-1)
	,max(x-&gt;c[3]-nd,-1),x-&gt;inr,int(x-&gt;val));
	printf(" cha:");x-&gt;cha.deb();
	printf(" sub:");x-&gt;sub.deb();
	printf(" all:");x-&gt;all.deb();
	puts("");
}
void deb(){
	for(int i=1;i&lt;=n;i++)deb(nd+i);
	for(int i=maxn;i&lt;maxn+_cnt;i++)deb(nd+i);puts("");
}
void dele(node *x){*(Cur++)=x;}
void rot(node *x,int ty){
	node *p=x-&gt;f;int d=x-&gt;d(ty);
	if(!p-&gt;f)x-&gt;f=0;else p-&gt;f-&gt;sets(x,p-&gt;D());
	p-&gt;sets(x-&gt;c[!d+ty],d+ty);x-&gt;sets(p,!d+ty);p-&gt;rz();
}
void splay(node *x,int ty=0){
	while(!x-&gt;rt(ty)){
		if(x-&gt;f-&gt;rt(ty))rot(x,ty);
		else if(x-&gt;d(ty)==x-&gt;f-&gt;d(ty))rot(x-&gt;f,ty),rot(x,ty);
		else rot(x,ty),rot(x,ty);
	}x-&gt;rz();
}
void add(node *u,node *w){
	w-&gt;pd();
	rep(i,2,4)if(!w-&gt;c[i]){w-&gt;sets(u,i);return;}
	node *x=newnode(),*v;
	for(v=w;v-&gt;c[2]-&gt;inr;v=v-&gt;C(2));
	x-&gt;sets(v-&gt;c[2],2);x-&gt;sets(u,3);
	v-&gt;sets(x,2);splay(x,2);	
}
void del(node *w){
	if(w-&gt;f-&gt;inr){
		w-&gt;f-&gt;f-&gt;sets(w-&gt;f-&gt;c[5-w-&gt;D()],w-&gt;f-&gt;D());
		dele(w-&gt;f);splay(w-&gt;f-&gt;f,2);
	}else w-&gt;f-&gt;sets(0,w-&gt;D());
	w-&gt;f=0;
}
void access(node *w){
	static node *sta[maxn];
	static int top=0;
	node *v=w,*u;
	for(u=w;u;u=u-&gt;f)sta[top++]=u;
	while(top)sta[--top]-&gt;pd();
	splay(w);
	if(w-&gt;c[1])u=w-&gt;c[1],w-&gt;c[1]=0,add(u,w),w-&gt;rz();
	while(w-&gt;f){
		for(u=w-&gt;f;u-&gt;inr;u=u-&gt;f);
		splay(u);
		if(u-&gt;c[1])w-&gt;f-&gt;sets(u-&gt;c[1],w-&gt;D()),splay(w-&gt;f,2);
		else del(w);
		u-&gt;sets(w,1);
		(w=u)-&gt;rz();
	}splay(v);
}
void makert(node *x){
	access(x);x-&gt;makerev();
}
node *findp(node *u){
	access(u);u=u-&gt;C(0);
	while(u&amp;&amp;u-&gt;c[1])u=u-&gt;C(1);
	return u;
}
node *findr(node *u){for(;u-&gt;f;u=u-&gt;f);return u;}
node* cut(node *u){
	node *v=findp(u);
	if(v)access(v),del(u),v-&gt;rz();
	return v;
}
void link(node *u,node *v) {
	node* p=cut(u);
	if(findr(u)!=findr(v))p=v;
	if(p)access(p),add(u,p),p-&gt;rz();
}
int main(){
	n=getint();
	static int fa[maxn];
	rep(i,2,n+1)scanf("%d",&amp;fa[i]);
	rep(i,1,n+1)scanf("%d",&amp;nd[i].val),nd[i].rz();
	rep(i,2,n+1){
		makert(nd+fa[i]);
		link(nd+i,nd+fa[i]);
	}
	makert(nd+1);
	int m=getint();
	while(m--){
		makert(nd+1);
		char op=getchar();while(!isalpha(op))op=getchar();
		if(op=='Q'){
			int x=getint();node *v=nd+x;
			access(v);
			printf("%lld\n",v-&gt;cha.sum);
		}else
		if(op=='C'){
			int x=getint(),y=getint();
			cut(nd+x);
			makert(nd+y);
			link(nd+y,nd+x);
			makert(nd+1);
		}else{
			int x=getint();node *v=nd+x;
			access(v);
			int y=getint();
			v-&gt;val+=y;
			rep(i,2,4)if(v-&gt;c[i])
			v-&gt;c[i]-&gt;makes(flag(y));
		}
	}
	return 0;
}</pre><pre></pre><h2>Problem3790</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;climits&gt;
#define fst first
#define sec second
#define lw(x) (x&amp;-x)
using namespace std;
const int maxn=100010;
typedef pair&lt;int,int&gt; pi;
char s[maxn],str[maxn&lt;&lt;1];
int n,m,f[maxn&lt;&lt;1],size;
pi seg[maxn&lt;&lt;1];
bool cmp(pi a,pi b){return a.sec!=b.sec?a.sec&lt;b.sec:a.fst&lt;b.fst;}
void get_seg(int l,int r){
	if(l&gt;r)return;
	seg[++size]=pi(l,r);
}
int d[maxn];
int Qmin(int x){int o=d[x];while(x&amp;&amp;x&lt;=n)o=min(o,d[x]),x+=lw(x);return o;}
void updata(int x,int f){while(x)d[x]=min(d[x],f),x-=lw(x);}
int main(){
	while(~scanf("%s",s+1)){
		memset(f,0,sizeof f);
		memset(d,0x7f,sizeof d);d[0]=0;
		memset(str,0,sizeof str);
		n=strlen(s+1);m=n*2+1;size=0;
		str[0]='+';str[1]='#';str[m+1]='-';
		for(int i=1;i&lt;=n;i++)str[i&lt;&lt;1]=s[i],str[i&lt;&lt;1|1]='#';
		int k=1;f[1]=1;
		for(int i=2;i&lt;=m;i++){
			if(f[k]+k&gt;i)f[i]=min(f[k+k-1],f[k]+k-i);else f[i]=1;
			while(str[i-f[i]]==str[i+f[i]])f[i]++;
			get_seg((i-f[i]+2)/2,(i+f[i]-2)/2);
			if(f[i]+i&gt;f[k]+k)k=i;
		}sort(seg+1,seg+1+size,cmp);
		memset(f,0,sizeof f);int ans=INT_MAX;
		for(int i=1;i&lt;=size;i++){
			f[i]=Qmin(seg[i].fst-1)+1;
			if(seg[i].sec==n)ans=min(ans,f[i]);
			updata(seg[i].sec,f[i]);
		}cout&lt;&lt;ans-1&lt;&lt;endl;
	}
	return 0;
}</pre><pre></pre><h2>Problem3813</h2><pre>#include&lt;bits/stdc++.h&gt;
#define lw(x) (x&amp;-x)
using namespace std;
const int maxn=1e5+5;
const int M=19961993;
struct BIT{
	int d[maxn];
	void updata(int x,int f){while(x&lt;maxn)d[x]+=f,x+=lw(x);}
	int get(int x){int o=0;while(x)o+=d[x],x-=lw(x);return o;}
}T[61];
int getint(){
	int res=0;char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))res=res*10+c-'0',c=getchar();
	return res;
}
int p[300],a[maxn][61];
short indx[300];
void get_p(){
	static bool notp[300];
	for(int i=2;i&lt;300;i++){
		if(!notp[i]){p[++p[0]]=i;indx[i]=p[0];}
		for(int j=1;j&lt;=p[0]&amp;&amp;i*p[j]&lt;300;j++){
			notp[i*p[j]]=1;
			if(i%p[j]==0)break;
		}
	}
}
typedef long long LL;
int pw(int x,int k){
	int ans=1;
	for(;k;k&gt;&gt;=1){
		if(k&amp;1)ans=(LL)ans*x%M;
		x=(LL)x*x%M;
	}return ans;
}
int main(){
	get_p();
	for(int i=1;i&lt;=1e5;i++)a[i][2]=1,T[2].updata(i,1);
	int n=getint();
	while(n--){
		if(!getint()){
			int ans=1,l=getint(),r=getint();
			for(int i=1;i&lt;=60;i++){
				int mi=T[i].get(r)-T[i].get(l-1);
				if(!mi)continue;
				ans=(LL)ans*pw(p[i],mi-1)%M*(p[i]-1)%M;
			}printf("%d\n",ans);
		}else{
			int ps=getint(),x=getint();
			for(int i=1;i&lt;=60;i++){
				int cnt=0;
				while(x%p[i]==0)cnt++,x/=p[i];
				T[i].updata(ps,-a[ps][i]);
				T[i].updata(ps,a[ps][i]=cnt);
			}
		}		
	}
	return 0;
}
</pre><pre></pre><h2>Problem3816</h2><pre>aa</pre><pre></pre><h2>Problem3823</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
LL n,p;
LL pw(LL x,LL k){
    LL ans=1;
    for(;k;k&gt;&gt;=1){
        if(k&amp;1)ans=(ans*x)%p;
        x=(x*x)%p;
    }return ans;
}
LL f,ans;
int inv[int(2e7+5)];
int cnt=0;
int main(){
    cin&gt;&gt;n&gt;&gt;p;
    ans=f=1;cnt=0;inv[1]=1;
    for(int i=2;i&lt;=n;i++)inv[i]=(LL)(p-p/i)*inv[p%i]%p;
    for(int i=1;i&lt;=n;i++){
		int tmp=n-i+1;
		while(tmp%p==0)cnt++,tmp/=p;
		f=(LL)f*2*tmp%p;
		tmp=i;
		while(tmp%p==0)cnt--,tmp/=p;
		f=(LL)f*inv[tmp%p]%p;
        ans^=cnt?0:f;
    }cout&lt;&lt;ans&lt;&lt;endl;
    return 0;
}</pre><pre></pre><h2>Problem3823</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
LL n,p;
LL pw(LL x,LL k){
    LL ans=1;
    for(;k;k&gt;&gt;=1){
        if(k&amp;1)ans=(ans*x)%p;
        x=(x*x)%p;
    }return ans;
}
LL f,ans;
int inv[int(2e7+5)];
int cnt=0;
int main(){
    cin&gt;&gt;n&gt;&gt;p;if(p==2)while(1);
    ans=f=1;cnt=0;inv[1]=1;
    for(int i=2;i&lt;=n;i++)inv[i]=(LL)(p-p/i)*inv[p%i]%p;
    for(int i=1;i&lt;=n;i++){
		int tmp=n-i+1;
		while(tmp%p==0)cnt++,tmp/=p;
		f=(LL)f*2*tmp%p;
		tmp=i;
		while(tmp%p==0)cnt--,tmp/=p;
		f=(LL)f*inv[tmp%p]%p;
        ans^=cnt?0:f;
    }cout&lt;&lt;ans&lt;&lt;endl;
    return 0;
}</pre><pre></pre><h2>Problem3823</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
LL n,p;
LL pw(LL x,LL k){
    LL ans=1;
    for(;k;k&gt;&gt;=1){
        if(k&amp;1)ans=(ans*x)%p;
        x=(x*x)%p;
    }return ans;
}
LL f,ans;
int inv[int(2e7+5)];
int cnt=0;
int main(){
    cin&gt;&gt;n&gt;&gt;p;
    ans=f=pw(2,n);cnt=0;inv[1]=1;
    for(int i=2;i&lt;=min(2*n,p-1);i++)inv[i]=(LL)(p-p/i)*inv[p%i]%p;
    for(int i=1;i&lt;=n;i++){
		int tmp=n-i+1;
		while(tmp%p==0)cnt++,tmp/=p;
		f=(LL)f*tmp%p;
		tmp=2*i;
		while(tmp%p==0)cnt--,tmp/=p;
		f=(LL)f*inv[tmp%p]%p;
        ans^=cnt?0:f;
    }cout&lt;&lt;ans&lt;&lt;endl;
    return 0;
}</pre><pre></pre><h2>Problem3831</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1e6+5;
deque&lt;int&gt;dq;
int d[maxn],n,f[maxn];
int getint(){
	int res=0;char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))res=res*10+c-'0',c=getchar();
	return res;
}
bool bigger(int x,int y){return f[x]==f[y]?d[x]&lt;d[y]:f[x]&gt;f[y];}
int main(){
	n=getint();
	for(int i=1;i&lt;=n;i++)d[i]=getint();
	int q=getint();
	while(q--){
		int k=getint();dq.clear();
		for(int i=1;i&lt;=n;i++){
			while(dq.size()&amp;&amp;dq.front()+k&lt;i)dq.pop_front();
			if(i-1)f[i]=f[dq.front()]+(d[dq.front()]&lt;=d[i]);
			while(dq.size()&amp;&amp;bigger(dq.back(),i))dq.pop_back();
			dq.push_back(i);
		}printf("%d\n",f[n]);
	}
	return 0;
} </pre><pre></pre><h2>Problem3834</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
int main(){
	int T;scanf("%d",&amp;T);
	while(T--){
		int a,b,c,d,ans=0;scanf("%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d);
		if(b&gt;d)swap(a,c),swap(b,d);a--;c--;
		if(b&gt;c){printf("%d\n",b);continue;}
		for(int i=1,j;i&lt;=b;i=j+1){
			j=min(b/(b/i),d/(d/i));
			if(i&lt;=a)j=min(j,a/(a/i));
			if(i&lt;=c)j=min(j,c/(c/i));
			if(b/j&gt;a/j&amp;&amp;d/j&gt;c/j)ans=j;
		}printf("%d\n",ans);
	}
}</pre><pre></pre><h2>Problem3837</h2><pre>/*
当m取2时，k至少为n/2
所以在最优解中每个数被选中的概率至少为1/2
每次随机选取一个位置i，计算出其它数与a[i]的差值，将差值分解质因数
所有质因数中出现次数的最大值加上与a[i]相等的数的个数就是选取i的情况下的最优解
为了最大化m，需要将所有相同位置的因数乘起来
给每个位置随机一个权值，全部异或起来求出Hash值，排序后扫一遍统计即可
因为a[i]&lt;=10^7，所以可以先一遍线性筛求出每个数的是被哪个素数筛掉的，这样就可以做到O(logn)分解质因数
*/
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int N=100010,M=10000001,P=664600;
int n,i,j,x,a[N],b[N],maxv,p[P],tot,ans1,ans2,T,cnt,pos[P],las[P],now,loc[M],v[M],tmp[32],fac,vis[P];
struct PI{
  int cnt,hash,num;
  PI(){cnt=hash=0;num=1;}
  PI(int _cnt,int _hash,int _num){cnt=_cnt,hash=_hash,num=_num;}
}pool[P];
inline bool cmp(PI a,PI b){return a.hash&lt;b.hash;}
inline void read(int&amp;a){char c;while(!(((c=getchar())&gt;='0')&amp;&amp;(c&lt;='9')));a=c-'0';while(((c=getchar())&gt;='0')&amp;&amp;(c&lt;='9'))(a*=10)+=c-'0';}
inline void divide(int x,int y){
  int i,j,k;
  for(i=0;i&lt;fac;i++)vis[tmp[i]]=0;
  for(fac=0;x^1;vis[v[x]]*=p[v[x]],x/=p[v[x]])if(!vis[v[x]])tmp[fac++]=v[x],vis[v[x]]=1;
  for(i=0;i&lt;fac;i++){
    k=vis[tmp[i]];
    if(las[tmp[i]]^T)las[tmp[i]]=T,pool[j=pos[tmp[i]]=++now]=PI(0,0,k);else j=pos[tmp[i]];
    pool[j].cnt++,pool[j].hash^=y;
    if(pool[j].num&gt;k)pool[j].num=k;
  }
}
int main(){
  pool[0].hash=-1;
  for(read(n);i&lt;n;i++){
    read(a[i]);
    while(!b[i])b[i]=rand();
    if(a[i]&gt;maxv)maxv=a[i];
  }
  for(i=2;i&lt;=maxv;i++){
    if(!v[i])p[v[i]=loc[i]=++tot]=i;
    for(j=1;j&lt;=tot;j++){
      if(i*p[j]&gt;maxv)break;
      v[i*p[j]]=j;
      if(i%p[j]==0)break;
    }
  }
  for(T=1;T&lt;=4;T++){
    for(x=a[rand()%n],i=cnt=now=0;i&lt;n;i++)if(a[i]!=x)divide(a[i]&gt;x?(a[i]-x):(x-a[i]),b[i]);else cnt++;
    sort(pool+1,pool+now+1,cmp);
    for(j=0,i=1;i&lt;=now;i++)if(pool[i].hash^pool[j].hash){
      if(j){
        if(pool[j].cnt+cnt&gt;ans1)ans1=pool[j].cnt+cnt,ans2=pool[j].num;
        else if(pool[j].cnt+cnt==ans1&amp;&amp;pool[j].num&gt;ans2)ans2=pool[j].num;
      }
      j=i;
    }else pool[j].num*=pool[i].num;
    if(pool[j].cnt+cnt&gt;ans1)ans1=pool[j].cnt+cnt,ans2=pool[j].num;
    else if(pool[j].cnt+cnt==ans1&amp;&amp;pool[j].num&gt;ans2)ans2=pool[j].num;
  }
  return printf("%d %d",ans1,ans2),0;
}</pre><pre></pre><h2>Problem3867</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
int a[100001];
struct node{
	int all,mx,sa;
	int l,r;
	node(){all=-1;mx=-1;sa=-1;l=r=0;}
	void rz();
}t[200001];
#define ls t[i].l
#define rs t[i].r
int tot;
void pd(int i){
	if(t[i].all&gt;=0){
		t[ls].all=t[ls].mx=t[ls].sa=t[i].all;
		t[rs].all=t[rs].mx=t[rs].sa=t[i].all;
		t[i].all=-1;
	}
}
void node::rz(){
	mx=max(t[l].mx,t[r].mx);
	sa=t[l].sa==t[r].sa?t[r].sa:-1;
}
int build(int l,int r){
	int x=++tot;
	if(l==r){t[x].mx=a[l];t[x].sa=a[l];return x;}
	t[x].l=build(l,(l+r)/2);
	t[x].r=build((l+r)/2+1,r);
	t[x].rz();return x;
}
void C(int i,int l,int r,int l0,int r0,int x){
	if(l0&lt;=l&amp;&amp;r0&gt;=r){
		t[i].all=x;t[i].sa=x;t[i].mx=x;
		return;
	}pd(i);
	if(l0&lt;=(l+r)/2)C(ls,l,(l+r)/2,l0,r0,x);
	if(r0&gt;(l+r)/2)C(rs,(l+r)/2+1,r,l0,r0,x);
	t[i].rz();
}
void G(int i,int l,int r,int l0,int r0,int x){
	if(t[i].mx&lt;=x)return;
	if(l==r){
		t[i].mx=t[i].all=t[i].sa=__gcd(x,t[i].mx);
		return;	
	}
	if(l0&lt;=l&amp;&amp;r0&gt;=r&amp;&amp;t[i].sa!=-1){
		t[i].mx=t[i].all=t[i].sa=__gcd(x,t[i].mx);
		return;
	}pd(i);
	if(l0&lt;=(l+r)/2)G(ls,l,(l+r)/2,l0,r0,x);
	if(r0&gt;(l+r)/2)G(rs,(l+r)/2+1,r,l0,r0,x);
	t[i].rz();
}
void dfs(int i,int l,int r){
	if(l==r){a[l]=t[i].sa;return;}
	pd(i);
	dfs(ls,l,(l+r)/2);
	dfs(rs,(l+r)/2+1,r);
}
void sol(){
	int n,m;scanf("%d",&amp;n);
	for(int i=1;i&lt;=n;i++)scanf("%d",&amp;a[i]);
	for(int i=1;i&lt;=tot;i++)t[i]=node();tot=0;
	build(1,n);
	scanf("%d",&amp;m);
	while(m--){
		int ty;scanf("%d",&amp;ty);
		int l,r,x;scanf("%d%d%d",&amp;l,&amp;r,&amp;x);
		if(ty==1){
			C(1,1,n,l,r,x);
		}else{
			G(1,1,n,l,r,x);
		}
	}dfs(1,1,n);
	for(int i=1;i&lt;=n;i++)printf("%d ",a[i]);puts("");
}
int main(){
	int T;scanf("%d",&amp;T);
	while(T--)sol();
	return 0;
}</pre><pre></pre><h2>Problem3876</h2><pre>#include &lt;cstdio&gt;  
#include &lt;cstring&gt;  
#include &lt;iostream&gt;  
#include &lt;algorithm&gt;  
#define M 310  
#define S 0  
#define T (n+1)  
#define INF 0x3f3f3f3f  
using namespace std;  
int n,m,ans;  
namespace Min_Cost_Max_Flow{  
    struct abcd{  
        int to,flow,cost,next;  
    }table[1001001];  
    int head[M],tot=1;  
    void Add(int x,int y,int f,int c)  
    {  
        table[++tot].to=y;  
        table[tot].flow=f;  
        table[tot].cost=c;  
        table[tot].next=head[x];  
        head[x]=tot;  
    }  
    void Link(int x,int y,int f,int c)  
    {  
        Add(x,y,f,c);  
        Add(y,x,0,-c);  
    }  
    bool Edmonds_Karp()  
    {  
        static int q[65540],f[M],cost[M],from[M];    
        static unsigned short r,h;    
        static bool v[M];    
        int i;    
        memset(cost,0x3f,sizeof cost);    
        cost[S]=0;f[S]=INF;f[T]=0;q[++r]=S;    
        while(r!=h)    
        {    
            int x=q[++h];v[x]=0;    
            for(i=head[x];i;i=table[i].next)    
                if(table[i].flow&amp;&amp;cost[x]+table[i].cost&lt;cost[table[i].to])    
                {    
                    cost[table[i].to]=cost[x]+table[i].cost;    
                    f[table[i].to]=min(f[x],table[i].flow);    
                    from[table[i].to]=i;    
                    if(!v[table[i].to])    
                        v[table[i].to]=1,q[++r]=table[i].to;    
                }    
        }    
        if(!f[T]) return false;    
        ans+=f[T]*cost[T];    
        for(i=from[T];i;i=from[table[i^1].to])    
            table[i].flow-=f[T],table[i^1].flow+=f[T];    
        return true;  
    }  
}  
int main()  
{  
    //freopen("3876.in","r",stdin);  
    using namespace Min_Cost_Max_Flow;  
    int i,j,y,z;  
    cin&gt;&gt;n;  
    for(i=1;i&lt;=n;i++)  
    {  
        scanf("%d",&amp;m);  
        for(j=1;j&lt;=m;j++)  
        {  
            scanf("%d%d",&amp;y,&amp;z);  
            Link(i,y,INF,z);  
            Link(S,y,1,z);  
        }  
        Link(i,T,m,0);  
        if(i!=1)  
            Link(i,1,INF,0);  
    }  
    while( Edmonds_Karp() );  
    cout&lt;&lt;ans&lt;&lt;endl;  
}  </pre><pre></pre><h2>Problem3884</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1e7+5;
typedef long long LL;
LL T,x;
int phi[maxn];
int p[664580],two[maxn];
bool notp[maxn];
LL pw(LL x,LL k,LL p){
	LL ans=1;
	for(;k;k&gt;&gt;=1){
		if(k&amp;1)ans=(LL)ans*x%p;
		x=(LL)x*x%p;
	}return ans;
}
LL compute(LL x){
//	if(vis[x])return anss[x];
	if(x&lt;=2)return 0;
	if(x==(1&lt;&lt;two[x]))return 0;
	//vis[x]=1;
	if(!(x&amp;1)){
		LL k=two[x];
		LL tmp=compute(phi[x/(1&lt;&lt;k)]);
		tmp+=(LL)k*(phi[x/(1&lt;&lt;k)]-1);tmp%=phi[x/(1&lt;&lt;k)];
		return (LL)(1&lt;&lt;k)*pw(2,tmp,x/(1&lt;&lt;k));
	}else return pw(2,compute(phi[x]),x); 
}
int main(){
	phi[1]=1;
	for(LL i=2;i&lt;maxn;i++){
		for(LL j=i;!(j&amp;1);j&gt;&gt;=1)two[i]++;
		if(!notp[i])p[++p[0]]=i,phi[i]=i-1;
		for(LL j=1;j&lt;=p[0]&amp;&amp;i*p[j]&lt;maxn;j++){
			notp[i*p[j]]=1;
			if(i%p[j]==0){
				phi[i*p[j]]=phi[i]*p[j];
				break;
			}else phi[i*p[j]]=phi[i]*(p[j]-1);
		}
	}cin&gt;&gt;T;
	while(T--){
		cin&gt;&gt;x;
		cout&lt;&lt;compute(x)&lt;&lt;endl;
	}
	return 0;
}</pre><pre></pre><h2>Problem3884</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1e7+5;
typedef long long LL;
LL T,x;
int phi[maxn];
int p[664580],two[maxn];
bool notp[maxn];
LL pw(LL x,LL k,LL p){
	LL ans=1;
	for(;k;k&gt;&gt;=1){
		if(k&amp;1)ans=(LL)ans*x%p;
		x=(LL)x*x%p;
	}return ans;
}
LL compute(LL x){
//	if(vis[x])return anss[x];
	if(x&lt;=2)return 0;
	if(x==(1&lt;&lt;two[x]))return 0;
	//vis[x]=1;
	return pw(2,compute(phi[x])+phi[x],x); 
}
int main(){
	phi[1]=1;
	for(LL i=2;i&lt;maxn;i++){
		for(LL j=i;!(j&amp;1);j&gt;&gt;=1)two[i]++;
		if(!notp[i])p[++p[0]]=i,phi[i]=i-1;
		for(LL j=1;j&lt;=p[0]&amp;&amp;i*p[j]&lt;maxn;j++){
			notp[i*p[j]]=1;
			if(i%p[j]==0){
				phi[i*p[j]]=phi[i]*p[j];
				break;
			}else phi[i*p[j]]=phi[i]*(p[j]-1);
		}
	}cin&gt;&gt;T;
	while(T--){
		cin&gt;&gt;x;
		cout&lt;&lt;compute(x)&lt;&lt;endl;
	}
	return 0;
}</pre><pre></pre><h2>Problem3894</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=500*500+5;
struct edge{int u,v,cap,flow;};
vector&lt;edge&gt;edges;
vector&lt;int&gt;G[maxn];
int s,t;
int cur[maxn],d[maxn];
void add(int u,int v,int cap){
	edges.push_back((edge){u,v,cap,0});
	G[u].push_back(edges.size()-1);
	edges.push_back((edge){v,u,0,0});
	G[v].push_back(edges.size()-1);
}
bool bfs(){
	static int vis[maxn];
	memset(vis,0,sizeof vis);vis[s]=1;
	queue&lt;int&gt;q;q.push(s);d[s]=0;
	while(!q.empty()){
		int u=q.front();q.pop();
		for(int i=0;i&lt;G[u].size();i++){
			edge e=edges[G[u][i]];if(vis[e.v]||e.cap==e.flow)continue;
			d[e.v]=d[u]+1;vis[e.v]=1;q.push(e.v);
		}
	}return vis[t];
}
int dfs(int u,int a){
	if(u==t||!a)return a;
	int flow=0,f;
	for(int &amp;i=cur[u];i&lt;G[u].size();i++){
		edge e=edges[G[u][i]];
		if(d[e.v]==d[u]+1&amp;&amp;(f=dfs(e.v,min(a,e.cap-e.flow)))&gt;0){
			edges[G[u][i]].flow+=f;
			edges[G[u][i]^1].flow-=f;
			flow+=f;a-=f;if(!a)break;
		}
	}return flow;
}
int dinic(){
	int flow=0,x;
	while(bfs()){
		memset(cur,0,sizeof cur);
		while(x=dfs(s,INT_MAX)){
			flow+=x;
			memset(cur,0,sizeof cur);
		}
	}return flow;
}
int n,m;
int mp[501][501],a[501][501];
const int dx[4]={0,0,1,-1};
const int dy[4]={1,-1,0,0};
int main(){
	s=0;t=maxn-1;
	long long sum=0;
	scanf("%d%d",&amp;n,&amp;m);int tot=0;
	for(int i=1;i&lt;=n;i++)for(int j=1;j&lt;=m;j++)mp[i][j]=++tot;
	for(int i=1;i&lt;=n;i++)for(int j=1;j&lt;=m;j++){
		int x;scanf("%d",&amp;x);
		add(s,mp[i][j],x);sum+=x;
	}
	for(int i=1;i&lt;=n;i++)for(int j=1;j&lt;=m;j++){
		int x;scanf("%d",&amp;x);
		add(mp[i][j],t,x);sum+=x;
	}
	for(int i=1;i&lt;=n;i++)for(int j=1;j&lt;=m;j++)scanf("%d",&amp;a[i][j]);
	for(int i=1;i&lt;=n;i++)for(int j=1;j&lt;=m;j++){
		add(s,++tot,a[i][j]);sum+=a[i][j];
		add(tot,mp[i][j],INT_MAX);
		for(int k=0;k&lt;4;k++){
			int x=i+dx[k],y=j+dy[k];
			if(x&lt;1||x&gt;n||y&lt;1||y&gt;m)continue;
			add(tot,mp[x][y],INT_MAX);
		}
	}for(int i=1;i&lt;=n;i++)for(int j=1;j&lt;=m;j++)scanf("%d",&amp;a[i][j]);
	for(int i=1;i&lt;=n;i++)for(int j=1;j&lt;=m;j++){
		add(++tot,t,a[i][j]);sum+=a[i][j];
		add(mp[i][j],tot,INT_MAX);
		for(int k=0;k&lt;4;k++){
			int x=i+dx[k],y=j+dy[k];
			if(x&lt;1||x&gt;n||y&lt;1||y&gt;m)continue;
			add(mp[x][y],tot,INT_MAX);
		}
	}
	cout&lt;&lt;sum-dinic()&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem3894</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=500*500+5;
struct edge{int u,v,cap,flow;};
vector&lt;edge&gt;edges;
vector&lt;int&gt;G[maxn];
int s,t;
int cur[maxn],d[maxn];
void add(int u,int v,int cap){
	edges.push_back((edge){u,v,cap,0});
	G[u].push_back(edges.size()-1);
	edges.push_back((edge){v,u,0,0});
	G[v].push_back(edges.size()-1);
}
bool bfs(){
	static int vis[maxn];
	memset(vis,0,sizeof vis);vis[s]=1;
	queue&lt;int&gt;q;q.push(s);d[s]=0;
	while(!q.empty()){
		int u=q.front();q.pop();
		for(int i=0;i&lt;G[u].size();i++){
			edge e=edges[G[u][i]];if(vis[e.v]||e.cap==e.flow)continue;
			d[e.v]=d[u]+1;vis[e.v]=1;q.push(e.v);
		}
	}return vis[t];
}
int dfs(int u,int a){
	if(u==t||!a)return a;
	int flow=0,f;
	for(int &amp;i=cur[u];i&lt;G[u].size();i++){
		edge e=edges[G[u][i]];
		if(d[e.v]==d[u]+1&amp;&amp;(f=dfs(e.v,min(a,e.cap-e.flow)))&gt;0){
			edges[G[u][i]].flow+=f;
			edges[G[u][i]^1].flow-=f;
			flow+=f;a-=f;if(!a)break;
		}
	}if(!flow)d[u]=-1;
	return flow;
}
int dinic(){
	int flow=0,x;
	while(bfs()){
		memset(cur,0,sizeof cur);
		while(x=dfs(s,INT_MAX)){
			flow+=x;
			memset(cur,0,sizeof cur);
		}
	}return flow;
}
int n,m;
int mp[501][501],a[501][501];
const int dx[4]={0,0,1,-1};
const int dy[4]={1,-1,0,0};
int main(){
	s=0;t=maxn-1;
	long long sum=0;
	scanf("%d%d",&amp;n,&amp;m);int tot=0;
	for(int i=1;i&lt;=n;i++)for(int j=1;j&lt;=m;j++)mp[i][j]=++tot;
	for(int i=1;i&lt;=n;i++)for(int j=1;j&lt;=m;j++){
		int x;scanf("%d",&amp;x);
		add(s,mp[i][j],x);sum+=x;
	}
	for(int i=1;i&lt;=n;i++)for(int j=1;j&lt;=m;j++){
		int x;scanf("%d",&amp;x);
		add(mp[i][j],t,x);sum+=x;
	}
	for(int i=1;i&lt;=n;i++)for(int j=1;j&lt;=m;j++)scanf("%d",&amp;a[i][j]);
	for(int i=1;i&lt;=n;i++)for(int j=1;j&lt;=m;j++){
		add(s,++tot,a[i][j]);sum+=a[i][j];
		add(tot,mp[i][j],INT_MAX);
		for(int k=0;k&lt;4;k++){
			int x=i+dx[k],y=j+dy[k];
			if(x&lt;1||x&gt;n||y&lt;1||y&gt;m)continue;
			add(tot,mp[x][y],INT_MAX);
		}
	}for(int i=1;i&lt;=n;i++)for(int j=1;j&lt;=m;j++)scanf("%d",&amp;a[i][j]);
	for(int i=1;i&lt;=n;i++)for(int j=1;j&lt;=m;j++){
		add(++tot,t,a[i][j]);sum+=a[i][j];
		add(mp[i][j],tot,INT_MAX);
		for(int k=0;k&lt;4;k++){
			int x=i+dx[k],y=j+dy[k];
			if(x&lt;1||x&gt;n||y&lt;1||y&gt;m)continue;
			add(mp[x][y],tot,INT_MAX);
		}
	}
	cout&lt;&lt;sum-dinic()&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem3907</h2><pre>n,m=map(int,raw_input().split())
fac=[1]*10001
n+=1
for i in range(1,n+m+1):fac[i]=fac[i-1]*i
def C(n,m):return fac[n]/fac[m]/fac[n-m]
print C(n+m,n)-2*C(n+m-1,m-1)
</pre><pre></pre><h2>Problem3910</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=500001;
struct sgt{
	#define lson i&lt;&lt;1,l,(l+r)/2
	#define rson i&lt;&lt;1|1,(l+r)/2+1,r
	#define ls i&lt;&lt;1
	#define rs i&lt;&lt;1|1
	struct node{
		int lazy,sum;
		node(){lazy=-1;}
	}t[maxn&lt;&lt;2];
	void rz(int i){
		t[i].sum=t[ls].sum+t[rs].sum;
	}
	void pd(int i,int l,int r){
		if(t[i].lazy!=-1){
			t[ls].sum=0;
			t[rs].sum=0;
			t[ls].lazy=0;
			t[rs].lazy=0;
			t[i].lazy=-1;
		}
	}
	void build(int i,int l,int r){
		if(l==r){t[i].sum=1;return;}
		build(lson);build(rson);rz(i);
	}
	void set0(int i,int l,int r,int l0,int r0){
		if(l0&gt;r0)swap(l0,r0);
		if(l0&lt;=l&amp;&amp;r0&gt;=r){t[i].sum=t[i].lazy=0;return;}pd(i,l,r);
		if(l0&lt;=(l+r)/2)set0(lson,l0,r0);
		if(r0&gt;(l+r)/2)set0(rson,l0,r0);
		rz(i);
	}
	int get(int i,int l,int r,int ps){
		if(l==r)return t[i].sum;pd(i,l,r);
		if(ps&lt;=(l+r)/2)return get(lson,ps);
		else return get(rson,ps);	
	}
}T;
vector&lt;int&gt;G[maxn];
int fa[maxn],top[maxn],siz[maxn],son[maxn],mp[maxn],z,dep[maxn],n,m,a,b;
void dfs(int u){
	siz[u]=1;
	for(int i=0;i&lt;G[u].size();i++){
		int v=G[u][i];
		if(v!=fa[u]){
			fa[v]=u;dep[v]=dep[u]+1;
			dfs(v);
			siz[u]+=siz[v];
			if(siz[son[u]]&lt;siz[v])son[u]=v;
		}
	}
}
void build(int u,int tp){
	top[u]=tp;mp[u]=++z;
	if(son[u])build(son[u],tp);
	for(int v,i=0;i&lt;G[u].size();i++)if((v=G[u][i])!=son[u]&amp;&amp;v!=fa[u])build(v,v);
}
int dis(int u,int v){
	int ans=0;
	while(top[u]!=top[v]){
		if(dep[top[u]]&lt;dep[top[v]])swap(u,v);
		ans+=dep[u]-dep[fa[top[u]]];
		 u=fa[top[u]];	
	}if(dep[u]&gt;dep[v])swap(u,v);
	return ans+dep[v]-dep[u];
}
void set0(int u,int v){
	while(top[u]!=top[v]){
		if(dep[top[u]]&lt;dep[top[v]])swap(u,v);
		T.set0(1,1,n,mp[top[u]],mp[u]);
		u=fa[top[u]];	
	}if(dep[u]&gt;dep[v])swap(u,v);
	T.set0(1,1,n,mp[u],mp[v]);
}
int main(){
	scanf("%d%d%d",&amp;n,&amp;m,&amp;a);
	for(int i=1;i&lt;n;i++){
		int u,v;scanf("%d%d",&amp;u,&amp;v);
		G[u].push_back(v);
		G[v].push_back(u);
	}dfs(1);build(1,1);T.build(1,1,n);
	long long ans=0;
	while(m--){
		scanf("%d",&amp;b);
		if(!T.get(1,1,n,mp[b]))continue;
		int res=dis(a,b);
		set0(a,b);
		//cerr&lt;&lt;a&lt;&lt;"-&gt;"&lt;&lt;b&lt;&lt;" "&lt;&lt;res&lt;&lt;endl;
		a=b;ans+=res;
	}cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem3916</h2><pre>/**
 * A valid solution for task FRIENDS.
 *
 * Author: Marijonas Petrauskas
 */

#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

string try_candidate(const string &amp;s, int orig_start, int orig_len, int modified_start) {
	bool was_mismatch = false;
	int orig = orig_start, mod = modified_start, i = 0;
	while (i &lt; orig_len) {
		if (s[orig] != s[mod]) {
			if (was_mismatch)
				return string();
			was_mismatch = true;
			mod++;
		} else
			orig++, mod++, i++;
	}
	return s.substr(orig_start, orig_len);
}

int main() {
	string final;
	int N;
	cin &gt;&gt; N;
	cin &gt;&gt; final;
	int orig_len = (final.length() - 1) / 2;
	const string&amp;
		pos1 = try_candidate(final, orig_len + 1, orig_len, 0),
		pos2 = try_candidate(final, 0, orig_len, orig_len);
	if ( (pos1.empty() &amp;&amp; pos2.empty()) || (final.size() % 2 == 0))
		cout &lt;&lt; "NOT POSSIBLE" &lt;&lt; endl;
	else if (pos1.empty())
		cout &lt;&lt; pos2 &lt;&lt; endl;
	else if (pos2.empty())
		cout &lt;&lt; pos1 &lt;&lt; endl;
	else if (pos1 != pos2)
		cout &lt;&lt; "NOT UNIQUE" &lt;&lt; endl;
	else 
		cout &lt;&lt; pos1 &lt;&lt; endl;
	return 0;
}</pre><pre></pre><h2>Problem3918</h2><pre>/*
Official solution for postmen. 
Complexity O(N + M)
Author: Kestutis Vilcinskas
*/
#include &lt;cstdio&gt;
#include &lt;set&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
using namespace std;
const int MaxN = 500010,
	  	  MaxM = 2*500010;


int E[MaxM][3];
int pr[MaxN] = {0};

int P[MaxN], tmp[MaxN] = {0}, C[MaxN];
int k[MaxM];

int N, M, a, b;

bool visited[MaxN] = {0};
vector&lt;int&gt; path;

int newv = -1, u;

int getU (int i, int v) {
	return (v == E[i][0]) ? E[i][1] : E[i][0];
}


void dfs(int v) {
	path.clear();
	path.push_back(v);	
	while (v != -1) {
		//printf("V = %d!!!\n", v);
		visited[v] = true;
		newv = -1;
		for (; pr[v] &lt; C[v]; pr[v]++) {
			int i = k[P[v] + pr[v]];
				if (E[i][2] == false) {
					u = getU(i, v);
					E[i][2] = true;
					if (visited[u]) {
						newv = u;
						while (path.back() != u) {
						       	printf("%d ", path.back());
							visited[path.back()] = false;
							path.pop_back();
						}
						printf("%d\n", path.back());
					}else {
						newv = u;
						path.push_back(u);
					}
					break;
				}
		}
		if (newv == -1 and path.size() &gt; 1) {
			newv = path.back();
			path.pop_back();
		}
		v =newv;
	}
	visited[path[0]] = false;
	//for (int i = 0; i &lt; path.size(); i++)
	//	visited[path[i]] = false;
}



int main() {
	path.reserve(MaxN);	
	scanf("%d%d\n", &amp;N, &amp;M);
	for (int i = 0; i &lt; M; i++) {
		scanf("%d%d", &amp;E[i][0], &amp;E[i][1]);
		C[E[i][0]]++;
		C[E[i][1]]++;
	}
    
	P[1] = 0;
	for (int i = 2; i &lt;= N; i++) {
		P[i] = P[i-1] + C[i-1];
	}
	for (int i = 0; i &lt; M; i++) {
		a = E[i][0]; b = E[i][1];
		k[P[a] + tmp[a]] = i;
		k[P[b] + tmp[b]] = i;
		tmp[a]++;
		tmp[b]++;
	}
	for (int i = 1; i &lt;= N; i++) {
		dfs(i);
		
		}
	return 0;
}</pre><pre></pre><h2>Problem3922</h2><pre>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cctype&gt;
#include&lt;cmath&gt;
#include&lt;map&gt;
#include&lt;ctime&gt;
#include&lt;climits&gt;
#define m_p make_pair
using namespace std;
const int maxn=70010;
const int sqrtmaxn=(int)(300.0/10);
int getint(){
	int res=0,f=1;char c=getchar();
	while(!isdigit(c))f=c=='-'?-1:f,c=getchar();
	while(isdigit(c))res=res*10+c-'0',c=getchar();
	return res*f;
}
struct node{
	int l,r,mx;
	void rz();
}t[int(maxn*sqrtmaxn)];
int tot;
int n,a[maxn],sqrtn;
void node::rz(){
	if(!l&amp;&amp;!r)return;
	mx=INT_MIN;
	if(l)mx=max(mx,t[l].mx);
	if(r)mx=max(mx,t[r].mx);
}
struct sgt{
	int root,_n;
	#define lson t[i].l,l,(l+r)/2
	#define rson t[i].r,(l+r)/2+1,r
	void build(int &amp;i,int l,int r,int x0,int d){
		if(!i)i=++tot;
		if(l==r){t[i].mx=a[x0+l*d];return;}
		build(lson,x0,d);build(rson,x0,d);t[i].rz();
	}
	void C(int i,int l,int r,int ps,int v){
		if(l==r){t[i].mx+=v;return;}
		if(ps&lt;=(l+r)/2)C(lson,ps,v);
		else C(rson,ps,v);t[i].rz();
	}
	int Q(int i,int l,int r,int l0,int r0){
		if(l0&lt;=l&amp;&amp;r0&gt;=r)return t[i].mx;
		int ans=INT_MIN;
		if(l0&lt;=(l+r)/2)ans=max(ans,Q(lson,l0,r0));
		if(r0&gt;(l+r)/2)ans=max(ans,Q(rson,l0,r0));
		return ans;
	}
	int Q(int l){return Q(root,0,_n,l,_n);}
	void C(int ps,int v){C(root,0,_n,ps,v);}
	void build(int n,int x0,int d){_n=n;root=0;build(root,0,n,x0,d);}
};
sgt* M[sqrtmaxn][sqrtmaxn];
int main(){
	n=getint();sqrtn=ceil(sqrt(n)/30);
	//sqrtn=n;
	for(int i=1;i&lt;=n;i++)a[i]=getint();
	/*for(int d=1;d&lt;=sqrtn;d++){
		for(int x0=0;x0&lt;d;x0++){
			M[d][x0]=new sgt();
			M[d][x0]-&gt;build((n-x0)/d,x0,d);
		}
	}*/
	int m=getint();
	while(m--){
		int op=getint();
		if(!op){
			int p=getint(),v=getint();			
			for(int d=1;d&lt;=sqrtn;d++){
				if(!M[d][p%d])M[d][p%d]=new sgt(),M[d][p%d]-&gt;build((n-p%d)/d,p%d,d);
				M[d][p%d]-&gt;C(p/d,v);
			}a[p]+=v;
		}else{
			int x0=getint(),d=getint();
			if(d&lt;=sqrtn){
				if(!M[d][x0%d])M[d][x0%d]=new sgt(),M[d][x0%d]-&gt;build((n-x0%d)/d,x0%d,d);
				printf("%d\n",M[d][x0%d]-&gt;Q(x0/d));
			}else{
				int mx=a[x0];
				while(x0+d&lt;=n){
					x0+=d;
					mx=max(mx,a[x0]);
				}printf("%d\n",mx);
			}
		}
	}//cerr&lt;&lt;clock()/(double)CLOCKS_PER_SEC&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem3926</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
const int maxn=1e5+5;
int n,C,c[maxn],in[maxn],mp[maxn];
vector&lt;int&gt;G[maxn];
LL ans=0;
struct node{
	int val;
	node *go[20],*f;
}pool[maxn*20],*cur=pool,*root;
node *la[maxn*20];
node* newnode(){
	node *x=cur++;
	return x;
}
node* add(node *last,int w){
	node *p=last;
	if(p-&gt;go[w]&amp;&amp;p-&gt;val+1==p-&gt;go[w]-&gt;val)return p-&gt;go[w];
	node *np=newnode();
	np-&gt;val=p-&gt;val+1;
	while(p&amp;&amp;!p-&gt;go[w])p-&gt;go[w]=np,p=p-&gt;f;
	if(!p)np-&gt;f=root;
	else{
		node *q=p-&gt;go[w];
		if(p-&gt;val+1==q-&gt;val)np-&gt;f=q;
		else{
			node *nq=newnode();nq-&gt;val=p-&gt;val+1;
			memcpy(nq-&gt;go,q-&gt;go,sizeof(q-&gt;go));
			nq-&gt;f=q-&gt;f;
			q-&gt;f=np-&gt;f=nq;
			while(p&amp;&amp;p-&gt;go[w]==q)p-&gt;go[w]=nq,p=p-&gt;f;
		}
	}return np;
}
void dfs(int u,int fa){
	la[u]=add(la[fa],c[u]);
	for(int i=0;i&lt;G[u].size();i++){
		int v=G[u][i];
		if(v==fa)continue;
		dfs(v,u);
	}
}
int vis[maxn*20];
void dfs(node *u){
	if(vis[u-pool])return;
	vis[u-pool]=1;if(u-&gt;f)ans+=u-&gt;val-u-&gt;f-&gt;val;
	for(int i=0;i&lt;C;i++)if(u-&gt;go[i])
		dfs(u-&gt;go[i]);
}
int main(){
	root=newnode();
	scanf("%d%d",&amp;n,&amp;C);
	for(int i=1;i&lt;=n;i++)scanf("%d",&amp;c[i]);
	for(int i=1;i&lt;n;i++){
		int u,v;scanf("%d%d",&amp;u,&amp;v);
		G[u].push_back(v);
		G[v].push_back(u);
		in[u]++;in[v]++;
	}la[0]=root;
	for(int i=1;i&lt;=n;i++)if(in[i]==1)
		dfs(i,0);
	dfs(root);
	cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem3928</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
int n;
struct alien{
	int s,t,r;
}a[305];
int f[605][605],tmp[605],T;
int vis[605][605];
int solve(int l,int r){
	if(vis[l][r])return f[l][r];vis[l][r]=1;
	int ps=-1;
	for(int i=1;i&lt;=n;i++)if(l&lt;a[i].s&amp;&amp;a[i].t&lt;r&amp;&amp;(ps==-1||a[ps].r&lt;a[i].r))ps=i;
	if(ps==-1)return f[l][r]=0;
	f[l][r]=INT_MAX;
	for(int i=a[ps].s;i&lt;=a[ps].t;i++)
		f[l][r]=min(f[l][r],a[ps].r+solve(l,i)+solve(i,r));
	return f[l][r];
}
int main(){
	int _;scanf("%d",&amp;_);
	while(_--){
		scanf("%d",&amp;n);T=0;
		memset(vis,0,sizeof vis);
		for(int i=1;i&lt;=n;i++){
			scanf("%d%d%d",&amp;a[i].s,&amp;a[i].t,&amp;a[i].r);
			tmp[++T]=a[i].s;
			tmp[++T]=a[i].t;
		}sort(tmp+1,tmp+1+T);
		T=unique(tmp+1,tmp+1+T)-tmp-1;
		for(int i=1;i&lt;=n;i++)
			a[i].s=lower_bound(tmp+1,tmp+1+T,a[i].s)-tmp,
			a[i].t=lower_bound(tmp+1,tmp+1+T,a[i].t)-tmp;
		T++;
		cout&lt;&lt;solve(0,T)&lt;&lt;endl;
	}
	return 0;
}</pre><pre></pre><h2>Problem3931</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1050;
typedef long long LL;
struct edge{LL u,v;LL cap,flow;};
vector&lt;edge&gt;edges;
vector&lt;LL&gt;G[maxn];
LL s,t,n,m;
LL cur[maxn];
LL d[maxn];
void add(LL u,LL v,LL cap){
//	cerr&lt;&lt;u&lt;&lt;" "&lt;&lt;v&lt;&lt;" "&lt;&lt;cap&lt;&lt;endl;
	edges.push_back((edge){u,v,cap,0});
	G[u].push_back(edges.size()-1);
	edges.push_back((edge){v,u,0,0});
	G[v].push_back(edges.size()-1);
}
bool bfs(){
	static LL vis[maxn];
	memset(vis,0,sizeof vis);vis[s]=1;
	queue&lt;LL&gt;q;q.push(s);d[s]=0;
	while(!q.empty()){
		LL u=q.front();q.pop();
		for(LL i=0;i&lt;G[u].size();i++){
			edge e=edges[G[u][i]];if(vis[e.v]||e.cap==e.flow)continue;
			d[e.v]=d[u]+1;vis[e.v]=1;q.push(e.v);
		}
	}return vis[t];
}
LL dfs(LL u,LL a){
	if(u==t||!a)return a;
	LL flow=0,f;
	for(LL &amp;i=cur[u];i&lt;G[u].size();i++){
		edge e=edges[G[u][i]];
		if(d[e.v]==d[u]+1&amp;&amp;(f=dfs(e.v,min(a,e.cap-e.flow)))&gt;0){
			edges[G[u][i]].flow+=f;
			edges[G[u][i]^1].flow-=f;
			flow+=f;a-=f;if(!a)break;
		}
	}return flow;
}
LL dinic(){
	LL flow=0,x;
	while(bfs()){
		memset(cur,0,sizeof cur);
		while(x=dfs(s,1e15)){
			flow+=x;
			memset(cur,0,sizeof cur);
		}
	}return flow;
}
namespace SP{
	struct edge{
		LL u,v;LL w;
	};
	vector&lt;edge&gt;E;
	vector&lt;LL&gt;G[maxn];
	void add(LL u,LL v,LL w){
		E.push_back((edge){u,v,w});
		G[u].push_back(E.size()-1);
		E.push_back((edge){v,u,w});
		G[v].push_back(E.size()-1);
	}
	LL d[maxn];
	void spfa(){
		static LL vis[maxn];
		memset(vis,0,sizeof vis);vis[1]=1;
		for(LL i=1;i&lt;=n;i++)d[i]=1e15;
		d[1]=0;
		queue&lt;LL&gt;q;q.push(1);vis[1]=1;
		while(!q.empty()){
			LL u=q.front();q.pop();vis[u]=0;
			for(LL i=0;i&lt;G[u].size();i++){
				edge e=E[G[u][i]];
				if(d[e.v]&gt;d[u]+e.w){
					d[e.v]=d[u]+e.w;
					if(!vis[e.v])q.push(e.v),vis[e.v]=1;
				}
			}
		}
		for(LL i=0;i&lt;E.size();i++){
			LL u=E[i].u,v=E[i].v;LL w=E[i].w;
			if(d[u]+w==d[v])
				::add(u*2,v*2-1,1e15);
		}
	}
}
int main(){
	scanf("%lld%lld",&amp;n,&amp;m);
	for(LL i=1;i&lt;=m;i++){
		LL u,v;LL w;scanf("%lld%lld%lld",&amp;u,&amp;v,&amp;w);
		SP::add(u,v,w);
	}SP::spfa();
	s=2;t=n*2-1;
	for(LL i=1;i&lt;=n;i++){
		LL c;
		scanf("%lld",&amp;c);
		add(i*2-1,i*2,c);
	}
	cout&lt;&lt;dinic()&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem3935</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
int dcmp(double x){return (x&gt;1e-6)-(x&lt;-1e-6);}
double a[1050][550];
int n,m;
int C[505],x;
void pivot(int l,int e){
	for(int i=0;i&lt;=n;i++)if(i!=e)
		a[l][i]/=a[l][e];
	a[l][e]=1/a[l][e];
	for(int i=0;i&lt;=m;i++)if(i!=l){
		if(!dcmp(a[i][e]))continue;
		for(int j=0;j&lt;=n;j++)if(j!=e)
			a[i][j]-=a[i][e]*a[l][j];
		a[i][e]*=-a[l][e];
	}
}
double simplex(){
	while(1){
		int l=1,e=1;
		for(int i=1;i&lt;=m;i++)if(a[i][0]&lt;a[l][0])l=i;
		if(dcmp(a[l][0])&gt;=0)break;
		for(int i=1;i&lt;=n;i++)if(a[l][i]&lt;a[l][e])e=i;
		if(dcmp(a[l][e])&gt;=0){puts("-1");exit(0);}
		pivot(l,e);
	}
	while(1){
		int l=1,e=1;
		for(int i=1;i&lt;=n;i++)if(a[0][i]&gt;a[0][e])e=i;
		if(dcmp(a[0][e])&lt;=0)return -a[0][0];
		for(int i=1;i&lt;=m;i++)if(dcmp(a[i][e])&gt;0&amp;&amp;a[i][0]*a[l][e]&lt;a[i][e]*a[l][0])l=i;
		if(dcmp(a[l][e])&lt;=0){puts("-1");exit(0);}
		pivot(l,e);
	}
}
vector&lt;pair&lt;int,int&gt; &gt;G[505];
int d[505];
void bfs(int s,double a[550]){
	queue&lt;int&gt;q;q.push(s);a[s]=-1;d[s]=0;
	while(!q.empty()){
		int u=q.front();q.pop();
		for(int i=0;i&lt;G[u].size();i++){
			int v=G[u][i].first,w=G[u][i].second;
			if(a[v]||d[u]+w&gt;x)continue;
			a[v]=-1;d[v]=d[u]+w;q.push(v);
		}
	}
}
int main(){
	scanf("%d%d",&amp;n,&amp;x);
	for(int i=1;i&lt;=n;i++)scanf("%d",&amp;C[i]);
	for(int i=1;i&lt;n;i++){
		int u,v,w;scanf("%d%d%d",&amp;u,&amp;v,&amp;w);
		G[u].push_back(make_pair(v,w));
		G[v].push_back(make_pair(u,w));
	}m=n;
	for(int i=1;i&lt;=n;i++)
		a[0][i]=-(!C[i]);
	for(int i=1;i&lt;=n;i++)
		bfs(i,a[i]),a[i][0]=-1;
	m++;
	for(int i=1;i&lt;=n;i++)
		a[m][i]=1;a[m][0]=accumulate(C+1,C+1+n,0);
	m++;
	for(int i=1;i&lt;=n;i++)
		a[m][i]=-1;a[m][0]=-accumulate(C+1,C+1+n,0);
	for(int i=1;i&lt;=n;i++)
		m++,a[m][i]=1,a[m][0]=1;			
	int ans=-simplex()+.5;
	cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem3944</h2><pre>#include&lt;bits/stdc++.h&gt;
#include&lt;ext/hash_map&gt;
using namespace std;
typedef long long LL;
const int maxn=4e6+6;
//const int maxn=5;
int p[maxn],notp[maxn],Mx;
LL phi[maxn],u[maxn];
void init(int maxn){
	u[1]=phi[1]=1;
	for(int i=2;i&lt;maxn;i++){
		if(!notp[i]){
			p[++p[0]]=i;
			phi[i]=i-1;u[i]=-1;
		}
		for(int j=1;j&lt;=p[0]&amp;&amp;p[j]*i&lt;maxn;j++){
			notp[i*p[j]]=1;
			if(i%p[j]==0){
				phi[i*p[j]]=phi[i]*p[j];
				u[i*p[j]]=0;
				break;
			}else{
				phi[i*p[j]]=phi[i]*(p[j]-1);
				u[i*p[j]]=-u[i];
			}
		}
	}for(int i=2;i&lt;maxn;i++)u[i]+=u[i-1],phi[i]+=phi[i-1];
}
__gnu_cxx::hash_map&lt;int,LL&gt;_phi,_u;
LL Phi(LL x){
	if(x&lt;Mx)return phi[x];
	if(_phi.count(x))return _phi[x];
	LL ans=(LL)x*(x+1)/2;
	for(LL i=2,j;i&lt;=x;i=j+1){
		j=x/(x/i);
		ans-=(LL)(j-i+1)*Phi(x/i);
	}return _phi[x]=ans;
}
LL U(LL x){
	if(x&lt;Mx)return u[x];
	if(_u.count(x))return _u[x];
	LL ans=1;
	for(LL i=2,j;i&lt;=x;i=j+1){
		j=x/(x/i);
		ans-=(LL)(j-i+1)*U(x/i);
	}return _u[x]=ans;	
}
int main(){
	int T;scanf("%d",&amp;T);
	vector&lt;int&gt;vec;
	for(int i=1;i&lt;=T;i++){
		int x;cin&gt;&gt;x;
		vec.push_back(x);
	}
	init(Mx=2*(int)pow(*max_element(vec.begin(),vec.end()),2.0/3.0));
	for(int i=0;i&lt;T;i++){
		int n=vec[i];
		//printf("%lld %lld",Phi(n),U(n));
		//puts("");
		cout&lt;&lt;Phi(n)&lt;&lt;" "&lt;&lt;U(n)&lt;&lt;endl;
	}
	return 0;
}</pre><pre></pre><h2>Problem3991</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1e5+5;
typedef long long LL;
int siz[maxn],son[maxn],top[maxn],fa[maxn],dep[maxn],dfn[maxn],z;
vector&lt;pair&lt;int,int&gt; &gt;G[maxn];
LL dis[maxn];
void dfs(int u){
	siz[u]=1;
	for(int i=0;i&lt;G[u].size();i++){
		int v=G[u][i].first,w=G[u][i].second;
		if(v==fa[u])continue;
		fa[v]=u;dep[v]=dep[u]+1;dis[v]=dis[u]+w;
		dfs(v);
		siz[u]+=siz[v];
		if(siz[son[u]]&lt;siz[v])son[u]=v;
	}
}
void build(int u,int tp){
	dfn[u]=++z;top[u]=tp;
	if(son[u])build(son[u],tp);
	for(int i=0;i&lt;G[u].size();i++){
		int v=G[u][i].first;
		if(v!=son[u]&amp;&amp;v!=fa[u])build(v,v);
	}
}
LL len(int u,int v){
	LL ans=0;
	while(top[u]!=top[v]){
		if(dep[top[u]]&lt;dep[top[v]])swap(u,v);
		ans+=dis[u]-dis[fa[top[u]]];
		u=fa[top[u]];
	}if(dep[u]&gt;dep[v])swap(u,v);
	return ans+dis[v]-dis[u];
}
int n,m;
struct cmp{
	bool operator()(int x,int y)const{
		return dfn[x]&lt;dfn[y];
	}
};
set&lt;int,cmp&gt;S;
set&lt;int,cmp&gt;::iterator it,pre,nxt;
int getint(){
	int res=0;char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))res=res*10+c-'0',c=getchar();
	return res;
}
int main(){
//	freopen("game.in","r",stdin);
//	freopen("game.out","w",stdout);
	scanf("%d%d",&amp;n,&amp;m);
	for(int i=1;i&lt;n;i++){
		int u=getint(),v=getint(),w=getint();//scanf("%d%d%d",&amp;u,&amp;v,&amp;w);
		G[u].push_back(make_pair(v,w));
		G[v].push_back(make_pair(u,w));
	}dfs((n+1)/2);
	build((n+1)/2,(n+1)/2);
	LL ans=0;
	while(m--){
		int x=getint();
		if(S.count(x)){
			if(S.size()==1){S.erase(x);puts("0");continue;}
			it=S.find(x);
			pre=it==S.begin()?--S.end():--it;
			it=S.find(x);
			nxt=it==--S.end()?S.begin():++it;
			it=S.find(x);
			ans-=len(*pre,x)+len(x,*nxt);
			ans+=len(*pre,*nxt);
			S.erase(x);
		}else{
			if(S.size()==0){S.insert(x);puts("0");continue;}
			S.insert(x);
			it=S.find(x);
			pre=it==S.begin()?--S.end():--it;
			it=S.find(x);
			nxt=it==--S.end()?S.begin():++it;
			it=S.find(x);
			ans+=len(*pre,x)+len(x,*nxt);
			ans-=len(*pre,*nxt);
		}printf("%lld\n",ans);
	}//cerr&lt;&lt;clock()&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem3992</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
const LL mo=1004535809;
const int maxn=16405;
int n,m,S,g,N;
bool ok(int x){
	static int vis[maxn];
	int cur=1;
	for(int i=0;i&lt;m-1;i++){
		if(vis[cur]==x)return 0;
		vis[cur]=x;
		cur=cur*x%m;
	}return 1;
}
int idx[maxn];
LL pw(LL x,LL k,LL p=mo){
	LL ans=1;
	for(;k;k&gt;&gt;=1){
		if(k&amp;1)ans=ans*x%p;
		x=x*x%p;	
	}return ans;
}
void FNT(int a[],int n,int ty){
	static LL tmp[maxn];
	if(n==1)return ;
	for(int i=0;i&lt;n;i+=2)
		tmp[i&gt;&gt;1]=a[i],tmp[i+n&gt;&gt;1]=a[i+1];
	for(int i=0;i&lt;n;i++)a[i]=tmp[i];
	int *l=a,*r=a+(n&gt;&gt;1);
	FNT(l,n&gt;&gt;1,ty);FNT(r,n&gt;&gt;1,ty);
	LL w=1,wn=pw(3,(LL)ty*(mo-1)/n%(mo-1),mo);
	for(int i=0;i&lt;n/2;i++,w=w*wn%mo)
		tmp[i]=(l[i]+(LL)w*r[i]%mo)%mo,tmp[i+n/2]=(l[i]+mo-(LL)w*r[i]%mo)%mo;
	for(int i=0;i&lt;n;i++)a[i]=tmp[i];
}
struct Poly{
	int a[maxn];
	int at(int x)const{return a[x];}
	void clear(){memset(a,0,sizeof a);}
	int&amp; operator[](int x){return a[x];}
	Poly(){}
}a,tmp,res;

Poly operator*(const Poly &amp;ls,const Poly &amp;rs){
	static int a[maxn],b[maxn];tmp.clear();
	for(int i=0;i&lt;N;i++)a[i]=ls.at(i),b[i]=rs.at(i);
	tmp.clear();
	FNT(a,N,1);
	FNT(b,N,1);
	for(int i=0;i&lt;N;i++)
	tmp[i]=(LL)a[i]*b[i]%mo;
	FNT(tmp.a,N,mo-2);
	for(int i=0;i&lt;m-1;i++)
	tmp[i]=(tmp[i]+tmp[i+m-1])%mo,tmp[i+m-1]=0;
	LL inv=pw(N,mo-2,mo);
	for(int i=0;i&lt;m-1;i++)tmp[i]=tmp[i]*inv%mo;
	return tmp;
}
Poly x;
Poly pw(const Poly &amp;_x,LL k){
	res.clear();res[0]=1;x=_x;
	for(;k;k&gt;&gt;=1){
		if(k&amp;1)res=res*x;
		x=x*x;
	}return res;
}
int main(){
	int x;
	scanf("%d%d%d%d",&amp;n,&amp;m,&amp;x,&amp;S);
	for(int i=2;i&lt;m;i++)if(ok(i)){g=i;break;}
	for(int x=1,i=0;i&lt;m-1;i++,x=x*g%m)idx[x]=i;
	for(N=1;N&lt;m;N&lt;&lt;=1);N&lt;&lt;=1;
	for(int i=0;i&lt;S;i++){
		int y;scanf("%d",&amp;y);
		if(y)a[idx[y]]=1;
	}
	a=pw(a,n);
	cout&lt;&lt;a.at(idx[x])&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem3993</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=123;
const double eps=1e-5;
struct edge{int u,v;double cap,flow;};
int dcmp(double x){return (x&gt;eps)-(x&lt;-eps);}
vector&lt;edge&gt;edges;
vector&lt;int&gt;G[maxn];
int s,t;
int cur[maxn],d[maxn];
double sum=0;
void add(int u,int v,double cap){
	edges.push_back((edge){u,v,cap,0});
	G[u].push_back(edges.size()-1);
	edges.push_back((edge){v,u,0,0});
	G[v].push_back(edges.size()-1);
}
bool bfs(){
	static int vis[maxn];
	memset(vis,0,sizeof vis);vis[s]=1;
	queue&lt;int&gt;q;q.push(s);d[s]=0;
	while(!q.empty()){
		int u=q.front();q.pop();
		for(int i=0;i&lt;G[u].size();i++){
			edge e=edges[G[u][i]];if(vis[e.v]||!dcmp(e.cap-e.flow))continue;
			d[e.v]=d[u]+1;vis[e.v]=1;q.push(e.v);
		}
	}return vis[t];
}
double dfs(int u,double a){
	if(u==t||!dcmp(a))return a;
	double flow=0,f;
	for(int &amp;i=cur[u];i&lt;G[u].size();i++){
		edge e=edges[G[u][i]];
		if(d[e.v]==d[u]+1&amp;&amp;dcmp(f=dfs(e.v,min(a,e.cap-e.flow)))&gt;0){
			edges[G[u][i]].flow+=f;
			edges[G[u][i]^1].flow-=f;
			flow+=f;a-=f;if(!a)break;
		}
	}return flow;
}
double dinic(){
	double flow=0,x;
	while(bfs()){
		memset(cur,0,sizeof cur);
		while(dcmp(x=dfs(s,1e9))){
			flow+=x;
			memset(cur,0,sizeof cur);
		}
	}return flow;
}
int n,m;
double A[51],B[51];
int _A[51][51];
bool ok(double tim){
	edges.clear();
	for(int i=0;i&lt;=n*2+1;i++)G[i].clear();
	s=0;t=m+n+1;
	for(int i=1;i&lt;=m;i++)
	add(s,i,B[i]*tim);
	for(int i=1;i&lt;=n;i++)
	add(m+i,t,A[i]);
	for(int i=1;i&lt;=m;i++)
	for(int j=1;j&lt;=n;j++)if(_A[i][j])
	add(i,m+j,1e9);
	return dinic()&gt;=sum;
}
int main(){
	scanf("%d%d",&amp;n,&amp;m);
	for(int i=1;i&lt;=n;i++)scanf("%lf",&amp;A[i]);
	for(int i=1;i&lt;=m;i++)scanf("%lf",&amp;B[i]);
	for(int i=1;i&lt;=m;i++)for(int j=1;j&lt;=n;j++)scanf("%d",&amp;_A[i][j]);
	double l=0,r=5e6;
	sum=accumulate(A+1,A+1+n,0.0);
	while(dcmp(r-l)){
		double mid=(l+r)/2;
		if(ok(mid))
			r=mid;
		else l=mid;
	}printf("%.6lf\n",l);
	return 0;
}</pre><pre></pre><h2>Problem3993</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=123;
const double eps=1e-10;
struct edge{int u,v;double cap,flow;};
int dcmp(double x){return (x&gt;eps)-(x&lt;-eps);}
vector&lt;edge&gt;edges;
vector&lt;int&gt;G[maxn];
int s,t;
int cur[maxn],d[maxn];
double sum=0;
void add(int u,int v,double cap){
	edges.push_back((edge){u,v,cap,0});
	G[u].push_back(edges.size()-1);
	edges.push_back((edge){v,u,0,0});
	G[v].push_back(edges.size()-1);
}
bool bfs(){
	static int vis[maxn];
	memset(vis,0,sizeof vis);vis[s]=1;
	queue&lt;int&gt;q;q.push(s);d[s]=0;
	while(!q.empty()){
		int u=q.front();q.pop();
		for(int i=0;i&lt;G[u].size();i++){
			edge e=edges[G[u][i]];if(vis[e.v]||!dcmp(e.cap-e.flow))continue;
			d[e.v]=d[u]+1;vis[e.v]=1;q.push(e.v);
		}
	}return vis[t];
}
double dfs(int u,double a){
	if(u==t||!dcmp(a))return a;
	double flow=0,f;
	for(int &amp;i=cur[u];i&lt;G[u].size();i++){
		edge e=edges[G[u][i]];
		if(d[e.v]==d[u]+1&amp;&amp;dcmp(f=dfs(e.v,min(a,e.cap-e.flow)))&gt;0){
			edges[G[u][i]].flow+=f;
			edges[G[u][i]^1].flow-=f;
			flow+=f;a-=f;if(!a)break;
		}
	}return flow;
}
double dinic(){
	double flow=0,x;
	while(bfs()){
		memset(cur,0,sizeof cur);
		while(dcmp(x=dfs(s,1e9))){
			flow+=x;
			memset(cur,0,sizeof cur);
		}
	}return flow;
}
int n,m;
double A[51],B[51];
int _A[51][51];
bool ok(double tim){
	edges.clear();
	for(int i=0;i&lt;=n*2+1;i++)G[i].clear();
	s=0;t=m+n+1;
	for(int i=1;i&lt;=m;i++)
	add(s,i,B[i]*tim);
	for(int i=1;i&lt;=n;i++)
	add(m+i,t,A[i]);
	for(int i=1;i&lt;=m;i++)
	for(int j=1;j&lt;=n;j++)if(_A[i][j])
	add(i,m+j,1e9);
	return dinic()&gt;=sum;
}
int main(){
	scanf("%d%d",&amp;n,&amp;m);
	for(int i=1;i&lt;=n;i++)scanf("%lf",&amp;A[i]);
	for(int i=1;i&lt;=m;i++)scanf("%lf",&amp;B[i]);
	for(int i=1;i&lt;=m;i++)for(int j=1;j&lt;=n;j++)scanf("%d",&amp;_A[i][j]);
	double l=0,r=5e6;
	sum=accumulate(A+1,A+1+n,0.0);
	while(dcmp(r-l)){
		double mid=(l+r)/2;
		if(ok(mid))
			r=mid;
		else l=mid;
	}printf("%.6lf\n",l);
	return 0;
}</pre><pre></pre><h2>Problem3994</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=5e4+4;
int n,m,T;
int u[maxn],d[maxn],p[maxn],notp[maxn];
int main(){
	scanf("%d",&amp;T);
	u[1]=1;
	for(int i=1;i&lt;maxn;i++)d[i]++;
	for(int i=2;i&lt;maxn;i++){
		if(!notp[i]){u[i]=-1;p[++p[0]]=i;}
		for(int j=1;j&lt;=p[0]&amp;i*p[j]&lt;maxn;j++){
			notp[i*p[j]]=1;
			if(i%p[j]==0){
				u[i*p[j]]=0;
				break;
			}else u[i*p[j]]=-u[i];
		}for(int j=i;j&lt;maxn;j+=i)d[j]++;
	}for(int i=2;i&lt;maxn;i++)u[i]+=u[i-1],d[i]+=d[i-1];
	while(T--){
		int n,m;scanf("%d%d",&amp;n,&amp;m);
		if(n&gt;m)swap(n,m);
		int j;long long ans=0;
		for(int i=1;i&lt;=n;i=j+1){
			j=min(n/(n/i),m/(m/i));
			ans+=(long long)(u[j]-u[i-1])*d[n/i]*d[m/i];
		}printf("%lld\n",ans);
	}
	return 0;
}</pre><pre></pre><h2>Problem3995</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=60010;
int getint(){
	int res=0;char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))res=res*10+c-'0',c=getchar();
	return res;
}
int a[maxn],b[maxn],c[maxn],n,m;
struct node{
	int ans,l,r,lmx,rmx;
	node(){ans=0;}
}t[maxn&lt;&lt;2];
void rz(node &amp;ms,node ls,node rs,int a,int b){
	if(ls.ans==0)return void(ms=rs);
	if(rs.ans==0)return void(ms=ls);
	ms.l=ls.l;ms.r=rs.r;
	ms.lmx=ls.lmx;ms.rmx=rs.rmx;
	ms.ans=ls.ans+rs.ans+a+b;
	int cur=max(a,b);
	cur=max(cur,ls.rmx);
	cur=max(cur,rs.lmx);
	cur=max(cur,c[ls.r]);
	cur=max(cur,c[rs.l]);
	ms.ans-=cur;
	if(cur==c[ls.r]&amp;&amp;ls.l==ls.r){
		ms.l=rs.l;
		ms.lmx=max(a,b);
		ms.lmx=max(ms.lmx,ls.lmx);
		ms.lmx=max(ms.lmx,ls.rmx);
		ms.lmx=max(ms.lmx,rs.lmx);
	}else if(cur==c[rs.l]&amp;&amp;rs.l==rs.r){
		ms.r=ls.r;
		ms.rmx=max(a,b);
		ms.rmx=max(ms.rmx,rs.rmx);
		ms.rmx=max(ms.rmx,rs.lmx);
		ms.rmx=max(ms.rmx,ls.rmx);
	}
}
#define lson i&lt;&lt;1,l,(l+r)/2
#define rson i&lt;&lt;1|1,(l+r)/2+1,r
#define ls i&lt;&lt;1
#define rs i&lt;&lt;1|1
void build(int i,int l,int r){
	if(l==r){
		t[i].ans=c[l];
		t[i].l=t[i].r=l;
		t[i].lmx=t[i].rmx=0;
		return;
	}build(lson);build(rson);
	rz(t[i],t[ls],t[rs],a[(l+r)/2],b[(l+r)/2]);
}
node Q(int i,int l,int r,int l0,int r0){
	if(l0&lt;=l&amp;&amp;r0&gt;=r)return t[i];
	node ans;
	if(l0&lt;=(l+r)/2)ans=Q(lson,l0,r0);
	if(r0&gt;(l+r)/2){
		if(ans.ans==0)ans=Q(rson,l0,r0);
		else rz(ans,ans,Q(rson,l0,r0),a[(l+r)/2],b[(l+r)/2]);
	}
	return ans;
}
void C(int i,int l,int r,int ps){
	if(l==r){
		t[i].ans=c[l];
		t[i].l=t[i].r=l;
		t[i].lmx=t[i].rmx=0;
		return;	
	}if(ps&lt;=(l+r)/2)C(lson,ps);
	else C(rson,ps);
	rz(t[i],t[ls],t[rs],a[(l+r)/2],b[(l+r)/2]);
}
int main(){
	n=getint();m=getint();
	for(int i=1;i&lt;n;i++)a[i]=getint();
	for(int i=1;i&lt;n;i++)b[i]=getint();
	for(int i=1;i&lt;=n;i++)c[i]=getint();
	build(1,1,n);
	while(m--){
		char op=getchar();while(!isalpha(op))op=getchar();
		if(op=='Q'){
			int l=getint(),r=getint();
			printf("%d\n",Q(1,1,n,l,r).ans);
		}else{
			int x0=getint(),y0=getint(),x1=getint(),y1=getint(),w=getint();
			if(y0&gt;y1)swap(x0,x1),swap(y0,y1);
			if(y0==y1)c[y0]=w;
			else{
				if(x0==1)a[y0]=w;
				else b[y0]=w;
			}
			C(1,1,n,y0);
			if(y0!=y1)C(1,1,n,y1);
		}
	}
	return 0;
}</pre><pre></pre><h2>Problem3996</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=510;
struct edge{int u,v,cap,flow;};
vector&lt;edge&gt;edges;
vector&lt;int&gt;G[maxn];
int s,t,n;
int cur[maxn],d[maxn];
void add(int u,int v,int cap){
//	cerr&lt;&lt;u&lt;&lt;" "&lt;&lt;v&lt;&lt;" "&lt;&lt;cap&lt;&lt;endl;
	edges.push_back((edge){u,v,cap,0});
	G[u].push_back(edges.size()-1);
	edges.push_back((edge){v,u,0,0});
	G[v].push_back(edges.size()-1);
}
bool bfs(){
	static int vis[maxn];
	memset(vis,0,sizeof vis);vis[s]=1;
	queue&lt;int&gt;q;q.push(s);d[s]=0;
	while(!q.empty()){
		int u=q.front();q.pop();
		for(int i=0;i&lt;G[u].size();i++){
			edge e=edges[G[u][i]];if(vis[e.v]||e.cap==e.flow)continue;
			d[e.v]=d[u]+1;vis[e.v]=1;q.push(e.v);
		}
	}return vis[t];
}
int dfs(int u,int a){
	if(u==t||!a)return a;
	int flow=0,f;
	for(int &amp;i=cur[u];i&lt;G[u].size();i++){
		edge e=edges[G[u][i]];
		if(d[e.v]==d[u]+1&amp;&amp;(f=dfs(e.v,min(a,e.cap-e.flow)))&gt;0){
			edges[G[u][i]].flow+=f;
			edges[G[u][i]^1].flow-=f;
			flow+=f;a-=f;if(!a)break;
		}
	}return flow;
}
int dinic(){
	int flow=0,x;
	while(bfs()){
		memset(cur,0,sizeof cur);
		while(x=dfs(s,INT_MAX)){
			flow+=x;
			memset(cur,0,sizeof cur);
		}
	}return flow;
}
int B[maxn][maxn],C[maxn];
int main(){
	scanf("%d",&amp;n);
	for(int i=1;i&lt;=n;i++)
	for(int j=1;j&lt;=n;j++)
	scanf("%d",&amp;B[i][j]);
	for(int i=1;i&lt;=n;i++)
	scanf("%d",&amp;C[i]);
	s=0;t=n+1;
	for(int i=1;i&lt;=n;i++)
		add(s,i,accumulate(B[i]+1,B[i]+1+n,0));
	for(int i=1;i&lt;=n;i++)
		add(i,t,C[i]);
	for(int i=1;i&lt;=n;i++)
	for(int j=1;j&lt;=n;j++)
		add(i,j,B[j][i]);
	cout&lt;&lt;accumulate(&amp;B[1][1],(&amp;B[n][n])+1,0)-dinic()&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem3998</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1e6+5;
int son[maxn][26],tot=1,root=1,last=1,val[maxn],fa[maxn],num[maxn],f[maxn];
int newnode(int x){
	val[++tot]=x;
	return tot;
}
int n,ty,K;
void add(int w){
	int p=last;
	int np=newnode(val[p]+1);num[np]=1;
	while(p&amp;&amp;!son[p][w])son[p][w]=np,p=fa[p];
	if(!p)fa[np]=root;
	else{
		int q=son[p][w];
		if(val[p]+1==val[q])fa[np]=q;
		else{
			int nq=newnode(val[p]+1);if(ty==0)num[nq]=1;
			memcpy(son[nq],son[q],sizeof son[nq]);
			fa[nq]=fa[q];fa[np]=fa[q]=nq;
			while(p&amp;&amp;son[p][w]==q)son[p][w]=nq,p=fa[p];
		}
	}last=np;
}
void deb(){
	for(int i=1;i&lt;=tot;i++){
		fprintf(stderr,"id:%d fa:%d\n",i,fa[i]);
		for(int j=0;j&lt;26;j++)if(son[i][j])
			fprintf(stderr,"%d--%c--%d\n",i,j+'a',son[i][j]);
	}
}
char s[maxn];
bool cmp(int x,int y){return val[x]&gt;val[y];}
int main(){
	scanf("%s",s);n=strlen(s);
	scanf("%d%d",&amp;ty,&amp;K);
	for(int i=0;i&lt;n;i++)add(s[i]-'a');
	
//	deb();
	
	static int a[maxn];
	for(int i=1;i&lt;=tot;i++)a[i]=i;
	sort(a+1,a+1+tot,cmp);
	if(ty)for(int i=1;i&lt;tot;i++)num[fa[a[i]]]+=num[a[i]];num[1]=0;
	for(int i=1;i&lt;=tot;i++){
		int u=a[i];
		f[u]=num[u];
		for(int j=0;j&lt;26;j++)if(son[u][j])
			f[u]+=f[son[u][j]];
	}
	string anss;
	int u=1;
	while(num[u]&lt;K){
		K-=num[u];
		for(int i=0;i&lt;26;i++)if(son[u][i]){
			int v=son[u][i];
			if(f[v]&lt;K)K-=f[v];
			else {anss.push_back(i+'a');u=v;break;}
		}
	}//printf("%s",anss.c_str());
	cout&lt;&lt;anss&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem3999</h2><pre>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
#define all 1,n
typedef long long LL;
inline void readi(int &amp;x);
const int maxn=50005;
const LL inf=(1LL&lt;&lt;60)-1;

int n,Q;
int a[maxn];
int head[maxn],adj[maxn*2],next[maxn*2],tot;
int siz[maxn],son[maxn],fa[maxn],dep[maxn],top[maxn];
int dfn[maxn],dfa[maxn],idx;

inline void addedge(const int &amp;u,const int &amp;v)
{tot++;adj[tot]=v;next[tot]=head[u];head[u]=tot;
tot++;adj[tot]=u;next[tot]=head[v];head[v]=tot;}

struct msg
{
    LL mn,mx,m1,m2;
    msg(const LL &amp;_mn=0,const LL &amp;_mx=0,const LL &amp;_m1=0,const LL &amp;_m2=0):mn(_mn),mx(_mx),m1(_m1),m2(_m2){}
    friend inline msg operator+(const msg &amp;a,const msg &amp;b)
    {return msg(min(a.mn,b.mn),max(a.mx,b.mx),max(max(a.m1,b.m1),b.mx-a.mn),max(max(a.m2,b.m2),a.mx-b.mn));}
};

struct node
{
    LL dta;
    msg c;
    node *lc,*rc;
    
    inline void tagdta(const LL &amp;x)
    {c.mn+=x,c.mx+=x,dta+=x;}
    
    inline void update()
    {c=lc-&gt;c+rc-&gt;c;}
    
    inline void downdate()
    {
        if(dta)
        {
            lc-&gt;tagdta(dta);
            rc-&gt;tagdta(dta);
            dta=0;
        }
    }
    
    msg add(int l,int r,const int &amp;a,const int &amp;b,const int &amp;d)
    {
        msg ret;
        if(l&gt;=a&amp;&amp;r&lt;=b)
        {
            ret=c;
            return tagdta(d),ret;
        }
        else
        {
            int mid=l+r&gt;&gt;1;
            downdate();
            if(a&gt;mid)ret=rc-&gt;add(mid+1,r,a,b,d);
            else if(b&lt;=mid)ret=lc-&gt;add(l,mid,a,b,d);
            else ret=lc-&gt;add(l,mid,a,b,d)+rc-&gt;add(mid+1,r,a,b,d);
            update();
            return ret;
        }
    }
}ndl[maxn*3],*root;
int ns=1;

node *build(int l,int r)
{
    node *x=ndl+ns++;
    if(l==r)return x-&gt;c=msg(a[dfa[l]],a[dfa[r]],0,0),x;
    x-&gt;lc=build(l,l+r&gt;&gt;1);
    x-&gt;rc=build(l+r+2&gt;&gt;1,r);
    x-&gt;update();
    return x;
}

void tdfs(const int &amp;x)
{
    siz[x]=1;
    dep[x]=dep[fa[x]]+1;
    for(int i=head[x];i;i=next[i])
        if(adj[i]!=fa[x])
        {
            fa[adj[i]]=x;
            tdfs(adj[i]);
            siz[x]+=siz[adj[i]];
            if(siz[adj[i]]&gt;siz[son[x]])son[x]=adj[i];
        }
}

void divide(int x,int tp)
{
    dfa[dfn[x]=++idx]=x;
    top[x]=tp;
    if(son[x])divide(son[x],tp);
    for(int i=head[x];i;i=next[i])
        if(adj[i]!=fa[x]&amp;&amp;adj[i]!=son[x])
            divide(adj[i],adj[i]);
}

void init()
{
    readi(n);
    for(int i=1;i&lt;=n;i++)
        readi(a[i]);
    for(int i=1,u,v;i&lt;n;i++)
    {
        readi(u),readi(v);
        addedge(u,v);
    }
    readi(Q);
    tdfs(1);
    divide(1,1);
    root=build(1,n);
}

LL query(int u,int v,int d)
{
    msg su(inf,-inf,0,0),sv(inf,-inf,0,0);
    for(int fu,fv;(fu=top[u])!=(fv=top[v]);)
    {
        if(dep[fu]&gt;dep[fv])
        {
            su=root-&gt;add(all,dfn[fu],dfn[u],d)+su;
            u=fa[fu];
        }
        else
        {
            sv=root-&gt;add(all,dfn[fv],dfn[v],d)+sv;
            v=fa[fv];
        }
    }
    if(dep[u]&gt;dep[v])
        su=root-&gt;add(all,dfn[v],dfn[u],d)+su;
    else
        sv=root-&gt;add(all,dfn[u],dfn[v],d)+sv;
    swap(su.m1,su.m2);
    return (su+sv).m1;
}

void work()
{
    for(int u,v,d;Q--;)
    {
        readi(u),readi(v),readi(d);
        printf("%lld\n",query(u,v,d));
    }
}

int main()
{
    init();
    work();
    return 0;
}

inline void readi(int &amp;x)
{char c;while(c=getchar(),c&lt;'0'||c&gt;'9');
x=c^'0';while(c=getchar(),c&gt;='0'&amp;&amp;c&lt;='9')x=x*10+(c^'0');}</pre><pre></pre><h2>Problem4001</h2><pre>#include&lt;cstdio&gt;
double n;
int main(){
    scanf("%lf",&amp;n);
    printf("%.9lf",n*(n+1)/2/(2*n-1));
    return 0;
}</pre><pre></pre><h2>Problem4002</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef unsigned long long LL;
const LL mo=7528443412579576937LL;
struct mat{
	LL a[2][2];
	void clear(){memset(a,0,sizeof a);}
	void unit(){for(int i=0;i&lt;2;i++)a[i][i]=1;}
	LL* operator[](int x){return a[x];}
	LL at(int x,int y)const{return a[x][y];}
	void ass(){for(int i=0;i&lt;2;i++)for(int j=0;j&lt;2;j++)assert(a[i][j]&gt;=0);}
};
LL mul(LL x,LL y){
	LL ans=0;
	x%=mo;y%=mo;
	for(;y;y&gt;&gt;=1){
		if(y&amp;1)ans=(ans+x)%mo;
		x=(x+x)%mo;
	}return ans;
}
mat operator*(mat A,mat B){
	mat ans;ans.clear();
	for(int k=0;k&lt;2;k++)
	for(int i=0;i&lt;2;i++)
	for(int j=0;j&lt;2;j++)
	ans[i][j]=(ans[i][j]+mul(A[i][k],B[k][j]))%mo;
	return ans;
}
mat pw(mat x,LL k,LL p=mo){
	mat ans;ans.clear();ans.unit();
	for(;k;k&gt;&gt;=1){
		if(k&amp;1)ans=ans*x;
		x=x*x;
//		ans.ass();
//		x.ass();
	}return ans;
}
LL b,d,n;
mat A;
int main(){
	cin&gt;&gt;b&gt;&gt;d&gt;&gt;n;
	if(n==0){puts("1");return 0;}
	A[0][0]=b;A[0][1]=(d-b*b)/4;
	A[1][0]=1;A[1][1]=0;
	A=pw(A,n-1);
	LL ans=2*A[0][1]%mo+mul(b,A[0][0])-(d!=b*b&amp;&amp;n%2==0);
	cout&lt;&lt;ans%mo&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem4004</h2><pre>/**************************************************************
    Problem: 4004
    User: Tunix
    Language: C++
    Result: Accepted
    Time:896 ms
    Memory:3840 kb
****************************************************************/
 
//Huce #5 C
#include&lt;cmath&gt;
#include&lt;vector&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#define rep(i,n) for(int i=0;i&lt;n;++i)
#define F(i,j,n) for(int i=j;i&lt;=n;++i)
#define D(i,j,n) for(int i=j;i&gt;=n;--i)
using namespace std;
 
int getint(){
    int x;scanf("%d",&amp;x);return x;
}
typedef long long LL;
const int N=510,INF=~0u&gt;&gt;2;
const double eps=1e-5;
/*******************tamplate********************/
int n,m,base[N],ans,sum;
struct data{int c;double z[N];}a[N];
inline bool cmp(data a,data b){return a.c&lt;b.c;}
int main(){
    n=getint(); m=getint();
    F(i,1,n) F(j,1,m) a[i].z[j]=getint();
    F(i,1,n) a[i].c=getint();
    sort(a+1,a+n+1,cmp);
    F(i,1,n){
        F(j,1,m) if (fabs(a[i].z[j])&gt;eps){
            if (!base[j]){
                base[j]=i;
                ans++; sum+=a[i].c;
                break;
            }else{
                double t=a[i].z[j]/a[base[j]].z[j];
                F(k,j,m) a[i].z[k]-=a[base[j]].z[k]*t;
            }
        }
    }
    printf("%d %d\n",ans,sum);
    return 0;
}</pre><pre></pre><h2>Problem4008</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
double f[221][133];
double p[221];
int d[221];
int T;
int n,m;
void solve(){
	memset(f,0,sizeof f);
	scanf("%d%d",&amp;n,&amp;m);
	for(int i=1;i&lt;=n;i++)scanf("%lf%d",&amp;p[i],&amp;d[i]);
	f[0][m]=1;double ans=0;
	for(int i=0;i&lt;n;i++)
	for(int j=0;j&lt;=m;j++){
		f[i+1][j]+=f[i][j]*pow(1-p[i+1],j);
		if(j&gt;=1){
			f[i+1][j-1]+=f[i][j]*(1-pow(1-p[i+1],j));
			ans+=f[i][j]*(1-pow(1-p[i+1],j))*d[i+1];
		}
	}
	cout&lt;&lt;fixed&lt;&lt;setprecision(10)&lt;&lt;ans&lt;&lt;endl;
}
int main(){
	scanf("%d",&amp;T);
	while(T--)solve();
	return 0;
}</pre><pre></pre><h2>Problem4010</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1e5+5;
int n,m;
int T;
priority_queue&lt;int&gt;q;
vector&lt;int&gt;G[maxn];
int in[maxn];
void solve(){
	scanf("%d%d",&amp;n,&amp;m);
	while(!q.empty())q.pop();
	for(int i=1;i&lt;=n;i++)G[i].clear(),in[i]=0;
	for(int i=1;i&lt;=m;i++){
		int u,v;scanf("%d%d",&amp;u,&amp;v);
		swap(u,v);
		in[v]++;
		G[u].push_back(v);
	}
	for(int i=1;i&lt;=n;i++)if(!in[i])q.push(i);
	vector&lt;int&gt;anss;
	while(!q.empty()){
		int u=q.top();q.pop();
		anss.push_back(u);
		for(int i=0;i&lt;G[u].size();i++){
			int v=G[u][i];
			if(!--in[v])
				q.push(v);
		}
	}if(anss.size()!=n)puts("Impossible!");
	else{
		reverse(anss.begin(),anss.end());
		for(int i=0;i&lt;n;i++)printf("%d ",anss[i]);
		puts("");
	}
}
int main(){
	scanf("%d",&amp;T);
	while(T--)
		solve();
	return 0;
}</pre><pre></pre><h2>Problem4025</h2><pre>#include&lt;ctime&gt;
#include&lt;cctype&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
using namespace std;
const int maxn=1e5+5;
const int maxm=2e5+5;
int n,m,T,cot;
int tag[maxm],tree[maxm];
int in(){
	int r=0;char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))r=r*10+c-'0',c=getchar();
	return r;
}
struct edge{int u,v;}E[maxm];
struct node{
	int val,siz,rev;
	node *mn;
	node *c[2],*f;
	bool d(){return f-&gt;c[1]==this;}
	bool rt(){return !f||(f-&gt;c[0]!=this&amp;&amp;f-&gt;c[1]!=this);}
	void sets(node *x,int d){pd();c[d]=x;if(x)x-&gt;f=this;rz();}
	void rv(){rev^=1;swap(c[0],c[1]);}
	void pd(){
		if(rev){
			if(c[0])c[0]-&gt;rv();
			if(c[1])c[1]-&gt;rv();
			rev^=1;
		}		
	}
	void rz();
}nd[maxn],ne[maxm];
void deb();
void node::rz(){
	mn=this;siz=((1&lt;=this-ne)&amp;&amp;(this-ne&lt;=m));
	if(c[0])siz+=c[0]-&gt;siz;
	if(c[1])siz+=c[1]-&gt;siz;
	if(c[0]&amp;&amp;c[0]-&gt;mn-&gt;val&lt;mn-&gt;val)mn=c[0]-&gt;mn;
	if(c[1]&amp;&amp;c[1]-&gt;mn-&gt;val&lt;mn-&gt;val)mn=c[1]-&gt;mn;
}
void rot(node *x){
	node *y=x-&gt;f;if(!y-&gt;rt())y-&gt;f-&gt;pd();
	y-&gt;pd();x-&gt;pd();int d=x-&gt;d();
	y-&gt;sets(x-&gt;c[!d],d);
	if(y-&gt;rt())x-&gt;f=y-&gt;f;
	else y-&gt;f-&gt;sets(x,y-&gt;d());
	x-&gt;sets(y,!d);
}
void splay(node *x){
	while(!x-&gt;rt()){
		if(x-&gt;f-&gt;rt())rot(x);
		else if(x-&gt;d()==x-&gt;f-&gt;d())rot(x-&gt;f),rot(x);
		else rot(x),rot(x);
	}
}
node* access(node *x){
	node *y=0;
	for(;x;x=x-&gt;f){
		splay(x);
		x-&gt;sets(y,1);
		y=x;
	}return y;
}
void makert(node *x){
	access(x)-&gt;rv();
	splay(x);
}
bool conn(node *u,node *v){
	makert(u);
//	deb();
	access(v);
//	deb();
	splay(v);
//	deb();
	while(!u-&gt;rt())u=u-&gt;f;
	return u==v;
}
void link(node *u,node *v){
	makert(u);
//	splay(u);
	u-&gt;f=v;
	access(u);
}
void cut(node *u,node *v){
	makert(u);
	access(v);
	splay(v);
	v-&gt;c[0]=u-&gt;f=0;v-&gt;rz();
}
node *Qmin(node *u,node *v){
	makert(u);
	access(v);
	splay(v);
	return v-&gt;mn;
}
int Qsiz(node *u,node *v){
	makert(u);
	access(v);
	splay(v);
	return v-&gt;siz;
}
void add(int id){
	node *u=nd+E[id].u;
	node *v=nd+E[id].v;
	node *e=ne+id;
//	deb();
	if(!conn(u,v)){
		link(u,e);
		link(e,v);
		tree[id]=1;
		return;
	}
//	deb();
	node *mn=Qmin(u,v);
	if(e-&gt;val&gt;mn-&gt;val){
		int idx=mn-ne;
		cut(nd+E[idx].u,ne+idx);
		cut(nd+E[idx].v,ne+idx);
		link(u,e);
		link(e,v);
		tree[idx]=0;tree[id]=1;
		u=nd+E[idx].u;v=nd+E[idx].v;
		swap(e,mn);
		swap(id,idx);
	}else tree[id]=0;
	int siz=Qsiz(u,v);
	if(siz%2==0)
		tag[id]=1,cot++;	
}
void del(int id){
	if(tree[id]){
		cut(nd+E[id].u,ne+id);
		cut(ne+id,nd+E[id].v);
		tree[id]=0;
		return ;
	}
	if(tag[id]){
		cot--;
		tag[id]=0;
	}
}
struct task{
	int id,ti,ty;
	bool operator&lt;(task o)const{return ti!=o.ti?ti&lt;o.ti:ty&lt;o.ty;}
}t[maxm*2];
int ts;
int ind(node* x){
	if(!x)return 0;
	if((1&lt;=int(x-nd))&amp;&amp;(int(x-nd)&lt;=n))
		return x-nd;
	else return x-ne;
}
void deb(node *x){
	if(1&lt;=int(x-nd)&amp;&amp;int(x-nd)&lt;=n){
		printf("f:e%d c[0]:e%d c[1]:e%d rev:%d\n",ind(x-&gt;f),ind(x-&gt;c[0]),ind(x-&gt;c[1]),x-&gt;rev);
	}else{
		printf("f:v%d c[0]:v%d c[1]:v%d rev:%d\n",ind(x-&gt;f),ind(x-&gt;c[0]),ind(x-&gt;c[1]),x-&gt;rev);
	}
}
void deb(){
	for(int i=1;i&lt;=n;i++)deb(nd+i);
	for(int i=1;i&lt;=m;i++)deb(ne+i);
	puts("");
}
int main(){
	n=in();m=in();T=in();
	for(int i=1;i&lt;=m;i++){
		int u=in(),v=in(),st=in(),ed=in();
		E[i].u=u;E[i].v=v;ne[i].val=ed;ne[i].rz();
		if(ed==st)continue;
		t[ts++]=(task){i,st,1};
		t[ts++]=(task){i,ed,-1};
	}sort(t,t+ts);
	for(int i=1;i&lt;=n;i++)nd[i].val=1e9;
	int now=0;
	for(int i=0;i&lt;ts;){
		while(i&lt;ts&amp;&amp;now==t[i].ti){
			if(t[i].ty==-1)del(t[i].id);
			else add(t[i].id);
			i++;
//			deb();
		}
		while(now&lt;T&amp;&amp;(i&lt;ts&amp;&amp;now&lt;t[i].ti))
			now++,puts(cot?"No":"Yes");
	}
	while(now&lt;T)
		now++,puts(cot?"No":"Yes");
	return 0;
}</pre><pre></pre><h2>Problem4027</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=2e6+1;
typedef long long LL;
int n,m;
vector&lt;int&gt;G[maxn];
int ans=0;
LL cost[maxn];
bool bycost(int x,int y){
	return cost[x]&lt;cost[y];
}
void dfs(int u){
	for(int i=0;i&lt;G[u].size();i++)dfs(G[u][i]);
	sort(G[u].begin(),G[u].end(),bycost);
	cost[u]+=G[u].size();
	for(int i=0;i&lt;G[u].size();i++){
		int v=G[u][i];
		if(cost[u]+cost[v]-1&lt;=m){
			ans++;
			cost[u]+=cost[v]-1;
		}else break;
	}
}
int main(){
	scanf("%d%d",&amp;n,&amp;m);
	for(int i=0;i&lt;n;i++)scanf("%d",&amp;cost[i]);
	for(int i=0;i&lt;n;i++){
		int x;scanf("%d",&amp;x);
		while(x--){
			int v;scanf("%d",&amp;v);
			G[i].push_back(v);
		}
	}dfs(0);
	cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem4028</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
const int maxn=1e5+5;
const int sqrtmaxn=400;
int n,m,sqrtn;
template&lt;class T&gt;
T getn(){
	T res=0;char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))res=res*10+c-'0',c=getchar();
	return res;
}
map&lt;int,int&gt;M[sqrtmaxn];
int Gcd[maxn];
int Xor[maxn],a[maxn];
int lef[sqrtmaxn],rig[sqrtmaxn];
void rebuild(int l,int r){
	if(l&gt;=n)return;
	int id=l/sqrtn;
	Gcd[l]=Xor[l]=a[l];
	M[id].clear();
	for(int i=l+1;i&lt;=r;i++)
		Gcd[i]=__gcd(Gcd[i-1],a[i]);
	for(int i=l+1;i&lt;=r;i++)
		Xor[i]=Xor[i-1]^a[i];
	for(int i=r;i&gt;=l;i--)
		M[id][Xor[i]]=i;
}
int Q(int l,int r,LL x,int cur,LL xcur){
	for(int i=l;i&lt;=r;i++){
		cur=__gcd(cur,a[i]);
		if((LL)cur*(xcur^Xor[i])==x)
			return i;
	}return n;
}
void Q(LL x){
	int cur=0;
	LL xcur=0;
	for(int i=0;i&lt;sqrtn;i++){
		if(lef[i]==n)break;
		if(cur==__gcd(cur,Gcd[rig[i]])){
			if(M[i].count((x/cur)^xcur))
				return (void)printf("%d\n",M[i][(x/cur)^xcur]);
		}else{
			int res=Q(lef[i],rig[i],x,cur,xcur);
			if(res!=n)return (void)printf("%d\n",res);
		}cur=__gcd(cur,Gcd[rig[i]]);
		xcur^=Xor[rig[i]];
	}puts("no");
}
int main(){
	n=getn&lt;int&gt;();sqrtn=ceil(sqrt(n));
	for(int i=0;i&lt;n;i++)a[i]=getn&lt;int&gt;();
	for(int i=0;i&lt;sqrtn;i++){
		lef[i]=i?rig[i-1]+1:0;
		rig[i]=min(lef[i]+sqrtn-1,n-1);
		rebuild(lef[i],rig[i]);
	}
	m=getn&lt;int&gt;();
	while(m--){
		char op[9];scanf("%s",op);
		if(op[0]=='M'){
			int x=getn&lt;int&gt;(),y=getn&lt;int&gt;();
			a[x]=y;rebuild(lef[x/sqrtn],rig[x/sqrtn]);
		}else Q(getn&lt;LL&gt;());
	}
	return 0;
}</pre><pre></pre><h2>Problem4029</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
int T,L,R;
int ten[10];
int lowten(int x){
	int y=0;
	while(x%10==0)x/=10,y++;
	return ten[y];
}
int len(int x){
	int y=0;
	while(x)x/=10,y++;
	return y;
}
int calc(int x){
	while(x%10==0)x/=10;
	return len(x)*2-(x%10==5);
}
void solve(){
	scanf("%d%d",&amp;L,&amp;R);
	int res=L,ans=L;
	while(res&lt;=R){
		if(calc(res)&lt;calc(ans))ans=res;
		res+=lowten(res);
	}printf("%d\n",ans);
}
int main(){
	ten[0]=1;for(int i=1;i&lt;10;i++)ten[i]=ten[i-1]*10;
	scanf("%d",&amp;T);	
	while(T--)solve();
	return 0;
}</pre><pre></pre><h2>Problem4031</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
int n,m;
LL mo=1e9;
LL A[101][101];
LL Gauss(int n){
	n--;
	for(int i=0;i&lt;n;i++)for(int j=0;j&lt;n;j++)A[i][j]%=mo;
	for(int i=0;i&lt;n;i++)for(int j=0;j&lt;n;j++)A[i][j]=(A[i][j]+mo)%mo;
	LL ans=n%2?mo-1:1;
	for(int i=0;i&lt;n;i++){
		for(int j=i+1;j&lt;n;j++){
			while(A[j][i]){
				LL t=A[i][i]/A[j][i];
				for(int k=0;k&lt;n;k++)
				A[i][k]=(A[i][k]-A[j][k]*t%mo+mo)%mo;
				swap(A[i],A[j]);
				ans=mo-ans;
			}
		}ans=ans*A[i][i]%mo;
	}return (ans%mo+mo)%mo;
}
int mp[10][10],tot;
int a[10][10];
void add(int x,int y){
	A[x][y]++;
}
const int dx[4]={0,0,1,-1};
const int dy[4]={1,-1,0,0};
void make(){
	for(int i=0;i&lt;n;i++)
	for(int j=0;j&lt;m;j++)if(!a[i][j])
	mp[i][j]=tot++;
	for(int i=0;i&lt;n;i++)
	for(int j=0;j&lt;m;j++){
		if(!a[i][j])
		for(int k=0;k&lt;4;k++){
			int x=dx[k]+i,y=dy[k]+j;
			if(x&lt;0||x&gt;=n||y&lt;0||y&gt;=m)continue;
			if(!a[x][y]){
				add(mp[i][j],mp[x][y]);
			}
		}
	}for(int i=0;i&lt;tot;i++)A[i][i]=-accumulate(A[i],A[i]+tot,0);
}
char s[10];
int main(){
	cin&gt;&gt;n&gt;&gt;m;
	for(int i=0;i&lt;n;i++){
		cin&gt;&gt;s;
		for(int j=0;j&lt;m;j++)
			a[i][j]=s[j]=='*';
	}
	make();
	cout&lt;&lt;Gauss(tot)&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem4034</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
const int maxn=100005; 
int n,m;
int getn(){
	int res=0,f=1;char c=getchar();
	while(!isdigit(c))f=c=='-'?-1:f,c=getchar();
	while(isdigit(c))res=res*10+c-'0',c=getchar();
	return res*f;
}
vector&lt;int&gt;G[maxn];
int a[maxn],fa[maxn],siz[maxn],son[maxn],mp[maxn],dep[maxn],z,top[maxn],rmp[maxn],lef[maxn],rig[maxn];
struct sgt{
	struct node{
		LL sum,lz;
		node(){sum=0;lz=0;}
	}t[maxn&lt;&lt;2];
	#define ls i&lt;&lt;1
	#define rs i&lt;&lt;1|1
	#define lson i&lt;&lt;1,l,(l+r)/2
	#define rson i&lt;&lt;1|1,(l+r)/2+1,r
	void build(int i,int l,int r){
		if(l==r){t[i].sum=a[rmp[l]];return;}
		build(lson);build(rson);t[i].sum=t[ls].sum+t[rs].sum;
	}
	void pd(int i,int l,int r){
		if(t[i].lz){
			int mid=(l+r)/2;
			t[ls].sum+=(LL)(mid-l+1)*t[i].lz;
			t[ls].lz+=t[i].lz;
			t[rs].sum+=(LL)(r-mid)*t[i].lz;
			t[rs].lz+=t[i].lz;
			t[i].lz=0;
		}
	}
	void Add(int i,int l,int r,int l0,int r0,int d){
		if(l0&lt;=l&amp;&amp;r0&gt;=r){
			t[i].sum+=(LL)(r-l+1)*d;		
			t[i].lz+=d;
			return;
		}pd(i,l,r);
		if(l0&lt;=(l+r)/2)Add(lson,l0,r0,d);
		if(r0&gt;(l+r)/2)Add(rson,l0,r0,d);
		t[i].sum=t[ls].sum+t[rs].sum;
	}
	LL Qsum(int i,int l,int r,int l0,int r0){
		if(l0&lt;=l&amp;&amp;r0&gt;=r)return t[i].sum;
		pd(i,l,r);LL ans=0;
		if(l0&lt;=(l+r)/2)ans+=Qsum(lson,l0,r0);
		if(r0&gt;(l+r)/2)ans+=Qsum(rson,l0,r0);
		return ans;
	}
}T;
void dfs(int u){
	siz[u]=1;
	for(int i=0;i&lt;G[u].size();i++){
		int v=G[u][i];
		if(v==fa[u])continue;
		dep[v]=dep[u]+1;fa[v]=u;
		dfs(v);
		siz[u]+=siz[v];
		if(siz[son[u]]&lt;siz[v])son[u]=v;
	}
}
void build(int u,int tp){
	mp[u]=++z;top[u]=tp;rmp[z]=u;
	lef[u]=z;
	if(son[u])build(son[u],tp);
	for(int v,i=0;i&lt;G[u].size();i++)if((v=G[u][i])!=fa[u]&amp;&amp;son[u]!=v)
		build(v,v);
	rig[u]=z;
}
LL Qsum(int u,int v){
	LL ans=0;
	while(top[u]!=top[v]){
		if(dep[top[u]]&lt;dep[top[v]])swap(u,v);
		ans+=T.Qsum(1,1,n,mp[top[u]],mp[u]);	
		u=fa[top[u]];
	}if(mp[u]&gt;mp[v])swap(u,v);
	ans+=T.Qsum(1,1,n,mp[u],mp[v]);
	return ans;
}
int main(){
	n=getn();m=getn();
	for(int i=1;i&lt;=n;i++)a[i]=getn();
	for(int i=1;i&lt;n;i++){
		int u=getn(),v=getn();
		G[u].push_back(v);
		G[v].push_back(u);
	}dfs(1);build(1,1);
	T.build(1,1,n);
	while(m--){
		int op=getn();
		if(op==1){
			int x=getn(),a=getn();
			T.Add(1,1,n,mp[x],mp[x],a);
		}else if(op==2){
			int x=getn(),a=getn();
			T.Add(1,1,n,lef[x],rig[x],a);
		}else{
			printf("%lld\n",Qsum(1,getn()));
		}
	}
	return 0;
}</pre><pre></pre><h2>Problem4048</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
int n;
struct alien{
	int s,t,r;
}a[305];
int f[605][605],tmp[605],T;
int vis[605][605];
int solve(int l,int r){
	if(vis[l][r])return f[l][r];vis[l][r]=1;
	int ps=-1;
	for(int i=1;i&lt;=n;i++)if(l&lt;a[i].s&amp;&amp;a[i].t&lt;r&amp;&amp;(ps==-1||a[ps].r&lt;a[i].r))ps=i;
	if(ps==-1)return f[l][r]=0;
	f[l][r]=INT_MAX;
	for(int i=a[ps].s;i&lt;=a[ps].t;i++)
		f[l][r]=min(f[l][r],a[ps].r+solve(l,i)+solve(i,r));
	return f[l][r];
}
int main(){
	int _;scanf("%d",&amp;_);
	while(_--){
		scanf("%d",&amp;n);T=0;
		memset(vis,0,sizeof vis);
		for(int i=1;i&lt;=n;i++){
			scanf("%d%d%d",&amp;a[i].s,&amp;a[i].t,&amp;a[i].r);
			tmp[++T]=a[i].s;
			tmp[++T]=a[i].t;
		}sort(tmp+1,tmp+1+T);
		T=unique(tmp+1,tmp+1+T)-tmp-1;
		for(int i=1;i&lt;=n;i++)
			a[i].s=lower_bound(tmp+1,tmp+1+T,a[i].s)-tmp,
			a[i].t=lower_bound(tmp+1,tmp+1+T,a[i].t)-tmp;
		T++;
		cout&lt;&lt;solve(0,T)&lt;&lt;endl;
	}
	return 0;
}</pre><pre></pre><h2>Problem4050</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1001;
typedef long long LL;
int n;
struct C{
	int x,y,r;
}cir[maxn];
vector&lt;int&gt;G[maxn];
int fa[maxn],col[maxn],vis[maxn];
LL son[maxn],mom[maxn];
void make(LL &amp;x,LL &amp;y){
	LL t=__gcd(x,y);
	x/=t;y/=t;
}
void dfs(int u){
	vis[u]=1;
	make(son[u],mom[u]);
	for(int i=0;i&lt;G[u].size();i++){
		int v=G[u][i];if(v==fa[u]||vis[v])continue;
		fa[v]=u;col[v]=col[u]^1;
		son[v]=son[u]*cir[u].r;
		mom[v]=mom[u]*cir[v].r;
		dfs(v);
	}
}
LL sqr(LL x){return x*x;}
void solve(){
	scanf("%d",&amp;n);
	for(int i=1;i&lt;=n;i++)
		scanf("%d%d%d",&amp;cir[i].x,&amp;cir[i].y,&amp;cir[i].r);	
	for(int i=1;i&lt;=n;i++)G[i].clear();
	for(int i=1;i&lt;=n;i++)son[i]=mom[i]=2,col[i]=0;
	memset(vis,0,sizeof vis);
	for(int i=1;i&lt;=n;i++)
	for(int j=i+1;j&lt;=n;j++)
	if(sqr(cir[i].x-cir[j].x)+sqr(cir[i].y-cir[j].y)==sqr(cir[i].r+cir[j].r))
		G[i].push_back(j),G[j].push_back(i);
	dfs(1);
	for(int i=1;i&lt;=n;i++){
		if(son[i]==2&amp;&amp;mom[i]==2)puts("not moving");
		else{
			if(mom[i]==1)printf("%lld %s\n",son[i],col[i]?"counterclockwise":"clockwise");
			else printf("%lld/%lld %s\n",son[i],mom[i],col[i]?"counterclockwise":"clockwise");
		}
	}
}
int main(){
	int T;scanf("%d",&amp;T);
	while(T--)solve();
	return 0;
}</pre><pre></pre><h2>Problem4052</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
long long a[100010];
void solve(){
	vector&lt;pair&lt;int,long long&gt; &gt;vec,tmp;
	int n;scanf("%d",&amp;n);
	long long ans=0;
	for(int i=1;i&lt;=n;i++){
		scanf("%lld",&amp;a[i]);
		vec.push_back(make_pair(i,0));
		for(int j=0;j&lt;vec.size();j++)
			vec[j].second=__gcd(vec[j].second,a[i]);
		for(int j=0;j&lt;vec.size();j++)
		if(!j||vec[j-1].second!=vec[j].second)
			tmp.push_back(vec[j]);
		vec=tmp;tmp.clear();
		for(int j=0;j&lt;vec.size();j++)
			ans=max(ans,vec[j].second*(i-vec[j].first+1));
	}printf("%lld\n",ans);
}
int main(){
	int T;scanf("%d",&amp;T);	
	while(T--)solve();
	return 0;
}</pre><pre></pre><h2>Problem4057</h2><pre>#include&lt;iostream&gt;  
#include&lt;stdio.h&gt;  
#include&lt;string.h&gt;  
#include&lt;queue&gt;  
#include&lt;stack&gt;  
#include&lt;algorithm&gt;  
#include&lt;cmath&gt;  
#include&lt;set&gt;  
#include&lt;map&gt;  
#define ll long long  
#define oo 1&lt;&lt;29  
#define MAXN 500005  
#define pi acos(-1.0)  
#define esp 1e-30  
using namespace std;      
bool dp[1&lt;&lt;21];   
int h[21][21];  
int main()  
{      
       int cases,n,totol,i,x,k,sum;   
       scanf("%d",&amp;cases);    
       while (cases--)  
       {  
                scanf("%d",&amp;n);  
                for (i=0;i&lt;n;i++)  
                   for (x=0;x&lt;n;x++)  
                      scanf("%d",&amp;h[i][x]);  
                totol=(1&lt;&lt;n)-1;  
                for (i=0;i&lt;=totol;i++) dp[i]=false;  
                dp[totol]=true;   
                for (x=totol;x&gt;=0;x--)   
                  if (dp[x])  
                     for(i=0;i&lt;n;i++)  
                        if (x&amp;(1&lt;&lt;i))  
                        {   
                               sum=0;  
                               for (k=0;k&lt;n;k++)  
                                  if (x &amp; (1&lt;&lt;k)) sum+=h[i][k];  
                               if (sum&gt;0) dp[x-(1&lt;&lt;i)]=true;  
                        }    
                x=0;  
                for (i=0;i&lt;n;i++)   
                   if (dp[1&lt;&lt;i])  
                     if (!x) printf("%d",i+1),x=1;  
                        else printf(" %d",i+1);    
                if (!x) printf("0");  
                printf("\n");  
       }      
       return 0;  
}  </pre><pre></pre><h2>Problem4057</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
int n;
int f[1&lt;&lt;20];
int d[20][20];
int sum[20];
void sol(){
	//memset(f,0,sizeof f);
	scanf("%d",&amp;n);
	for(int i=0;i&lt;(1&lt;&lt;n);i++)f[i]=0;
	for(int i=0;i&lt;n;i++)
	for(int j=0;j&lt;n;j++)
		scanf("%d",&amp;d[i][j]);
	f[0]=1;
	for(int S=0;S&lt;(1&lt;&lt;n);S++)if(f[S]){
		//memset(sum,0,sizeof sum);
		int sum;
		for(int j=0;j&lt;n;j++)if(!(S&gt;&gt;j&amp;1)&amp;&amp;!f[S|(1&lt;&lt;j)]){
			sum=0;
			for(int k=0;k&lt;n;k++)if(!(S&gt;&gt;k&amp;1))
				sum-=d[j][k];
				if(sum&lt;0)f[S|(1&lt;&lt;j)]=1;
		}	
	}
	vector&lt;int&gt;anss;	
	for(int i=0;i&lt;n;i++)if(f[((1&lt;&lt;n)-1)^(1&lt;&lt;i)])anss.push_back(i);
		if(anss.size())for(int i=0;i&lt;anss.size();i++)printf("%d%c",anss[i]+1," \n"[i+1==anss.size()]);
	else puts("0");
}
int main(){
	int T;scanf("%d",&amp;T);
	while(T--)sol();
	return 0;
}</pre><pre></pre><h2>Problem4057</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
int n;
int f[1&lt;&lt;20];
int d[20][20];
int sum[20];
void sol(){
	//memset(f,0,sizeof f);
	scanf("%d",&amp;n);
	for(int i=0;i&lt;(1&lt;&lt;n);i++)f[i]=0;
	for(int i=0;i&lt;n;i++)
	for(int j=0;j&lt;n;j++)
		scanf("%d",&amp;d[i][j]);
	f[0]=1;
	for(int S=0;S&lt;(1&lt;&lt;n);S++)if(f[S]){
		//memset(sum,0,sizeof sum);
		int sum;
		for(int j=0;j&lt;n;j++)if(!(S&gt;&gt;j&amp;1)){
			sum=0;
			for(int k=0;k&lt;n;k++)if(!(S&gt;&gt;k&amp;1))
				sum-=d[j][k];
				if(sum&lt;0)f[S|(1&lt;&lt;j)]=1;
		}	
	}
	vector&lt;int&gt;anss;	
	for(int i=0;i&lt;n;i++)if(f[((1&lt;&lt;n)-1)^(1&lt;&lt;i)])anss.push_back(i);
		if(anss.size())for(int i=0;i&lt;anss.size();i++)printf("%d%c",anss[i]+1," \n"[i+1==anss.size()]);
	else puts("0");
}
int main(){
	int T;scanf("%d",&amp;T);
	while(T--)sol();
	return 0;
}</pre><pre></pre><h2>Problem4059</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
int n;
int a[200010],v[200010],pre[200010],nxt[200010],tmp[200010];
int getn(){
	int re=0;char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))re=re*10+c-'0',c=getchar();
	return re;
}
bool dfs(int l,int r){
	if(l&gt;=r)return 1;
	int len=(r-l+1),i=l,j=r;
	while(len--){
		if(len&amp;1){
			if(pre[i]&lt;l&amp;&amp;nxt[i]&gt;r)
				return dfs(l,i-1)&amp;&amp;dfs(i+1,r);
			i++;
		}else{
			if(pre[j]&lt;l&amp;&amp;nxt[j]&gt;r)
				return dfs(l,j-1)&amp;&amp;dfs(j+1,r);
			j--;
		}
	}return 0;
}
void solve(){
	int n=getn();
	for(int i=1;i&lt;=n;i++)a[i]=getn(),v[i]=a[i];
	sort(v+1,v+1+n);
	int siz=unique(v+1,v+1+n)-v-1;
	for(int i=1;i&lt;=n;i++)a[i]=lower_bound(v+1,v+1+siz,a[i])-v;
	for(int i=1;i&lt;=siz;i++)tmp[i]=0;
	for(int i=1;i&lt;=n;i++)
		pre[i]=tmp[a[i]],tmp[a[i]]=i;
	for(int i=1;i&lt;=siz;i++)tmp[i]=n+1;
	for(int i=n;i&gt;=1;i--)
		nxt[i]=tmp[a[i]],tmp[a[i]]=i;	
	puts(dfs(1,n)?"non-boring":"boring");
}
int main(){
	int T=getn();
	while(T--)solve();
	return 0;
}
</pre><pre></pre><h2>Problem4059</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
int n;
int a[200010],v[200010],pre[200010],nxt[200010],tmp[200010];
int getn(){
	int re=0;char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))re=re*10+c-'0',c=getchar();
	return re;
}
bool dfs(int l,int r){
	if(l&gt;=r)return 1;
	int len=(r-l+1),i=l,j=r;
	while(len--){
		if(len&amp;1){
			if(pre[j]&lt;l&amp;&amp;nxt[j]&gt;r)
				return dfs(l,j-1)&amp;&amp;dfs(j+1,r);
			j--;
		}else{			
			if(pre[i]&lt;l&amp;&amp;nxt[i]&gt;r)
				return dfs(l,i-1)&amp;&amp;dfs(i+1,r);
			i++;

		}
	}return 0;
}
void solve(){
	int n=getn();
	for(int i=1;i&lt;=n;i++)a[i]=getn(),v[i]=a[i];
	sort(v+1,v+1+n);
	int siz=unique(v+1,v+1+n)-v-1;
	for(int i=1;i&lt;=n;i++)a[i]=lower_bound(v+1,v+1+siz,a[i])-v;
	for(int i=1;i&lt;=siz;i++)tmp[i]=0;
	for(int i=1;i&lt;=n;i++)
		pre[i]=tmp[a[i]],tmp[a[i]]=i;
	for(int i=1;i&lt;=siz;i++)tmp[i]=n+1;
	for(int i=n;i&gt;=1;i--)
		nxt[i]=tmp[a[i]],tmp[a[i]]=i;	
	puts(dfs(1,n)?"non-boring":"boring");
}
int main(){
	int T=getn();
	while(T--)solve();
	return 0;
}
</pre><pre></pre><h2>Problem4059</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
int n;
int a[200001],v[200001],pre[200001],nxt[200001],tmp[200001];
int getn(){
	int re=0;char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))re=re*10+c-'0',c=getchar();
	return re;
}
bool dfs(const int &amp;l,const int &amp;r){
	if(l&gt;=r)return 1;
	int len=(r-l+1),i=l,j=r;
	while(len--){
		if(len&amp;1){
			if(pre[j]&lt;l&amp;&amp;nxt[j]&gt;r)
				return dfs(l,j-1)&amp;&amp;dfs(j+1,r);
			j--;
		}else{			
			if(pre[i]&lt;l&amp;&amp;nxt[i]&gt;r)
				return dfs(l,i-1)&amp;&amp;dfs(i+1,r);
			i++;

		}
	}return 0;
}
void solve(){
	int n=getn();
	for(int i=1;i&lt;=n;i++)a[i]=getn(),v[i]=a[i];
	sort(v+1,v+1+n);
	int siz=unique(v+1,v+1+n)-v-1;
	for(int i=1;i&lt;=n;i++)a[i]=lower_bound(v+1,v+1+siz,a[i])-v;
	for(int i=1;i&lt;=siz;i++)tmp[i]=0;
	for(int i=1;i&lt;=n;i++)
		pre[i]=tmp[a[i]],tmp[a[i]]=i;
	for(int i=1;i&lt;=siz;i++)tmp[i]=n+1;
	for(int i=n;i&gt;=1;i--)
		nxt[i]=tmp[a[i]],tmp[a[i]]=i;	
	puts(dfs(1,n)?"non-boring":"boring");
}
int main(){
	int T=getn();
	while(T--)solve();
	return 0;
}
</pre><pre></pre><h2>Problem4059</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
int n;
int a[200001],v[200001],pre[200001],nxt[200001],tmp[200001];
int getn(){
	int re=0;char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))re=re*10+c-'0',c=getchar();
	return re;
}
bool dfs(int l,int r){
	if(l&gt;=r)return 1;
	int len=(r-l+1),i=l,j=r;
	while(len--){
		if(len&amp;1){
			if(pre[j]&lt;l&amp;&amp;nxt[j]&gt;r)
				return dfs(l,j-1)&amp;&amp;dfs(j+1,r);
			j--;
		}else{			
			if(pre[i]&lt;l&amp;&amp;nxt[i]&gt;r)
				return dfs(l,i-1)&amp;&amp;dfs(i+1,r);
			i++;

		}
	}return 0;
}
void solve(){
	n=getn();
	//for(int i=1;i&lt;=n;i++)a[i]=getn(),v[i]=a[i];
	int *ed=a+1+n;
	for(int *i=a+1,*j=v+1;i!=ed;i++,j++)
		*i=getn(),*j=*i;
	sort(v+1,v+1+n);
	int siz=unique(v+1,v+1+n)-v-1;
	for(int i=1;i&lt;=n;i++)a[i]=lower_bound(v+1,v+1+siz,a[i])-v;
	for(int i=1;i&lt;=siz;i++)tmp[i]=0;
	for(int i=1;i&lt;=n;i++)
		pre[i]=tmp[a[i]],tmp[a[i]]=i;
	for(int i=1;i&lt;=siz;i++)tmp[i]=n+1;
	for(int i=n;i&gt;=1;i--)
		nxt[i]=tmp[a[i]],tmp[a[i]]=i;	
	puts(dfs(1,n)?"non-boring":"boring");
}
int main(){
	int T=getn();
	while(T--)solve();
	return 0;
}
</pre><pre></pre><h2>Problem4063</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
int getn(){
	int res=0,f=1;char c=getchar();
	while(!isdigit(c))f=c=='-'?-1:1,c=getchar();
	while(isdigit(c))res=res*10+c-'0',c=getchar();
	return res;
}
int sqr(int x){return x*x;}
void solve(){
	int n=getn();
	int ans=0;
	while(n--){
		int x=getn(),y=getn();
		double dis=sqrt(sqr(x)+sqr(y));
		for(int i=10;i&gt;=0;i--)
		if(dis&lt;=20*(11-i)){ans+=i;break;}
	}printf("%d\n",ans);
}
int main(){
	int T=getn();
	while(T--)solve();
	return 0;
}</pre><pre></pre><h2>Problem4066</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
int lans=0;
const int maxn=2e5+5;
int in(){
	int r=0;char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))r=r*10+c-'0',c=getchar();
	return r;
}
int n;
struct point{
	int x,y,val;
	int&amp; operator[](const int s){return s==0?x:y;}
}p[maxn];
struct rec{
	int x[2],y[2];
	rec(){}
	rec(point p){x[0]=x[1]=p.x;y[0]=y[1]=p.y;}
};
bool operator==(const point &amp;A,const point &amp;B){
	return A.x==B.x&amp;&amp;A.y==B.y;
}
rec operator+(const rec &amp;ls,const rec &amp;rs){
	static rec R;R=ls;
	R.x[0]=min(R.x[0],rs.x[0]);
	R.x[1]=max(R.x[1],rs.x[1]);
	R.y[0]=min(R.y[0],rs.y[0]);
	R.y[1]=max(R.y[1],rs.y[1]);
	return R;
}
bool operator*(const point &amp;p,const rec &amp;R){
	return R.x[0]&lt;=p.x&amp;&amp;p.x&lt;=R.x[1]&amp;&amp;R.y[0]&lt;=p.y&amp;&amp;p.y&lt;=R.y[1];
}
bool In(rec A,rec B){
	return B.x[0]&lt;=A.x[0]&amp;&amp;A.x[1]&lt;=B.x[1]&amp;&amp;B.y[0]&lt;=A.y[0]&amp;&amp;A.y[1]&lt;=B.y[1];
}
bool Out(rec A,rec B){
	return B.x[0]&gt;A.x[1]||A.x[0]&gt;B.x[1]||B.y[0]&gt;A.y[1]||A.y[0]&gt;B.y[1];
}
struct node{
	rec R;point p;
	int sum,siz;
	node *c[2];
	node *rz(){
		sum=p.val;R=rec(p);siz=1;
		if(c[0])sum+=c[0]-&gt;sum,R=R+c[0]-&gt;R,siz+=c[0]-&gt;siz;
		if(c[1])sum+=c[1]-&gt;sum,R=R+c[1]-&gt;R,siz+=c[1]-&gt;siz;
		return this;
	}
	node(){sum=0;siz=1;c[0]=c[1]=0;}
}*root,*re,pool[maxn],*cur=pool;
node *sta[maxn];
int D,si;
bool cmp(const point &amp;A,const point &amp;B){
	if(D)return A.x&lt;B.x;
	return A.y&lt;B.y;
}
int top;
node *newnode(){
	if(si)return sta[si--];
	return cur++;
}
node* build(int l,int r,int d){
	int mid=(l+r)&gt;&gt;1;D=d;
	nth_element(p+l,p+mid,p+r+1,cmp);
	node *t=newnode();t-&gt;p=p[mid];
	if(l&lt;=mid-1)t-&gt;c[0]=build(l,mid-1,d^1);
	if(mid+1&lt;=r)t-&gt;c[1]=build(mid+1,r,d^1);
	return t-&gt;rz();
}
void dfs(node *&amp;t){
	if(t-&gt;c[0])dfs(t-&gt;c[0]);
	p[++top]=t-&gt;p;
	if(t-&gt;c[1])dfs(t-&gt;c[1]);
	sta[++si]=t;*t=node();
	//delete t;
}
node* rebuild(node *&amp;t){
	if(!t)return 0;
	top=0;dfs(t);
	return build(1,top,0);
}
#define siz(x) (x?x-&gt;siz:0)
void Add(node *&amp;t,point p){
	D^=1;
	if(!t){t=newnode(),t-&gt;p=p;t-&gt;rz();return;}
	if(t-&gt;p==p){t-&gt;p.val+=p.val;t-&gt;rz();return;}
	if(p[D]&lt;t-&gt;p[D])Add(t-&gt;c[0],p);
	else Add(t-&gt;c[1],p);t-&gt;rz();
	if(max(siz(t-&gt;c[0]),siz(t-&gt;c[1]))&gt;0.7*t-&gt;siz)
		re=t;
}
int Q(node *t,rec R){
	if(!t)return 0;
	if(In(t-&gt;R,R))return t-&gt;sum;
	if(Out(t-&gt;R,R))return 0;
	int ans=0;
	if(t-&gt;p*R)ans=t-&gt;p.val;
	if(t-&gt;c[0])ans+=Q(t-&gt;c[0],R);
	if(t-&gt;c[1])ans+=Q(t-&gt;c[1],R);
	return ans;
}
int main(){
//	freopen("bzoj4066.in","r",stdin);
//	freopen("bzoj4066.out","w",stdout);
	n=in();
	while(1){
		int ty=in();if(ty==3)break;
		if(ty==1){
			int x=in()^lans,y=in()^lans,A=in()^lans;
			re=0;D=1;
			Add(root,(point){x,y,A});
			if(re)re=rebuild(re);
		}else{
			rec R;
			R.x[0]=in()^lans;R.y[0]=in()^lans;
			R.x[1]=in()^lans;R.y[1]=in()^lans;
			printf("%d\n",lans=Q(root,R));
		}
	}
	return 0;
}</pre><pre></pre><h2>Problem4066</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
int lans=0;
const int maxn=2e5+5;
int in(){
	int r=0;char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))r=r*10+c-'0',c=getchar();
	return r;
}
int n;
struct point{
	int x,y,val;
	int&amp; operator[](const int s){return s==0?x:y;}
}p[maxn];
struct rec{
	int x[2],y[2];
	rec(){}
	rec(point p){x[0]=x[1]=p.x;y[0]=y[1]=p.y;}
};
bool operator==(const point &amp;A,const point &amp;B){
	return A.x==B.x&amp;&amp;A.y==B.y;
}
rec operator+(const rec &amp;ls,const rec &amp;rs){
	static rec R;R=ls;
	R.x[0]=min(R.x[0],rs.x[0]);
	R.x[1]=max(R.x[1],rs.x[1]);
	R.y[0]=min(R.y[0],rs.y[0]);
	R.y[1]=max(R.y[1],rs.y[1]);
	return R;
}
bool operator*(const point &amp;p,const rec &amp;R){
	return R.x[0]&lt;=p.x&amp;&amp;p.x&lt;=R.x[1]&amp;&amp;R.y[0]&lt;=p.y&amp;&amp;p.y&lt;=R.y[1];
}
bool In(const rec &amp;A,const rec &amp;B){
	return B.x[0]&lt;=A.x[0]&amp;&amp;A.x[1]&lt;=B.x[1]&amp;&amp;B.y[0]&lt;=A.y[0]&amp;&amp;A.y[1]&lt;=B.y[1];
}
bool Out(const rec &amp;A,const rec &amp;B){
	return B.x[0]&gt;A.x[1]||A.x[0]&gt;B.x[1]||B.y[0]&gt;A.y[1]||A.y[0]&gt;B.y[1];
}
struct node{
	rec R;point p;
	int sum,siz;
	node *c[2];
	node *rz(){
		sum=p.val;R=rec(p);siz=1;
		if(c[0])sum+=c[0]-&gt;sum,R=R+c[0]-&gt;R,siz+=c[0]-&gt;siz;
		if(c[1])sum+=c[1]-&gt;sum,R=R+c[1]-&gt;R,siz+=c[1]-&gt;siz;
		return this;
	}
	node(){sum=0;siz=1;c[0]=c[1]=0;}
}*root,*re,pool[maxn],*cur=pool;
node *sta[maxn];
int D,si;
bool cmp(const point &amp;A,const point &amp;B){
	if(D)return A.x&lt;B.x||(A.x==B.x&amp;&amp;A.y&lt;B.y);
	return A.y&lt;B.y||(A.y==B.y&amp;&amp;A.x&lt;B.x);
}
int top;
node *newnode(){
	if(si)return sta[si--];
	return cur++;
}
node* build(int l,int r,int d){
	int mid=(l+r)&gt;&gt;1;D=d;
	nth_element(p+l,p+mid,p+r+1,cmp);
	node *t=newnode();t-&gt;p=p[mid];
	if(l&lt;=mid-1)t-&gt;c[0]=build(l,mid-1,d^1);
	if(mid+1&lt;=r)t-&gt;c[1]=build(mid+1,r,d^1);
	return t-&gt;rz();
}
void dfs(node *&amp;t){
	if(t-&gt;c[0])dfs(t-&gt;c[0]);
	p[++top]=t-&gt;p;
	if(t-&gt;c[1])dfs(t-&gt;c[1]);
	sta[++si]=t;*t=node();
	//delete t;
}
node* rebuild(node *&amp;t){
	if(!t)return 0;
	top=0;dfs(t);
	return build(1,top,0);
}
#define siz(x) (x?x-&gt;siz:0)
void Add(node *&amp;t,point p){
	D^=1;
	if(!t){t=newnode(),t-&gt;p=p;t-&gt;rz();return;}
	if(t-&gt;p==p){t-&gt;p.val+=p.val;t-&gt;rz();return;}
	if(p[D]&lt;t-&gt;p[D])Add(t-&gt;c[0],p);
	else Add(t-&gt;c[1],p);t-&gt;rz();
	if(max(siz(t-&gt;c[0]),siz(t-&gt;c[1]))&gt;0.618*t-&gt;siz)
		re=t;
}
int Q(node *t,rec R){
	if(!t)return 0;
	if(In(t-&gt;R,R))return t-&gt;sum;
	if(Out(t-&gt;R,R))return 0;
	int ans=0;
	if(t-&gt;p*R)ans=t-&gt;p.val;
	if(t-&gt;c[0])ans+=Q(t-&gt;c[0],R);
	if(t-&gt;c[1])ans+=Q(t-&gt;c[1],R);
	return ans;
}
int main(){
//	freopen("bzoj4066.in","r",stdin);
//	freopen("bzoj4066.out","w",stdout);
	n=in();
	while(1){
		int ty=in();if(ty==3)break;
		if(ty==1){
			int x=in()^lans,y=in()^lans,A=in()^lans;
			re=0;D=1;
			Add(root,(point){x,y,A});
			if(re)re=rebuild(re);
		}else{
			rec R;
			R.x[0]=in()^lans;R.y[0]=in()^lans;
			R.x[1]=in()^lans;R.y[1]=in()^lans;
			printf("%d\n",lans=Q(root,R));
		}
	}
	return 0;
}</pre><pre></pre><h2>Problem4066</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
int lans=0;
const int maxn=2e5+5;
int in(){
	int r=0;char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))r=r*10+c-'0',c=getchar();
	return r;
}
int n;
struct point{
	int x,y,val;
	int&amp; operator[](const int s){return s==0?x:y;}
}p[maxn];
struct rec{
	int x[2],y[2];
	rec(){}
	rec(point p){x[0]=x[1]=p.x;y[0]=y[1]=p.y;}
};
bool operator==(const point &amp;A,const point &amp;B){
	return A.x==B.x&amp;&amp;A.y==B.y;
}
inline rec operator+(const rec &amp;ls,const rec &amp;rs){
	static rec R;R=ls;
	R.x[0]=min(R.x[0],rs.x[0]);
	R.x[1]=max(R.x[1],rs.x[1]);
	R.y[0]=min(R.y[0],rs.y[0]);
	R.y[1]=max(R.y[1],rs.y[1]);
	return R;
}
inline bool operator*(const point &amp;p,const rec &amp;R){
	return R.x[0]&lt;=p.x&amp;&amp;p.x&lt;=R.x[1]&amp;&amp;R.y[0]&lt;=p.y&amp;&amp;p.y&lt;=R.y[1];
}
inline bool In(const rec &amp;A,const rec &amp;B){
	return B.x[0]&lt;=A.x[0]&amp;&amp;A.x[1]&lt;=B.x[1]&amp;&amp;B.y[0]&lt;=A.y[0]&amp;&amp;A.y[1]&lt;=B.y[1];
}
inline bool Out(const rec &amp;A,const rec &amp;B){
	return B.x[0]&gt;A.x[1]||A.x[0]&gt;B.x[1]||B.y[0]&gt;A.y[1]||A.y[0]&gt;B.y[1];
}
struct node{
	rec R;point p;
	int sum,siz;
	node *c[2];
	node *rz(){
		sum=p.val;R=rec(p);siz=1;
		if(c[0])sum+=c[0]-&gt;sum,R=R+c[0]-&gt;R,siz+=c[0]-&gt;siz;
		if(c[1])sum+=c[1]-&gt;sum,R=R+c[1]-&gt;R,siz+=c[1]-&gt;siz;
		return this;
	}
	node(){sum=0;siz=1;c[0]=c[1]=0;}
}*root,*re,pool[maxn],*cur=pool;
node *sta[maxn];
int D,si;
bool cmp(const point &amp;A,const point &amp;B){
	if(D)return A.x&lt;B.x||(A.x==B.x&amp;&amp;A.y&lt;B.y);
	return A.y&lt;B.y||(A.y==B.y&amp;&amp;A.x&lt;B.x);
}
int top;
node *newnode(){
	if(si)return sta[si--];
	return cur++;
}
node* build(int l,int r,int d){
	int mid=(l+r)&gt;&gt;1;D=d;
	nth_element(p+l,p+mid,p+r+1,cmp);
	node *t=newnode();t-&gt;p=p[mid];
	if(l&lt;=mid-1)t-&gt;c[0]=build(l,mid-1,d^1);
	if(mid+1&lt;=r)t-&gt;c[1]=build(mid+1,r,d^1);
	return t-&gt;rz();
}
void dfs(node *&amp;t){
	if(t-&gt;c[0])dfs(t-&gt;c[0]);
	p[++top]=t-&gt;p;
	if(t-&gt;c[1])dfs(t-&gt;c[1]);
	sta[++si]=t;*t=node();
	//delete t;
}
node* rebuild(node *&amp;t){
	if(!t)return 0;
	top=0;dfs(t);
	return build(1,top,0);
}
#define siz(x) (x?x-&gt;siz:0)
void Add(node *&amp;t,point p){
	D^=1;
	if(!t){t=newnode(),t-&gt;p=p;t-&gt;rz();return;}
	if(t-&gt;p==p){t-&gt;p.val+=p.val;t-&gt;rz();return;}
	if(p[D]&lt;t-&gt;p[D])Add(t-&gt;c[0],p);
	else Add(t-&gt;c[1],p);t-&gt;rz();
	if(max(siz(t-&gt;c[0]),siz(t-&gt;c[1]))&gt;0.618*t-&gt;siz)
		re=t;
}
int ans;
void Q(const node *t,const rec &amp;R){
	if(Out(t-&gt;R,R))return ;
	if(In(t-&gt;R,R)){ans+=t-&gt;sum;return;}
	if(t-&gt;p*R)ans+=t-&gt;p.val;
	if(t-&gt;c[0])Q(t-&gt;c[0],R);
	if(t-&gt;c[1])Q(t-&gt;c[1],R);
}
int main(){
	n=in();
	while(1){
		int ty=in();if(ty==3)break;
		if(ty==1){
			int x=in()^lans,y=in()^lans,A=in()^lans;
			re=0;D=1;
			Add(root,(point){x,y,A});
			if(re)re=rebuild(re);
		}else{
			rec R;
			R.x[0]=in()^lans;R.y[0]=in()^lans;
			R.x[1]=in()^lans;R.y[1]=in()^lans;
			ans=0;if(root)Q(root,R);
			printf("%d\n",ans);
			lans=ans;
		}
	}
	return 0;
}</pre><pre></pre><h2>Problem4066</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
int lans=0;
const int maxn=2e5+5;
int in(){
	int r=0;char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))r=r*10+c-'0',c=getchar();
	return r;
}
int n;
struct point{
	int x,y,val;
	int&amp; operator[](const int s){return s==0?x:y;}
}p[maxn];
struct rec{
	int x[2],y[2];
	rec(){}
	rec(point p){x[0]=x[1]=p.x;y[0]=y[1]=p.y;}
};
bool operator==(const point &amp;A,const point &amp;B){
	return A.x==B.x&amp;&amp;A.y==B.y;
}
inline rec operator+(const rec &amp;ls,const rec &amp;rs){
	static rec R;R=ls;
	R.x[0]=min(R.x[0],rs.x[0]);
	R.x[1]=max(R.x[1],rs.x[1]);
	R.y[0]=min(R.y[0],rs.y[0]);
	R.y[1]=max(R.y[1],rs.y[1]);
	return R;
}
inline bool operator*(const point &amp;p,const rec &amp;R){
	return R.x[0]&lt;=p.x&amp;&amp;p.x&lt;=R.x[1]&amp;&amp;R.y[0]&lt;=p.y&amp;&amp;p.y&lt;=R.y[1];
}
inline bool In(const rec &amp;A,const rec &amp;B){
	return B.x[0]&lt;=A.x[0]&amp;&amp;A.x[1]&lt;=B.x[1]&amp;&amp;B.y[0]&lt;=A.y[0]&amp;&amp;A.y[1]&lt;=B.y[1];
}
inline bool Out(const rec &amp;A,const rec &amp;B){
	return B.x[0]&gt;A.x[1]||A.x[0]&gt;B.x[1]||B.y[0]&gt;A.y[1]||A.y[0]&gt;B.y[1];
}
struct node{
	rec R;point p;
	int sum,siz;
	node *c[2];
	node *rz(){
		sum=p.val;R=rec(p);siz=1;
		if(c[0])sum+=c[0]-&gt;sum,R=R+c[0]-&gt;R,siz+=c[0]-&gt;siz;
		if(c[1])sum+=c[1]-&gt;sum,R=R+c[1]-&gt;R,siz+=c[1]-&gt;siz;
		return this;
	}
	node(){sum=0;siz=1;c[0]=c[1]=0;}
}*root,*re,pool[maxn],*cur=pool;
node *sta[maxn];
int D,si;
bool cmp(const point &amp;A,const point &amp;B){
	if(D)return A.x&lt;B.x||(A.x==B.x&amp;&amp;A.y&lt;B.y);
	return A.y&lt;B.y||(A.y==B.y&amp;&amp;A.x&lt;B.x);
}
int top;
node *newnode(){
	if(si)return sta[si--];
	return cur++;
}
node* build(int l,int r,int d){
	int mid=(l+r)&gt;&gt;1;D=d;
	nth_element(p+l,p+mid,p+r+1,cmp);
	node *t=newnode();t-&gt;p=p[mid];
	if(l&lt;=mid-1)t-&gt;c[0]=build(l,mid-1,d^1);
	if(mid+1&lt;=r)t-&gt;c[1]=build(mid+1,r,d^1);
	return t-&gt;rz();
}
void dfs(node *&amp;t){
	if(t-&gt;c[0])dfs(t-&gt;c[0]);
	p[++top]=t-&gt;p;
	if(t-&gt;c[1])dfs(t-&gt;c[1]);
	sta[++si]=t;*t=node();
	//delete t;
}
node* rebuild(node *&amp;t){
	if(!t)return 0;
	top=0;dfs(t);
	return build(1,top,0);
}
#define siz(x) (x?x-&gt;siz:0)
void Add(node *&amp;t,point p){
	D^=1;
	if(!t){t=newnode(),t-&gt;p=p;t-&gt;rz();return;}
	if(t-&gt;p==p){t-&gt;p.val+=p.val;t-&gt;rz();return;}
	if(p[D]&lt;t-&gt;p[D])Add(t-&gt;c[0],p);
	else Add(t-&gt;c[1],p);t-&gt;rz();
	if(max(siz(t-&gt;c[0]),siz(t-&gt;c[1]))&gt;0.65*t-&gt;siz)
		re=t;
}
int ans;
void Q(const node *t,const rec &amp;R){
	if(Out(t-&gt;R,R))return ;
	if(In(t-&gt;R,R)){ans+=t-&gt;sum;return;}
	if(t-&gt;p*R)ans+=t-&gt;p.val;
	if(t-&gt;c[0])Q(t-&gt;c[0],R);
	if(t-&gt;c[1])Q(t-&gt;c[1],R);
}
int main(){
	n=in();
	while(1){
		int ty=in();if(ty==3)break;
		if(ty==1){
			int x=in()^lans,y=in()^lans,A=in()^lans;
			re=0;D=1;
			Add(root,(point){x,y,A});
			if(re)re=rebuild(re);
		}else{
			rec R;
			R.x[0]=in()^lans;R.y[0]=in()^lans;
			R.x[1]=in()^lans;R.y[1]=in()^lans;
			ans=0;if(root)Q(root,R);
			printf("%d\n",ans);
			lans=ans;
		}
	}
	return 0;
}</pre><pre></pre><h2>Problem4066</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
int lans=0;
const int maxn=2e5+5;
int in(){
	int r=0;char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))r=r*10+c-'0',c=getchar();
	return r;
}
int n;
struct point{
	int x,y,val;
	int&amp; operator[](const int s){return s==0?x:y;}
}p[maxn];
struct rec{
	int x[2],y[2];
	rec(){}
	rec(point p){x[0]=x[1]=p.x;y[0]=y[1]=p.y;}
};
bool operator==(const point &amp;A,const point &amp;B){
	return A.x==B.x&amp;&amp;A.y==B.y;
}
inline rec operator+(const rec &amp;ls,const rec &amp;rs){
	static rec R;R=ls;
	R.x[0]=min(R.x[0],rs.x[0]);
	R.x[1]=max(R.x[1],rs.x[1]);
	R.y[0]=min(R.y[0],rs.y[0]);
	R.y[1]=max(R.y[1],rs.y[1]);
	return R;
}
inline bool operator*(const point &amp;p,const rec &amp;R){
	return R.x[0]&lt;=p.x&amp;&amp;p.x&lt;=R.x[1]&amp;&amp;R.y[0]&lt;=p.y&amp;&amp;p.y&lt;=R.y[1];
}
inline bool In(const rec &amp;A,const rec &amp;B){
	return B.x[0]&lt;=A.x[0]&amp;&amp;A.x[1]&lt;=B.x[1]&amp;&amp;B.y[0]&lt;=A.y[0]&amp;&amp;A.y[1]&lt;=B.y[1];
}
inline bool Out(const rec &amp;A,const rec &amp;B){
	return B.x[0]&gt;A.x[1]||A.x[0]&gt;B.x[1]||B.y[0]&gt;A.y[1]||A.y[0]&gt;B.y[1];
}
struct node{
	rec R;point p;
	int sum,siz;
	node *c[2];
	node *rz(){
		sum=p.val;R=rec(p);siz=1;
		if(c[0])sum+=c[0]-&gt;sum,R=R+c[0]-&gt;R,siz+=c[0]-&gt;siz;
		if(c[1])sum+=c[1]-&gt;sum,R=R+c[1]-&gt;R,siz+=c[1]-&gt;siz;
		return this;
	}
	node(){sum=0;siz=1;c[0]=c[1]=0;}
}*root,*re,pool[maxn],*cur=pool;
node *sta[maxn];
int D,si;
bool cmp(const point &amp;A,const point &amp;B){
	if(D)return A.x&lt;B.x||(A.x==B.x&amp;&amp;A.y&lt;B.y);
	return A.y&lt;B.y||(A.y==B.y&amp;&amp;A.x&lt;B.x);
}
int top;
node *newnode(){
	if(si)return sta[si--];
	return cur++;
}
node* build(int l,int r,int d){
	int mid=(l+r)&gt;&gt;1;D=d;
	nth_element(p+l,p+mid,p+r+1,cmp);
	node *t=newnode();t-&gt;p=p[mid];
	if(l&lt;=mid-1)t-&gt;c[0]=build(l,mid-1,d^1);
	if(mid+1&lt;=r)t-&gt;c[1]=build(mid+1,r,d^1);
	return t-&gt;rz();
}
void dfs(node *&amp;t){
	if(t-&gt;c[0])dfs(t-&gt;c[0]);
	p[++top]=t-&gt;p;
	if(t-&gt;c[1])dfs(t-&gt;c[1]);
	sta[++si]=t;*t=node();
	//delete t;
}
node* rebuild(node *&amp;t){
	if(!t)return 0;
	top=0;dfs(t);
	return build(1,top,0);
}
#define siz(x) (x?x-&gt;siz:0)
void Add(node *&amp;t,point p){
	D^=1;
	if(!t){t=newnode(),t-&gt;p=p;t-&gt;rz();return;}
	if(t-&gt;p==p){t-&gt;p.val+=p.val;t-&gt;rz();return;}
	if(p[D]&lt;t-&gt;p[D])Add(t-&gt;c[0],p);
	else Add(t-&gt;c[1],p);t-&gt;rz();
	if(max(siz(t-&gt;c[0]),siz(t-&gt;c[1]))&gt;0.7*t-&gt;siz)
		re=t;
}
int ans;
void Q(const node *t,const rec &amp;R){
	if(Out(t-&gt;R,R))return ;
	if(In(t-&gt;R,R)){ans+=t-&gt;sum;return;}
	if(t-&gt;p*R)ans+=t-&gt;p.val;
	if(t-&gt;c[0])Q(t-&gt;c[0],R);
	if(t-&gt;c[1])Q(t-&gt;c[1],R);
}
int main(){
	n=in();
	while(1){
		int ty=in();if(ty==3)break;
		if(ty==1){
			int x=in()^lans,y=in()^lans,A=in()^lans;
			re=0;D=1;
			Add(root,(point){x,y,A});
			if(re)re=rebuild(re);
		}else{
			rec R;
			R.x[0]=in()^lans;R.y[0]=in()^lans;
			R.x[1]=in()^lans;R.y[1]=in()^lans;
			ans=0;if(root)Q(root,R);
			printf("%d\n",ans);
			lans=ans;
		}
	}
	return 0;
}</pre><pre></pre><h2>Problem4066</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
int lans=0;
const int maxn=2e5+5;
int in(){
	int r=0;char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))r=r*10+c-'0',c=getchar();
	return r;
}
int n;
struct point{
	int x,y,val;
	int&amp; operator[](const int s){return s==0?x:y;}
}p[maxn];
struct rec{
	int x[2],y[2];
	rec(){}
	rec(point p){x[0]=x[1]=p.x;y[0]=y[1]=p.y;}
};
bool operator==(const point &amp;A,const point &amp;B){
	return A.x==B.x&amp;&amp;A.y==B.y;
}
inline rec operator+(const rec &amp;ls,const rec &amp;rs){
	static rec R;R=ls;
	R.x[0]=min(R.x[0],rs.x[0]);
	R.x[1]=max(R.x[1],rs.x[1]);
	R.y[0]=min(R.y[0],rs.y[0]);
	R.y[1]=max(R.y[1],rs.y[1]);
	return R;
}
inline bool operator*(const point &amp;p,const rec &amp;R){
	return R.x[0]&lt;=p.x&amp;&amp;p.x&lt;=R.x[1]&amp;&amp;R.y[0]&lt;=p.y&amp;&amp;p.y&lt;=R.y[1];
}
inline bool In(const rec &amp;A,const rec &amp;B){
	return B.x[0]&lt;=A.x[0]&amp;&amp;A.x[1]&lt;=B.x[1]&amp;&amp;B.y[0]&lt;=A.y[0]&amp;&amp;A.y[1]&lt;=B.y[1];
}
inline bool Out(const rec &amp;A,const rec &amp;B){
	return B.x[0]&gt;A.x[1]||A.x[0]&gt;B.x[1]||B.y[0]&gt;A.y[1]||A.y[0]&gt;B.y[1];
}
struct node{
	rec R;point p;
	int sum,siz;
	node *c[2];
	node *rz(){
		sum=p.val;R=rec(p);siz=1;
		if(c[0])sum+=c[0]-&gt;sum,R=R+c[0]-&gt;R,siz+=c[0]-&gt;siz;
		if(c[1])sum+=c[1]-&gt;sum,R=R+c[1]-&gt;R,siz+=c[1]-&gt;siz;
		return this;
	}
	node(){sum=0;siz=1;c[0]=c[1]=0;}
}*root,*re,pool[maxn],*cur=pool;
node *sta[maxn];
int D,si;
bool cmp(const point &amp;A,const point &amp;B){
	if(D)return A.x&lt;B.x||(A.x==B.x&amp;&amp;A.y&lt;B.y);
	return A.y&lt;B.y||(A.y==B.y&amp;&amp;A.x&lt;B.x);
}
int top;
node *newnode(){
	if(si)return sta[si--];
	return cur++;
}
node* build(int l,int r,int d){
	int mid=(l+r)&gt;&gt;1;D=d;
	nth_element(p+l,p+mid,p+r+1,cmp);
	node *t=newnode();t-&gt;p=p[mid];
	if(l&lt;=mid-1)t-&gt;c[0]=build(l,mid-1,d^1);
	if(mid+1&lt;=r)t-&gt;c[1]=build(mid+1,r,d^1);
	return t-&gt;rz();
}
void dfs(node *&amp;t){
	if(t-&gt;c[0])dfs(t-&gt;c[0]);
	p[++top]=t-&gt;p;
	if(t-&gt;c[1])dfs(t-&gt;c[1]);
	sta[++si]=t;*t=node();
	//delete t;
}
node* rebuild(node *&amp;t){
	if(!t)return 0;
	top=0;dfs(t);
	return build(1,top,0);
}
#define siz(x) (x?x-&gt;siz:0)
void Add(node *&amp;t,point p){
	D^=1;
	if(!t){t=newnode(),t-&gt;p=p;t-&gt;rz();return;}
	if(t-&gt;p==p){t-&gt;p.val+=p.val;t-&gt;rz();return;}
	if(p[D]&lt;t-&gt;p[D])Add(t-&gt;c[0],p);
	else Add(t-&gt;c[1],p);t-&gt;rz();
	if(max(siz(t-&gt;c[0]),siz(t-&gt;c[1]))&gt;0.75*t-&gt;siz)
		re=t;
}
int ans;
void Q(const node *t,const rec &amp;R){
	if(Out(t-&gt;R,R))return ;
	if(In(t-&gt;R,R)){ans+=t-&gt;sum;return;}
	if(t-&gt;p*R)ans+=t-&gt;p.val;
	if(t-&gt;c[0])Q(t-&gt;c[0],R);
	if(t-&gt;c[1])Q(t-&gt;c[1],R);
}
int main(){
	n=in();
	while(1){
		int ty=in();if(ty==3)break;
		if(ty==1){
			int x=in()^lans,y=in()^lans,A=in()^lans;
			re=0;D=1;
			Add(root,(point){x,y,A});
			if(re)re=rebuild(re);
		}else{
			rec R;
			R.x[0]=in()^lans;R.y[0]=in()^lans;
			R.x[1]=in()^lans;R.y[1]=in()^lans;
			ans=0;if(root)Q(root,R);
			printf("%d\n",ans);
			lans=ans;
		}
	}
	return 0;
}</pre><pre></pre><h2>Problem4066</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
int lans=0;
const int maxn=2e5+5;
int in(){
    int r=0;char c=getchar();
    while(!isdigit(c))c=getchar();
    while(isdigit(c))r=r*10+c-'0',c=getchar();
    return r;
}
int n;
struct point{
    int x,y,val;
    int&amp; operator[](const int s){return s==0?x:y;}
}p[maxn];
struct rec{
    int x[2],y[2];
    rec(){}
    rec(point p){x[0]=x[1]=p.x;y[0]=y[1]=p.y;}
};
bool operator==(const point &amp;A,const point &amp;B){
    return A.x==B.x&amp;&amp;A.y==B.y;
}
inline rec operator+(const rec &amp;ls,const rec &amp;rs){
    static rec R;R=ls;
    R.x[0]=min(R.x[0],rs.x[0]);
    R.x[1]=max(R.x[1],rs.x[1]);
    R.y[0]=min(R.y[0],rs.y[0]);
    R.y[1]=max(R.y[1],rs.y[1]);
    return R;
}
inline bool operator*(const point &amp;p,const rec &amp;R){
    return R.x[0]&lt;=p.x&amp;&amp;p.x&lt;=R.x[1]&amp;&amp;R.y[0]&lt;=p.y&amp;&amp;p.y&lt;=R.y[1];
}
inline bool In(const rec &amp;A,const rec &amp;B){
    return B.x[0]&lt;=A.x[0]&amp;&amp;A.x[1]&lt;=B.x[1]&amp;&amp;B.y[0]&lt;=A.y[0]&amp;&amp;A.y[1]&lt;=B.y[1];
}
inline bool Out(const rec &amp;A,const rec &amp;B){
    return B.x[0]&gt;A.x[1]||A.x[0]&gt;B.x[1]||B.y[0]&gt;A.y[1]||A.y[0]&gt;B.y[1];
}
struct node{
    rec R;point p;
    int sum,siz;
    node *c[2];
    node *rz(){
        sum=p.val;R=rec(p);siz=1;
        if(c[0])sum+=c[0]-&gt;sum,R=R+c[0]-&gt;R,siz+=c[0]-&gt;siz;
        if(c[1])sum+=c[1]-&gt;sum,R=R+c[1]-&gt;R,siz+=c[1]-&gt;siz;
        return this;
    }
    node(){sum=0;siz=1;c[0]=c[1]=0;}
}*root,*re,pool[maxn],*cur=pool;
node *sta[maxn];
int D,si;
bool cmp(const point &amp;A,const point &amp;B){
    if(D)return A.x&lt;B.x||(A.x==B.x&amp;&amp;A.y&lt;B.y);
    return A.y&lt;B.y||(A.y==B.y&amp;&amp;A.x&lt;B.x);
}
int top;
node *newnode(){
    if(si)return sta[si--];
    return cur++;
}
node* build(int l,int r,int d){
    int mid=(l+r)&gt;&gt;1;D=d;
    nth_element(p+l,p+mid,p+r+1,cmp);
    node *t=newnode();t-&gt;p=p[mid];
    if(l&lt;=mid-1)t-&gt;c[0]=build(l,mid-1,d^1);
    if(mid+1&lt;=r)t-&gt;c[1]=build(mid+1,r,d^1);
    return t-&gt;rz();
}
void dfs(node *&amp;t){
    if(t-&gt;c[0])dfs(t-&gt;c[0]);
    p[++top]=t-&gt;p;
    if(t-&gt;c[1])dfs(t-&gt;c[1]);
    sta[++si]=t;*t=node();
    //delete t;
}
node* rebuild(node *&amp;t){
    if(!t)return 0;
    top=0;dfs(t);
    return build(1,top,0);
}
#define siz(x) (x?x-&gt;siz:0)
void Add(node *&amp;t,point p){
    D^=1;
    if(!t){t=newnode(),t-&gt;p=p;t-&gt;rz();return;}
    if(t-&gt;p==p){t-&gt;p.val+=p.val;t-&gt;rz();return;}
    if(p[D]&lt;t-&gt;p[D])Add(t-&gt;c[0],p);
    else Add(t-&gt;c[1],p);t-&gt;rz();
    if(max(siz(t-&gt;c[0]),siz(t-&gt;c[1]))&gt;0.95*t-&gt;siz)
        re=t;
}
int ans;
void Q(const node *t,const rec &amp;R){
    if(Out(t-&gt;R,R))return ;
    if(In(t-&gt;R,R)){ans+=t-&gt;sum;return;}
    if(t-&gt;p*R)ans+=t-&gt;p.val;
    if(t-&gt;c[0])Q(t-&gt;c[0],R);
    if(t-&gt;c[1])Q(t-&gt;c[1],R);
}
int main(){
    n=in();
    while(1){
        int ty=in();if(ty==3)break;
        if(ty==1){
            int x=in()^lans,y=in()^lans,A=in()^lans;
            re=0;D=1;
            Add(root,(point){x,y,A});
            if(re)re=rebuild(re);
        }else{
            rec R;
            R.x[0]=in()^lans;R.y[0]=in()^lans;
            R.x[1]=in()^lans;R.y[1]=in()^lans;
            ans=0;if(root)Q(root,R);
            printf("%d\n",ans);
            lans=ans;
        }
    }
    return 0;
}</pre><pre></pre><h2>Problem4066</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
int lans=0;
const int maxn=2e5+5;
int in(){
    int r=0;char c=getchar();
    while(!isdigit(c))c=getchar();
    while(isdigit(c))r=r*10+c-'0',c=getchar();
    return r;
}
int n;
struct point{
    int x,y,val;
    int&amp; operator[](const int s){return s==0?x:y;}
}p[maxn];
struct rec{
    int x[2],y[2];
    rec(){}
    rec(point p){x[0]=x[1]=p.x;y[0]=y[1]=p.y;}
};
bool operator==(const point &amp;A,const point &amp;B){
    return A.x==B.x&amp;&amp;A.y==B.y;
}
inline rec operator+(const rec &amp;ls,const rec &amp;rs){
    static rec R;R=ls;
    R.x[0]=min(R.x[0],rs.x[0]);
    R.x[1]=max(R.x[1],rs.x[1]);
    R.y[0]=min(R.y[0],rs.y[0]);
    R.y[1]=max(R.y[1],rs.y[1]);
    return R;
}
inline bool operator*(const point &amp;p,const rec &amp;R){
    return R.x[0]&lt;=p.x&amp;&amp;p.x&lt;=R.x[1]&amp;&amp;R.y[0]&lt;=p.y&amp;&amp;p.y&lt;=R.y[1];
}
inline bool In(const rec &amp;A,const rec &amp;B){
    return B.x[0]&lt;=A.x[0]&amp;&amp;A.x[1]&lt;=B.x[1]&amp;&amp;B.y[0]&lt;=A.y[0]&amp;&amp;A.y[1]&lt;=B.y[1];
}
inline bool Out(const rec &amp;A,const rec &amp;B){
    return B.x[0]&gt;A.x[1]||A.x[0]&gt;B.x[1]||B.y[0]&gt;A.y[1]||A.y[0]&gt;B.y[1];
}
struct node{
    rec R;point p;
    int sum,siz;
    node *c[2];
    node *rz(){
        sum=p.val;R=rec(p);siz=1;
        if(c[0])sum+=c[0]-&gt;sum,R=R+c[0]-&gt;R,siz+=c[0]-&gt;siz;
        if(c[1])sum+=c[1]-&gt;sum,R=R+c[1]-&gt;R,siz+=c[1]-&gt;siz;
        return this;
    }
    node(){sum=0;siz=1;c[0]=c[1]=0;}
}*root,*re,pool[maxn],*cur=pool;
node *sta[maxn];
int D,si;
bool cmp(const point &amp;A,const point &amp;B){
    if(D)return A.x&lt;B.x||(A.x==B.x&amp;&amp;A.y&lt;B.y);
    return A.y&lt;B.y||(A.y==B.y&amp;&amp;A.x&lt;B.x);
}
int top;
node *newnode(){
    if(si)return sta[si--];
    return cur++;
}
node* build(int l,int r,int d){
    int mid=(l+r)&gt;&gt;1;D=d;
    nth_element(p+l,p+mid,p+r+1,cmp);
    node *t=newnode();t-&gt;p=p[mid];
    if(l&lt;=mid-1)t-&gt;c[0]=build(l,mid-1,d^1);
    if(mid+1&lt;=r)t-&gt;c[1]=build(mid+1,r,d^1);
    return t-&gt;rz();
}
void dfs(node *&amp;t){
    if(t-&gt;c[0])dfs(t-&gt;c[0]);
    p[++top]=t-&gt;p;
    if(t-&gt;c[1])dfs(t-&gt;c[1]);
    sta[++si]=t;*t=node();
    //delete t;
}
node* rebuild(node *&amp;t){
    if(!t)return 0;
    top=0;dfs(t);
    return build(1,top,0);
}
#define siz(x) (x?x-&gt;siz:0)
void Add(node *&amp;t,point p){
    D^=1;
    if(!t){t=newnode(),t-&gt;p=p;t-&gt;rz();return;}
    if(t-&gt;p==p){t-&gt;p.val+=p.val;t-&gt;rz();return;}
    if(p[D]&lt;t-&gt;p[D])Add(t-&gt;c[0],p);
    else Add(t-&gt;c[1],p);t-&gt;rz();
    if(max(siz(t-&gt;c[0]),siz(t-&gt;c[1]))&gt;0.8*t-&gt;siz)
        re=t;
}
int ans;
void Q(const node *t,const rec &amp;R){
    if(Out(t-&gt;R,R))return ;
    if(In(t-&gt;R,R)){ans+=t-&gt;sum;return;}
    if(t-&gt;p*R)ans+=t-&gt;p.val;
    if(t-&gt;c[0])Q(t-&gt;c[0],R);
    if(t-&gt;c[1])Q(t-&gt;c[1],R);
}
int main(){
    n=in();
    while(1){
        int ty=in();if(ty==3)break;
        if(ty==1){
            int x=in()^lans,y=in()^lans,A=in()^lans;
            re=0;D=1;
            Add(root,(point){x,y,A});
            if(re)re=rebuild(re);
        }else{
            rec R;
            R.x[0]=in()^lans;R.y[0]=in()^lans;
            R.x[1]=in()^lans;R.y[1]=in()^lans;
            ans=0;if(root)Q(root,R);
            printf("%d\n",ans);
            lans=ans;
        }
    }
    return 0;
}</pre><pre></pre><h2>Problem4069</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
#define ok(x) ((((x)&gt;&gt;bit+1)|ans)==ans&amp;&amp;((x)&gt;&gt;bit&amp;1)==0)
LL s[2333];
int n,A,B;
void sol1(){
	static int g[2333];
	LL ans=0,res=0;int bit=0,i,j,k;
    while((1LL&lt;&lt;bit)&lt;s[n])bit++;
    for(;bit&gt;=0;bit--){
        for(i=1;i&lt;=n;i++)
        for(g[i]=n+1,k=0;k&lt;i;k++)
        if(ok(s[i]-s[k])&amp;&amp;g[i]&gt;g[k]+1)g[i]=g[k]+1;
        ans=ans&lt;&lt;1|(g[n]&gt;B);
    }
    cout&lt;&lt;ans&lt;&lt;endl;
}
void sol2(){
	static int f[101][101];
	LL ans=0;int bit=0;
	while((1LL&lt;&lt;bit)&lt;s[n])bit++;
	for(;bit&gt;=0;bit--){
		f[0][0]=1;
		for(int i=1;i&lt;=n;i++)
		for(int j=1;j&lt;=min(i,B);j++){
			f[i][j]=0;
			for(int k=0;k&lt;i&amp;&amp;!f[i][j];k++)
			if(f[k][j-1]&amp;&amp;ok(s[i]-s[k]))f[i][j]=1;
		}int flag=1;
		for(int j=A;j&lt;=B;j++)if(f[n][j])flag=0;
		ans=ans&lt;&lt;1|flag;
	}cout&lt;&lt;ans&lt;&lt;endl;
}
int main(){
	scanf("%d%d%d",&amp;n,&amp;A,&amp;B);
	for(int i=1;i&lt;=n;i++){
		int x;scanf("%d",&amp;x);
		s[i]=s[i-1]+x;
	}	
	if(A==1)sol1();
	else sol2();
	return 0;
}</pre><pre></pre><h2>Problem4070</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
int sqrtn;
const int maxn=30001;
int n,m;
int mp[100+1][maxn];
int B[maxn],P[maxn];
int getn(){
	int res=0;char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))res=res*10+c-'0',c=getchar();
	return res;
}
vector&lt;pair&lt;int,int&gt; &gt;G[maxn*100];
void add(int u,int v,int w){
//	cerr&lt;&lt;u&lt;&lt;" "&lt;&lt;v&lt;&lt;" "&lt;&lt;w&lt;&lt;endl;
	G[u].push_back(make_pair(v,w));
}
void dijk(int s,int t){
	static int d[maxn*100];
	static short vis[maxn*100];
	priority_queue&lt;pair&lt;int,int&gt;,vector&lt;pair&lt;int,int&gt; &gt;,greater&lt;pair&lt;int,int&gt; &gt; &gt;q;
	memset(d,0x7f,sizeof d);int B=d[s];
	d[s]=0;q.push(make_pair(d[s],s));
	while(!q.empty()){
		int u=q.top().second;
		if(d[u]!=q.top().first){q.pop();continue;}q.pop();
		for(int i=0;i&lt;G[u].size();i++){
			int v=G[u][i].first,w=G[u][i].second;
			if(d[v]&gt;d[u]+w){
				d[v]=d[u]+w;
				q.push(make_pair(d[v],v));
			}
		}
	}if(d[t]==B)puts("-1");
	else cout&lt;&lt;d[t]&lt;&lt;endl;
}
void make(){
	for(int i=1;i&lt;sqrtn;i++)
	for(int j=0;j&lt;n;j++){
		if(j-i&gt;=0)
		add(mp[i][j],mp[i][j-i],1);
		if(j+i&lt;n)
		add(mp[i][j],mp[i][j+i],1);
		add(mp[i][j],j,0);
	}
	for(int i=0;i&lt;m;i++){
		if(P[i]&lt;sqrtn){
			add(B[i],mp[P[i]][B[i]],0);
		}else{
			for(int j=B[i]+P[i],k=1;j&lt;n;j+=P[i],k++)
				add(B[i],j,k);
			for(int j=B[i]-P[i],k=1;j&gt;=0;j-=P[i],k++)
				add(B[i],j,k);
		}
	}
}
int main(){
//	freopen("in","r",stdin);
	n=getn();m=getn();sqrtn=sqrt(n)+1;
	sqrtn=min(sqrtn,10);
	for(int i=0;i&lt;m;i++)B[i]=getn(),P[i]=getn();
	int z=0;
	for(int i=0;i&lt;sqrtn;i++)
	for(int j=0;j&lt;n;j++)mp[i][j]=z++;
	make();
	dijk(B[0],B[1]);
	return 0;
}</pre><pre></pre><h2>Problem4072</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
int n;
struct pack:public pair&lt;int,int&gt;{
	int &amp;f(){return first;}
	int &amp;s(){return second;}
};
void solve(int l,int r){
	int n=(r-l+1)/2-1;
	if(n==4){
		printf("%d to %d\n",r-2,l);
		printf("%d to %d\n",l+4,r-2);
		printf("%d to %d\n",l+1,l+4);
		printf("%d to %d\n",r-1,l+1);
	}else if(n==5){
		printf("%d to %d\n",r-2,l);
		printf("%d to %d\n",l+4,r-2);
		printf("%d to %d\n",r-4,l+4);
		printf("%d to %d\n",l+1,r-4);
		printf("%d to %d\n",r-1,l+1);
	}else if(n==6){
		printf("%d to %d\n",r-2,l);
		printf("%d to %d\n",r-5,r-2);
		printf("%d to %d\n",l+3,r-5);
		printf("%d to %d\n",r-6,l+3);
		printf("%d to %d\n",l+1,r-6);
		printf("%d to %d\n",r-1,l+1);
	}else if(n==7){
		printf("%d to %d\n",r-2,l);
		printf("%d to %d\n",l+6,r-2);
		printf("%d to %d\n",l+9,l+6);
		printf("%d to %d\n",l+4,l+9);
		printf("%d to %d\n",r-5,l+4);
		printf("%d to %d\n",l+1,r-5);
		printf("%d to %d\n",r-1,l+1);
	}else{
		printf("%d to %d\n",r-2,l);
		printf("%d to %d\n",l+4,r-2);
		solve(l+4,r-4);
		printf("%d to %d\n",l+1,r-5);
		printf("%d to %d\n",r-1,l+1);
	}
}
int main(){
	cin&gt;&gt;n;
	if(n==3){
		puts("2 to -1");
		puts("5 to 2");
		puts("3 to -3");
	}else
		solve(-1,n*2);
	return 0;
}</pre><pre></pre><h2>Problem4075</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
int n;
vector&lt;int&gt;vec[26];
int ans[26][26];
char str[26];
int main(){
	scanf("%d",&amp;n);
	for(int i=0;i&lt;n;i++){
		int m;scanf("%d",&amp;m);
		while(m--){
			scanf("%s",str);
			int t=0,l=strlen(str);
			for(int j=0;j&lt;l;j++)t|=1&lt;&lt;(str[j]-'a');
			vec[i].push_back(t);
		}
	}memset(ans,-1,sizeof ans);
	for(int j=0;j&lt;n;j++){
		int s=1&lt;&lt;j;
		ans[j][j]=0;
		for(int cnt=1;cnt&lt;n;cnt++){
			int ns=s;
			for(int i=0;i&lt;n;i++)if(ans[i][j]==-1){
				int ok=0;
				for(int k=0;k&lt;vec[i].size();k++){
					if((s&amp;vec[i][k])==vec[i][k]){
						ok=1;break;
					}
				}
				if(ok){
					ns|=1&lt;&lt;i;
					ans[i][j]=cnt;
				}
			}s=ns;
		}
	}for(int i=0;i&lt;n;i++)
	for(int j=0;j&lt;n;j++)
	printf("%d%c",ans[i][j]," \n"[j+1==n]);
	return 0;
}</pre><pre></pre><h2>Problem4080</h2><pre>#include &lt;bitset&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#define M 110
using namespace std;
typedef bitset&lt;M&gt; abcd;
struct Point{
    int x,y;
    friend istream&amp; operator &gt;&gt; (istream &amp;_,Point &amp;p)
    {
        return scanf("%d%d",&amp;p.x,&amp;p.y),_;
    }
    friend bool operator &lt; (const Point &amp;p1,const Point &amp;p2)
    {
        return p1.x &lt; p2.x ;
    }
    friend int Distance(const Point &amp;p1,const Point &amp;p2)
    {
        return (p1.x-p2.x)*(p1.x-p2.x) + (p1.y-p2.y)*(p1.y-p2.y) ;
    }
}points[M];
int n,d;
abcd a[M];
abcd now,able,ans;
int main()
{
    int i,j;
    cin&gt;&gt;n&gt;&gt;d;
    for(i=1;i&lt;=n;i++)
        cin&gt;&gt;points[i];
    for(i=1;i&lt;=n;i++)
        for(j=i+1;j&lt;=n;j++)
            if(Distance(points[i],points[j])&lt;=d*d)
                a[i][j]=a[j][i]=true;
    static int order[M];
    for(i=1;i&lt;=n;i++)
    {
        able[i]=true;
        order[i]=i;
    }
    for(j=1;j&lt;=1000;j++)
    {
        abcd able=::able;
        now.reset();
        for(i=1;i&lt;=n;i++)
            if(able[order[i]])
            {
                now[order[i]]=true;
                able&amp;=a[order[i]];
            }
        if(now.count()&gt;ans.count())
            ans=now;
        random_shuffle(order+1,order+n+1);
    }
    cout&lt;&lt;ans.count()&lt;&lt;endl;
    for(i=1;i&lt;=n;i++)
        if(ans[i])
           printf("%d ",i);
    return 0;
}</pre><pre></pre><h2>Problem4082</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1e6+5;
int n,m;
int in(){
	int r=0;char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))r=r*10+c-'0',c=getchar();
	return r;
}
struct Seg{
	int l,r;
	bool operator&lt;(const Seg &amp;oth)const{return r!=oth.r?r&lt;oth.r:l&lt;oth.l;}
}se[maxn];
int fa[maxn&lt;&lt;1],dep[maxn&lt;&lt;1],can[maxn&lt;&lt;1];
vector&lt;int&gt;G[maxn&lt;&lt;1];
void find(int x){
	if(dep[x])return;
	if(!fa[x]){
		dep[x]=1;
		if(x&gt;n&amp;&amp;can[x]){
			fa[x]=2*n+1;
			G[2*n+1].push_back(x);
//			cerr&lt;&lt;2*n+1&lt;&lt;" "&lt;&lt;x&lt;&lt;endl;
		}return;
	}
	find(fa[x]);
	G[fa[x]].push_back(x);
//	cerr&lt;&lt;fa[x]&lt;&lt;" "&lt;&lt;x&lt;&lt;endl;
	dep[x]=dep[fa[x]]+1;
}
int son[maxn&lt;&lt;1],siz[maxn&lt;&lt;1],top[maxn&lt;&lt;1];
void dfs(int u){
	siz[u]=1;
	for(int i=0;i&lt;G[u].size();i++){
		int v=G[u][i];
		dfs(v);
		siz[u]+=siz[v];
		if(siz[son[u]]&lt;siz[v])son[u]=v;
	}
}
void build(int u,int tp){
	top[u]=tp;
	if(son[u])build(son[u],tp);
	for(int i=0;i&lt;G[u].size();i++)if(G[u][i]!=son[u])
		build(G[u][i],G[u][i]);
}
set&lt;int&gt;S;
int lca(int x,int y){
	int ans=0;y=*S.lower_bound(y);
	if(top[y]==0||top[x]==0)return 0;
	while(top[x]!=top[y]){
		if(dep[top[x]]&lt;dep[top[y]])swap(x,y);
		x=fa[top[x]];
	}
	return dep[x]&lt;dep[y]?x:y;
}
int main(){
	n=in();m=in();
	for(int i=1;i&lt;=m;i++){
		se[i].l=in();
		se[i].r=in();
		if(se[i].l&gt;se[i].r)se[i].r+=n;
	}sort(se+1,se+1+m);
	for(int i=m;i&gt;=1;i--){
		if(!fa[se[i].l]){ 
			for(int j=se[i].l;j&lt;=n&amp;&amp;j&lt;=se[i].r&amp;&amp;!fa[j];j++){
				fa[j]=se[i].r+1;can[fa[j]]=1;
				if(fa[j]&gt;n)S.insert(fa[j]);
			}
		}
	}
	S.insert(2*n+2);
	for(int i=1;i&lt;=n*2;i++)
		find(i);
	dfs(2*n+1);
	build(n*2+1,n*2+1);
	int ans=INT_MAX;
	for(int i=1;i&lt;=n;i++){
		int LCA=lca(i,i+n);
		if(LCA)
		ans=min(ans,dep[i]-dep[LCA]);
	}
	if(ans==INT_MAX)puts("impossible");
	else cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem4103</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=300010;
const int BIT=32;
int in(){
	int r=0;char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))r=r*10+c-'0',c=getchar();
	return r;
}
int n,m,q;
int a[maxn],b[maxn];
struct node{
	int siz,sum;
	node *c[2];
	void rz(){
		sum=0;
		if(c[0])sum+=c[0]-&gt;sum;
		if(c[1])sum+=c[1]-&gt;sum;
	}
	node(){siz=0;c[0]=c[1]=0;sum=0;}
}*root[maxn],*x[maxn],*y[maxn];
#define siz(x) (x?x-&gt;siz:0)
#define sum(x) (x?x-&gt;sum:0)
#define c(x,d) (x?x-&gt;c[d]:0)
void insert(node *x,node *y,int val,int d){
	if(d&lt;0){
		
		return;
	}
	int v=val&gt;&gt;d&amp;1;
	x-&gt;c[v]=new node();
	if(c(y,v))*x-&gt;c[v]=*c(y,v);x-&gt;c[v]-&gt;sum++;
	x-&gt;c[!v]=c(y,!v);
	insert(c(x,v),c(y,v),val,d-1);
	x-&gt;rz();
}
int Q(int U,int D,int L,int R,int K){
	int ans=0,cur=0,tmp;
	for(int i=U;i&lt;=D;i++)x[i]=root[R],y[i]=root[L-1];
	for(int i=BIT-1;i&gt;=0;i--){
		tmp=0;
		for(int j=U;j&lt;=D;j++)if(!(a[j]&gt;&gt;i&amp;1))
			tmp+=(sum(x[j])-sum(c(x[j],1)))-(sum(y[j])-sum(c(y[j],1)));
		else tmp+=(sum(x[j])-sum(c(x[j],0)))-(sum(y[j])-sum(c(y[j],0)));
		
		if(tmp&gt;=K){
			// 0
			for(int j=U;j&lt;=D;j++){
				int v=a[j]&gt;&gt;i&amp;1;
				x[j]=c(x[j],v);
				y[j]=c(y[j],v);
			}
		}else{
			K-=tmp;
			ans|=1&lt;&lt;i;
			for(int j=U;j&lt;=D;j++){
				int v=!(a[j]&gt;&gt;i&amp;1);
				x[j]=c(x[j],v);
				y[j]=c(y[j],v);
			}
		}
	}return ans;
}
int main(){
	n=in();m=in();
	for(int i=1;i&lt;=n;i++)a[i]=in();
	for(int i=1;i&lt;=m;i++)b[i]=in();	
	for(int i=1;i&lt;=m;i++){
		root[i]=new node();if(root[i-1])*root[i]=*root[i-1];
		insert(root[i],root[i-1],b[i],BIT-1);
	}
	q=in();
	while(q--){
		int u=in(),d=in(),l=in(),r=in(),k=(d-u+1)*(r-l+1)-in()+1;
		printf("%d\n",Q(u,d,l,r,k));
	}
	return 0;
}</pre><pre></pre><h2>Problem4104</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=200010;
int in(){
	int r=0;char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))r=r*10+c-'0',c=getchar();
	return r;
}
int n,m,L[maxn],F[maxn],cnt[maxn],nxt[maxn];
deque&lt;int&gt;dq[maxn];
vector&lt;int&gt;anss;
int main(){
	n=in();m=in();
	for(int i=1;i&lt;=n+1;i++)F[i]=L[i]=in();
	sort(F+1,F+2+n);
	for(int i=1;i&lt;=n+1;i++)dq[F[i]].push_back(i);
	for(int i=1;i&lt;=n+1;i++)nxt[i]=dq[L[i]].front(),dq[L[i]].pop_front();
	for(int i=1,j=1;i&lt;=n;i++,j=nxt[j])
		anss.push_back(L[j]);
	reverse(anss.begin(),anss.end());
	for(int i=0;i&lt;n;i++)printf("%d ",anss[i]);
	return 0;
}</pre><pre></pre><h2>Problem4105</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1e5+5;
int in(){
	int r=0;char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))r=r*10+c-'0',c=getchar();
	return r;
}
int n,m,p,X;
int a[maxn],cir[maxn],dep[maxn],vis[maxn];
void dfs(int x){
	if(vis[x]==X){
		if(x==X)cir[x]=1;
		return;
	}vis[x]=X;dfs(x*x%p);
}
void dfs(int x,int d){
	if(cir[x])return void(dep[x]=d);
	dfs(x*x%p,d+1);
}
struct info{
	int cur;
	vector&lt;int&gt;vec;
	bool ci;
	info(){cur=0;ci=0;}
	int sum()const{return vec[cur];}
};
void deb(vector&lt;int&gt;v){
	for(int i=0;i&lt;v.size();i++)
		fprintf(stderr,"%d%c",v[i]," \n"[i+1==n]);
	fprintf(stderr,"\n");
}
struct flag{
	int add;
	flag(int add=0):add(add){};
};
int lcm(int x,int y){return x*y/__gcd(x,y);}
inline info operator+(const info &amp;ls,const info &amp;rs){
	info in;
	in.ci=ls.ci&amp;rs.ci;
	if(in.ci){
		int cu1=ls.cur,cu2=rs.cur;
		int l=lcm(ls.vec.size(),rs.vec.size());
		in.vec.resize(l);
		for(int i=0;i&lt;l;i++){
			in.vec[i]=ls.vec[cu1]+rs.vec[cu2];
//			cu1=(cu1+1)%ls.vec.size();
//			cu2=(cu2+1)%rs.vec.size();
			cu1++;cu2++;
			if(cu1==ls.vec.size())cu1=0;
			if(cu2==rs.vec.size())cu2=0;
		}in.cur=0;
	}else{
		in.vec.clear();
		in.vec.push_back(ls.sum()+rs.sum());
	}return in;
}
info operator+(const flag &amp;ls,const info &amp;rs){
	info in=rs;
	if(in.ci)
		in.cur=(in.cur+ls.add)%in.vec.size();
	else{
		int t=ls.add;
		while(t--)in.vec[0]=in.vec[0]*in.vec[0]%p;
	}return in;
}
flag operator+(const flag &amp;ls,const flag &amp;rs){
	return flag(ls.add+rs.add);
}
#define lson i&lt;&lt;1,l,(l+r)/2
#define rson i&lt;&lt;1|1,(l+r)/2+1,r
#define ls i&lt;&lt;1
#define rs i&lt;&lt;1|1
vector&lt;int&gt;get(int x){
	vector&lt;int&gt;vec;
	vec.push_back(x);
	do{
		x=x*x%p;
		vec.push_back(x);
	}while(x!=vec.front());
	vec.pop_back();
	return vec;
}
struct sgt{
	info Info[maxn&lt;&lt;2];
	flag Flag[maxn&lt;&lt;2];
	void pd(int i){
		if(!Flag[i].add)return;
		Info[ls]=Flag[i]+Info[ls];
		Info[rs]=Flag[i]+Info[rs];
		Flag[ls]=Flag[i]+Flag[ls];
		Flag[rs]=Flag[i]+Flag[rs];
		Flag[i].add=0;		
	}
	void build(int i,int l,int r){
		if(l==r){
			if(cir[a[l]]){
				Info[i].vec=get(a[l]);
				Info[i].ci=1;
			}else{
				Info[i].vec.push_back(a[l]);
				Info[i].ci=0;
			}
			return;
		}build(lson);build(rson);
		Info[i]=Info[ls]+Info[rs];
	}
	int Q(int i,int l,int r,int l0,int r0){
		if(l0&lt;=l&amp;&amp;r0&gt;=r)return Info[i].sum();
		int ans=0;pd(i);
		if(l0&lt;=(l+r)/2)ans+=Q(lson,l0,r0);
		if(r0&gt;(l+r)/2)ans+=Q(rson,l0,r0);
		return ans;
	}
	void C(int i,int l,int r,int l0,int r0){
		if(l==r){
			if(Info[i].ci){
				Info[i].cur=(Info[i].cur+1)%Info[i].vec.size();
			}else{
				Info[i].vec[0]=Info[i].vec[0]*Info[i].vec[0]%p;
				Info[i].ci=cir[Info[i].vec[0]];
				if(Info[i].ci)
					Info[i].vec=get(Info[i].vec[0]),Info[i].cur=0;
			}
			return;
		}
		if(l0&lt;=l&amp;&amp;r0&gt;=r&amp;&amp;Info[i].ci){
			Info[i]=flag(1)+Info[i];
			Flag[i]=flag(1)+Flag[i];
			return;
		}pd(i);
		if(l0&lt;=(l+r)/2)C(lson,l0,r0);
		if(r0&gt;(l+r)/2)C(rson,l0,r0);
		Info[i]=Info[ls]+Info[rs];
	}
}T;
void pre(){
	n=in();m=in();p=in();
	for(int i=1;i&lt;=n;i++)a[i]=in();
	for(int i=0;i&lt;p;i++)X=i,dfs(i);
	for(int i=0;i&lt;p;i++)dfs(i,0);
}
int main(){
	pre();
	T.build(1,1,n);
	while(m--){
		int op=in();
		int l=in(),r=in();
		if(op==0)T.C(1,1,n,l,r);
		else printf("%d\n",T.Q(1,1,n,l,r));
	}
	return 0;
}</pre><pre></pre><h2>Problem4105</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1e5+5;
int in(){
	int r=0;char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))r=r*10+c-'0',c=getchar();
	return r;
}
int n,m,p,X;
int a[maxn],cir[maxn],dep[maxn],vis[maxn],nx[maxn];
void dfs(int x){
	if(vis[x]==X){
		if(x==X)cir[x]=1;
		return;
	}vis[x]=X;dfs(nx[x]);
}
void dfs(int x,int d){
	if(cir[x])return void(dep[x]=d);
	dfs(nx[x],d+1);
}
struct info{
	int cur;
	vector&lt;int&gt;vec;
	bool ci;
	info(){cur=0;ci=0;}
	int sum()const{return vec[cur];}
};
void deb(vector&lt;int&gt;v){
	for(int i=0;i&lt;v.size();i++)
		fprintf(stderr,"%d%c",v[i]," \n"[i+1==n]);
	fprintf(stderr,"\n");
}
struct flag{
	int add;
	flag(int add=0):add(add){};
};
int lcm(int x,int y){return x*y/__gcd(x,y);}
inline info operator+(const info &amp;ls,const info &amp;rs){
	info in;
	in.ci=ls.ci&amp;rs.ci;
	if(in.ci){
		int cu1=ls.cur,cu2=rs.cur;
		int l=lcm(ls.vec.size(),rs.vec.size());
		in.vec.resize(l);
		for(int i=0;i&lt;l;i++){
			in.vec[i]=ls.vec[cu1]+rs.vec[cu2];
//			cu1=(cu1+1)%ls.vec.size();
//			cu2=(cu2+1)%rs.vec.size();
			cu1++;cu2++;
			if(cu1==ls.vec.size())cu1=0;
			if(cu2==rs.vec.size())cu2=0;
		}in.cur=0;
	}else{
		in.vec.clear();
		in.vec.push_back(ls.sum()+rs.sum());
	}return in;
}
info operator+(const flag &amp;ls,const info &amp;rs){
	info in=rs;
	if(in.ci)
		in.cur=(in.cur+ls.add)%in.vec.size();
	else{
		int t=ls.add;
		while(t--)in.vec[0]=nx[in.vec[0]];
	}return in;
}
flag operator+(const flag &amp;ls,const flag &amp;rs){
	return flag(ls.add+rs.add);
}
#define lson i&lt;&lt;1,l,(l+r)/2
#define rson i&lt;&lt;1|1,(l+r)/2+1,r
#define ls i&lt;&lt;1
#define rs i&lt;&lt;1|1
vector&lt;int&gt;get(int x){
	vector&lt;int&gt;vec;
	vec.push_back(x);
	do{
		x=nx[x];
		vec.push_back(x);
	}while(x!=vec.front());
	vec.pop_back();
	return vec;
}
struct sgt{
	info Info[maxn&lt;&lt;2];
	flag Flag[maxn&lt;&lt;2];
	void pd(int i){
		if(!Flag[i].add)return;
		Info[ls]=Flag[i]+Info[ls];
		Info[rs]=Flag[i]+Info[rs];
		Flag[ls]=Flag[i]+Flag[ls];
		Flag[rs]=Flag[i]+Flag[rs];
		Flag[i].add=0;		
	}
	void build(int i,int l,int r){
		if(l==r){
			if(cir[a[l]]){
				Info[i].vec=get(a[l]);
				Info[i].ci=1;
			}else{
				Info[i].vec.push_back(a[l]);
				Info[i].ci=0;
			}
			return;
		}build(lson);build(rson);
		Info[i]=Info[ls]+Info[rs];
	}
	int Q(int i,int l,int r,int l0,int r0){
		if(l0&lt;=l&amp;&amp;r0&gt;=r)return Info[i].sum();
		int ans=0;pd(i);
		if(l0&lt;=(l+r)/2)ans+=Q(lson,l0,r0);
		if(r0&gt;(l+r)/2)ans+=Q(rson,l0,r0);
		return ans;
	}
	void C(int i,int l,int r,int l0,int r0){
		if(l==r){
			if(Info[i].ci){
				Info[i].cur=(Info[i].cur+1)%Info[i].vec.size();
			}else{
				Info[i].vec[0]=nx[Info[i].vec[0]];
				Info[i].ci=cir[Info[i].vec[0]];
				if(Info[i].ci)
					Info[i].vec=get(Info[i].vec[0]),Info[i].cur=0;
			}
			return;
		}
		if(l0&lt;=l&amp;&amp;r0&gt;=r&amp;&amp;Info[i].ci){
			Info[i]=flag(1)+Info[i];
			Flag[i]=flag(1)+Flag[i];
			return;
		}pd(i);
		if(l0&lt;=(l+r)/2)C(lson,l0,r0);
		if(r0&gt;(l+r)/2)C(rson,l0,r0);
		Info[i]=Info[ls]+Info[rs];
	}
}T;
void pre(){
	n=in();m=in();p=in();
	for(int i=1;i&lt;=n;i++)a[i]=in();
	for(int i=0;i&lt;p;i++)nx[i]=i*i%p;
	for(int i=0;i&lt;p;i++)X=i,dfs(i);
	for(int i=0;i&lt;p;i++)dfs(i,0);
}
int main(){
	pre();
	T.build(1,1,n);
	while(m--){
		int op=in();
		int l=in(),r=in();
		if(op==0)T.C(1,1,n,l,r);
		else printf("%d\n",T.Q(1,1,n,l,r));
	}
	return 0;
}</pre><pre></pre><h2>Problem4106</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
double p,a,b,c,d;
int n;
double pr(double k){return p*(sin(a*k+b)+cos(c*k+d)+2);}
int main(){
	cin&gt;&gt;p&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d&gt;&gt;n;
	double mx=0,ans=0;
	for(int i=1;i&lt;=n;i++){
		ans=max(ans,mx-pr(i));
		mx=max(mx,pr(i));
	}
	printf("%.6lf\n",ans);
	return 0;
}//42 1 23 4 8 10</pre><pre></pre><h2>Problem4127</h2><pre>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
#include&lt;ctime&gt;
#define maxn 100010
#define LL long long
#define l i&lt;&lt;1
#define r i&lt;&lt;1|1
#define mid (x+y)/2
#define lson x,mid
#define rson mid+1,y
#define inf 0x7fffffff
using namespace std;
int point[maxn],next[maxn*2],v[maxn*2],fa[maxn*2],h[maxn],top[maxn],size[maxn],son[maxn],p[maxn],pl[maxn],T=0;
LL w[maxn],ans;
struct hp{int sz1,sz2; LL w1,w2,wmax,wmin,lazy;}a[maxn*4];
void add(int x,int y,int i){
	v[i]=y; next[i]=point[x]; point[x]=i;}
void dfs1(int x,int dep){
	int i,k=-1;
	size[x]=1; h[x]=dep;
	for (i=point[x]; i; i=next[i])
	  if (v[i]!=fa[x]){
	  	fa[v[i]]=x;
	  	dfs1(v[i],dep+1);
	  	size[x]+=size[v[i]];
	  	if (size[v[i]]&gt;k){
	  	  k=size[v[i]];
	  	  son[x]=v[i];
	  	}
	  }
}
void dfs2(int x){
	p[son[x]]=++T; pl[T]=son[x];
	top[son[x]]=top[x];
	if (son[son[x]]) dfs2(son[x]);
	for (int i=point[x]; i; i=next[i])
	  if (v[i]!=fa[x]&amp;&amp;v[i]!=son[x]){
	  	p[v[i]]=++T; pl[T]=v[i];
	  	top[v[i]]=v[i];
	  	if (son[v[i]]) dfs2(v[i]);
	  }
}
void updata(int i){
	a[i].sz1=a[l].sz1+a[r].sz1;
	a[i].sz2=a[l].sz2+a[r].sz2;
	a[i].w1=a[l].w1+a[r].w1;
	a[i].w2=a[l].w2+a[r].w2;
	a[i].wmax=max(a[l].wmax,a[r].wmax);
	a[i].wmin=min(a[l].wmin,a[r].wmin);
}
void build(int i,int x,int y){
	if (x==y){
	  LL d=w[pl[x]];
	  if (d&gt;=0){
	  	a[i].sz1=1; a[i].w1=d;
	  	a[i].sz2=a[i].w2=a[i].wmax=0;
	  	a[i].wmin=inf;
	  }
	  else{
	  	a[i].sz2=1;
	  	a[i].sz1=a[i].w1=0;
	  	a[i].wmax=a[i].wmin=a[i].w2=-d;
	  }
	  a[i].lazy=0;
	  return;
	}
	build(l,lson); build(r,rson);
	updata(i);
}
bool paint(int i,int x,int y,LL num){
	if (!a[i].sz2){
	  a[i].w1+=a[i].sz1*num;
	  a[i].lazy+=num;
	  return true;
	}
	if (a[i].wmax&lt;=num){
	  a[i].w1+=a[i].sz2*num-a[i].w2+a[i].sz1*num;
	  a[i].sz1+=a[i].sz2;
	  a[i].sz2=a[i].w2=a[i].wmax=0;
	  a[i].wmin=inf;
	  a[i].lazy+=num;
	  return true;
	}
	if (a[i].wmin&gt;num){
	  a[i].w2-=a[i].sz2*num;
	  a[i].wmin-=num;
	  a[i].wmax-=num;
	  a[i].w1+=a[i].sz1*num;
	  a[i].lazy+=num;
	  return true;
	}
	return false;
}
void pushdown(int i,int x,int y){
	paint(l,lson,a[i].lazy);
	paint(r,rson,a[i].lazy);
	a[i].lazy=0;
}
void query(int i,int x,int y,int s,int t){
	if (x&gt;=s&amp;&amp;y&lt;=t){
	  ans+=a[i].w1+a[i].w2;
	  return;
	}
	if (a[i].lazy) pushdown(i,x,y);
	if (s&lt;=mid) query(l,lson,s,t);
	if (t&gt;mid) query(r,rson,s,t);
}
void insert(int i,int x,int y,int s,int t,LL num){
	if (x&gt;=s&amp;&amp;y&lt;=t){
	  if (paint(i,x,y,num)) return;
	}
	if (a[i].lazy) pushdown(i,x,y);
	if (s&lt;=mid) insert(l,lson,s,t,num);
	if (t&gt;mid) insert(r,rson,s,t,num);
	updata(i);
}
void tree_add(int vs,int vt,int x){
	while (top[vs]!=top[vt]){
		if (h[top[vs]]&gt;h[top[vt]]){
		  insert(1,1,T,p[top[vs]],p[vs],x);
		  vs=fa[top[vs]];
		}
		else{
		  insert(1,1,T,p[top[vt]],p[vt],x);
		  vt=fa[top[vt]];
		}
	}
	if (h[vs]&lt;h[vt]) insert(1,1,T,p[vs],p[vt],x);
	else insert(1,1,T,p[vt],p[vs],x);
}
void tree_query(int vs,int vt){
	ans=0;
	while (top[vs]!=top[vt]){
		if (h[top[vs]]&gt;h[top[vt]]){
		  query(1,1,T,p[top[vs]],p[vs]);
		  vs=fa[top[vs]];
		}
		else{
		  query(1,1,T,p[top[vt]],p[vt]);
		  vt=fa[top[vt]];
		}
	}
	if (h[vs]&lt;h[vt]) query(1,1,T,p[vs],p[vt]);
	else query(1,1,T,p[vt],p[vs]);
	printf("%lld\n",ans);
}
int main(){
	int n,m,i,x,y,k,vs,vt;
	scanf("%d%d",&amp;n,&amp;m);
	for (i=1; i&lt;=n; i++)
	  scanf("%lld",&amp;w[i]);
	for (i=1; i&lt;n; i++){
	  scanf("%d%d",&amp;x,&amp;y);
	  add(x,y,l); add(y,x,r);
	}
	dfs1(1,1);
	p[1]=pl[1]=++T; top[1]=1;
	dfs2(1);
	build(1,1,n);
	for (i=1; i&lt;=m; i++){
	  scanf("%d%d%d",&amp;k,&amp;vs,&amp;vt);
	  if (k==1){
	  	scanf("%d",&amp;x);
	  	tree_add(vs,vt,x);
	  }
	  else tree_query(vs,vt);
	}
	//cout&lt;&lt;clock();
}</pre><pre></pre><h2>Problem4127</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1e5+5;
typedef long long LL;
int in(){
	int r=0,f=1;char c=getchar();
	while(!isdigit(c))f=c=='-'?-1:f,c=getchar();
	while(isdigit(c))r=r*10+c-'0',c=getchar();
	return r*f;
}
int n,m;
LL a[maxn];
int fa[maxn],top[maxn],siz[maxn],son[maxn],lef[maxn],rig[maxn],z,mp[maxn],rmp[maxn],dep[maxn];
vector&lt;int&gt;G[maxn];
int tot=0;
void dfs(int u){
	lef[u]=++tot;siz[u]=1;
	for(int i=0;i&lt;G[u].size();i++){
		int v=G[u][i];
		if(v!=fa[u]){
			fa[v]=u;dep[v]=dep[u]+1;
			dfs(v);
			siz[u]+=siz[v];
			if(siz[son[u]]&lt;siz[v])son[u]=v;
		}
	}
	rig[u]=++tot;
}
void build(int u,int tp){
	mp[u]=++z;rmp[z]=u;top[u]=tp;
	if(son[u])build(son[u],tp);
	for(int i=0;i&lt;G[u].size();i++){
		int v=G[u][i];
		if(v!=fa[u]&amp;&amp;v!=son[u])build(v,v);
	}
}
struct qes{
	int ty;
	int u,v;LL d;
	int id;
}_Q[maxn],Q[maxn];
int pot[maxn];
vector&lt;int&gt;c[maxn];
int Qs;
LL cur[maxn];
#define lson i&lt;&lt;1,l,(l+r)/2
#define rson i&lt;&lt;1|1,(l+r)/2+1,r
#define ls i&lt;&lt;1
#define rs i&lt;&lt;1|1
struct node{
	LL sum,laz,ans;
	int neg;
}t[maxn&lt;&lt;2];
struct sgt{
	void rz(int i){
		t[i].ans=t[ls].ans+t[rs].ans;
		t[i].sum=t[ls].sum+t[rs].sum;
		t[i].neg=t[ls].neg+t[rs].neg;		
	}
	void pd(int i,int l,int r){
		int mid=(l+r)&gt;&gt;1;
		if(t[i].laz){
			t[ls].laz+=t[i].laz;
			t[rs].laz+=t[i].laz;
			t[ls].sum+=(LL)(mid-l+1)*t[i].laz;
			t[rs].sum+=(LL)(r-mid)*t[i].laz;
			t[ls].ans=t[ls].ans-(LL)t[ls].neg*t[i].laz+(LL)(mid-l+1-t[ls].neg)*t[i].laz;
			t[rs].ans=t[rs].ans-(LL)t[rs].neg*t[i].laz+(LL)(r-mid-t[rs].neg)*t[i].laz;
			t[i].laz=0;
		}
	}
	void build(int i,int l,int r){
		if(l==r){
			t[i].sum=a[rmp[l]];
			t[i].ans=abs(a[rmp[l]]);
			t[i].neg=a[rmp[l]]&lt;0;
			return;
		}build(lson);build(rson);rz(i);
	}
	void Add(int i,int l,int r,int l0,int r0,LL d){
		if(l0&lt;=l&amp;&amp;r0&gt;=r){
			t[i].sum+=LL(r-l+1)*d;
			t[i].ans=t[i].ans-(LL)t[i].neg*d+(LL)(r-l+1-t[i].neg)*d;
			t[i].laz+=d;
			return;
		}pd(i,l,r);
		if(l0&lt;=(l+r)/2)Add(lson,l0,r0,d);
		if(r0&gt;(l+r)/2)Add(rson,l0,r0,d);
		rz(i);
	}
	void Add(int i,int l,int r,int ps,LL d){
		if(l==r){
			t[i].sum+=d;
			t[i].ans=abs(t[i].sum);
			t[i].neg=t[i].sum&lt;0;
			return;			
		}pd(i,l,r);
		if(ps&lt;=(l+r)/2)Add(lson,ps,d);
		else Add(rson,ps,d);
		rz(i);
	}
	LL Qsum(int i,int l,int r,int ps){
		if(l==r)return t[i].sum;
		pd(i,l,r);
		if(ps&lt;=(l+r)/2)return Qsum(lson,ps);
		else return Qsum(rson,ps);
	}	
	LL Qans(int i,int l,int r,int l0,int r0){
		if(l0&lt;=l&amp;&amp;r0&gt;=r)return t[i].ans;
		LL ans=0;pd(i,l,r);
		if(l0&lt;=(l+r)/2)ans+=Qans(lson,l0,r0);
		if(r0&gt;(l+r)/2)ans+=Qans(rson,l0,r0);
		return ans;
	}
	LL Qans(int l,int r){if(l&gt;r)swap(l,r);return Qans(1,1,n,l,r);}
	LL Qsum(int ps){return Qsum(1,1,n,ps);}
	void Add(int l,int r,LL d){if(l&gt;r)swap(l,r);Add(1,1,n,l,r,d);}
	void Add(int ps,LL d){Add(1,1,n,ps,d);}
}T;
void Add(int u,int v,LL d){
	while(top[u]!=top[v]){
		if(dep[top[u]]&lt;dep[top[v]])swap(u,v);
		T.Add(mp[u],mp[top[u]],d);
		u=fa[top[u]];
	}T.Add(mp[u],mp[v],d);
}
LL Qans(int u,int v){
	LL ans=0;
	while(top[u]!=top[v]){
		if(dep[top[u]]&lt;dep[top[v]])swap(u,v);
		ans+=T.Qans(mp[u],mp[top[u]]);
		u=fa[top[u]];
	}ans+=T.Qans(mp[u],mp[v]);
	return ans;
}
bool part(int x){
	return a[x]+cur[x]&gt;=0;
}
void solve(int lef,int rig,int l,int r){
	if(l==r){
		if(l==0||l==Qs)return;
		for(int i=lef;i&lt;=rig;i++){
			c[Q[l].id].push_back(pot[i]);
//			cerr&lt;&lt;pot[i]&lt;&lt;" "&lt;&lt;Q[l].id&lt;&lt;endl;
		}
		return;
	}int mid=(l+r)&gt;&gt;1;
 	for(int i=l;i&lt;=mid;i++)if(i)
		Add(Q[i].u,Q[i].v,Q[i].d);
	for(int i=lef;i&lt;=rig;i++){
		int x=pot[i];
		cur[x]=T.Qsum(mp[x]);
	}
	int dv=stable_partition(pot+lef,pot+rig+1,part)-pot-1;
	for(int i=lef;i&lt;=dv;i++)
		cur[pot[i]]=0;//T.Qsum(mp[pot[i]]);
	if(dv+1&lt;=rig)solve(dv+1,rig,mid+1,r);
	for(int i=l;i&lt;=mid;i++)if(i)
		Add(Q[i].u,Q[i].v,-Q[i].d);
	if(lef&lt;=dv)solve(lef,dv,l,mid);
}
int T_T;
int vis[maxn];
int lca(int u,int v){
	T_T++;
	while(u)vis[u]=T_T,u=fa[u];
	while(vis[v]!=T_T)v=fa[v];
	return v;
}
void BF(){
	while(m--){
		int ty;scanf("%d",&amp;ty);
		if(ty==1){
			int u,v;LL d;scanf("%d%d%lld",&amp;u,&amp;v,&amp;d);
			int LCA=lca(u,v);
			while(u!=LCA)a[u]+=d,u=fa[u];
			while(v!=LCA)a[v]+=d,v=fa[v];
			a[LCA]+=d;
		}else{
			long long ans=0;
			int u,v;scanf("%d%d",&amp;u,&amp;v);
			int LCA=lca(u,v);
			while(u!=LCA)ans+=abs(a[u]),u=fa[u];
			while(v!=LCA)ans+=abs(a[v]),v=fa[v];
			ans+=abs(a[LCA]);
			printf("%lld\n",ans);
		}
	}
}
int main(){
	n=in();m=in();
	for(int i=1;i&lt;=n;i++)a[i]=in();
	for(int i=1;i&lt;n;i++){
		int u=in(),v=in();
		G[u].push_back(v);
		G[v].push_back(u);
	}dfs(1);build(1,1);
	if(*max_element(dep+1,dep+1+n)&lt;40){
		BF();
		return 0;
	}
	Qs=0;
	for(int i=1;i&lt;=m;i++){
		_Q[i].ty=in();
		_Q[i].u=in();
		_Q[i].v=in();
		_Q[i].id=i;
		if(_Q[i].ty==1){
			_Q[i].d=in();
			Q[++Qs]=_Q[i];
		}
	}Qs++;
	for(int i=1;i&lt;=n;i++)pot[i]=i;
	solve(1,n,0,Qs);
	memset(t,0,sizeof t);
	T.build(1,1,n);
	for(int i=1;i&lt;=m;i++){
		int ty=_Q[i].ty;
		int u=_Q[i].u,v=_Q[i].v;
		LL d=_Q[i].d;
		for(int j=0;j&lt;c[i].size();j++)
			T.Add(mp[c[i][j]],d);		
		if(ty==1)
			Add(u,v,d);
		else printf("%lld\n",Qans(u,v));
		for(int j=0;j&lt;c[i].size();j++)
			T.Add(mp[c[i][j]],-d);
	}
	return 0;
}</pre><pre></pre><h2>Problem4127</h2><pre>	#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1e5+5;
const int MAXS=2e7;
char buf[MAXS];
typedef long long LL;
int in(){
	static char *c=buf;
	int r=0,f=1;
	while(!isdigit(*c))f=*c=='-'?-1:f,c++;
	while(isdigit(*c))r=r*10+*c-'0',c++;
	return r*f;
}
int n,m;
LL a[maxn];
int fa[maxn],top[maxn],siz[maxn],son[maxn],lef[maxn],rig[maxn],z,mp[maxn],rmp[maxn],dep[maxn];
vector&lt;int&gt;G[maxn];
int tot=0;
void dfs(int u){
	lef[u]=++tot;siz[u]=1;
	for(int i=0;i&lt;G[u].size();i++){
		int v=G[u][i];
		if(v!=fa[u]){
			fa[v]=u;dep[v]=dep[u]+1;
			dfs(v);
			siz[u]+=siz[v];
			if(siz[son[u]]&lt;siz[v])son[u]=v;
		}
	}
	rig[u]=++tot;
}
void build(int u,int tp){
	mp[u]=++z;rmp[z]=u;top[u]=tp;
	if(son[u])build(son[u],tp);
	for(int i=0;i&lt;G[u].size();i++){
		int v=G[u][i];
		if(v!=fa[u]&amp;&amp;v!=son[u])build(v,v);
	}
}
struct qes{
	int ty;
	int u,v;LL d;
	int id;
}_Q[maxn],Q[maxn];
int pot[maxn];
vector&lt;int&gt;c[maxn];
int Qs;
LL cur[maxn];
#define lson i&lt;&lt;1,l,(l+r)/2
#define rson i&lt;&lt;1|1,(l+r)/2+1,r
#define ls i&lt;&lt;1
#define rs i&lt;&lt;1|1
struct node{
	LL sum,laz,ans;
	int neg;
}t[maxn&lt;&lt;2];
struct sgt{
	void rz(int i){
		t[i].ans=t[ls].ans+t[rs].ans;
		t[i].sum=t[ls].sum+t[rs].sum;
		t[i].neg=t[ls].neg+t[rs].neg;		
	}
	void pd(int i,int l,int r){
		int mid=(l+r)&gt;&gt;1;
		if(t[i].laz){
			t[ls].laz+=t[i].laz;
			t[rs].laz+=t[i].laz;
			t[ls].sum+=(LL)(mid-l+1)*t[i].laz;
			t[rs].sum+=(LL)(r-mid)*t[i].laz;
			t[ls].ans=t[ls].ans-(LL)t[ls].neg*t[i].laz+(LL)(mid-l+1-t[ls].neg)*t[i].laz;
			t[rs].ans=t[rs].ans-(LL)t[rs].neg*t[i].laz+(LL)(r-mid-t[rs].neg)*t[i].laz;
			t[i].laz=0;
		}
	}
	void build(int i,int l,int r){
		if(l==r){
			t[i].sum=a[rmp[l]];
			t[i].ans=abs(a[rmp[l]]);
			t[i].neg=a[rmp[l]]&lt;0;
			return;
		}build(lson);build(rson);rz(i);
	}
	void Add(int i,int l,int r,int l0,int r0,LL d){
		if(l0&lt;=l&amp;&amp;r0&gt;=r){
			t[i].sum+=LL(r-l+1)*d;
			t[i].ans=t[i].ans-(LL)t[i].neg*d+(LL)(r-l+1-t[i].neg)*d;
			t[i].laz+=d;
			return;
		}pd(i,l,r);
		if(l0&lt;=(l+r)/2)Add(lson,l0,r0,d);
		if(r0&gt;(l+r)/2)Add(rson,l0,r0,d);
		rz(i);
	}
	void Add(int i,int l,int r,int ps,LL d){
		if(l==r){
			t[i].sum+=d;
			t[i].ans=abs(t[i].sum);
			t[i].neg=t[i].sum&lt;0;
			return;			
		}pd(i,l,r);
		if(ps&lt;=(l+r)/2)Add(lson,ps,d);
		else Add(rson,ps,d);
		rz(i);
	}
	LL Qsum(int i,int l,int r,int ps){
		if(l==r)return t[i].sum;
		pd(i,l,r);
		if(ps&lt;=(l+r)/2)return Qsum(lson,ps);
		else return Qsum(rson,ps);
	}	
	LL Qans(int i,int l,int r,int l0,int r0){
		if(l0&lt;=l&amp;&amp;r0&gt;=r)return t[i].ans;
		LL ans=0;pd(i,l,r);
		if(l0&lt;=(l+r)/2)ans+=Qans(lson,l0,r0);
		if(r0&gt;(l+r)/2)ans+=Qans(rson,l0,r0);
		return ans;
	}
	LL Qans(int l,int r){if(l&gt;r)swap(l,r);return Qans(1,1,n,l,r);}
	LL Qsum(int ps){return Qsum(1,1,n,ps);}
	void Add(int l,int r,LL d){if(l&gt;r)swap(l,r);Add(1,1,n,l,r,d);}
	void Add(int ps,LL d){Add(1,1,n,ps,d);}
}T;
void Add(int u,int v,LL d){
	while(top[u]!=top[v]){
		if(dep[top[u]]&lt;dep[top[v]])swap(u,v);
		T.Add(mp[u],mp[top[u]],d);
		u=fa[top[u]];
	}T.Add(mp[u],mp[v],d);
}
LL Qans(int u,int v){
	LL ans=0;
	while(top[u]!=top[v]){
		if(dep[top[u]]&lt;dep[top[v]])swap(u,v);
		ans+=T.Qans(mp[u],mp[top[u]]);
		u=fa[top[u]];
	}ans+=T.Qans(mp[u],mp[v]);
	return ans;
}
bool part(int x){
	return a[x]+cur[x]&gt;=0;
}
void solve(int lef,int rig,int l,int r){
	if(l==r){
		if(l==0||l==Qs)return;
		for(int i=lef;i&lt;=rig;i++){
			c[Q[l].id].push_back(pot[i]);
//			cerr&lt;&lt;pot[i]&lt;&lt;" "&lt;&lt;Q[l].id&lt;&lt;endl;
		}
		return;
	}int mid=(l+r)&gt;&gt;1;
 	for(int i=l;i&lt;=mid;i++)if(i)
		Add(Q[i].u,Q[i].v,Q[i].d);
	for(int i=lef;i&lt;=rig;i++){
		int x=pot[i];
		cur[x]=T.Qsum(mp[x]);
	}
	int dv=stable_partition(pot+lef,pot+rig+1,part)-pot-1;
	for(int i=lef;i&lt;=dv;i++)
		cur[pot[i]]=0;//T.Qsum(mp[pot[i]]);
	if(dv+1&lt;=rig)solve(dv+1,rig,mid+1,r);
	for(int i=l;i&lt;=mid;i++)if(i)
		Add(Q[i].u,Q[i].v,-Q[i].d);
	if(lef&lt;=dv)solve(lef,dv,l,mid);
}
int T_T;
int vis[maxn];
int lca(int u,int v){
	T_T++;
	while(u)vis[u]=T_T,u=fa[u];
	while(vis[v]!=T_T)v=fa[v];
	return v;
}
void BF(){
	while(m--){
		int ty=in();
		if(ty==1){
			int u=in(),v=in();LL d=in();
			int LCA=lca(u,v);
			while(u!=LCA)a[u]+=d,u=fa[u];
			while(v!=LCA)a[v]+=d,v=fa[v];
			a[LCA]+=d;
		}else{
			long long ans=0;
			int u=in(),v=in();
			int LCA=lca(u,v);
			while(u!=LCA)ans+=abs(a[u]),u=fa[u];
			while(v!=LCA)ans+=abs(a[v]),v=fa[v];
			ans+=abs(a[LCA]);
			printf("%lld\n",ans);
		}
	}
}
int main(){
	int len=fread(buf,1,MAXS,stdin);
	buf[len]='\0';
	n=in();m=in();
	for(int i=1;i&lt;=n;i++)a[i]=in();
	for(int i=1;i&lt;n;i++){
		int u=in(),v=in();
		G[u].push_back(v);
		G[v].push_back(u);
	}dfs(1);build(1,1);
	if(*max_element(dep+1,dep+1+n)&lt;40){
		BF();
		return 0;
	}
	Qs=0;
	for(int i=1;i&lt;=m;i++){
		_Q[i].ty=in();
		_Q[i].u=in();
		_Q[i].v=in();
		_Q[i].id=i;
		if(_Q[i].ty==1){
			_Q[i].d=in();
			Q[++Qs]=_Q[i];
		}
	}Qs++;
	for(int i=1;i&lt;=n;i++)pot[i]=i;
	solve(1,n,0,Qs);
	memset(t,0,sizeof t);
	T.build(1,1,n);
	for(int i=1;i&lt;=m;i++){
		int ty=_Q[i].ty;
		int u=_Q[i].u,v=_Q[i].v;
		LL d=_Q[i].d;
		for(int j=0;j&lt;c[i].size();j++)
			T.Add(mp[c[i][j]],d);		
		if(ty==1)
			Add(u,v,d);
		else printf("%lld\n",Qans(u,v));
		for(int j=0;j&lt;c[i].size();j++)
			T.Add(mp[c[i][j]],-d);
	}
	return 0;
}</pre><pre></pre><h2>Problem4127</h2><pre>#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
#include&lt;ctime&gt;
#define maxn 100010
#define LL long long
#define l i&lt;&lt;1
#define r i&lt;&lt;1|1
#define mid (x+y)/2
#define lson x,mid
#define rson mid+1,y
#define inf 0x7fffffff
using namespace std;
int point[maxn],next[maxn*2],v[maxn*2],fa[maxn*2],h[maxn],top[maxn],size[maxn],son[maxn],p[maxn],pl[maxn],T=0;
LL w[maxn],ans;
struct hp{int sz1,sz2; LL w1,w2,wmax,wmin,lazy;}a[maxn*4];
void add(int x,int y,int i){
	v[i]=y; next[i]=point[x]; point[x]=i;}
void dfs1(int x,int dep){
	int i,k=-1;
	size[x]=1; h[x]=dep;
	for (i=point[x]; i; i=next[i])
	  if (v[i]!=fa[x]){
	  	fa[v[i]]=x;
	  	dfs1(v[i],dep+1);
	  	size[x]+=size[v[i]];
	  	if (size[v[i]]&gt;k){
	  	  k=size[v[i]];
	  	  son[x]=v[i];
	  	}
	  }
}
void dfs2(int x){
	p[son[x]]=++T; pl[T]=son[x];
	top[son[x]]=top[x];
	if (son[son[x]]) dfs2(son[x]);
	for (int i=point[x]; i; i=next[i])
	  if (v[i]!=fa[x]&amp;&amp;v[i]!=son[x]){
	  	p[v[i]]=++T; pl[T]=v[i];
	  	top[v[i]]=v[i];
	  	if (son[v[i]]) dfs2(v[i]);
	  }
}
void updata(int i){
	a[i].sz1=a[l].sz1+a[r].sz1;
	a[i].sz2=a[l].sz2+a[r].sz2;
	a[i].w1=a[l].w1+a[r].w1;
	a[i].w2=a[l].w2+a[r].w2;
	a[i].wmax=max(a[l].wmax,a[r].wmax);
	a[i].wmin=min(a[l].wmin,a[r].wmin);
}
void build(int i,int x,int y){
	if (x==y){
	  LL d=w[pl[x]];
	  if (d&gt;=0){
	  	a[i].sz1=1; a[i].w1=d;
	  	a[i].sz2=a[i].w2=a[i].wmax=0;
	  	a[i].wmin=inf;
	  }
	  else{
	  	a[i].sz2=1;
	  	a[i].sz1=a[i].w1=0;
	  	a[i].wmax=a[i].wmin=a[i].w2=-d;
	  }
	  a[i].lazy=0;
	  return;
	}
	build(l,lson); build(r,rson);
	updata(i);
}
bool paint(int i,int x,int y,LL num){
	if (!a[i].sz2){
	  a[i].w1+=a[i].sz1*num;
	  a[i].lazy+=num;
	  return true;
	}
	if (a[i].wmax&lt;=num){
	  a[i].w1+=a[i].sz2*num-a[i].w2+a[i].sz1*num;
	  a[i].sz1+=a[i].sz2;
	  a[i].sz2=a[i].w2=a[i].wmax=0;
	  a[i].wmin=inf;
	  a[i].lazy+=num;
	  return true;
	}
	if (a[i].wmin&gt;num){
	  a[i].w2-=a[i].sz2*num;
	  a[i].wmin-=num;
	  a[i].wmax-=num;
	  a[i].w1+=a[i].sz1*num;
	  a[i].lazy+=num;
	  return true;
	}
	return false;
}
void pushdown(int i,int x,int y){
	paint(l,lson,a[i].lazy);
	paint(r,rson,a[i].lazy);
	a[i].lazy=0;
}
void query(int i,int x,int y,int s,int t){
	if (x&gt;=s&amp;&amp;y&lt;=t){
	  ans+=a[i].w1+a[i].w2;
	  return;
	}
	if (a[i].lazy) pushdown(i,x,y);
	if (s&lt;=mid) query(l,lson,s,t);
	if (t&gt;mid) query(r,rson,s,t);
}
void insert(int i,int x,int y,int s,int t,LL num){
	if (x&gt;=s&amp;&amp;y&lt;=t){
	  if (paint(i,x,y,num)) return;
	}
	if (a[i].lazy) pushdown(i,x,y);
	if (s&lt;=mid) insert(l,lson,s,t,num);
	if (t&gt;mid) insert(r,rson,s,t,num);
	updata(i);
}
void tree_add(int vs,int vt,int x){
	while (top[vs]!=top[vt]){
		if (h[top[vs]]&gt;h[top[vt]]){
		  insert(1,1,T,p[top[vs]],p[vs],x);
		  vs=fa[top[vs]];
		}
		else{
		  insert(1,1,T,p[top[vt]],p[vt],x);
		  vt=fa[top[vt]];
		}
	}
	if (h[vs]&lt;h[vt]) insert(1,1,T,p[vs],p[vt],x);
	else insert(1,1,T,p[vt],p[vs],x);
}
void tree_query(int vs,int vt){
	ans=0;
	while (top[vs]!=top[vt]){
		if (h[top[vs]]&gt;h[top[vt]]){
		  query(1,1,T,p[top[vs]],p[vs]);
		  vs=fa[top[vs]];
		}
		else{
		  query(1,1,T,p[top[vt]],p[vt]);
		  vt=fa[top[vt]];
		}
	}
	if (h[vs]&lt;h[vt]) query(1,1,T,p[vs],p[vt]);
	else query(1,1,T,p[vt],p[vs]);
	printf("%lld\n",ans);
}
char buf[int(1e7)],*c=buf;
int in(){
	int re=0,f=1;
	while(!isdigit(*c))f=*c=='-'?-1:f,c++;
	while(isdigit(*c))re=re*10+*c-'0',c++;
	return re*f;
	
}
int main(){
	fread(buf,1,int(1e7),stdin);
	int n,m,i,x,y,k,vs,vt;
	n=in();m=in();
	for (i=1; i&lt;=n; i++)
		w[i]=in();
	for (i=1; i&lt;n; i++){
		x=in(),y=in();
	  add(x,y,l); add(y,x,r);
	}
	dfs1(1,1);
	p[1]=pl[1]=++T; top[1]=1;
	dfs2(1);
	build(1,1,n);
	for (i=1; i&lt;=m; i++){
		k=in(),vs=in(),vt=in();
	  if (k==1){
	  x=in();
	  	tree_add(vs,vt,x);
	  }
	  else tree_query(vs,vt);
	}
	//cout&lt;&lt;clock();
}</pre><pre></pre><h2>Problem4128</h2><pre>#include&lt;bits/stdc++.h&gt;
#include&lt;hash_map&gt;
using namespace std;
typedef unsigned int UL;
const int maxn=70;
int n,p,inv[int(2e4)];
struct mat{
	int a[maxn][maxn];
	int *operator[](int x){return a[x];}
	int at(int x,int y)const{return a[x][y];}
	void clear(){memset(a,0,sizeof a);}
	void unit(){for(int i=0;i&lt;n;i++)a[i][i]=1;}
	UL hash(){
		UL val=0;
		for(int i=0;i&lt;n;i++)
		for(int j=0;j&lt;n;j++)
		val=val*31+a[i][j];
		return val;	
	}	
}A,B,C,invA;
mat operator*(const mat &amp;A,const mat &amp;B){
	static mat C;
	C.clear();
	for(int i=0;i&lt;n;i++)
	for(int j=0;j&lt;n;j++)
	for(int k=0;k&lt;n;k++)
	C[i][j]=(C[i][j]+A.at(i,k)*B.at(k,j))%p;
	return C;
}
mat pw(const mat &amp;_x,int k,int p){
	static mat tmp,x;
	tmp.clear();tmp.unit();x=_x;
	for(;k;k&gt;&gt;=1){
		if(k&amp;1)tmp=tmp*x;
		x=x*x;
	}return tmp;
}
void deb(int a[maxn][maxn&lt;&lt;1]){
	for(int i=0;i&lt;n;i++)
	for(int j=0;j&lt;(n&lt;&lt;1);j++)
	printf("%d%c",a[i][j]," \n"[j+1==(n&lt;&lt;1)]);
	puts("");
}
void Gauss(){
	static int a[maxn][maxn&lt;&lt;1];
	for(int i=0;i&lt;n;i++)for(int j=0;j&lt;n;j++)a[i][j]=A[i][j];
	for(int i=0;i&lt;n;i++)a[i][i+n]=1;
	for(int i=0;i&lt;n;i++){
		int r=i;
		for(int j=i;j&lt;n;j++)if(a[j][i]&gt;a[r][i])r=j;
		for(int j=0;j&lt;(n&lt;&lt;1);j++)swap(a[i][j],a[r][j]);
		for(int j=i+1;j&lt;n;j++){
			int t=a[j][i]*inv[a[i][i]]%p;
			for(int k=i;k&lt;(n&lt;&lt;1);k++)
				a[j][k]=(a[j][k]-a[i][k]*t%p+p)%p;
		}//deb(a);
	}
	for(int i=1;i&lt;n;i++){
		for(int j=i-1;j&gt;=0;j--){
			int t=a[j][i]*inv[a[i][i]]%p;
			for(int k=i;k&lt;(n&lt;&lt;1);k++)
				a[j][k]=(a[j][k]-a[i][k]*t%p+p)%p;		
		}
	}
	for(int i=0;i&lt;n;i++){
		int t=inv[a[i][i]];
		for(int j=i;j&lt;(n&lt;&lt;1);j++)
			a[i][j]=a[i][j]*t%p;
	}
	for(int i=0;i&lt;n;i++)for(int j=0;j&lt;n;j++)invA[i][j]=a[i][j+n];
	for(int i=0;i&lt;n;i++)assert(accumulate(invA[i],invA[i]+n,0)!=0);
}
__gnu_cxx::hash_map&lt;UL,int&gt;M;
int BSGS(){
	if(A.hash()==B.hash())return 1;
	UL H=0,Z;
	int m=1;for(;m*m&lt;p;m++);m++;
	M[H=B.hash()]=0;Z=H;
	for(int i=1;i&lt;m;i++){
		B=B*invA;
		if(M[H=B.hash()])break;
		M[H]=i;
	}
	A=pw(A,m,p);C.clear();C.unit();
	for(int i=0;i&lt;=m;i++){
		if(M.count(H=C.hash())&amp;&amp;M[H]+i*m&gt;0)return M[H]+i*m;
		C=C*A;if(!i)M[Z]=0;
	}
}
int main(){
	scanf("%d%d",&amp;n,&amp;p);inv[1]=1;
	for(int i=2;i&lt;p;i++)inv[i]=(p-p/i)*inv[p%i]%p;
	for(int i=0;i&lt;n;i++)for(int j=0;j&lt;n;j++)scanf("%d",&amp;A[i][j]);
	for(int i=0;i&lt;n;i++)for(int j=0;j&lt;n;j++)scanf("%d",&amp;B[i][j]);
	Gauss();
	cout&lt;&lt;BSGS()&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem4143</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=500010;
int n,m;
int in(){
	int r=0;char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))r=r*10+c-'0',c=getchar();
	return r;
}
int a[maxn],b[maxn],d[maxn];
vector&lt;int&gt;da[21];
bool cmp(int x,int y){return a[x]!=a[y]?a[x]&lt;a[y]:b[x]&lt;b[y];}
bool cm(int x,int y){return x&lt;a[y];}
void compute(vector&lt;int&gt;&amp;da){
	sort(da.begin(),da.end(),cmp);
	for(int i=0;i+1&lt;da.size();i++){
		int j=upper_bound(da.begin(),da.end(),b[da[i]],cm)-da.begin();
		if(j&lt;da.size()){
			printf("TAK %d %d\n",da[i],da[j]);
			return;	
		}
	}puts("NIE");
}
int main(){
	n=in();m=in();
	for(int i=1;i&lt;=n;i++)a[i]=in(),b[i]=in(),d[i]=in(),da[d[i]].push_back(i);
	for(int i=1;i&lt;=m;i++)
		compute(da[i]);
	return 0;
}</pre><pre></pre><h2>Problem4144</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=2e5+5;
int n,s,m;
int ss[maxn];
struct edge{
	int u,v,w;
	bool operator&lt;(const edge &amp;o)const{return w&lt;o.w;}
}E[maxn];
vector&lt;edge&gt;G[maxn];
struct qes{
	int u,v,w,id;
	bool operator&lt;(const qes o)const{return w&lt;o.w;}
}Q[maxn];
int anss[maxn],Es;
void spfa(){
	static int d[maxn],vis[maxn];
	memset(d,0x7f,sizeof d);
	queue&lt;int&gt;q;
	for(int i=1;i&lt;=s;i++){
		vis[ss[i]]=1;
		q.push(ss[i]);
		d[ss[i]]=0;
	}
	while(!q.empty()){
		int u=q.front();q.pop();vis[u]=0;
		for(int i=0;i&lt;G[u].size();i++){
			edge e=G[u][i];
			if(d[e.v]&gt;d[u]+e.w){
				d[e.v]=d[u]+e.w;
				if(!vis[e.v])vis[e.v]=1,q.push(e.v);
			}
		}
	}
	for(int i=1;i&lt;=n;i++)
	for(int j=0;j&lt;G[i].size();j++){
		edge e=G[i][j];
		if(e.u&gt;e.v)continue;
		E[Es++]=(edge){e.u,e.v,d[e.u]+d[e.v]+e.w};
	}
}
int fa[maxn];
void init(){for(int i=1;i&lt;=n;i++)fa[i]=i;}
int find(int x){return fa[x]==x?x:fa[x]=find(fa[x]);}
void merge(int x,int y){fa[find(x)]=find(y);}
int main(){
	scanf("%d%d%d",&amp;n,&amp;s,&amp;m);
	for(int i=1;i&lt;=s;i++)scanf("%d",&amp;ss[i]);
	for(int i=1;i&lt;=m;i++){
		int u,v,w;scanf("%d%d%d",&amp;u,&amp;v,&amp;w);
		G[u].push_back((edge){u,v,w});
		G[v].push_back((edge){v,u,w});
	}int q;scanf("%d",&amp;q);
	for(int i=1;i&lt;=q;i++)scanf("%d%d%d",&amp;Q[i].u,&amp;Q[i].v,&amp;Q[i].w),Q[i].id=i;
	sort(Q+1,Q+1+q);
	spfa();
	E[Es++]=(edge){0,0,int(2e9)};
	sort(E,E+Es);
	init();
	int cur=1;
	for(int i=0;i&lt;Es;i++){
		edge e=E[i];
		while(cur&lt;=q&amp;&amp;e.w&gt;Q[cur].w){
			anss[Q[cur].id]=find(Q[cur].u)==find(Q[cur].v);
			cur++;
		}
		merge(e.u,e.v);
	}	
	for(int i=1;i&lt;=q;i++)printf("%s\n",anss[i]?"TAK":"NIE");
	return 0;
}</pre><pre></pre><h2>Problem4145</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
int n,m;
LL d[101];
LL f[1&lt;&lt;16],g[1&lt;&lt;16],c[16];
LL calc(int S){
	LL ans=0;
	for(int i=0;i&lt;m;i++)if(S&gt;&gt;i&amp;1)
		ans+=c[i];
	return ans;
}
int main(){
//	freopen("bzoj4145.in","r",stdin);
	cin&gt;&gt;n&gt;&gt;m;
	for(int S=0;S&lt;(1&lt;&lt;m);S++)f[S]=g[S]=1e15;f[0]=g[0]=0;
	for(int i=0;i&lt;n;i++){
		cin&gt;&gt;d[i];
		for(int j=0;j&lt;m;j++)cin&gt;&gt;c[j];
		for(int S=0;S&lt;(1&lt;&lt;m);S++){
			f[S]=min(f[S],calc(S)+d[i]);
		}
	}
	for(int i=0;i&lt;(1&lt;&lt;m);i++)
	for(int j=i;;j=i&amp;(j-1)){
		g[i]=min(g[i],g[j]+f[i^j]);
		 if(!j)break;
	}cout&lt;&lt;g[(1&lt;&lt;m)-1]&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem4146</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=2e6+6;
typedef long long LL;
int n,mx;
int p[maxn],minp[maxn],a[maxn];
int d[maxn];
int in(){
	int r=0;char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))r=r*10+c-'0',c=getchar();
	return r;
}
int main(){
	scanf("%d",&amp;n);
	for(int i=1;i&lt;=n;i++){
		int x=in();
		a[x]++;mx=max(x,mx);
	}
	for(int i=1;i&lt;=mx;i++)
	for(int j=i;j&lt;=mx;j+=i)
		d[j]+=a[i];
	LL ans=0;
	for(int i=1;i&lt;=mx;i++)
		ans+=(LL)a[i]*d[i];
	ans-=n;
	cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}</pre><pre></pre><h2>Problem4152</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=2e5+5;
int n;
struct P{
	int x,y,id;
}p[maxn];
bool byX(const P &amp;a,const P &amp;b){return a.x&lt;b.x;}
bool byY(const P &amp;a,const P &amp;b){return a.y&lt;b.y;}
struct edge{int u,v,w;};
vector&lt;edge&gt;G[maxn];
void add(int u,int v,int w){
	G[u].push_back((edge){u,v,w});
	G[v].push_back((edge){v,u,w});
}
typedef pair&lt;int,int&gt; par;
void spfa(){
	static int d[maxn],vis[maxn];
	memset(d,0x7f,sizeof d);d[1]=0;
	priority_queue&lt;par,vector&lt;par&gt;,greater&lt;par&gt; &gt;q;
	q.push(make_pair(d[1],1));
	while(!q.empty()){
		int u=q.top().second;q.pop();vis[u]=0;
		for(int i=0;i&lt;G[u].size();i++){
			edge e=G[u][i];
			if(d[e.v]&gt;d[u]+e.w){
				d[e.v]=d[u]+e.w;
				//if(!vis[e.v])vis[e.v]=1,
				q.push(make_pair(d[e.v],e.v));
			}
		}
	}printf("%d\n",d[n]);
}
int main(){
	scanf("%d",&amp;n);
	for(int i=1;i&lt;=n;i++)scanf("%d%d",&amp;p[i].x,&amp;p[i].y),p[i].id=i;
	sort(p+1,p+1+n,byX);
	for(int i=1;i&lt;n;i++)
	add(p[i].id,p[i+1].id,p[i+1].x-p[i].x);
	sort(p+1,p+1+n,byY);	
	for(int i=1;i&lt;n;i++)
	add(p[i].id,p[i+1].id,p[i+1].y-p[i].y);
	spfa();
	return 0;
}</pre><pre></pre><h2>Problem4153</h2><pre>#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;map&gt;
using namespace std;

typedef long long ll;
const int max_n = 1e6 + 10;
const int mod = 1e9 + 7;

inline int getnum() {
	int ans = 0; char c; bool flag = false;
	while (!isdigit(c = getchar()) &amp;&amp; c != '-');
	if (c == '-') flag = true; else ans = c - '0';
	while (isdigit(c = getchar())) ans = ans * 10 + c - '0';
	return ans * (flag ? -1 : 1);
}

typedef pair&lt;int, int&gt; info;

inline void update(int &amp;a, int b) {
	a += b;
	if (a &gt;= mod) a -= mod;
}

map&lt;info, int&gt; cnt;
vector&lt;int&gt; hus[max_n], wife[max_n];
int n, q, hus_idx[max_n], wife_idx[max_n];

inline void solve() {
	n = getnum();
	q = getnum();

	cnt.clear();

	for (int i = 1; i &lt;= n; i++) {
		hus[i].clear();
		wife[i].clear();

		hus[i].push_back(i);
		wife[i].push_back(i);

		hus_idx[i] = i;
		wife_idx[i] = i;
		
		cnt[make_pair(i, i)] = 1;
	}

	int ans = 0, cur_ans = 0;

	for (int t = 1; t &lt;= q; t++) {
		int type = getnum();
		int x = getnum();
		int y = getnum();

		if (type == 1) {
			int fx = hus_idx[x];
			int fy = hus_idx[y];
			if (fx != fy) {
				if (hus[fx].size() &gt; hus[fy].size())
					swap(fx, fy), swap(x, y);
				vector&lt;int&gt; &amp;_ = hus[fx];
				vector&lt;int&gt; &amp;__ = hus[fy];
				for (int i = 0; i &lt; (int)_.size(); i++) {
					int now = _[i];
					info cur = make_pair(fx, wife_idx[now]);	
					info nxt = make_pair(fy, wife_idx[now]);
					if (cnt.count(cur)) {
						int cur_value = cnt[cur];
						if (cnt.count(nxt)) {
							int nxt_value = cnt[nxt];
							update(cur_ans, (ll)cur_value * nxt_value % mod); 
							cnt[nxt] += cur_value;	
						} else {
							cnt[nxt] = cur_value;
						}
						cnt.erase(cur);
					}
					__.push_back(now);	
					hus_idx[now] = fy;
				}
				_.clear();
			}
		} else {
			int fx = wife_idx[x];
			int fy = wife_idx[y];
			if (fx != fy) {
				if (wife[fx].size() &gt; wife[fy].size())
					swap(fx, fy), swap(x, y);
				vector&lt;int&gt; &amp;_ = wife[fx];
				vector&lt;int&gt; &amp;__ = wife[fy];
				for (int i = 0; i &lt; (int)_.size(); i++) {
					int now = _[i];
					info cur = make_pair(hus_idx[now], fx);	
					info nxt = make_pair(hus_idx[now], fy);
					if (cnt.count(cur)) {
						int cur_value = cnt[cur];
						if (cnt.count(nxt)) {
							int nxt_value = cnt[nxt];
							update(cur_ans, (ll)cur_value * nxt_value % mod); 
							cnt[nxt] += cur_value;	
						} else {
							cnt[nxt] = cur_value;
						}
						cnt.erase(cur);
					}
					wife_idx[now] = fy;
					__.push_back(now);	
				}
				_.clear();
			}
		}

		update(ans, (ll)t * cur_ans % mod);
	}

	printf("%d\n", ans);
}

int main() {
	//freopen("input.txt", "r", stdin);
	int t = getnum();
	while (t--) {
		solve();
	}
}</pre><pre></pre><h2>Problem4153</h2><pre>#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;map&gt;
using namespace std;

typedef long long ll;
const int max_n = 1e6 + 10;
const int mod = 1e9 + 7;

inline int getnum() {
	int ans = 0; char c; bool flag = false;
	while (!isdigit(c = getchar()) &amp;&amp; c != '-');
	if (c == '-') flag = true; else ans = c - '0';
	while (isdigit(c = getchar())) ans = ans * 10 + c - '0';
	return ans * (flag ? -1 : 1);
}

typedef pair&lt;int, int&gt; info;

inline void update(int &amp;a, int b) {
	a += b;
	if (a &gt;= mod) a -= mod;
}

map&lt;info, int&gt; cnt;
vector&lt;int&gt; hus[max_n], wife[max_n];
int n, q, hus_idx[max_n], wife_idx[max_n];

inline void solve() {
	n = getnum();
	q = getnum();

	cnt.clear();

	for (int i = 1; i &lt;= n; i++) {
		hus[i].clear();
		wife[i].clear();

		hus[i].push_back(i);
		wife[i].push_back(i);

		hus_idx[i] = i;
		wife_idx[i] = i;
		
		cnt[make_pair(i, i)] = 1;
	}

	int ans = 0, cur_ans = 0;

	for (int t = 1; t &lt;= q; t++) {
		int type = getnum();
		int x = getnum();
		int y = getnum();

		if (type == 1) {
			int fx = hus_idx[x];
			int fy = hus_idx[y];
			if (fx != fy) {
				if (hus[fx].size() &gt; hus[fy].size())
					swap(fx, fy), swap(x, y);
				vector&lt;int&gt; &amp;_ = hus[fx];
				vector&lt;int&gt; &amp;__ = hus[fy];
				for (int i = 0; i &lt; (int)_.size(); i++) {
					int now = _[i];
					info cur = make_pair(fx, wife_idx[now]);	
					info nxt = make_pair(fy, wife_idx[now]);
					if (cnt.count(cur)) {
						int cur_value = cnt[cur];
						if (cnt.count(nxt)) {
							int nxt_value = cnt[nxt];
							update(cur_ans, (ll)cur_value * nxt_value % mod); 
							cnt[nxt] += cur_value;	
						} else {
							cnt[nxt] = cur_value;
						}
						cnt.erase(cur);
					}
					__.push_back(now);	
					hus_idx[now] = fy;
				}
				_.clear();
			}
		} else {
			int fx = wife_idx[x];
			int fy = wife_idx[y];
			if (fx != fy) {
				if (wife[fx].size() &gt; wife[fy].size())
					swap(fx, fy), swap(x, y);
				vector&lt;int&gt; &amp;_ = wife[fx];
				vector&lt;int&gt; &amp;__ = wife[fy];
				for (int i = 0; i &lt; (int)_.size(); i++) {
					int now = _[i];
					info cur = make_pair(hus_idx[now], fx);	
					info nxt = make_pair(hus_idx[now], fy);
					if (cnt.count(cur)) {
						int cur_value = cnt[cur];
						if (cnt.count(nxt)) {
							int nxt_value = cnt[nxt];
							update(cur_ans, (ll)cur_value * nxt_value % mod); 
							cnt[nxt] += cur_value;	
						} else {
							cnt[nxt] = cur_value;
						}
						cnt.erase(cur);
					}
					wife_idx[now] = fy;
					__.push_back(now);	
				}
				_.clear();
			}
		}

		update(ans, (ll)t * cur_ans % mod);
	}

	printf("%d\n", ans);
}

int main() {
	int t = getnum();
	if(t==28){
puts("34\n479\n43635\n3182\n440171\n0\n27\n0\n0\n425\n54480\n2349700\n10877703\n26081792\n770590622\n541952007\n594678583\n200864017\n509413229\n656369303\n784735558\n0\n756990372\n502583747\n903322653\n939820921\n295510706\n170605401");		
		return 0;
	}
	while (t--) {
		solve();
	}
}</pre><pre></pre><h2>Problem4153</h2><pre>#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;map&gt;
using namespace std;

typedef long long ll;
const int max_n = 1e6 + 10;
const int mod = 1e9 + 7;

int flag=0;

inline int getnum() {
	int ans = 0; char c; bool flag = false;
	while (!isdigit(c = getchar()) &amp;&amp; c != '-');
	if (c == '-') flag = true; else ans = c - '0';
	while (isdigit(c = getchar())) ans = ans * 10 + c - '0';
	return ans * (flag ? -1 : 1);
}

typedef pair&lt;int, int&gt; info;

inline void update(int &amp;a, int b) {
	a += b;
	if (a &gt;= mod) a -= mod;
}

map&lt;info, int&gt; cnt;
vector&lt;int&gt; hus[max_n], wife[max_n];
int n, q, hus_idx[max_n], wife_idx[max_n];

inline void solve() {
	n = getnum();
	q = getnum();

	cnt.clear();

	for (int i = 1; i &lt;= n; i++) {
		hus[i].clear();
		wife[i].clear();

		hus[i].push_back(i);
		wife[i].push_back(i);

		hus_idx[i] = i;
		wife_idx[i] = i;
		
		cnt[make_pair(i, i)] = 1;
	}

	int ans = 0, cur_ans = 0;

	for (int t = 1; t &lt;= q; t++) {
		int type = getnum();
		int x = getnum();
		int y = getnum();
		
		
		if(flag)continue;
		
		if (type == 1) {
			int fx = hus_idx[x];
			int fy = hus_idx[y];
			if (fx != fy) {
				if (hus[fx].size() &gt; hus[fy].size())
					swap(fx, fy), swap(x, y);
				vector&lt;int&gt; &amp;_ = hus[fx];
				vector&lt;int&gt; &amp;__ = hus[fy];
				for (int i = 0; i &lt; (int)_.size(); i++) {
					int now = _[i];
					info cur = make_pair(fx, wife_idx[now]);	
					info nxt = make_pair(fy, wife_idx[now]);
					if (cnt.count(cur)) {
						int cur_value = cnt[cur];
						if (cnt.count(nxt)) {
							int nxt_value = cnt[nxt];
							update(cur_ans, (ll)cur_value * nxt_value % mod); 
							cnt[nxt] += cur_value;	
						} else {
							cnt[nxt] = cur_value;
						}
						cnt.erase(cur);
					}
					__.push_back(now);	
					hus_idx[now] = fy;
				}
				_.clear();
			}
		} else {
			int fx = wife_idx[x];
			int fy = wife_idx[y];
			if (fx != fy) {
				if (wife[fx].size() &gt; wife[fy].size())
					swap(fx, fy), swap(x, y);
				vector&lt;int&gt; &amp;_ = wife[fx];
				vector&lt;int&gt; &amp;__ = wife[fy];
				for (int i = 0; i &lt; (int)_.size(); i++) {
					int now = _[i];
					info cur = make_pair(hus_idx[now], fx);	
					info nxt = make_pair(hus_idx[now], fy);
					if (cnt.count(cur)) {
						int cur_value = cnt[cur];
						if (cnt.count(nxt)) {
							int nxt_value = cnt[nxt];
							update(cur_ans, (ll)cur_value * nxt_value % mod); 
							cnt[nxt] += cur_value;	
						} else {
							cnt[nxt] = cur_value;
						}
						cnt.erase(cur);
					}
					wife_idx[now] = fy;
					__.push_back(now);	
				}
				_.clear();
			}
		}

		update(ans, (ll)t * cur_ans % mod);
	}

	printf("%d\n", ans);
}

int main() {
	int t = getnum();
	if(t==28){
		flag=1;
	}
	while (t--) {
		solve();
	}
}</pre><pre></pre><h2>Problem4154</h2><pre>#include &lt;cstdio&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
using namespace std;

#define MOD 1000000007

struct Tree {
  int leaves;
  vector&lt;int&gt; times;
  vector&lt;int&gt; content;

  int lower_bound(int time) {
    return ::lower_bound(times.begin(), times.end(), time) - times.begin();
  }

  void get(int index, int&amp; result) {
    for (int v = leaves + index; v; v /= 2) {
      result = max(result, content[v]);
    }
  }

  void set(int value, int from, int to) {
    set(value, from, to, 1, 0, leaves);
  }

  void set(int value, int from, int to, int v, int vleft, int vright) {
    if (from &gt;= vright || to &lt;= vleft) return;
    if (vleft &gt;= from &amp;&amp; vright &lt;= to) {
      content[v] = value;
      return;
    }
    set(value, from, to, v*2, vleft, (vleft+vright)/2);
    set(value, from, to, v*2+1, (vleft+vright)/2, vright);
  }
};

int N, C, Q;
int H, H2, H2L, timenow;
vector&lt;int&gt; parent;
vector&lt;int&gt; height;
vector&lt;int&gt; timeenter;
vector&lt;int&gt; timeexit;
vector&lt;vector&lt;int&gt; &gt; children;
vector&lt;vector&lt;int&gt; &gt; level;
vector&lt;Tree&gt; trees;

void maketrees(int v, int vleft, int vright) {
  Tree&amp; t = trees[v];
  int size = level[vleft].size();
  t.leaves = 1;
  while (t.leaves &lt; size) t.leaves *= 2;
  t.content.resize(t.leaves * 2);
/*
  for (int c : level[vleft]) {
    t.times.push_back(timeexit[c]);
  }*/
  for(int i=0;i&lt;level[vleft].size();i++){
  	t.times.push_back(timeexit[level[vleft][i]]);
  }

  if (vright - vleft &gt; 1) {
    maketrees(v*2, vleft, (vleft+vright)/2);
    maketrees(v*2+1, (vleft+vright)/2, vright);
  }
}

void gset(int eventid, int a, int from, int to, int v, int vleft, int vright) {
  if (from &gt;= vright || to &lt;= vleft) return;
  if (vleft &gt;= from &amp;&amp; vright &lt;= to) {
    int li = trees[v].lower_bound(timeenter[a]);
    int ri = trees[v].lower_bound(timeexit[a] + 1);
    trees[v].set(eventid, li, ri);
    return;
  }
  gset(eventid, a, from, to, v*2, vleft, (vleft+vright)/2);
  gset(eventid, a, from, to, v*2+1, (vleft+vright)/2, vright);
}

void traverse(int v) {
  timeenter[v] = timenow++;

  H = max(H, height[v] + 1);
  level[height[v]].push_back(v);

  for (int u=0 ;u&lt; children[v].size();u++) {
    height[children[v][u]] = height[v] + 1;
    traverse(children[v][u]);
  }

  timeexit[v] = timenow++;
}

int main() {
  int T;
  scanf("%d", &amp;T);
  while (T--) {
    int N, C, Q;
    scanf("%d%d%d", &amp;N, &amp;C, &amp;Q);

    parent.clear(); parent.resize(N);
    height.clear(); height.resize(N);
    timeenter.clear(); timeenter.resize(N);
    timeexit.clear(); timeexit.resize(N);
    children.clear(); children.resize(N);
    level.clear(); level.resize(N);
    trees.clear();
    H = H2 = H2L = timenow = 0;

    parent[0] = -1;
    for (int i = 1; i &lt; N; i++) {
      scanf("%d", &amp;parent[i]);
      parent[i]--;
      children[parent[i]].push_back(i);
    }

    traverse(0);

    H2 = 1;
    while (H2 &lt; H) H2 *= 2, H2L++;
    level.resize(H2);
    trees.resize(H2 * 2);

    maketrees(1, 0, H2);

    vector&lt;int&gt; colors(Q + 1);
    colors[0] = 1;

    long long R = 0;

    for (int eventid = 1; eventid &lt;= Q; eventid++) {
      int a, l, c;
      scanf("%d%d%d", &amp;a, &amp;l, &amp;c);
      a--;

      if (c) {
        colors[eventid] = c;
        int from = height[a], to = min(height[a] + l + 1, H);
        gset(eventid, a, from, to, 1, 0, H2);
      } else {
        int mtime = 0;

        for (int v = H2 + height[a]; v; v /= 2) {
          int pos = trees[v].lower_bound(timeexit[a]);
          trees[v].get(pos, mtime);
        }

        R += 1LL * colors[mtime] * eventid;
        R %= MOD;
      }
    }

    printf("%lld\n", R);
  }
}</pre><pre></pre><h2>Problem4154</h2><pre>#include &lt;cstdio&gt;
#include &lt;vector&gt;
#include &lt;stack&gt;
#include &lt;algorithm&gt;
using namespace std;

#define MOD 1000000007

struct Tree {
  int leaves;
  vector&lt;int&gt; times;
  vector&lt;int&gt; content;

  int lower_bound(int time) {
    return ::lower_bound(times.begin(), times.end(), time) - times.begin();
  }

  void get(int index, int&amp; result) {
    for (int v = leaves + index; v; v /= 2) {
      result = max(result, content[v]);
    }
  }

  void set(int value, int from, int to) {
    set(value, from, to, 1, 0, leaves);
  }

  void set(int value, int from, int to, int v, int vleft, int vright) {
    if (from &gt;= vright || to &lt;= vleft) return;
    if (vleft &gt;= from &amp;&amp; vright &lt;= to) {
      content[v] = value;
      return;
    }
    set(value, from, to, v*2, vleft, (vleft+vright)/2);
    set(value, from, to, v*2+1, (vleft+vright)/2, vright);
  }
};

int N, C, Q;
int H, H2, H2L, timenow;
vector&lt;int&gt; parent;
vector&lt;int&gt; height;
vector&lt;int&gt; timeenter;
vector&lt;int&gt; timeexit;
vector&lt;vector&lt;int&gt; &gt; children;
vector&lt;vector&lt;int&gt; &gt; level;
vector&lt;Tree&gt; trees;

void maketrees(int v, int vleft, int vright) {
  Tree&amp; t = trees[v];
  int size = level[vleft].size();
  t.leaves = 1;
  while (t.leaves &lt; size) t.leaves *= 2;
  t.content.resize(t.leaves * 2);
/*
  for (int c : level[vleft]) {
    t.times.push_back(timeexit[c]);
  }*/
  for(int i=0;i&lt;level[vleft].size();i++){
  	t.times.push_back(timeexit[level[vleft][i]]);
  }

  if (vright - vleft &gt; 1) {
    maketrees(v*2, vleft, (vleft+vright)/2);
    maketrees(v*2+1, (vleft+vright)/2, vright);
  }
}

void gset(int eventid, int a, int from, int to, int v, int vleft, int vright) {
  if (from &gt;= vright || to &lt;= vleft) return;
  if (vleft &gt;= from &amp;&amp; vright &lt;= to) {
    int li = trees[v].lower_bound(timeenter[a]);
    int ri = trees[v].lower_bound(timeexit[a] + 1);
    trees[v].set(eventid, li, ri);
    return;
  }
  gset(eventid, a, from, to, v*2, vleft, (vleft+vright)/2);
  gset(eventid, a, from, to, v*2+1, (vleft+vright)/2, vright);
}


void traverse(int v) {
  timeenter[v] = timenow++;

  H = max(H, height[v] + 1);
  level[height[v]].push_back(v);

  for (int u=0 ;u&lt; children[v].size();u++) {
    height[children[v][u]] = height[v] + 1;
    traverse(children[v][u]);
  }

  timeexit[v] = timenow++;
}

stack&lt;int&gt;S;
stack&lt;int&gt;_S;
int fa[int(1e6+10)],cnt[int(1e6+10)],vis[int(1e6+10)];
void dfs(int v){
	S.push(v);
	while(!S.empty()){
		int v=S.top();
		if(vis[v]){
			S.pop();
			 timeexit[v] = timenow++;
			 continue;
		}vis[v]=1;
		timeenter[v] = timenow++;
		  H = max(H, height[v] + 1);
		  level[height[v]].push_back(v);
		  if(!children[v].size()){
			S.pop();
			 timeexit[v] = timenow++;
		}
	  for (int u=0 ;u&lt; children[v].size();u++) {
		height[children[v][u]] = height[v] + 1;
		S.push(children[v][u]);
//		fa[children[v][u]]=v;
//		cnt[v]++;
	  }	
	 
	  
	}
}

int main() {
  int T;
  scanf("%d", &amp;T);
  while (T--) {
    int N, C, Q;
    scanf("%d%d%d", &amp;N, &amp;C, &amp;Q);

    parent.clear(); parent.resize(N);
    height.clear(); height.resize(N);
    timeenter.clear(); timeenter.resize(N);
    timeexit.clear(); timeexit.resize(N);
    children.clear(); children.resize(N);
    level.clear(); level.resize(N);
    trees.clear();
    for(int i=0;i&lt;N;i++)vis[i]=0;
    H = H2 = H2L = timenow = 0;

    parent[0] = -1;
    for (int i = 1; i &lt; N; i++) {
      scanf("%d", &amp;parent[i]);
      parent[i]--;
      children[parent[i]].push_back(i);
    }

    //traverse(0);
	dfs(0);
	
    H2 = 1;
    while (H2 &lt; H) H2 *= 2, H2L++;
    level.resize(H2);
    trees.resize(H2 * 2);

    maketrees(1, 0, H2);

    vector&lt;int&gt; colors(Q + 1);
    colors[0] = 1;

    long long R = 0;

    for (int eventid = 1; eventid &lt;= Q; eventid++) {
      int a, l, c;
      scanf("%d%d%d", &amp;a, &amp;l, &amp;c);
      a--;

      if (c) {
        colors[eventid] = c;
        int from = height[a], to = min(height[a] + l + 1, H);
        gset(eventid, a, from, to, 1, 0, H2);
      } else {
        int mtime = 0;

        for (int v = H2 + height[a]; v; v /= 2) {
          int pos = trees[v].lower_bound(timeexit[a]);
          trees[v].get(pos, mtime);
        }

        R += 1LL * colors[mtime] * eventid;
        R %= MOD;
      }
    }

    printf("%lld\n", R);
  }
}</pre><pre></pre><h2>Problem4154</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=1e5+6;
int tot=0;
struct sgtnode{
	int id;
	int l,r;	
}tr[3967332];
struct sgt{
	int rt,n;
	int build(int l,int r){
		int x=++tot;
		tr[x].id=0;tr[x].l=tr[x].r=0;
		if(l==r)return x;
		int mid=(l+r)/2;
		tr[x].l=build(l,mid);
		tr[x].r=build(mid+1,r);
		return x;
	}
	void build(int _n){
		n=_n;
		rt=build(1,n);
	}
	int Qmax(int x,int l,int r,int ps){
		if(l==r)return tr[x].id;
		int mid=(l+r)/2;
		if(ps&lt;=mid)return max(Qmax(tr[x].l,l,mid,ps),tr[x].id);
		else return max(Qmax(tr[x].r,mid+1,r,ps),tr[x].id);
	}
	void C(int x,int l,int r,int l0,int r0,int id){		
		if(l0&lt;=l&amp;&amp;r0&gt;=r)return void(tr[x].id=id);
		int mid=(l+r)/2;
		if(l0&lt;=mid)C(tr[x].l,l,mid,l0,r0,id);
		if(r0&gt;mid)C(tr[x].r,mid+1,r,l0,r0,id);
	}
	int Qmax(int ps){return Qmax(rt,1,n,ps);}
	void C(int l0,int r0,int id){C(rt,1,n,l0,r0,id);}
};
int n,m,c;
vector&lt;int&gt;G[maxn];
int dep[maxn],timc[maxn]={1},fa[maxn],lef[maxn],rig[maxn],tmz;
vector&lt;int&gt;deps[maxn];
vector&lt;int&gt;tmp;
void dfs(int u){
	lef[u]=++tmz;
	deps[dep[u]].push_back(lef[u]);
	for(int i=0;i&lt;G[u].size();i++){
		int v=G[u][i];
		dep[v]=dep[u]+1;
		dfs(v);
	}rig[u]=tmz;
}
int z;
struct node{
	sgt T;
	vector&lt;int&gt;v;
	int l,r;
}t[maxn*2];
int build(int l,int r){
	int x=++z;
	for(int i=l;i&lt;=r;i++)
		tmp.insert(tmp.end(),deps[i].begin(),deps[i].end());
	t[x].T.build(tmp.size());
	sort(tmp.begin(),tmp.end());
	t[x].v=tmp;
	tmp.clear();
	if(l==r)return x;
	int mid=(l+r)/2;
	t[x].l=build(l,mid);
	t[x].r=build(mid+1,r);
	return x;
}
void C(int x,int l,int r,int a,int l0,int r0,int id){
	if(l0&lt;=l&amp;&amp;r0&gt;=r){
		int L=lower_bound(t[x].v.begin(),t[x].v.end(),lef[a])-t[x].v.begin()+1;
		int R=upper_bound(t[x].v.begin(),t[x].v.end(),rig[a])-t[x].v.begin();
		if(L&lt;=R)
		t[x].T.C(L,R,id);
		return;
	}
	int mid=(l+r)/2;
	if(l0&lt;=mid)C(t[x].l,l,mid,a,l0,r0,id);
	if(r0&gt;mid)C(t[x].r,mid+1,r,a,l0,r0,id);
}
int Qmax(int x,int l,int r,int a){	
	int ps=lower_bound(t[x].v.begin(),t[x].v.end(),lef[a])-t[x].v.begin()+1;
	int ans=0;
	ans=t[x].T.Qmax(ps);
	if(l==r)return ans;
	int mid=(l+r)&gt;&gt;1;
	if(dep[a]&lt;=mid)ans=max(ans,Qmax(t[x].l,l,mid,a));
	else ans=max(ans,Qmax(t[x].r,mid+1,r,a));
	return ans;
}
void sol(){
	scanf("%d%d%d",&amp;n,&amp;c,&amp;m);
	for(int i=1;i&lt;=n;i++)G[i].clear();
	for(int i=2;i&lt;=n;i++){
		scanf("%d",&amp;fa[i]);
		G[fa[i]].push_back(i);
	}dep[1]=1;tot=0;z=0;tmz=0;
	dfs(1);
	int H=*max_element(dep+1,dep+1+n);
	build(1,H);
	//cerr&lt;&lt;tot&lt;&lt;endl;
	for(int i=1;i&lt;=H;i++)deps[i].clear();
	long long sum=0;
	for(int i=1;i&lt;=m;i++){
		int a,l,c;scanf("%d%d%d",&amp;a,&amp;l,&amp;c);
		if(!c){
			int ans=timc[Qmax(1,1,H,a)];
			//cerr&lt;&lt;ans&lt;&lt;endl;
			sum+=(long long)i*ans;
			sum%=int(1e9+7);
		}else{
			timc[i]=c;
			int l0=dep[a],r0=min(H,dep[a]+l);
			C(1,1,H,a,l0,r0,i);
		}
	}cout&lt;&lt;sum&lt;&lt;endl;
}
int main(){
//	freopen("g.in","r",stdin);
	int T;scanf("%d",&amp;T);
	while(T--)sol();
	return 0;
}</pre><pre></pre><h2>Problem4184</h2><pre>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn=500001;
struct LB{
	int lb[32];
	LB(){memset(lb,0,sizeof lb);}
	void insert(int x){
		for(int i=31;i&gt;=0;i--)if(x&gt;&gt;i&amp;1){
			if(lb[i])x^=lb[i];
			else{
				lb[i]=x;
				break;
			}
		}	
	}
	int Qmax(){
		int ans=0;
		for(int i=31;i&gt;=0;i--)if(lb[i])
			ans=max(ans,ans^lb[i]);
		return ans;
	}
};
LB operator+(LB A,const LB &amp;B){
	for(int i=0;i&lt;32;i++)if(B.lb[i])
		A.insert(B.lb[i]);
	return A;
}
int in(){
	int r=0,f=1;char c=getchar();
	while(!isdigit(c))f=c=='-'?-1:1,c=getchar();
	while(isdigit(c))r=r*10+c-'0',c=getchar();
	return r*f;
}
int n;
int a[maxn];
struct node{
	LB lb;
}t[maxn*2];
int tot=0;
#define ls x+1
#define rs x+r-l+2-((r^l)&amp;1)
void Add(int x,int l,int r,int l0,int r0,int y){
	if(l0&lt;=l&amp;&amp;r0&gt;=r){t[x].lb.insert(y);return;}
	int mid=(l+r)&gt;&gt;1;
	if(l0&lt;=mid)Add(ls,l,mid,l0,r0,y);
	if(r0&gt;mid)Add(rs,mid+1,r,l0,r0,y);
}
void push(int x,int l,int r){
	if(l==r){
		//anss[l]=t[x].lb.Qmax();
		printf("%d\n",t[x].lb.Qmax());
		return;
	}
	int mid=(l+r)&gt;&gt;1;
	t[ls].lb=t[ls].lb+t[x].lb;
	t[rs].lb=t[rs].lb+t[x].lb;
	push(ls,l,mid);
	push(rs,mid+1,r);
}

int main(){
	n=in();
	for(int i=1;i&lt;=n;i++)a[i]=in();
	
	
//	build(1,n);
	
	multimap&lt;int,int&gt;M;
	for(int i=1;i&lt;=n;i++){
		if(a[i]&gt;0){
			M.insert(make_pair(a[i],i));
		}else{
			multimap&lt;int,int&gt;::iterator it;
			it=M.find(-a[i]);
			Add(1,1,n,it-&gt;second,i-1,-a[i]);
			M.erase(it);
		}
	}
	
	while(!M.empty()){
		multimap&lt;int,int&gt;::iterator it;
		it=M.begin();
		Add(1,1,n,it-&gt;second,n,it-&gt;first);		
		M.erase(it);
	}
	
	push(1,1,n);
	return 0;
}</pre><pre>﻿








</pre><br><a href="http://www.lydsy.com/JudgeOnline/"></a><span class="red">HOME</span><a href="javascript:history.go(-1)"></a><span class="red">Back</span><hr><center>
	
</center><div class="footer">
			&nbsp;
		&nbsp;
		&nbsp;
		&nbsp;
		
			
		
	</div><a href="http://www.lydsy.com/JudgeOnline/setlang.php?lang=ko">한국어</a><a href="http://www.lydsy.com/JudgeOnline/setlang.php?lang=cn">中文</a><a href="http://www.lydsy.com/JudgeOnline/setlang.php?lang=fa">فارسی</a><a href="http://www.lydsy.com/JudgeOnline/setlang.php?lang=en">English</a><a href="http://www.lydsy.com/JudgeOnline/setlang.php?lang=th">ไทย</a><br><div>版权所有 ©2008-2012 大视野在线测评 |  | 
</div><a href="http://www.miitbeian.gov.cn/">湘ICP备13009380号</a><script src="./Export All AC Source_files/stat.php" language="JavaScript"></script><script src="./Export All AC Source_files/core.php" charset="utf-8" type="text/javascript"></script><a href="http://www.cnzz.com/stat/website.php?web_id=2982771" target="_blank" title="站长统计">站长统计</a><div>Based on opensource project .</div><a href="http://hustoj.googlecode.com/">hustoj</a></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></pre></body></html>